webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {\"use strict\";\nvar core_1 = __webpack_require__(2);\nvar platform_browser_dynamic_1 = __webpack_require__(20);\nvar app_module_1 = __webpack_require__(24);\n// depending on the env mode, enable prod mode or add debugging modules\nif ((undefined) === 'build') {\n    core_1.enableProdMode();\n}\nfunction main() {\n    return platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule).then(function (MODULE_REF) { if (module[\"hot\"]) {\n        module[\"hot\"][\"accept\"]();\n        if (MODULE_REF.instance[\"hmrOnInit\"]) {\n            module[\"hot\"][\"data\"] && MODULE_REF.instance[\"hmrOnInit\"](module[\"hot\"][\"data\"]);\n        }\n        if (MODULE_REF.instance[\"hmrOnStatus\"]) {\n            module[\"hot\"][\"apply\"](function (status) { MODULE_REF.instance[\"hmrOnStatus\"](status); });\n        }\n        if (MODULE_REF.instance[\"hmrOnCheck\"]) {\n            module[\"hot\"][\"check\"](function (err, outdatedModules) { MODULE_REF.instance[\"hmrOnCheck\"](err, outdatedModules); });\n        }\n        if (MODULE_REF.instance[\"hmrOnDecline\"]) {\n            module[\"hot\"][\"decline\"](function (dependencies) { MODULE_REF.instance[\"hmrOnDecline\"](dependencies); });\n        }\n        module[\"hot\"][\"dispose\"](function (store) { MODULE_REF.instance[\"hmrOnDestroy\"] && MODULE_REF.instance[\"hmrOnDestroy\"](store); MODULE_REF.destroy(); MODULE_REF.instance[\"hmrAfterDestroy\"] && MODULE_REF.instance[\"hmrAfterDestroy\"](store); });\n    } return MODULE_REF; });\n}\nexports.main = main;\nif (document.readyState === 'complete') {\n    main();\n}\nelse {\n    document.addEventListener('DOMContentLoaded', main);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi50cz9mYzBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxpQ0FBK0IsQ0FBZSxDQUFDO0FBQy9DLHFEQUF1QyxFQUFtQyxDQUFDO0FBQzNFLHVDQUEwQixFQUFrQixDQUFDO0FBRTdDLHVFQUF1RTtBQUN2RSxFQUFFLENBQUMsQ0FBQyxXQUFlLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNoQyxxQkFBYyxFQUFFLENBQUM7QUFDbkIsQ0FBQztBQUVEO0lBQ0UsTUFBTSxDQUFDLGlEQUFzQixFQUFFLENBQUMsZUFBZSxDQUFDLHNCQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBUyxVQUFVLElBQU0sRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBQVUsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUFLLENBQUM7UUFBSyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFTLE1BQU0sSUFBWSxVQUFVLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQU8sQ0FBQyxDQUFDLENBQUM7UUFBSyxDQUFDO1FBQUssRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsVUFBUyxHQUFHLEVBQUUsZUFBZSxJQUFZLFVBQVUsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQU8sQ0FBQyxDQUFDLENBQUM7UUFBSyxDQUFDO1FBQUssRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsVUFBUyxZQUFZLElBQVksVUFBVSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFPLENBQUMsQ0FBQyxDQUFDO1FBQUssQ0FBQztRQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxVQUFTLEtBQUssSUFBVSxVQUFVLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBTyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBTyxVQUFVLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLElBQUksVUFBVSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUssQ0FBQyxDQUFDLENBQUM7SUFBRyxDQUFDLENBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JsQyxDQUFDO0FBRmUsWUFBSSxPQUVuQjtBQUVELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQztJQUN2QyxJQUFJLEVBQUUsQ0FBQztBQUNULENBQUM7QUFBQyxJQUFJLENBQUMsQ0FBQztJQUNOLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN0RCxDQUFDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbmFibGVQcm9kTW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG5pbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC9hcHAubW9kdWxlJztcblxuLy8gZGVwZW5kaW5nIG9uIHRoZSBlbnYgbW9kZSwgZW5hYmxlIHByb2QgbW9kZSBvciBhZGQgZGVidWdnaW5nIG1vZHVsZXNcbmlmIChwcm9jZXNzLmVudi5FTlYgPT09ICdidWlsZCcpIHtcbiAgZW5hYmxlUHJvZE1vZGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1haW4oKSB7XG4gIHJldHVybiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSkudGhlbihmdW5jdGlvbihNT0RVTEVfUkVGKSB7ICAgaWYgKG1vZHVsZVtcImhvdFwiXSkgeyAgICAgbW9kdWxlW1wiaG90XCJdW1wiYWNjZXB0XCJdKCk7ICAgICAgICAgIGlmIChNT0RVTEVfUkVGLmluc3RhbmNlW1wiaG1yT25Jbml0XCJdKSB7ICAgICAgIG1vZHVsZVtcImhvdFwiXVtcImRhdGFcIl0gJiYgTU9EVUxFX1JFRi5pbnN0YW5jZVtcImhtck9uSW5pdFwiXShtb2R1bGVbXCJob3RcIl1bXCJkYXRhXCJdKTsgICAgIH0gICAgIGlmIChNT0RVTEVfUkVGLmluc3RhbmNlW1wiaG1yT25TdGF0dXNcIl0pIHsgICAgICAgbW9kdWxlW1wiaG90XCJdW1wiYXBwbHlcIl0oZnVuY3Rpb24oc3RhdHVzKSB7ICAgICAgICAgTU9EVUxFX1JFRi5pbnN0YW5jZVtcImhtck9uU3RhdHVzXCJdKHN0YXR1cyk7ICAgICAgIH0pOyAgICAgfSAgICAgaWYgKE1PRFVMRV9SRUYuaW5zdGFuY2VbXCJobXJPbkNoZWNrXCJdKSB7ICAgICAgIG1vZHVsZVtcImhvdFwiXVtcImNoZWNrXCJdKGZ1bmN0aW9uKGVyciwgb3V0ZGF0ZWRNb2R1bGVzKSB7ICAgICAgICAgTU9EVUxFX1JFRi5pbnN0YW5jZVtcImhtck9uQ2hlY2tcIl0oZXJyLCBvdXRkYXRlZE1vZHVsZXMpOyAgICAgICB9KTsgICAgIH0gICAgIGlmIChNT0RVTEVfUkVGLmluc3RhbmNlW1wiaG1yT25EZWNsaW5lXCJdKSB7ICAgICAgIG1vZHVsZVtcImhvdFwiXVtcImRlY2xpbmVcIl0oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7ICAgICAgICAgTU9EVUxFX1JFRi5pbnN0YW5jZVtcImhtck9uRGVjbGluZVwiXShkZXBlbmRlbmNpZXMpOyAgICAgICB9KTsgICAgIH0gICAgIG1vZHVsZVtcImhvdFwiXVtcImRpc3Bvc2VcIl0oZnVuY3Rpb24oc3RvcmUpIHsgICAgICAgTU9EVUxFX1JFRi5pbnN0YW5jZVtcImhtck9uRGVzdHJveVwiXSAmJiBNT0RVTEVfUkVGLmluc3RhbmNlW1wiaG1yT25EZXN0cm95XCJdKHN0b3JlKTsgICAgICAgTU9EVUxFX1JFRi5kZXN0cm95KCk7ICAgICAgIE1PRFVMRV9SRUYuaW5zdGFuY2VbXCJobXJBZnRlckRlc3Ryb3lcIl0gJiYgTU9EVUxFX1JFRi5pbnN0YW5jZVtcImhtckFmdGVyRGVzdHJveVwiXShzdG9yZSk7ICAgICB9KTsgICB9ICAgcmV0dXJuIE1PRFVMRV9SRUY7IH0pO1xufVxuXG5pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICBtYWluKCk7XG59IGVsc2Uge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgbWFpbik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vQGFuZ3VsYXJjbGFzcy9obXItbG9hZGVyIS4vc3JjL21haW4udHMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tmodule.children = [];\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.2.0\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(3), __webpack_require__(4)) :\n    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Subject', 'rxjs/Observable'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx));\n}(this, function (exports,rxjs_Subject,rxjs_Observable) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    function scheduleMicroTask(fn) {\n        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var global$1 = globalScope;\n    function getTypeNameForDebugging(type) {\n        return type['name'] || typeof type;\n    }\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    global$1.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj != null;\n    }\n    function isBlank(obj) {\n        return obj == null;\n    }\n    function stringify(token) {\n        if (typeof token === 'string') {\n            return token;\n        }\n        if (token == null) {\n            return '' + token;\n        }\n        if (token.overriddenName) {\n            return token.overriddenName;\n        }\n        if (token.name) {\n            return token.name;\n        }\n        var res = token.toString();\n        var newLineIndex = res.indexOf('\\n');\n        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n    }\n    // JS has NaN !== NaN\n    function looseIdentical(a, b) {\n        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n    }\n    function isJsObject(o) {\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\n    }\n    function print(obj) {\n        console.log(obj);\n    }\n    function warn(obj) {\n        console.warn(obj);\n    }\n    var _symbolIterator = null;\n    function getSymbolIterator() {\n        if (!_symbolIterator) {\n            if (globalScope.Symbol && Symbol.iterator) {\n                _symbolIterator = Symbol.iterator;\n            }\n            else {\n                // es6-shim specific logic\n                var keys = Object.getOwnPropertyNames(Map.prototype);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (key !== 'entries' && key !== 'size' &&\n                        Map.prototype[key] === Map.prototype['entries']) {\n                        _symbolIterator = key;\n                    }\n                }\n            }\n        }\n        return _symbolIterator;\n    }\n    function isPrimitive(obj) {\n        return !isJsObject(obj);\n    }\n\n    var _nextClassId = 0;\n    var Reflect = global$1.Reflect;\n    function extractAnnotation(annotation) {\n        if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {\n            // it is a decorator, extract annotation\n            annotation = annotation.annotation;\n        }\n        return annotation;\n    }\n    function applyParams(fnOrArray, key) {\n        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||\n            fnOrArray === Number || fnOrArray === Array) {\n            throw new Error(\"Can not use native \" + stringify(fnOrArray) + \" as constructor\");\n        }\n        if (typeof fnOrArray === 'function') {\n            return fnOrArray;\n        }\n        if (Array.isArray(fnOrArray)) {\n            var annotations = fnOrArray;\n            var annoLength = annotations.length - 1;\n            var fn = fnOrArray[annoLength];\n            if (typeof fn !== 'function') {\n                throw new Error(\"Last position of Class method array must be Function in key \" + key + \" was '\" + stringify(fn) + \"'\");\n            }\n            if (annoLength != fn.length) {\n                throw new Error(\"Number of annotations (\" + annoLength + \") does not match number of arguments (\" + fn.length + \") in the function: \" + stringify(fn));\n            }\n            var paramsAnnotations = [];\n            for (var i = 0, ii = annotations.length - 1; i < ii; i++) {\n                var paramAnnotations = [];\n                paramsAnnotations.push(paramAnnotations);\n                var annotation = annotations[i];\n                if (Array.isArray(annotation)) {\n                    for (var j = 0; j < annotation.length; j++) {\n                        paramAnnotations.push(extractAnnotation(annotation[j]));\n                    }\n                }\n                else if (typeof annotation === 'function') {\n                    paramAnnotations.push(extractAnnotation(annotation));\n                }\n                else {\n                    paramAnnotations.push(annotation);\n                }\n            }\n            Reflect.defineMetadata('parameters', paramsAnnotations, fn);\n            return fn;\n        }\n        throw new Error(\"Only Function or Array is supported in Class definition for key '\" + key + \"' is '\" + stringify(fnOrArray) + \"'\");\n    }\n    /**\n     * Provides a way for expressing ES6 classes with parameter annotations in ES5.\n     *\n     * ## Basic Example\n     *\n     * ```\n     * var Greeter = ng.Class({\n     *   constructor: function(name) {\n     *     this.name = name;\n     *   },\n     *\n     *   greet: function() {\n     *     alert('Hello ' + this.name + '!');\n     *   }\n     * });\n     * ```\n     *\n     * is equivalent to ES6:\n     *\n     * ```\n     * class Greeter {\n     *   constructor(name) {\n     *     this.name = name;\n     *   }\n     *\n     *   greet() {\n     *     alert('Hello ' + this.name + '!');\n     *   }\n     * }\n     * ```\n     *\n     * or equivalent to ES5:\n     *\n     * ```\n     * var Greeter = function (name) {\n     *   this.name = name;\n     * }\n     *\n     * Greeter.prototype.greet = function () {\n     *   alert('Hello ' + this.name + '!');\n     * }\n     * ```\n     *\n     * ### Example with parameter annotations\n     *\n     * ```\n     * var MyService = ng.Class({\n     *   constructor: [String, [new Optional(), Service], function(name, myService) {\n     *     ...\n     *   }]\n     * });\n     * ```\n     *\n     * is equivalent to ES6:\n     *\n     * ```\n     * class MyService {\n     *   constructor(name: string, @Optional() myService: Service) {\n     *     ...\n     *   }\n     * }\n     * ```\n     *\n     * ### Example with inheritance\n     *\n     * ```\n     * var Shape = ng.Class({\n     *   constructor: (color) {\n     *     this.color = color;\n     *   }\n     * });\n     *\n     * var Square = ng.Class({\n     *   extends: Shape,\n     *   constructor: function(color, size) {\n     *     Shape.call(this, color);\n     *     this.size = size;\n     *   }\n     * });\n     * ```\n     * @stable\n     */\n    function Class(clsDef) {\n        var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');\n        var proto = constructor.prototype;\n        if (clsDef.hasOwnProperty('extends')) {\n            if (typeof clsDef.extends === 'function') {\n                constructor.prototype = proto =\n                    Object.create(clsDef.extends.prototype);\n            }\n            else {\n                throw new Error(\"Class definition 'extends' property must be a constructor function was: \" + stringify(clsDef.extends));\n            }\n        }\n        for (var key in clsDef) {\n            if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {\n                proto[key] = applyParams(clsDef[key], key);\n            }\n        }\n        if (this && this.annotations instanceof Array) {\n            Reflect.defineMetadata('annotations', this.annotations, constructor);\n        }\n        var constructorName = constructor['name'];\n        if (!constructorName || constructorName === 'constructor') {\n            constructor['overriddenName'] = \"class\" + _nextClassId++;\n        }\n        return constructor;\n    }\n    function makeDecorator(name, props, parentClass, chainFn) {\n        if (chainFn === void 0) { chainFn = null; }\n        var metaCtor = makeMetadataCtor([props]);\n        function DecoratorFactory(objOrType) {\n            if (!(Reflect && Reflect.getMetadata)) {\n                throw 'reflect-metadata shim is required when using class decorators';\n            }\n            if (this instanceof DecoratorFactory) {\n                metaCtor.call(this, objOrType);\n                return this;\n            }\n            var annotationInstance = new DecoratorFactory(objOrType);\n            var chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];\n            chainAnnotation.push(annotationInstance);\n            var TypeDecorator = function TypeDecorator(cls) {\n                var annotations = Reflect.getOwnMetadata('annotations', cls) || [];\n                annotations.push(annotationInstance);\n                Reflect.defineMetadata('annotations', annotations, cls);\n                return cls;\n            };\n            TypeDecorator.annotations = chainAnnotation;\n            TypeDecorator.Class = Class;\n            if (chainFn)\n                chainFn(TypeDecorator);\n            return TypeDecorator;\n        }\n        if (parentClass) {\n            DecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        DecoratorFactory.prototype.toString = function () { return (\"@\" + name); };\n        DecoratorFactory.annotationCls = DecoratorFactory;\n        return DecoratorFactory;\n    }\n    function makeMetadataCtor(props) {\n        return function ctor() {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            props.forEach(function (prop, i) {\n                var argVal = args[i];\n                if (Array.isArray(prop)) {\n                    // plain parameter\n                    _this[prop[0]] = argVal === undefined ? prop[1] : argVal;\n                }\n                else {\n                    for (var propName in prop) {\n                        _this[propName] =\n                            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];\n                    }\n                }\n            });\n        };\n    }\n    function makeParamDecorator(name, props, parentClass) {\n        var metaCtor = makeMetadataCtor(props);\n        function ParamDecoratorFactory() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            if (this instanceof ParamDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();\n            ParamDecorator.annotation = annotationInstance;\n            return ParamDecorator;\n            function ParamDecorator(cls, unusedKey, index) {\n                var parameters = Reflect.getMetadata('parameters', cls) || [];\n                // there might be gaps if some in between parameters do not have annotations.\n                // we pad with nulls.\n                while (parameters.length <= index) {\n                    parameters.push(null);\n                }\n                parameters[index] = parameters[index] || [];\n                parameters[index].push(annotationInstance);\n                Reflect.defineMetadata('parameters', parameters, cls);\n                return cls;\n            }\n            var _a;\n        }\n        if (parentClass) {\n            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        ParamDecoratorFactory.prototype.toString = function () { return (\"@\" + name); };\n        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n        return ParamDecoratorFactory;\n    }\n    function makePropDecorator(name, props, parentClass) {\n        var metaCtor = makeMetadataCtor(props);\n        function PropDecoratorFactory() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            if (this instanceof PropDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            var decoratorInstance = new ((_a = PropDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();\n            return function PropDecorator(target, name) {\n                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};\n                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n                meta[name].unshift(decoratorInstance);\n                Reflect.defineMetadata('propMetadata', meta, target.constructor);\n            };\n            var _a;\n        }\n        if (parentClass) {\n            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        PropDecoratorFactory.prototype.toString = function () { return (\"@\" + name); };\n        PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n        return PropDecoratorFactory;\n    }\n\n    /**\n     * Inject decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Inject = makeParamDecorator('Inject', [['token', undefined]]);\n    /**\n     * Optional decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Optional = makeParamDecorator('Optional', []);\n    /**\n     * Injectable decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Injectable = makeParamDecorator('Injectable', []);\n    /**\n     * Self decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Self = makeParamDecorator('Self', []);\n    /**\n     * SkipSelf decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var SkipSelf = makeParamDecorator('SkipSelf', []);\n    /**\n     * Host decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Host = makeParamDecorator('Host', []);\n\n    /**\n     * Creates a token that can be used in a DI Provider.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\n     *\n     * ```typescript\n     * var t = new OpaqueToken(\"value\");\n     *\n     * var injector = Injector.resolveAndCreate([\n     *   {provide: t, useValue: \"bindingValue\"}\n     * ]);\n     *\n     * expect(injector.get(t)).toEqual(\"bindingValue\");\n     * ```\n     *\n     * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\n     * caused by multiple providers using the same string as two different tokens.\n     *\n     * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\n     * error messages.\n     * @stable\n     */\n    // so that metadata is gathered for this class\n    var OpaqueToken = (function () {\n        function OpaqueToken(_desc) {\n            this._desc = _desc;\n        }\n        OpaqueToken.prototype.toString = function () { return \"Token \" + this._desc; };\n        OpaqueToken.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        OpaqueToken.ctorParameters = [\n            null,\n        ];\n        return OpaqueToken;\n    }());\n\n    /**\n     * This token can be used to create a virtual provider that will populate the\n     * `entryComponents` fields of components and ng modules based on its `useValue`.\n     * All components that are referenced in the `useValue` value (either directly\n     * or in a nested array or map) will be added to the `entryComponents` property.\n     *\n     * ### Example\n     * The following example shows how the router can populate the `entryComponents`\n     * field of an NgModule based on the router configuration which refers\n     * to components.\n     *\n     * ```typescript\n     * // helper function inside the router\n     * function provideRoutes(routes) {\n     *   return [\n     *     {provide: ROUTES, useValue: routes},\n     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\n     *   ];\n     * }\n     *\n     * // user code\n     * let routes = [\n     *   {path: '/root', component: RootComp},\n     *   {path: '/teams', component: TeamsComp}\n     * ];\n     *\n     * @NgModule({\n     *   providers: [provideRoutes(routes)]\n     * })\n     * class ModuleWithRoutes {}\n     * ```\n     *\n     * @experimental\n     */\n    var ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');\n    /**\n     * Attribute decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);\n    /**\n     * Base class for query metadata.\n     *\n     * See {@link ContentChildren}, {@link ContentChild}, {@link ViewChildren}, {@link ViewChild} for\n     * more information.\n     *\n     * @stable\n     */\n    var Query = (function () {\n        function Query() {\n        }\n        return Query;\n    }());\n    /**\n     * ContentChildren decorator and metadata.\n     *\n     *  @stable\n     *  @Annotation\n     */\n    var ContentChildren = makePropDecorator('ContentChildren', [\n        ['selector', undefined], {\n            first: false,\n            isViewQuery: false,\n            descendants: false,\n            read: undefined,\n        }\n    ], Query);\n    /**\n     * @whatItDoes Configures a content query.\n     *\n     * @howToUse\n     *\n     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\n     *\n     * @description\n     *\n     * You can use ContentChild to get the first element or the directive matching the selector from the\n     * content DOM. If the content DOM changes, and a new child matches the selector,\n     * the property will be updated.\n     *\n     * Content queries are set before the `ngAfterContentInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **read** - read a different token from the queried element.\n     *\n     * Let's look at an example:\n     *\n     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\n     *\n     * **npm package**: `@angular/core`\n     *\n     * @stable\n     * @Annotation\n     */\n    var ContentChild = makePropDecorator('ContentChild', [\n        ['selector', undefined], {\n            first: true,\n            isViewQuery: false,\n            descendants: true,\n            read: undefined,\n        }\n    ], Query);\n    /**\n     * @whatItDoes Configures a view query.\n     *\n     * @howToUse\n     *\n     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\n     *\n     * @description\n     *\n     * You can use ViewChildren to get the {@link QueryList} of elements or directives from the\n     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,\n     * and the changes observable of the query list will emit a new value.\n     *\n     * View queries are set before the `ngAfterViewInit` callback is called.\n     *\n     * **Metadata Properties**:\n     *\n     * * **selector** - the directive type or the name used for querying.\n     * * **read** - read a different token from the queried elements.\n     *\n     * Let's look at an example:\n     *\n     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\n     *\n     * **npm package**: `@angular/core`\n     *\n     * @stable\n     * @Annotation\n     */\n    var ViewChildren = makePropDecorator('ViewChildren', [\n        ['selector', undefined], {\n            first: false,\n            isViewQuery: true,\n            descendants: true,\n            read: undefined,\n        }\n    ], Query);\n    /**\n     * ViewChild decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var ViewChild = makePropDecorator('ViewChild', [\n        ['selector', undefined], {\n            first: true,\n            isViewQuery: true,\n            descendants: true,\n            read: undefined,\n        }\n    ], Query);\n\n    /**\n     * Describes within the change detector which strategy will be used the next time change\n     * detection is triggered.\n     * @stable\n     */\n    exports.ChangeDetectionStrategy;\n    (function (ChangeDetectionStrategy) {\n        /**\n         * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.\n         */\n        ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n        /**\n         * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.\n         */\n        ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n    })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));\n    /**\n     * Describes the status of the detector.\n     */\n    var ChangeDetectorStatus;\n    (function (ChangeDetectorStatus) {\n        /**\n         * `CheckOnce` means that after calling detectChanges the mode of the change detector\n         * will become `Checked`.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"CheckOnce\"] = 0] = \"CheckOnce\";\n        /**\n         * `Checked` means that the change detector should be skipped until its mode changes to\n         * `CheckOnce`.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Checked\"] = 1] = \"Checked\";\n        /**\n         * `CheckAlways` means that after calling detectChanges the mode of the change detector\n         * will remain `CheckAlways`.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"CheckAlways\"] = 2] = \"CheckAlways\";\n        /**\n         * `Detached` means that the change detector sub tree is not a part of the main tree and\n         * should be skipped.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Detached\"] = 3] = \"Detached\";\n        /**\n         * `Errored` means that the change detector encountered an error checking a binding\n         * or calling a directive lifecycle method and is now in an inconsistent state. Change\n         * detectors in this state will no longer detect changes.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Errored\"] = 4] = \"Errored\";\n        /**\n         * `Destroyed` means that the change detector is destroyed.\n         */\n        ChangeDetectorStatus[ChangeDetectorStatus[\"Destroyed\"] = 5] = \"Destroyed\";\n    })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));\n    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\n        return isBlank(changeDetectionStrategy) ||\n            changeDetectionStrategy === exports.ChangeDetectionStrategy.Default;\n    }\n\n    /**\n     * Directive decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Directive = makeDecorator('Directive', {\n        selector: undefined,\n        inputs: undefined,\n        outputs: undefined,\n        host: undefined,\n        providers: undefined,\n        exportAs: undefined,\n        queries: undefined\n    });\n    /**\n     * Component decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Component = makeDecorator('Component', {\n        selector: undefined,\n        inputs: undefined,\n        outputs: undefined,\n        host: undefined,\n        exportAs: undefined,\n        moduleId: undefined,\n        providers: undefined,\n        viewProviders: undefined,\n        changeDetection: exports.ChangeDetectionStrategy.Default,\n        queries: undefined,\n        templateUrl: undefined,\n        template: undefined,\n        styleUrls: undefined,\n        styles: undefined,\n        animations: undefined,\n        encapsulation: undefined,\n        interpolation: undefined,\n        entryComponents: undefined\n    }, Directive);\n    /**\n     * Pipe decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Pipe = makeDecorator('Pipe', {\n        name: undefined,\n        pure: true,\n    });\n    /**\n     * Input decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);\n    /**\n     * Output decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);\n    /**\n     * HostBinding decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);\n    /**\n     * HostBinding decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @stable\n     */\n    var LifecycleHooks;\n    (function (LifecycleHooks) {\n        LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\n        LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\n        LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\n        LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\n        LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\n        LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\n        LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\n        LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\n    })(LifecycleHooks || (LifecycleHooks = {}));\n    var LIFECYCLE_HOOKS_VALUES = [\n        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n        LifecycleHooks.AfterViewChecked\n    ];\n    /**\n     * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}\n     *\n     * @description\n     * `ngOnChanges` is called right after the data-bound properties have been checked and before view\n     * and content children are checked if at least one of them has changed.\n     * The `changes` parameter contains the changed properties.\n     *\n     * See {@linkDocs guide/lifecycle-hooks#onchanges \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var OnChanges = (function () {\n        function OnChanges() {\n        }\n        return OnChanges;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are\n     * initialized.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}\n     *\n     * @description\n     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the\n     * first time, and before any of its children have been checked. It is invoked only once when the\n     * directive is instantiated.\n     *\n     * See {@linkDocs guide/lifecycle-hooks \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var OnInit = (function () {\n        function OnInit() {\n        }\n        return OnInit;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}\n     *\n     * @description\n     * `ngDoCheck` gets called to check the changes in the directives in addition to the default\n     * algorithm. The default change detection algorithm looks for differences by comparing\n     * bound-property values by reference across change detection runs.\n     *\n     * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to\n     * changes on the same input, as `ngOnChanges` will continue to be called when the default change\n     * detector detects changes.\n     *\n     * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking\n     * for collections.\n     *\n     * See {@linkDocs guide/lifecycle-hooks#docheck \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var DoCheck = (function () {\n        function DoCheck() {\n        }\n        return DoCheck;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called when a directive or pipe is destroyed.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}\n     *\n     * @description\n     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the\n     * instance is destroyed.\n     *\n     * See {@linkDocs guide/lifecycle-hooks \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var OnDestroy = (function () {\n        function OnDestroy() {\n        }\n        return OnDestroy;\n    }());\n    /**\n     *\n     * @whatItDoes Lifecycle hook that is called after a directive's content has been fully\n     * initialized.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#aftercontent \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterContentInit = (function () {\n        function AfterContentInit() {\n        }\n        return AfterContentInit;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after every check of a directive's content.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#aftercontent \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterContentChecked = (function () {\n        function AfterContentChecked() {\n        }\n        return AfterContentChecked;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after a component's view has been fully\n     * initialized.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#afterview \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterViewInit = (function () {\n        function AfterViewInit() {\n        }\n        return AfterViewInit;\n    }());\n    /**\n     * @whatItDoes Lifecycle hook that is called after every check of a component's view.\n     * @howToUse\n     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}\n     *\n     * @description\n     * See {@linkDocs guide/lifecycle-hooks#afterview \"Lifecycle Hooks Guide\"}.\n     *\n     * @stable\n     */\n    var AfterViewChecked = (function () {\n        function AfterViewChecked() {\n        }\n        return AfterViewChecked;\n    }());\n\n    /**\n     * Defines a schema that will allow:\n     * - any non-Angular elements with a `-` in their name,\n     * - any properties on elements with a `-` in their name which is the common rule for custom\n     * elements.\n     *\n     * @stable\n     */\n    var CUSTOM_ELEMENTS_SCHEMA = {\n        name: 'custom-elements'\n    };\n    /**\n     * Defines a schema that will allow any property on any element.\n     *\n     * @experimental\n     */\n    var NO_ERRORS_SCHEMA = {\n        name: 'no-errors-schema'\n    };\n    /**\n     * NgModule decorator and metadata.\n     *\n     * @stable\n     * @Annotation\n     */\n    var NgModule = makeDecorator('NgModule', {\n        providers: undefined,\n        declarations: undefined,\n        imports: undefined,\n        exports: undefined,\n        entryComponents: undefined,\n        bootstrap: undefined,\n        schemas: undefined,\n        id: undefined,\n    });\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Defines template and style encapsulation options available for Component's {@link Component}.\n     *\n     * See {@link ViewMetadata#encapsulation}.\n     * @stable\n     */\n    exports.ViewEncapsulation;\n    (function (ViewEncapsulation) {\n        /**\n         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n         * Element and pre-processing the style rules provided via\n         * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element\n         * attribute to all selectors.\n         *\n         * This is the default option.\n         */\n        ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n        /**\n         * Use the native encapsulation mechanism of the renderer.\n         *\n         * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n         * creating a ShadowRoot for Component's Host Element.\n         */\n        ViewEncapsulation[ViewEncapsulation[\"Native\"] = 1] = \"Native\";\n        /**\n         * Don't provide any template or style encapsulation.\n         */\n        ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));\n    /**\n     * Metadata properties available for configuring Views.\n     *\n     * For details on the `@Component` annotation, see {@link Component}.\n     *\n     * ### Example\n     *\n     * ```\n     * @Component({\n     *   selector: 'greet',\n     *   template: 'Hello {{name}}!',\n     * })\n     * class Greet {\n     *   name: string;\n     *\n     *   constructor() {\n     *     this.name = 'World';\n     *   }\n     * }\n     * ```\n     *\n     * @deprecated Use Component instead.\n     *\n     * {@link Component}\n     */\n    var ViewMetadata = (function () {\n        function ViewMetadata(_a) {\n            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;\n            this.templateUrl = templateUrl;\n            this.template = template;\n            this.styleUrls = styleUrls;\n            this.styles = styles;\n            this.encapsulation = encapsulation;\n            this.animations = animations;\n            this.interpolation = interpolation;\n        }\n        return ViewMetadata;\n    }());\n\n    /**\n     * Allows to refer to references which are not yet defined.\n     *\n     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n     * DI is declared,\n     * but not yet defined. It is also used when the `token` which we use when creating a query is not\n     * yet defined.\n     *\n     * ### Example\n     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n     * @experimental\n     */\n    function forwardRef(forwardRefFn) {\n        forwardRefFn.__forward_ref__ = forwardRef;\n        forwardRefFn.toString = function () { return stringify(this()); };\n        return forwardRefFn;\n    }\n    /**\n     * Lazily retrieves the reference value from a forwardRef.\n     *\n     * Acts as the identity function when given a non-forward-ref value.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))\n     *\n     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n     *\n     * See: {@link forwardRef}\n     * @experimental\n     */\n    function resolveForwardRef(type) {\n        if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&\n            type.__forward_ref__ === forwardRef) {\n            return type();\n        }\n        else {\n            return type;\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    function unimplemented() {\n        throw new Error('unimplemented');\n    }\n    /**\n     * @stable\n     */\n    var BaseError = (function (_super) {\n        __extends(BaseError, _super);\n        function BaseError(message) {\n            // Errors don't use current this, instead they create a new instance.\n            // We have to do forward all of our api to the nativeInstance.\n            var nativeError = _super.call(this, message);\n            this._nativeError = nativeError;\n        }\n        Object.defineProperty(BaseError.prototype, \"message\", {\n            get: function () { return this._nativeError.message; },\n            set: function (message) { this._nativeError.message = message; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"name\", {\n            get: function () { return this._nativeError.name; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"stack\", {\n            get: function () { return this._nativeError.stack; },\n            set: function (value) { this._nativeError.stack = value; },\n            enumerable: true,\n            configurable: true\n        });\n        BaseError.prototype.toString = function () { return this._nativeError.toString(); };\n        return BaseError;\n    }(Error));\n    /**\n     * @stable\n     */\n    var WrappedError = (function (_super) {\n        __extends(WrappedError, _super);\n        function WrappedError(message, error) {\n            _super.call(this, message + \" caused by: \" + (error instanceof Error ? error.message : error));\n            this.originalError = error;\n        }\n        Object.defineProperty(WrappedError.prototype, \"stack\", {\n            get: function () {\n                return (this.originalError instanceof Error ? this.originalError : this._nativeError)\n                    .stack;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return WrappedError;\n    }(BaseError));\n\n    var _THROW_IF_NOT_FOUND = new Object();\n    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n    var _NullInjector = (function () {\n        function _NullInjector() {\n        }\n        _NullInjector.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }\n            if (notFoundValue === _THROW_IF_NOT_FOUND) {\n                throw new Error(\"No provider for \" + stringify(token) + \"!\");\n            }\n            return notFoundValue;\n        };\n        return _NullInjector;\n    }());\n    /**\n     * @whatItDoes Injector interface\n     * @howToUse\n     * ```\n     * const injector: Injector = ...;\n     * injector.get(...);\n     * ```\n     *\n     * @description\n     * For more details, see the {@linkDocs guide/dependency-injection \"Dependency Injection Guide\"}.\n     *\n     * ### Example\n     *\n     * {@example core/di/ts/injector_spec.ts region='Injector'}\n     *\n     * `Injector` returns itself when given `Injector` as a token:\n     * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n     *\n     * @stable\n     */\n    var Injector = (function () {\n        function Injector() {\n        }\n        /**\n         * Retrieves an instance from the injector based on the provided token.\n         * If not found:\n         * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to\n         * Injector.THROW_IF_NOT_FOUND is given\n         * - Returns the `notFoundValue` otherwise\n         */\n        Injector.prototype.get = function (token, notFoundValue) { return unimplemented(); };\n        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n        Injector.NULL = new _NullInjector();\n        return Injector;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    function findFirstClosedCycle(keys) {\n        var res = [];\n        for (var i = 0; i < keys.length; ++i) {\n            if (res.indexOf(keys[i]) > -1) {\n                res.push(keys[i]);\n                return res;\n            }\n            res.push(keys[i]);\n        }\n        return res;\n    }\n    function constructResolvingPath(keys) {\n        if (keys.length > 1) {\n            var reversed = findFirstClosedCycle(keys.slice().reverse());\n            var tokenStrs = reversed.map(function (k) { return stringify(k.token); });\n            return ' (' + tokenStrs.join(' -> ') + ')';\n        }\n        return '';\n    }\n    /**\n     * Base class for all errors arising from misconfigured providers.\n     * @stable\n     */\n    var AbstractProviderError = (function (_super) {\n        __extends$1(AbstractProviderError, _super);\n        function AbstractProviderError(injector, key, constructResolvingMessage) {\n            _super.call(this, 'DI Error');\n            this.keys = [key];\n            this.injectors = [injector];\n            this.constructResolvingMessage = constructResolvingMessage;\n            this.message = this.constructResolvingMessage(this.keys);\n        }\n        AbstractProviderError.prototype.addKey = function (injector, key) {\n            this.injectors.push(injector);\n            this.keys.push(key);\n            this.message = this.constructResolvingMessage(this.keys);\n        };\n        return AbstractProviderError;\n    }(BaseError));\n    /**\n     * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n     * {@link Injector} does not have a {@link Provider} for the given key.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))\n     *\n     * ```typescript\n     * class A {\n     *   constructor(b:B) {}\n     * }\n     *\n     * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n     * ```\n     * @stable\n     */\n    var NoProviderError = (function (_super) {\n        __extends$1(NoProviderError, _super);\n        function NoProviderError(injector, key) {\n            _super.call(this, injector, key, function (keys) {\n                var first = stringify(keys[0].token);\n                return \"No provider for \" + first + \"!\" + constructResolvingPath(keys);\n            });\n        }\n        return NoProviderError;\n    }(AbstractProviderError));\n    /**\n     * Thrown when dependencies form a cycle.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))\n     *\n     * ```typescript\n     * var injector = Injector.resolveAndCreate([\n     *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n     *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n     * ]);\n     *\n     * expect(() => injector.get(\"one\")).toThrowError();\n     * ```\n     *\n     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n     * @stable\n     */\n    var CyclicDependencyError = (function (_super) {\n        __extends$1(CyclicDependencyError, _super);\n        function CyclicDependencyError(injector, key) {\n            _super.call(this, injector, key, function (keys) {\n                return \"Cannot instantiate cyclic dependency!\" + constructResolvingPath(keys);\n            });\n        }\n        return CyclicDependencyError;\n    }(AbstractProviderError));\n    /**\n     * Thrown when a constructing type returns with an Error.\n     *\n     * The `InstantiationError` class contains the original error plus the dependency graph which caused\n     * this object to be instantiated.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))\n     *\n     * ```typescript\n     * class A {\n     *   constructor() {\n     *     throw new Error('message');\n     *   }\n     * }\n     *\n     * var injector = Injector.resolveAndCreate([A]);\n\n     * try {\n     *   injector.get(A);\n     * } catch (e) {\n     *   expect(e instanceof InstantiationError).toBe(true);\n     *   expect(e.originalException.message).toEqual(\"message\");\n     *   expect(e.originalStack).toBeDefined();\n     * }\n     * ```\n     * @stable\n     */\n    var InstantiationError = (function (_super) {\n        __extends$1(InstantiationError, _super);\n        function InstantiationError(injector, originalException, originalStack, key) {\n            _super.call(this, 'DI Error', originalException);\n            this.keys = [key];\n            this.injectors = [injector];\n        }\n        InstantiationError.prototype.addKey = function (injector, key) {\n            this.injectors.push(injector);\n            this.keys.push(key);\n        };\n        Object.defineProperty(InstantiationError.prototype, \"message\", {\n            get: function () {\n                var first = stringify(this.keys[0].token);\n                return this.originalError.message + \": Error during instantiation of \" + first + \"!\" + constructResolvingPath(this.keys) + \".\";\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(InstantiationError.prototype, \"causeKey\", {\n            get: function () { return this.keys[0]; },\n            enumerable: true,\n            configurable: true\n        });\n        return InstantiationError;\n    }(WrappedError));\n    /**\n     * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n     * creation.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))\n     *\n     * ```typescript\n     * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n     * ```\n     * @stable\n     */\n    var InvalidProviderError = (function (_super) {\n        __extends$1(InvalidProviderError, _super);\n        function InvalidProviderError(provider) {\n            _super.call(this, \"Invalid provider - only instances of Provider and Type are allowed, got: \" + provider);\n        }\n        return InvalidProviderError;\n    }(BaseError));\n    /**\n     * Thrown when the class has no annotation information.\n     *\n     * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n     * need to be injected into the constructor.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))\n     *\n     * ```typescript\n     * class A {\n     *   constructor(b) {}\n     * }\n     *\n     * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n     * ```\n     *\n     * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n     *\n     * ```typescript\n     * class B {}\n     *\n     * class A {\n     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n     * }\n     *\n     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n     * ```\n     * @stable\n     */\n    var NoAnnotationError = (function (_super) {\n        __extends$1(NoAnnotationError, _super);\n        function NoAnnotationError(typeOrFunc, params) {\n            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));\n        }\n        NoAnnotationError._genMessage = function (typeOrFunc, params) {\n            var signature = [];\n            for (var i = 0, ii = params.length; i < ii; i++) {\n                var parameter = params[i];\n                if (!parameter || parameter.length == 0) {\n                    signature.push('?');\n                }\n                else {\n                    signature.push(parameter.map(stringify).join(' '));\n                }\n            }\n            return 'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n                signature.join(', ') + '). ' +\n                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n                stringify(typeOrFunc) + '\\' is decorated with Injectable.';\n        };\n        return NoAnnotationError;\n    }(BaseError));\n    /**\n     * Thrown when getting an object by index.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))\n     *\n     * ```typescript\n     * class A {}\n     *\n     * var injector = Injector.resolveAndCreate([A]);\n     *\n     * expect(() => injector.getAt(100)).toThrowError();\n     * ```\n     * @stable\n     */\n    var OutOfBoundsError = (function (_super) {\n        __extends$1(OutOfBoundsError, _super);\n        function OutOfBoundsError(index) {\n            _super.call(this, \"Index \" + index + \" is out-of-bounds.\");\n        }\n        return OutOfBoundsError;\n    }(BaseError));\n    // TODO: add a working example after alpha38 is released\n    /**\n     * Thrown when a multi provider and a regular provider are bound to the same token.\n     *\n     * ### Example\n     *\n     * ```typescript\n     * expect(() => Injector.resolveAndCreate([\n     *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n     *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n     * ])).toThrowError();\n     * ```\n     */\n    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {\n        __extends$1(MixingMultiProvidersWithRegularProvidersError, _super);\n        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\n            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +\n                provider2.toString());\n        }\n        return MixingMultiProvidersWithRegularProvidersError;\n    }(BaseError));\n\n    /**\n     * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n     *\n     * Keys have:\n     * - a system-wide unique `id`.\n     * - a `token`.\n     *\n     * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n     * the\n     * injector to store created objects in a more efficient way.\n     *\n     * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n     * resolving\n     * providers.\n     * @experimental\n     */\n    var ReflectiveKey = (function () {\n        /**\n         * Private\n         */\n        function ReflectiveKey(token, id) {\n            this.token = token;\n            this.id = id;\n            if (!token) {\n                throw new Error('Token must be defined!');\n            }\n        }\n        Object.defineProperty(ReflectiveKey.prototype, \"displayName\", {\n            /**\n             * Returns a stringified token.\n             */\n            get: function () { return stringify(this.token); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Retrieves a `Key` for a token.\n         */\n        ReflectiveKey.get = function (token) {\n            return _globalKeyRegistry.get(resolveForwardRef(token));\n        };\n        Object.defineProperty(ReflectiveKey, \"numberOfKeys\", {\n            /**\n             * @returns the number of keys registered in the system.\n             */\n            get: function () { return _globalKeyRegistry.numberOfKeys; },\n            enumerable: true,\n            configurable: true\n        });\n        return ReflectiveKey;\n    }());\n    /**\n     * @internal\n     */\n    var KeyRegistry = (function () {\n        function KeyRegistry() {\n            this._allKeys = new Map();\n        }\n        KeyRegistry.prototype.get = function (token) {\n            if (token instanceof ReflectiveKey)\n                return token;\n            if (this._allKeys.has(token)) {\n                return this._allKeys.get(token);\n            }\n            var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n            this._allKeys.set(token, newKey);\n            return newKey;\n        };\n        Object.defineProperty(KeyRegistry.prototype, \"numberOfKeys\", {\n            get: function () { return this._allKeys.size; },\n            enumerable: true,\n            configurable: true\n        });\n        return KeyRegistry;\n    }());\n    var _globalKeyRegistry = new KeyRegistry();\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @whatItDoes Represents a type that a Component or other object is instances of.\n     *\n     * @description\n     *\n     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n     * the `MyCustomComponent` constructor function.\n     *\n     * @stable\n     */\n    var Type = Function;\n\n    var ReflectionCapabilities = (function () {\n        function ReflectionCapabilities(reflect) {\n            this._reflect = reflect || global$1.Reflect;\n        }\n        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\n        ReflectionCapabilities.prototype.factory = function (t) { return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return new (t.bind.apply(t, [void 0].concat(args)))();\n        }; };\n        /** @internal */\n        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {\n            var result;\n            if (typeof paramTypes === 'undefined') {\n                result = new Array(paramAnnotations.length);\n            }\n            else {\n                result = new Array(paramTypes.length);\n            }\n            for (var i = 0; i < result.length; i++) {\n                // TS outputs Object for parameters without types, while Traceur omits\n                // the annotations. For now we preserve the Traceur behavior to aid\n                // migration, but this can be revisited.\n                if (typeof paramTypes === 'undefined') {\n                    result[i] = [];\n                }\n                else if (paramTypes[i] != Object) {\n                    result[i] = [paramTypes[i]];\n                }\n                else {\n                    result[i] = [];\n                }\n                if (paramAnnotations && isPresent(paramAnnotations[i])) {\n                    result[i] = result[i].concat(paramAnnotations[i]);\n                }\n            }\n            return result;\n        };\n        ReflectionCapabilities.prototype.parameters = function (type) {\n            // Prefer the direct API.\n            if (type.parameters) {\n                return type.parameters;\n            }\n            // API of tsickle for lowering decorators to properties on the class.\n            if (type.ctorParameters) {\n                var ctorParameters = type.ctorParameters;\n                var paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });\n                var paramAnnotations = ctorParameters.map(function (ctorParam) {\n                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);\n                });\n                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n            }\n            // API for metadata created by invoking the decorators.\n            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {\n                var paramAnnotations = this._reflect.getMetadata('parameters', type);\n                var paramTypes = this._reflect.getMetadata('design:paramtypes', type);\n                if (paramTypes || paramAnnotations) {\n                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n                }\n            }\n            // The array has to be filled with `undefined` because holes would be skipped by `some`\n            return new Array(type.length).fill(undefined);\n        };\n        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {\n            // Prefer the direct API.\n            if (typeOrFunc.annotations) {\n                var annotations = typeOrFunc.annotations;\n                if (typeof annotations === 'function' && annotations.annotations) {\n                    annotations = annotations.annotations;\n                }\n                return annotations;\n            }\n            // API of tsickle for lowering decorators to properties on the class.\n            if (typeOrFunc.decorators) {\n                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n            }\n            // API for metadata created by invoking the decorators.\n            if (this._reflect && this._reflect.getMetadata) {\n                var annotations = this._reflect.getMetadata('annotations', typeOrFunc);\n                if (annotations)\n                    return annotations;\n            }\n            return [];\n        };\n        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\n            // Prefer the direct API.\n            if (typeOrFunc.propMetadata) {\n                var propMetadata = typeOrFunc.propMetadata;\n                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n                    propMetadata = propMetadata.propMetadata;\n                }\n                return propMetadata;\n            }\n            // API of tsickle for lowering decorators to properties on the class.\n            if (typeOrFunc.propDecorators) {\n                var propDecorators_1 = typeOrFunc.propDecorators;\n                var propMetadata_1 = {};\n                Object.keys(propDecorators_1).forEach(function (prop) {\n                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);\n                });\n                return propMetadata_1;\n            }\n            // API for metadata created by invoking the decorators.\n            if (this._reflect && this._reflect.getMetadata) {\n                var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);\n                if (propMetadata)\n                    return propMetadata;\n            }\n            return {};\n        };\n        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {\n            return type instanceof Type && lcProperty in type.prototype;\n        };\n        ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };\n        ReflectionCapabilities.prototype.setter = function (name) {\n            return new Function('o', 'v', 'return o.' + name + ' = v;');\n        };\n        ReflectionCapabilities.prototype.method = function (name) {\n            var functionBody = \"if (!o.\" + name + \") throw new Error('\\\"\" + name + \"\\\" is undefined');\\n        return o.\" + name + \".apply(o, args);\";\n            return new Function('o', 'args', functionBody);\n        };\n        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\n        ReflectionCapabilities.prototype.importUri = function (type) {\n            // StaticSymbol\n            if (typeof type === 'object' && type['filePath']) {\n                return type['filePath'];\n            }\n            // Runtime type\n            return \"./\" + stringify(type);\n        };\n        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };\n        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };\n        return ReflectionCapabilities;\n    }());\n    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n        if (!decoratorInvocations) {\n            return [];\n        }\n        return decoratorInvocations.map(function (decoratorInvocation) {\n            var decoratorType = decoratorInvocation.type;\n            var annotationCls = decoratorType.annotationCls;\n            var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();\n        });\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Provides read-only access to reflection data about symbols. Used internally by Angular\n     * to power dependency injection and compilation.\n     */\n    var ReflectorReader = (function () {\n        function ReflectorReader() {\n        }\n        return ReflectorReader;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Provides access to reflection data about symbols. Used internally by Angular\n     * to power dependency injection and compilation.\n     */\n    var Reflector = (function (_super) {\n        __extends$2(Reflector, _super);\n        function Reflector(reflectionCapabilities) {\n            _super.call(this);\n            this.reflectionCapabilities = reflectionCapabilities;\n        }\n        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };\n        Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };\n        Reflector.prototype.parameters = function (typeOrFunc) {\n            return this.reflectionCapabilities.parameters(typeOrFunc);\n        };\n        Reflector.prototype.annotations = function (typeOrFunc) {\n            return this.reflectionCapabilities.annotations(typeOrFunc);\n        };\n        Reflector.prototype.propMetadata = function (typeOrFunc) {\n            return this.reflectionCapabilities.propMetadata(typeOrFunc);\n        };\n        Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n            return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\n        };\n        Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };\n        Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };\n        Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };\n        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };\n        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {\n            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);\n        };\n        Reflector.prototype.resolveEnum = function (identifier, name) {\n            return this.reflectionCapabilities.resolveEnum(identifier, name);\n        };\n        return Reflector;\n    }(ReflectorReader));\n\n    /**\n     * The {@link Reflector} used internally in Angular to access metadata\n     * about symbols.\n     */\n    var reflector = new Reflector(new ReflectionCapabilities());\n\n    /**\n     * `Dependency` is used by the framework to extend DI.\n     * This is internal to Angular and should not be used directly.\n     */\n    var ReflectiveDependency = (function () {\n        function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {\n            this.key = key;\n            this.optional = optional;\n            this.lowerBoundVisibility = lowerBoundVisibility;\n            this.upperBoundVisibility = upperBoundVisibility;\n            this.properties = properties;\n        }\n        ReflectiveDependency.fromKey = function (key) {\n            return new ReflectiveDependency(key, false, null, null, []);\n        };\n        return ReflectiveDependency;\n    }());\n    var _EMPTY_LIST = [];\n    var ResolvedReflectiveProvider_ = (function () {\n        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {\n            this.key = key;\n            this.resolvedFactories = resolvedFactories;\n            this.multiProvider = multiProvider;\n        }\n        Object.defineProperty(ResolvedReflectiveProvider_.prototype, \"resolvedFactory\", {\n            get: function () { return this.resolvedFactories[0]; },\n            enumerable: true,\n            configurable: true\n        });\n        return ResolvedReflectiveProvider_;\n    }());\n    /**\n     * An internal resolved representation of a factory function created by resolving {@link\n     * Provider}.\n     * @experimental\n     */\n    var ResolvedReflectiveFactory = (function () {\n        function ResolvedReflectiveFactory(\n            /**\n             * Factory function which can return an instance of an object represented by a key.\n             */\n            factory,\n            /**\n             * Arguments (dependencies) to the `factory` function.\n             */\n            dependencies) {\n            this.factory = factory;\n            this.dependencies = dependencies;\n        }\n        return ResolvedReflectiveFactory;\n    }());\n    /**\n     * Resolve a single provider.\n     */\n    function resolveReflectiveFactory(provider) {\n        var factoryFn;\n        var resolvedDeps;\n        if (provider.useClass) {\n            var useClass = resolveForwardRef(provider.useClass);\n            factoryFn = reflector.factory(useClass);\n            resolvedDeps = _dependenciesFor(useClass);\n        }\n        else if (provider.useExisting) {\n            factoryFn = function (aliasInstance) { return aliasInstance; };\n            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n        }\n        else if (provider.useFactory) {\n            factoryFn = provider.useFactory;\n            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n        }\n        else {\n            factoryFn = function () { return provider.useValue; };\n            resolvedDeps = _EMPTY_LIST;\n        }\n        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n    }\n    /**\n     * Converts the {@link Provider} into {@link ResolvedProvider}.\n     *\n     * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains\n     * convenience provider syntax.\n     */\n    function resolveReflectiveProvider(provider) {\n        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);\n    }\n    /**\n     * Resolve a list of Providers.\n     */\n    function resolveReflectiveProviders(providers) {\n        var normalized = _normalizeProviders(providers, []);\n        var resolved = normalized.map(resolveReflectiveProvider);\n        var resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n        return Array.from(resolvedProviderMap.values());\n    }\n    /**\n     * Merges a list of ResolvedProviders into a list where\n     * each key is contained exactly once and multi providers\n     * have been merged.\n     */\n    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {\n        for (var i = 0; i < providers.length; i++) {\n            var provider = providers[i];\n            var existing = normalizedProvidersMap.get(provider.key.id);\n            if (existing) {\n                if (provider.multiProvider !== existing.multiProvider) {\n                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);\n                }\n                if (provider.multiProvider) {\n                    for (var j = 0; j < provider.resolvedFactories.length; j++) {\n                        existing.resolvedFactories.push(provider.resolvedFactories[j]);\n                    }\n                }\n                else {\n                    normalizedProvidersMap.set(provider.key.id, provider);\n                }\n            }\n            else {\n                var resolvedProvider = void 0;\n                if (provider.multiProvider) {\n                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n                }\n                else {\n                    resolvedProvider = provider;\n                }\n                normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n            }\n        }\n        return normalizedProvidersMap;\n    }\n    function _normalizeProviders(providers, res) {\n        providers.forEach(function (b) {\n            if (b instanceof Type) {\n                res.push({ provide: b, useClass: b });\n            }\n            else if (b && typeof b == 'object' && b.provide !== undefined) {\n                res.push(b);\n            }\n            else if (b instanceof Array) {\n                _normalizeProviders(b, res);\n            }\n            else {\n                throw new InvalidProviderError(b);\n            }\n        });\n        return res;\n    }\n    function constructDependencies(typeOrFunc, dependencies) {\n        if (!dependencies) {\n            return _dependenciesFor(typeOrFunc);\n        }\n        else {\n            var params_1 = dependencies.map(function (t) { return [t]; });\n            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });\n        }\n    }\n    function _dependenciesFor(typeOrFunc) {\n        var params = reflector.parameters(typeOrFunc);\n        if (!params)\n            return [];\n        if (params.some(function (p) { return p == null; })) {\n            throw new NoAnnotationError(typeOrFunc, params);\n        }\n        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });\n    }\n    function _extractToken(typeOrFunc, metadata, params) {\n        var depProps = [];\n        var token = null;\n        var optional = false;\n        if (!Array.isArray(metadata)) {\n            if (metadata instanceof Inject) {\n                return _createDependency(metadata.token, optional, null, null, depProps);\n            }\n            else {\n                return _createDependency(metadata, optional, null, null, depProps);\n            }\n        }\n        var lowerBoundVisibility = null;\n        var upperBoundVisibility = null;\n        for (var i = 0; i < metadata.length; ++i) {\n            var paramMetadata = metadata[i];\n            if (paramMetadata instanceof Type) {\n                token = paramMetadata;\n            }\n            else if (paramMetadata instanceof Inject) {\n                token = paramMetadata.token;\n            }\n            else if (paramMetadata instanceof Optional) {\n                optional = true;\n            }\n            else if (paramMetadata instanceof Self) {\n                upperBoundVisibility = paramMetadata;\n            }\n            else if (paramMetadata instanceof Host) {\n                upperBoundVisibility = paramMetadata;\n            }\n            else if (paramMetadata instanceof SkipSelf) {\n                lowerBoundVisibility = paramMetadata;\n            }\n        }\n        token = resolveForwardRef(token);\n        if (token != null) {\n            return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);\n        }\n        else {\n            throw new NoAnnotationError(typeOrFunc, params);\n        }\n    }\n    function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {\n        return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);\n    }\n\n    // Threshold for the dynamic version\n    var _MAX_CONSTRUCTION_COUNTER = 10;\n    var UNDEFINED = new Object();\n    var ReflectiveProtoInjectorInlineStrategy = (function () {\n        function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {\n            this.provider0 = null;\n            this.provider1 = null;\n            this.provider2 = null;\n            this.provider3 = null;\n            this.provider4 = null;\n            this.provider5 = null;\n            this.provider6 = null;\n            this.provider7 = null;\n            this.provider8 = null;\n            this.provider9 = null;\n            this.keyId0 = null;\n            this.keyId1 = null;\n            this.keyId2 = null;\n            this.keyId3 = null;\n            this.keyId4 = null;\n            this.keyId5 = null;\n            this.keyId6 = null;\n            this.keyId7 = null;\n            this.keyId8 = null;\n            this.keyId9 = null;\n            var length = providers.length;\n            if (length > 0) {\n                this.provider0 = providers[0];\n                this.keyId0 = providers[0].key.id;\n            }\n            if (length > 1) {\n                this.provider1 = providers[1];\n                this.keyId1 = providers[1].key.id;\n            }\n            if (length > 2) {\n                this.provider2 = providers[2];\n                this.keyId2 = providers[2].key.id;\n            }\n            if (length > 3) {\n                this.provider3 = providers[3];\n                this.keyId3 = providers[3].key.id;\n            }\n            if (length > 4) {\n                this.provider4 = providers[4];\n                this.keyId4 = providers[4].key.id;\n            }\n            if (length > 5) {\n                this.provider5 = providers[5];\n                this.keyId5 = providers[5].key.id;\n            }\n            if (length > 6) {\n                this.provider6 = providers[6];\n                this.keyId6 = providers[6].key.id;\n            }\n            if (length > 7) {\n                this.provider7 = providers[7];\n                this.keyId7 = providers[7].key.id;\n            }\n            if (length > 8) {\n                this.provider8 = providers[8];\n                this.keyId8 = providers[8].key.id;\n            }\n            if (length > 9) {\n                this.provider9 = providers[9];\n                this.keyId9 = providers[9].key.id;\n            }\n        }\n        ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {\n            if (index == 0)\n                return this.provider0;\n            if (index == 1)\n                return this.provider1;\n            if (index == 2)\n                return this.provider2;\n            if (index == 3)\n                return this.provider3;\n            if (index == 4)\n                return this.provider4;\n            if (index == 5)\n                return this.provider5;\n            if (index == 6)\n                return this.provider6;\n            if (index == 7)\n                return this.provider7;\n            if (index == 8)\n                return this.provider8;\n            if (index == 9)\n                return this.provider9;\n            throw new OutOfBoundsError(index);\n        };\n        ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {\n            return new ReflectiveInjectorInlineStrategy(injector, this);\n        };\n        return ReflectiveProtoInjectorInlineStrategy;\n    }());\n    var ReflectiveProtoInjectorDynamicStrategy = (function () {\n        function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {\n            this.providers = providers;\n            var len = providers.length;\n            this.keyIds = new Array(len);\n            for (var i = 0; i < len; i++) {\n                this.keyIds[i] = providers[i].key.id;\n            }\n        }\n        ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {\n            if (index < 0 || index >= this.providers.length) {\n                throw new OutOfBoundsError(index);\n            }\n            return this.providers[index];\n        };\n        ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {\n            return new ReflectiveInjectorDynamicStrategy(this, ei);\n        };\n        return ReflectiveProtoInjectorDynamicStrategy;\n    }());\n    var ReflectiveProtoInjector = (function () {\n        function ReflectiveProtoInjector(providers) {\n            this.numberOfProviders = providers.length;\n            this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?\n                new ReflectiveProtoInjectorDynamicStrategy(this, providers) :\n                new ReflectiveProtoInjectorInlineStrategy(this, providers);\n        }\n        ReflectiveProtoInjector.fromResolvedProviders = function (providers) {\n            return new ReflectiveProtoInjector(providers);\n        };\n        ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {\n            return this._strategy.getProviderAtIndex(index);\n        };\n        return ReflectiveProtoInjector;\n    }());\n    var ReflectiveInjectorInlineStrategy = (function () {\n        function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {\n            this.injector = injector;\n            this.protoStrategy = protoStrategy;\n            this.obj0 = UNDEFINED;\n            this.obj1 = UNDEFINED;\n            this.obj2 = UNDEFINED;\n            this.obj3 = UNDEFINED;\n            this.obj4 = UNDEFINED;\n            this.obj5 = UNDEFINED;\n            this.obj6 = UNDEFINED;\n            this.obj7 = UNDEFINED;\n            this.obj8 = UNDEFINED;\n            this.obj9 = UNDEFINED;\n        }\n        ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };\n        ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {\n            return this.injector._new(provider);\n        };\n        ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {\n            var p = this.protoStrategy;\n            var inj = this.injector;\n            if (p.keyId0 === keyId) {\n                if (this.obj0 === UNDEFINED) {\n                    this.obj0 = inj._new(p.provider0);\n                }\n                return this.obj0;\n            }\n            if (p.keyId1 === keyId) {\n                if (this.obj1 === UNDEFINED) {\n                    this.obj1 = inj._new(p.provider1);\n                }\n                return this.obj1;\n            }\n            if (p.keyId2 === keyId) {\n                if (this.obj2 === UNDEFINED) {\n                    this.obj2 = inj._new(p.provider2);\n                }\n                return this.obj2;\n            }\n            if (p.keyId3 === keyId) {\n                if (this.obj3 === UNDEFINED) {\n                    this.obj3 = inj._new(p.provider3);\n                }\n                return this.obj3;\n            }\n            if (p.keyId4 === keyId) {\n                if (this.obj4 === UNDEFINED) {\n                    this.obj4 = inj._new(p.provider4);\n                }\n                return this.obj4;\n            }\n            if (p.keyId5 === keyId) {\n                if (this.obj5 === UNDEFINED) {\n                    this.obj5 = inj._new(p.provider5);\n                }\n                return this.obj5;\n            }\n            if (p.keyId6 === keyId) {\n                if (this.obj6 === UNDEFINED) {\n                    this.obj6 = inj._new(p.provider6);\n                }\n                return this.obj6;\n            }\n            if (p.keyId7 === keyId) {\n                if (this.obj7 === UNDEFINED) {\n                    this.obj7 = inj._new(p.provider7);\n                }\n                return this.obj7;\n            }\n            if (p.keyId8 === keyId) {\n                if (this.obj8 === UNDEFINED) {\n                    this.obj8 = inj._new(p.provider8);\n                }\n                return this.obj8;\n            }\n            if (p.keyId9 === keyId) {\n                if (this.obj9 === UNDEFINED) {\n                    this.obj9 = inj._new(p.provider9);\n                }\n                return this.obj9;\n            }\n            return UNDEFINED;\n        };\n        ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {\n            if (index == 0)\n                return this.obj0;\n            if (index == 1)\n                return this.obj1;\n            if (index == 2)\n                return this.obj2;\n            if (index == 3)\n                return this.obj3;\n            if (index == 4)\n                return this.obj4;\n            if (index == 5)\n                return this.obj5;\n            if (index == 6)\n                return this.obj6;\n            if (index == 7)\n                return this.obj7;\n            if (index == 8)\n                return this.obj8;\n            if (index == 9)\n                return this.obj9;\n            throw new OutOfBoundsError(index);\n        };\n        ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };\n        return ReflectiveInjectorInlineStrategy;\n    }());\n    var ReflectiveInjectorDynamicStrategy = (function () {\n        function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {\n            this.protoStrategy = protoStrategy;\n            this.injector = injector;\n            this.objs = new Array(protoStrategy.providers.length).fill(UNDEFINED);\n        }\n        ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };\n        ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {\n            return this.injector._new(provider);\n        };\n        ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {\n            var p = this.protoStrategy;\n            for (var i = 0; i < p.keyIds.length; i++) {\n                if (p.keyIds[i] === keyId) {\n                    if (this.objs[i] === UNDEFINED) {\n                        this.objs[i] = this.injector._new(p.providers[i]);\n                    }\n                    return this.objs[i];\n                }\n            }\n            return UNDEFINED;\n        };\n        ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {\n            if (index < 0 || index >= this.objs.length) {\n                throw new OutOfBoundsError(index);\n            }\n            return this.objs[index];\n        };\n        ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };\n        return ReflectiveInjectorDynamicStrategy;\n    }());\n    /**\n     * A ReflectiveDependency injection container used for instantiating objects and resolving\n     * dependencies.\n     *\n     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n     * constructor dependencies.\n     *\n     * In typical use, application code asks for the dependencies in the constructor and they are\n     * resolved by the `Injector`.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\n     *\n     * The following example creates an `Injector` configured to create `Engine` and `Car`.\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n     * var car = injector.get(Car);\n     * expect(car instanceof Car).toBe(true);\n     * expect(car.engine instanceof Engine).toBe(true);\n     * ```\n     *\n     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n     * resolve all of the object's dependencies automatically.\n     *\n     * @stable\n     */\n    var ReflectiveInjector = (function () {\n        function ReflectiveInjector() {\n        }\n        /**\n         * Turns an array of provider definitions into an array of resolved providers.\n         *\n         * A resolution is a process of flattening multiple nested arrays and converting individual\n         * providers into an array of {@link ResolvedReflectiveProvider}s.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n         *\n         * expect(providers.length).toEqual(2);\n         *\n         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n         * expect(providers[0].key.displayName).toBe(\"Car\");\n         * expect(providers[0].dependencies.length).toEqual(1);\n         * expect(providers[0].factory).toBeDefined();\n         *\n         * expect(providers[1].key.displayName).toBe(\"Engine\");\n         * });\n         * ```\n         *\n         * See {@link ReflectiveInjector#fromResolvedProviders} for more info.\n         */\n        ReflectiveInjector.resolve = function (providers) {\n            return resolveReflectiveProviders(providers);\n        };\n        /**\n         * Resolves an array of providers and creates an injector from those providers.\n         *\n         * The passed-in providers can be an array of `Type`, {@link Provider},\n         * or a recursive array of more providers.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n         * expect(injector.get(Car) instanceof Car).toBe(true);\n         * ```\n         *\n         * This function is slower than the corresponding `fromResolvedProviders`\n         * because it needs to resolve the passed-in providers first.\n         * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.\n         */\n        ReflectiveInjector.resolveAndCreate = function (providers, parent) {\n            if (parent === void 0) { parent = null; }\n            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n        };\n        /**\n         * Creates an injector from previously resolved providers.\n         *\n         * This API is the recommended way to construct injectors in performance-sensitive parts.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var providers = ReflectiveInjector.resolve([Car, Engine]);\n         * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n         * expect(injector.get(Car) instanceof Car).toBe(true);\n         * ```\n         * @experimental\n         */\n        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {\n            if (parent === void 0) { parent = null; }\n            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);\n        };\n        Object.defineProperty(ReflectiveInjector.prototype, \"parent\", {\n            /**\n             * Parent of this injector.\n             *\n             * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n             * -->\n             *\n             * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n             *\n             * ```typescript\n             * var parent = ReflectiveInjector.resolveAndCreate([]);\n             * var child = parent.resolveAndCreateChild([]);\n             * expect(child.parent).toBe(parent);\n             * ```\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Resolves an array of providers and creates a child injector from those providers.\n         *\n         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n         * -->\n         *\n         * The passed-in providers can be an array of `Type`, {@link Provider},\n         * or a recursive array of more providers.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n         *\n         * ```typescript\n         * class ParentProvider {}\n         * class ChildProvider {}\n         *\n         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n         * var child = parent.resolveAndCreateChild([ChildProvider]);\n         *\n         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n         * ```\n         *\n         * This function is slower than the corresponding `createChildFromResolved`\n         * because it needs to resolve the passed-in providers first.\n         * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.\n         */\n        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { return unimplemented(); };\n        /**\n         * Creates a child injector from previously resolved providers.\n         *\n         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n         * -->\n         *\n         * This API is the recommended way to construct injectors in performance-sensitive parts.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n         *\n         * ```typescript\n         * class ParentProvider {}\n         * class ChildProvider {}\n         *\n         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n         *\n         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n         * var child = parent.createChildFromResolved(childProviders);\n         *\n         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n         * ```\n         */\n        ReflectiveInjector.prototype.createChildFromResolved = function (providers) {\n            return unimplemented();\n        };\n        /**\n         * Resolves a provider and instantiates an object in the context of the injector.\n         *\n         * The created object does not get cached by the injector.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n         *\n         * var car = injector.resolveAndInstantiate(Car);\n         * expect(car.engine).toBe(injector.get(Engine));\n         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n         * ```\n         */\n        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return unimplemented(); };\n        /**\n         * Instantiates an object using a resolved provider in the context of the injector.\n         *\n         * The created object does not get cached by the injector.\n         *\n         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n         *\n         * ```typescript\n         * @Injectable()\n         * class Engine {\n         * }\n         *\n         * @Injectable()\n         * class Car {\n         *   constructor(public engine:Engine) {}\n         * }\n         *\n         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n         * var carProvider = ReflectiveInjector.resolve([Car])[0];\n         * var car = injector.instantiateResolved(carProvider);\n         * expect(car.engine).toBe(injector.get(Engine));\n         * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n         * ```\n         */\n        ReflectiveInjector.prototype.instantiateResolved = function (provider) { return unimplemented(); };\n        return ReflectiveInjector;\n    }());\n    var ReflectiveInjector_ = (function () {\n        /**\n         * Private\n         */\n        function ReflectiveInjector_(_proto /* ProtoInjector */, _parent) {\n            if (_parent === void 0) { _parent = null; }\n            /** @internal */\n            this._constructionCounter = 0;\n            this._proto = _proto;\n            this._parent = _parent;\n            this._strategy = _proto._strategy.createInjectorStrategy(this);\n        }\n        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\n            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);\n        };\n        ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };\n        Object.defineProperty(ReflectiveInjector_.prototype, \"parent\", {\n            get: function () { return this._parent; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ReflectiveInjector_.prototype, \"internalStrategy\", {\n            /**\n             * @internal\n             * Internal. Do not use.\n             * We return `any` not to export the InjectorStrategy type.\n             */\n            get: function () { return this._strategy; },\n            enumerable: true,\n            configurable: true\n        });\n        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {\n            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n            return this.createChildFromResolved(ResolvedReflectiveProviders);\n        };\n        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {\n            var proto = new ReflectiveProtoInjector(providers);\n            var inj = new ReflectiveInjector_(proto);\n            inj._parent = this;\n            return inj;\n        };\n        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {\n            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n        };\n        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {\n            return this._instantiateProvider(provider);\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._new = function (provider) {\n            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {\n                throw new CyclicDependencyError(this, provider.key);\n            }\n            return this._instantiateProvider(provider);\n        };\n        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {\n            if (provider.multiProvider) {\n                var res = new Array(provider.resolvedFactories.length);\n                for (var i = 0; i < provider.resolvedFactories.length; ++i) {\n                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n                }\n                return res;\n            }\n            else {\n                return this._instantiate(provider, provider.resolvedFactories[0]);\n            }\n        };\n        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {\n            var factory = ResolvedReflectiveFactory.factory;\n            var deps = ResolvedReflectiveFactory.dependencies;\n            var length = deps.length;\n            var d0;\n            var d1;\n            var d2;\n            var d3;\n            var d4;\n            var d5;\n            var d6;\n            var d7;\n            var d8;\n            var d9;\n            var d10;\n            var d11;\n            var d12;\n            var d13;\n            var d14;\n            var d15;\n            var d16;\n            var d17;\n            var d18;\n            var d19;\n            try {\n                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;\n                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;\n                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;\n                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;\n                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;\n                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;\n                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;\n                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;\n                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;\n                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;\n                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;\n                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;\n                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;\n                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;\n                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;\n                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;\n                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;\n                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;\n                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;\n                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;\n            }\n            catch (e) {\n                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {\n                    e.addKey(this, provider.key);\n                }\n                throw e;\n            }\n            var obj;\n            try {\n                switch (length) {\n                    case 0:\n                        obj = factory();\n                        break;\n                    case 1:\n                        obj = factory(d0);\n                        break;\n                    case 2:\n                        obj = factory(d0, d1);\n                        break;\n                    case 3:\n                        obj = factory(d0, d1, d2);\n                        break;\n                    case 4:\n                        obj = factory(d0, d1, d2, d3);\n                        break;\n                    case 5:\n                        obj = factory(d0, d1, d2, d3, d4);\n                        break;\n                    case 6:\n                        obj = factory(d0, d1, d2, d3, d4, d5);\n                        break;\n                    case 7:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6);\n                        break;\n                    case 8:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);\n                        break;\n                    case 9:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);\n                        break;\n                    case 10:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);\n                        break;\n                    case 11:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);\n                        break;\n                    case 12:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);\n                        break;\n                    case 13:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);\n                        break;\n                    case 14:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);\n                        break;\n                    case 15:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);\n                        break;\n                    case 16:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);\n                        break;\n                    case 17:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);\n                        break;\n                    case 18:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);\n                        break;\n                    case 19:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);\n                        break;\n                    case 20:\n                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);\n                        break;\n                    default:\n                        throw new Error(\"Cannot instantiate '\" + provider.key.displayName + \"' because it has more than 20 dependencies\");\n                }\n            }\n            catch (e) {\n                throw new InstantiationError(this, e, e.stack, provider.key);\n            }\n            return obj;\n        };\n        ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {\n            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n        };\n        ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {\n            if (key === INJECTOR_KEY) {\n                return this;\n            }\n            if (upperBoundVisibility instanceof Self) {\n                return this._getByKeySelf(key, notFoundValue);\n            }\n            else {\n                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);\n            }\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {\n            if (notFoundValue !== THROW_IF_NOT_FOUND) {\n                return notFoundValue;\n            }\n            else {\n                throw new NoProviderError(this, key);\n            }\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {\n            var obj = this._strategy.getObjByKeyId(key.id);\n            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n        };\n        /** @internal */\n        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {\n            var inj;\n            if (lowerBoundVisibility instanceof SkipSelf) {\n                inj = this._parent;\n            }\n            else {\n                inj = this;\n            }\n            while (inj instanceof ReflectiveInjector_) {\n                var inj_ = inj;\n                var obj = inj_._strategy.getObjByKeyId(key.id);\n                if (obj !== UNDEFINED)\n                    return obj;\n                inj = inj_._parent;\n            }\n            if (inj !== null) {\n                return inj.get(key.token, notFoundValue);\n            }\n            else {\n                return this._throwOrNull(key, notFoundValue);\n            }\n        };\n        Object.defineProperty(ReflectiveInjector_.prototype, \"displayName\", {\n            get: function () {\n                var providers = _mapProviders(this, function (b) { return ' \"' + b.key.displayName + '\" '; })\n                    .join(', ');\n                return \"ReflectiveInjector(providers: [\" + providers + \"])\";\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };\n        return ReflectiveInjector_;\n    }());\n    var INJECTOR_KEY = ReflectiveKey.get(Injector);\n    function _mapProviders(injector, fn) {\n        var res = new Array(injector._proto.numberOfProviders);\n        for (var i = 0; i < injector._proto.numberOfProviders; ++i) {\n            res[i] = fn(injector._proto.getProviderAtIndex(i));\n        }\n        return res;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @whatItDoes Provides a hook for centralized exception handling.\n     *\n     * @description\n     *\n     * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n     * intercept error handling, write a custom exception handler that replaces this default as\n     * appropriate for your app.\n     *\n     * ### Example\n     *\n     * ```\n     * class MyErrorHandler implements ErrorHandler {\n     *   handleError(error) {\n     *     // do something with the exception\n     *   }\n     * }\n     *\n     * @NgModule({\n     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n     * })\n     * class MyModule {}\n     * ```\n     *\n     * @stable\n     */\n    var ErrorHandler = (function () {\n        function ErrorHandler(rethrowError) {\n            if (rethrowError === void 0) { rethrowError = true; }\n            /**\n             * @internal\n             */\n            this._console = console;\n            this.rethrowError = rethrowError;\n        }\n        ErrorHandler.prototype.handleError = function (error) {\n            var originalError = this._findOriginalError(error);\n            var originalStack = this._findOriginalStack(error);\n            var context = this._findContext(error);\n            this._console.error(\"EXCEPTION: \" + this._extractMessage(error));\n            if (originalError) {\n                this._console.error(\"ORIGINAL EXCEPTION: \" + this._extractMessage(originalError));\n            }\n            if (originalStack) {\n                this._console.error('ORIGINAL STACKTRACE:');\n                this._console.error(originalStack);\n            }\n            if (context) {\n                this._console.error('ERROR CONTEXT:');\n                this._console.error(context);\n            }\n            // We rethrow exceptions, so operations like 'bootstrap' will result in an error\n            // when an error happens. If we do not rethrow, bootstrap will always succeed.\n            if (this.rethrowError)\n                throw error;\n        };\n        /** @internal */\n        ErrorHandler.prototype._extractMessage = function (error) {\n            return error instanceof Error ? error.message : error.toString();\n        };\n        /** @internal */\n        ErrorHandler.prototype._findContext = function (error) {\n            if (error) {\n                return error.context ? error.context :\n                    this._findContext(error.originalError);\n            }\n            return null;\n        };\n        /** @internal */\n        ErrorHandler.prototype._findOriginalError = function (error) {\n            var e = error.originalError;\n            while (e && e.originalError) {\n                e = e.originalError;\n            }\n            return e;\n        };\n        /** @internal */\n        ErrorHandler.prototype._findOriginalStack = function (error) {\n            if (!(error instanceof Error))\n                return null;\n            var e = error;\n            var stack = e.stack;\n            while (e instanceof Error && e.originalError) {\n                e = e.originalError;\n                if (e instanceof Error && e.stack) {\n                    stack = e.stack;\n                }\n            }\n            return stack;\n        };\n        return ErrorHandler;\n    }());\n\n    /**\n     * Wraps Javascript Objects\n     */\n    var StringMapWrapper = (function () {\n        function StringMapWrapper() {\n        }\n        StringMapWrapper.merge = function (m1, m2) {\n            var m = {};\n            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n                var k = _a[_i];\n                m[k] = m1[k];\n            }\n            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n                var k = _c[_b];\n                m[k] = m2[k];\n            }\n            return m;\n        };\n        StringMapWrapper.equals = function (m1, m2) {\n            var k1 = Object.keys(m1);\n            var k2 = Object.keys(m2);\n            if (k1.length != k2.length) {\n                return false;\n            }\n            for (var i = 0; i < k1.length; i++) {\n                var key = k1[i];\n                if (m1[key] !== m2[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return StringMapWrapper;\n    }());\n    var ListWrapper = (function () {\n        function ListWrapper() {\n        }\n        ListWrapper.removeAll = function (list, items) {\n            for (var i = 0; i < items.length; ++i) {\n                var index = list.indexOf(items[i]);\n                if (index > -1) {\n                    list.splice(index, 1);\n                }\n            }\n        };\n        ListWrapper.remove = function (list, el) {\n            var index = list.indexOf(el);\n            if (index > -1) {\n                list.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        ListWrapper.equals = function (a, b) {\n            if (a.length != b.length)\n                return false;\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        };\n        ListWrapper.flatten = function (list) {\n            return list.reduce(function (flat, item) {\n                var flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;\n                return flat.concat(flatItem);\n            }, []);\n        };\n        return ListWrapper;\n    }());\n    function isListLikeIterable(obj) {\n        if (!isJsObject(obj))\n            return false;\n        return Array.isArray(obj) ||\n            (!(obj instanceof Map) &&\n                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\n    }\n    function areIterablesEqual(a, b, comparator) {\n        var iterator1 = a[getSymbolIterator()]();\n        var iterator2 = b[getSymbolIterator()]();\n        while (true) {\n            var item1 = iterator1.next();\n            var item2 = iterator2.next();\n            if (item1.done && item2.done)\n                return true;\n            if (item1.done || item2.done)\n                return false;\n            if (!comparator(item1.value, item2.value))\n                return false;\n        }\n    }\n    function iterateListLike(obj, fn) {\n        if (Array.isArray(obj)) {\n            for (var i = 0; i < obj.length; i++) {\n                fn(obj[i]);\n            }\n        }\n        else {\n            var iterator = obj[getSymbolIterator()]();\n            var item = void 0;\n            while (!((item = iterator.next()).done)) {\n                fn(item.value);\n            }\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function isPromise(obj) {\n        // allow any Promise/A+ compliant thenable.\n        // It's up to the caller to ensure that obj.then conforms to the spec\n        return !!obj && typeof obj.then === 'function';\n    }\n\n    /**\n     * A function that will be executed when an application is initialized.\n     * @experimental\n     */\n    var APP_INITIALIZER = new OpaqueToken('Application Initializer');\n    /**\n     * A class that reflects the state of running {@link APP_INITIALIZER}s.\n     *\n     * @experimental\n     */\n    var ApplicationInitStatus = (function () {\n        function ApplicationInitStatus(appInits) {\n            var _this = this;\n            this._done = false;\n            var asyncInitPromises = [];\n            if (appInits) {\n                for (var i = 0; i < appInits.length; i++) {\n                    var initResult = appInits[i]();\n                    if (isPromise(initResult)) {\n                        asyncInitPromises.push(initResult);\n                    }\n                }\n            }\n            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });\n            if (asyncInitPromises.length === 0) {\n                this._done = true;\n            }\n        }\n        Object.defineProperty(ApplicationInitStatus.prototype, \"done\", {\n            get: function () { return this._done; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ApplicationInitStatus.prototype, \"donePromise\", {\n            get: function () { return this._donePromise; },\n            enumerable: true,\n            configurable: true\n        });\n        ApplicationInitStatus.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        ApplicationInitStatus.ctorParameters = [\n            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },\n        ];\n        return ApplicationInitStatus;\n    }());\n\n    /**\n     * A DI Token representing a unique string id assigned to the application by Angular and used\n     * primarily for prefixing application attributes and CSS styles when\n     * {@link ViewEncapsulation#Emulated} is being used.\n     *\n     * If you need to avoid randomly generated value to be used as an application id, you can provide\n     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\n     * using this token.\n     * @experimental\n     */\n    var APP_ID = new OpaqueToken('AppId');\n    function _appIdRandomProviderFactory() {\n        return \"\" + _randomChar() + _randomChar() + _randomChar();\n    }\n    /**\n     * Providers that will generate a random APP_ID_TOKEN.\n     * @experimental\n     */\n    var APP_ID_RANDOM_PROVIDER = {\n        provide: APP_ID,\n        useFactory: _appIdRandomProviderFactory,\n        deps: [],\n    };\n    function _randomChar() {\n        return String.fromCharCode(97 + Math.floor(Math.random() * 25));\n    }\n    /**\n     * A function that will be executed when a platform is initialized.\n     * @experimental\n     */\n    var PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');\n    /**\n     * All callbacks provided via this token will be called for every component that is bootstrapped.\n     * Signature of the callback:\n     *\n     * `(componentRef: ComponentRef) => void`.\n     *\n     * @experimental\n     */\n    var APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');\n    /**\n     * A token which indicates the root directory of the application\n     * @experimental\n     */\n    var PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');\n\n    var Console = (function () {\n        function Console() {\n        }\n        Console.prototype.log = function (message) { print(message); };\n        // Note: for reporting errors use `DOM.logError()` as it is platform specific\n        Console.prototype.warn = function (message) { warn(message); };\n        Console.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        Console.ctorParameters = [];\n        return Console;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Indicates that a component is still being loaded in a synchronous compile.\n     *\n     * @stable\n     */\n    var ComponentStillLoadingError = (function (_super) {\n        __extends$4(ComponentStillLoadingError, _super);\n        function ComponentStillLoadingError(compType) {\n            _super.call(this, \"Can't compile synchronously as \" + stringify(compType) + \" is still being loaded!\");\n            this.compType = compType;\n        }\n        return ComponentStillLoadingError;\n    }(BaseError));\n    /**\n     * Combination of NgModuleFactory and ComponentFactorys.\n     *\n     * @experimental\n     */\n    var ModuleWithComponentFactories = (function () {\n        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {\n            this.ngModuleFactory = ngModuleFactory;\n            this.componentFactories = componentFactories;\n        }\n        return ModuleWithComponentFactories;\n    }());\n    function _throwError() {\n        throw new Error(\"Runtime compiler is not loaded\");\n    }\n    /**\n     * Low-level service for running the angular compiler during runtime\n     * to create {@link ComponentFactory}s, which\n     * can later be used to create and render a Component instance.\n     *\n     * Each `@NgModule` provides an own `Compiler` to its injector,\n     * that will use the directives/pipes of the ng module for compilation\n     * of components.\n     * @stable\n     */\n    var Compiler = (function () {\n        function Compiler() {\n        }\n        /**\n         * Compiles the given NgModule and all of its components. All templates of the components listed\n         * in `entryComponents`\n         * have to be inlined. Otherwise throws a {@link ComponentStillLoadingError}.\n         */\n        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };\n        /**\n         * Compiles the given NgModule and all of its components\n         */\n        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };\n        /**\n         * Same as {@link compileModuleSync} but also creates ComponentFactories for all components.\n         */\n        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n            throw _throwError();\n        };\n        /**\n         * Same as {@link compileModuleAsync} but also creates ComponentFactories for all components.\n         */\n        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n            throw _throwError();\n        };\n        /**\n         * Clears all caches.\n         */\n        Compiler.prototype.clearCache = function () { };\n        /**\n         * Clears the cache for the given component/ngModule.\n         */\n        Compiler.prototype.clearCacheFor = function (type) { };\n        return Compiler;\n    }());\n    /**\n     * Token to provide CompilerOptions in the platform injector.\n     *\n     * @experimental\n     */\n    var COMPILER_OPTIONS = new OpaqueToken('compilerOptions');\n    /**\n     * A factory for creating a Compiler\n     *\n     * @experimental\n     */\n    var CompilerFactory = (function () {\n        function CompilerFactory() {\n        }\n        return CompilerFactory;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A wrapper around a native element inside of a View.\n     *\n     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n     * element.\n     *\n     * @security Permitting direct access to the DOM can make your application more vulnerable to\n     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n     * [Security Guide](http://g.co/ng/security).\n     *\n     * @stable\n     */\n    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n    // i.e. users have to ask for what they need. With that, we can build better analysis tools\n    // and could do better codegen in the future.\n    var ElementRef = (function () {\n        function ElementRef(nativeElement) {\n            this.nativeElement = nativeElement;\n        }\n        return ElementRef;\n    }());\n\n    var DefaultIterableDifferFactory = (function () {\n        function DefaultIterableDifferFactory() {\n        }\n        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };\n        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {\n            return new DefaultIterableDiffer(trackByFn);\n        };\n        return DefaultIterableDifferFactory;\n    }());\n    var trackByIdentity = function (index, item) { return item; };\n    /**\n     * @stable\n     */\n    var DefaultIterableDiffer = (function () {\n        function DefaultIterableDiffer(_trackByFn) {\n            this._trackByFn = _trackByFn;\n            this._length = null;\n            this._collection = null;\n            // Keeps track of the used records at any point in time (during & across `_check()` calls)\n            this._linkedRecords = null;\n            // Keeps track of the removed records at any point in time during `_check()` calls.\n            this._unlinkedRecords = null;\n            this._previousItHead = null;\n            this._itHead = null;\n            this._itTail = null;\n            this._additionsHead = null;\n            this._additionsTail = null;\n            this._movesHead = null;\n            this._movesTail = null;\n            this._removalsHead = null;\n            this._removalsTail = null;\n            // Keeps track of records where custom track by is the same, but item identity has changed\n            this._identityChangesHead = null;\n            this._identityChangesTail = null;\n            this._trackByFn = this._trackByFn || trackByIdentity;\n        }\n        Object.defineProperty(DefaultIterableDiffer.prototype, \"collection\", {\n            get: function () { return this._collection; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DefaultIterableDiffer.prototype, \"length\", {\n            get: function () { return this._length; },\n            enumerable: true,\n            configurable: true\n        });\n        DefaultIterableDiffer.prototype.forEachItem = function (fn) {\n            var record;\n            for (record = this._itHead; record !== null; record = record._next) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {\n            var nextIt = this._itHead;\n            var nextRemove = this._removalsHead;\n            var addRemoveOffset = 0;\n            var moveOffsets = null;\n            while (nextIt || nextRemove) {\n                // Figure out which is the next record to process\n                // Order: remove, add, move\n                var record = !nextRemove ||\n                    nextIt &&\n                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\n                    nextIt :\n                    nextRemove;\n                var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n                var currentIndex = record.currentIndex;\n                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\n                if (record === nextRemove) {\n                    addRemoveOffset--;\n                    nextRemove = nextRemove._nextRemoved;\n                }\n                else {\n                    nextIt = nextIt._next;\n                    if (record.previousIndex == null) {\n                        addRemoveOffset++;\n                    }\n                    else {\n                        // INVARIANT:  currentIndex < previousIndex\n                        if (!moveOffsets)\n                            moveOffsets = [];\n                        var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n                        var localCurrentIndex = currentIndex - addRemoveOffset;\n                        if (localMovePreviousIndex != localCurrentIndex) {\n                            for (var i = 0; i < localMovePreviousIndex; i++) {\n                                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\n                                var index = offset + i;\n                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                                    moveOffsets[i] = offset + 1;\n                                }\n                            }\n                            var previousIndex = record.previousIndex;\n                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n                        }\n                    }\n                }\n                if (adjPreviousIndex !== currentIndex) {\n                    fn(record, adjPreviousIndex, currentIndex);\n                }\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {\n            var record;\n            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {\n            var record;\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {\n            var record;\n            for (record = this._movesHead; record !== null; record = record._nextMoved) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {\n            var record;\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {\n            var record;\n            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n                fn(record);\n            }\n        };\n        DefaultIterableDiffer.prototype.diff = function (collection) {\n            if (isBlank(collection))\n                collection = [];\n            if (!isListLikeIterable(collection)) {\n                throw new Error(\"Error trying to diff '\" + collection + \"'\");\n            }\n            if (this.check(collection)) {\n                return this;\n            }\n            else {\n                return null;\n            }\n        };\n        DefaultIterableDiffer.prototype.onDestroy = function () { };\n        // todo(vicb): optim for UnmodifiableListView (frozen arrays)\n        DefaultIterableDiffer.prototype.check = function (collection) {\n            var _this = this;\n            this._reset();\n            var record = this._itHead;\n            var mayBeDirty = false;\n            var index;\n            var item;\n            var itemTrackBy;\n            if (Array.isArray(collection)) {\n                var list = collection;\n                this._length = collection.length;\n                for (var index_1 = 0; index_1 < this._length; index_1++) {\n                    item = list[index_1];\n                    itemTrackBy = this._trackByFn(index_1, item);\n                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\n                        record = this._mismatch(record, item, itemTrackBy, index_1);\n                        mayBeDirty = true;\n                    }\n                    else {\n                        if (mayBeDirty) {\n                            // TODO(misko): can we limit this to duplicates only?\n                            record = this._verifyReinsertion(record, item, itemTrackBy, index_1);\n                        }\n                        if (!looseIdentical(record.item, item))\n                            this._addIdentityChange(record, item);\n                    }\n                    record = record._next;\n                }\n            }\n            else {\n                index = 0;\n                iterateListLike(collection, function (item /** TODO #9100 */) {\n                    itemTrackBy = _this._trackByFn(index, item);\n                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\n                        record = _this._mismatch(record, item, itemTrackBy, index);\n                        mayBeDirty = true;\n                    }\n                    else {\n                        if (mayBeDirty) {\n                            // TODO(misko): can we limit this to duplicates only?\n                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);\n                        }\n                        if (!looseIdentical(record.item, item))\n                            _this._addIdentityChange(record, item);\n                    }\n                    record = record._next;\n                    index++;\n                });\n                this._length = index;\n            }\n            this._truncate(record);\n            this._collection = collection;\n            return this.isDirty;\n        };\n        Object.defineProperty(DefaultIterableDiffer.prototype, \"isDirty\", {\n            /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n             * changes.\n             */\n            get: function () {\n                return this._additionsHead !== null || this._movesHead !== null ||\n                    this._removalsHead !== null || this._identityChangesHead !== null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Reset the state of the change objects to show no changes. This means set previousKey to\n         * currentKey, and clear all of the queues (additions, moves, removals).\n         * Set the previousIndexes of moved and added items to their currentIndexes\n         * Reset the list of additions, moves and removals\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._reset = function () {\n            if (this.isDirty) {\n                var record = void 0;\n                var nextRecord = void 0;\n                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n                    record._nextPrevious = record._next;\n                }\n                for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                    record.previousIndex = record.currentIndex;\n                }\n                this._additionsHead = this._additionsTail = null;\n                for (record = this._movesHead; record !== null; record = nextRecord) {\n                    record.previousIndex = record.currentIndex;\n                    nextRecord = record._nextMoved;\n                }\n                this._movesHead = this._movesTail = null;\n                this._removalsHead = this._removalsTail = null;\n                this._identityChangesHead = this._identityChangesTail = null;\n            }\n        };\n        /**\n         * This is the core function which handles differences between collections.\n         *\n         * - `record` is the record which we saw at this position last time. If null then it is a new\n         *   item.\n         * - `item` is the current item in the collection\n         * - `index` is the position of the item in the collection\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {\n            // The previous record after which we will append the current one.\n            var previousRecord;\n            if (record === null) {\n                previousRecord = this._itTail;\n            }\n            else {\n                previousRecord = record._prev;\n                // Remove the record from the collection since we know it does not match the item.\n                this._remove(record);\n            }\n            // Attempt to see if we have seen the item before.\n            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n            if (record !== null) {\n                // We have seen this before, we need to move it forward in the collection.\n                // But first we need to check if identity changed, so we can update in view if necessary\n                if (!looseIdentical(record.item, item))\n                    this._addIdentityChange(record, item);\n                this._moveAfter(record, previousRecord, index);\n            }\n            else {\n                // Never seen it, check evicted list.\n                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);\n                if (record !== null) {\n                    // It is an item which we have evicted earlier: reinsert it back into the list.\n                    // But first we need to check if identity changed, so we can update in view if necessary\n                    if (!looseIdentical(record.item, item))\n                        this._addIdentityChange(record, item);\n                    this._reinsertAfter(record, previousRecord, index);\n                }\n                else {\n                    // It is a new item: add it.\n                    record =\n                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);\n                }\n            }\n            return record;\n        };\n        /**\n         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n         *\n         * Use case: `[a, a]` => `[b, a, a]`\n         *\n         * If we did not have this check then the insertion of `b` would:\n         *   1) evict first `a`\n         *   2) insert `b` at `0` index.\n         *   3) leave `a` at index `1` as is. <-- this is wrong!\n         *   3) reinsert `a` at index 2. <-- this is wrong!\n         *\n         * The correct behavior is:\n         *   1) evict first `a`\n         *   2) insert `b` at `0` index.\n         *   3) reinsert `a` at index 1.\n         *   3) move `a` at from `1` to `2`.\n         *\n         *\n         * Double check that we have not evicted a duplicate item. We need to check if the item type may\n         * have already been removed:\n         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n         * at the end.\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {\n            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);\n            if (reinsertRecord !== null) {\n                record = this._reinsertAfter(reinsertRecord, record._prev, index);\n            }\n            else if (record.currentIndex != index) {\n                record.currentIndex = index;\n                this._addToMoves(record, index);\n            }\n            return record;\n        };\n        /**\n         * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection\n         *\n         * - `record` The first excess {@link CollectionChangeRecord}.\n         *\n         * @internal\n         */\n        DefaultIterableDiffer.prototype._truncate = function (record) {\n            // Anything after that needs to be removed;\n            while (record !== null) {\n                var nextRecord = record._next;\n                this._addToRemovals(this._unlink(record));\n                record = nextRecord;\n            }\n            if (this._unlinkedRecords !== null) {\n                this._unlinkedRecords.clear();\n            }\n            if (this._additionsTail !== null) {\n                this._additionsTail._nextAdded = null;\n            }\n            if (this._movesTail !== null) {\n                this._movesTail._nextMoved = null;\n            }\n            if (this._itTail !== null) {\n                this._itTail._next = null;\n            }\n            if (this._removalsTail !== null) {\n                this._removalsTail._nextRemoved = null;\n            }\n            if (this._identityChangesTail !== null) {\n                this._identityChangesTail._nextIdentityChange = null;\n            }\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {\n            if (this._unlinkedRecords !== null) {\n                this._unlinkedRecords.remove(record);\n            }\n            var prev = record._prevRemoved;\n            var next = record._nextRemoved;\n            if (prev === null) {\n                this._removalsHead = next;\n            }\n            else {\n                prev._nextRemoved = next;\n            }\n            if (next === null) {\n                this._removalsTail = prev;\n            }\n            else {\n                next._prevRemoved = prev;\n            }\n            this._insertAfter(record, prevRecord, index);\n            this._addToMoves(record, index);\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {\n            this._unlink(record);\n            this._insertAfter(record, prevRecord, index);\n            this._addToMoves(record, index);\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {\n            this._insertAfter(record, prevRecord, index);\n            if (this._additionsTail === null) {\n                // todo(vicb)\n                // assert(this._additionsHead === null);\n                this._additionsTail = this._additionsHead = record;\n            }\n            else {\n                // todo(vicb)\n                // assert(_additionsTail._nextAdded === null);\n                // assert(record._nextAdded === null);\n                this._additionsTail = this._additionsTail._nextAdded = record;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {\n            // todo(vicb)\n            // assert(record != prevRecord);\n            // assert(record._next === null);\n            // assert(record._prev === null);\n            var next = prevRecord === null ? this._itHead : prevRecord._next;\n            // todo(vicb)\n            // assert(next != record);\n            // assert(prevRecord != record);\n            record._next = next;\n            record._prev = prevRecord;\n            if (next === null) {\n                this._itTail = record;\n            }\n            else {\n                next._prev = record;\n            }\n            if (prevRecord === null) {\n                this._itHead = record;\n            }\n            else {\n                prevRecord._next = record;\n            }\n            if (this._linkedRecords === null) {\n                this._linkedRecords = new _DuplicateMap();\n            }\n            this._linkedRecords.put(record);\n            record.currentIndex = index;\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._remove = function (record) {\n            return this._addToRemovals(this._unlink(record));\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._unlink = function (record) {\n            if (this._linkedRecords !== null) {\n                this._linkedRecords.remove(record);\n            }\n            var prev = record._prev;\n            var next = record._next;\n            // todo(vicb)\n            // assert((record._prev = null) === null);\n            // assert((record._next = null) === null);\n            if (prev === null) {\n                this._itHead = next;\n            }\n            else {\n                prev._next = next;\n            }\n            if (next === null) {\n                this._itTail = prev;\n            }\n            else {\n                next._prev = prev;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {\n            // todo(vicb)\n            // assert(record._nextMoved === null);\n            if (record.previousIndex === toIndex) {\n                return record;\n            }\n            if (this._movesTail === null) {\n                // todo(vicb)\n                // assert(_movesHead === null);\n                this._movesTail = this._movesHead = record;\n            }\n            else {\n                // todo(vicb)\n                // assert(_movesTail._nextMoved === null);\n                this._movesTail = this._movesTail._nextMoved = record;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addToRemovals = function (record) {\n            if (this._unlinkedRecords === null) {\n                this._unlinkedRecords = new _DuplicateMap();\n            }\n            this._unlinkedRecords.put(record);\n            record.currentIndex = null;\n            record._nextRemoved = null;\n            if (this._removalsTail === null) {\n                // todo(vicb)\n                // assert(_removalsHead === null);\n                this._removalsTail = this._removalsHead = record;\n                record._prevRemoved = null;\n            }\n            else {\n                // todo(vicb)\n                // assert(_removalsTail._nextRemoved === null);\n                // assert(record._nextRemoved === null);\n                record._prevRemoved = this._removalsTail;\n                this._removalsTail = this._removalsTail._nextRemoved = record;\n            }\n            return record;\n        };\n        /** @internal */\n        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {\n            record.item = item;\n            if (this._identityChangesTail === null) {\n                this._identityChangesTail = this._identityChangesHead = record;\n            }\n            else {\n                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n            }\n            return record;\n        };\n        DefaultIterableDiffer.prototype.toString = function () {\n            var list = [];\n            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });\n            var previous = [];\n            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });\n            var additions = [];\n            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });\n            var moves = [];\n            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });\n            var removals = [];\n            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });\n            var identityChanges = [];\n            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });\n            return 'collection: ' + list.join(', ') + '\\n' +\n                'previous: ' + previous.join(', ') + '\\n' +\n                'additions: ' + additions.join(', ') + '\\n' +\n                'moves: ' + moves.join(', ') + '\\n' +\n                'removals: ' + removals.join(', ') + '\\n' +\n                'identityChanges: ' + identityChanges.join(', ') + '\\n';\n        };\n        return DefaultIterableDiffer;\n    }());\n    /**\n     * @stable\n     */\n    var CollectionChangeRecord = (function () {\n        function CollectionChangeRecord(item, trackById) {\n            this.item = item;\n            this.trackById = trackById;\n            this.currentIndex = null;\n            this.previousIndex = null;\n            /** @internal */\n            this._nextPrevious = null;\n            /** @internal */\n            this._prev = null;\n            /** @internal */\n            this._next = null;\n            /** @internal */\n            this._prevDup = null;\n            /** @internal */\n            this._nextDup = null;\n            /** @internal */\n            this._prevRemoved = null;\n            /** @internal */\n            this._nextRemoved = null;\n            /** @internal */\n            this._nextAdded = null;\n            /** @internal */\n            this._nextMoved = null;\n            /** @internal */\n            this._nextIdentityChange = null;\n        }\n        CollectionChangeRecord.prototype.toString = function () {\n            return this.previousIndex === this.currentIndex ? stringify(this.item) :\n                stringify(this.item) + '[' +\n                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';\n        };\n        return CollectionChangeRecord;\n    }());\n    // A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item\n    var _DuplicateItemRecordList = (function () {\n        function _DuplicateItemRecordList() {\n            /** @internal */\n            this._head = null;\n            /** @internal */\n            this._tail = null;\n        }\n        /**\n         * Append the record to the list of duplicates.\n         *\n         * Note: by design all records in the list of duplicates hold the same value in record.item.\n         */\n        _DuplicateItemRecordList.prototype.add = function (record) {\n            if (this._head === null) {\n                this._head = this._tail = record;\n                record._nextDup = null;\n                record._prevDup = null;\n            }\n            else {\n                // todo(vicb)\n                // assert(record.item ==  _head.item ||\n                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\n                this._tail._nextDup = record;\n                record._prevDup = this._tail;\n                record._nextDup = null;\n                this._tail = record;\n            }\n        };\n        // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and\n        // CollectionChangeRecord.currentIndex >= afterIndex\n        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {\n            var record;\n            for (record = this._head; record !== null; record = record._nextDup) {\n                if ((afterIndex === null || afterIndex < record.currentIndex) &&\n                    looseIdentical(record.trackById, trackById)) {\n                    return record;\n                }\n            }\n            return null;\n        };\n        /**\n         * Remove one {@link CollectionChangeRecord} from the list of duplicates.\n         *\n         * Returns whether the list of duplicates is empty.\n         */\n        _DuplicateItemRecordList.prototype.remove = function (record) {\n            // todo(vicb)\n            // assert(() {\n            //  // verify that the record being removed is in the list.\n            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {\n            //    if (identical(cursor, record)) return true;\n            //  }\n            //  return false;\n            //});\n            var prev = record._prevDup;\n            var next = record._nextDup;\n            if (prev === null) {\n                this._head = next;\n            }\n            else {\n                prev._nextDup = next;\n            }\n            if (next === null) {\n                this._tail = prev;\n            }\n            else {\n                next._prevDup = prev;\n            }\n            return this._head === null;\n        };\n        return _DuplicateItemRecordList;\n    }());\n    var _DuplicateMap = (function () {\n        function _DuplicateMap() {\n            this.map = new Map();\n        }\n        _DuplicateMap.prototype.put = function (record) {\n            var key = record.trackById;\n            var duplicates = this.map.get(key);\n            if (!duplicates) {\n                duplicates = new _DuplicateItemRecordList();\n                this.map.set(key, duplicates);\n            }\n            duplicates.add(record);\n        };\n        /**\n         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we\n         * have already iterated over, we use the afterIndex to pretend it is not there.\n         *\n         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n         * have any more `a`s needs to return the last `a` not the first or second.\n         */\n        _DuplicateMap.prototype.get = function (trackById, afterIndex) {\n            if (afterIndex === void 0) { afterIndex = null; }\n            var key = trackById;\n            var recordList = this.map.get(key);\n            return recordList ? recordList.get(trackById, afterIndex) : null;\n        };\n        /**\n         * Removes a {@link CollectionChangeRecord} from the list of duplicates.\n         *\n         * The list of duplicates also is removed from the map if it gets empty.\n         */\n        _DuplicateMap.prototype.remove = function (record) {\n            var key = record.trackById;\n            var recordList = this.map.get(key);\n            // Remove the list of duplicates when it gets empty\n            if (recordList.remove(record)) {\n                this.map.delete(key);\n            }\n            return record;\n        };\n        Object.defineProperty(_DuplicateMap.prototype, \"isEmpty\", {\n            get: function () { return this.map.size === 0; },\n            enumerable: true,\n            configurable: true\n        });\n        _DuplicateMap.prototype.clear = function () { this.map.clear(); };\n        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };\n        return _DuplicateMap;\n    }());\n    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {\n        var previousIndex = item.previousIndex;\n        if (previousIndex === null)\n            return previousIndex;\n        var moveOffset = 0;\n        if (moveOffsets && previousIndex < moveOffsets.length) {\n            moveOffset = moveOffsets[previousIndex];\n        }\n        return previousIndex + addRemoveOffset + moveOffset;\n    }\n\n    var DefaultKeyValueDifferFactory = (function () {\n        function DefaultKeyValueDifferFactory() {\n        }\n        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };\n        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };\n        return DefaultKeyValueDifferFactory;\n    }());\n    var DefaultKeyValueDiffer = (function () {\n        function DefaultKeyValueDiffer() {\n            this._records = new Map();\n            this._mapHead = null;\n            this._previousMapHead = null;\n            this._changesHead = null;\n            this._changesTail = null;\n            this._additionsHead = null;\n            this._additionsTail = null;\n            this._removalsHead = null;\n            this._removalsTail = null;\n        }\n        Object.defineProperty(DefaultKeyValueDiffer.prototype, \"isDirty\", {\n            get: function () {\n                return this._additionsHead !== null || this._changesHead !== null ||\n                    this._removalsHead !== null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {\n            var record;\n            for (record = this._mapHead; record !== null; record = record._next) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {\n            var record;\n            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {\n            var record;\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {\n            var record;\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {\n            var record;\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n                fn(record);\n            }\n        };\n        DefaultKeyValueDiffer.prototype.diff = function (map) {\n            if (!map) {\n                map = new Map();\n            }\n            else if (!(map instanceof Map || isJsObject(map))) {\n                throw new Error(\"Error trying to diff '\" + map + \"'\");\n            }\n            return this.check(map) ? this : null;\n        };\n        DefaultKeyValueDiffer.prototype.onDestroy = function () { };\n        DefaultKeyValueDiffer.prototype.check = function (map) {\n            var _this = this;\n            this._reset();\n            var records = this._records;\n            var oldSeqRecord = this._mapHead;\n            var lastOldSeqRecord = null;\n            var lastNewSeqRecord = null;\n            var seqChanged = false;\n            this._forEach(map, function (value, key) {\n                var newSeqRecord;\n                if (oldSeqRecord && key === oldSeqRecord.key) {\n                    newSeqRecord = oldSeqRecord;\n                    _this._maybeAddToChanges(newSeqRecord, value);\n                }\n                else {\n                    seqChanged = true;\n                    if (oldSeqRecord !== null) {\n                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);\n                        _this._addToRemovals(oldSeqRecord);\n                    }\n                    if (records.has(key)) {\n                        newSeqRecord = records.get(key);\n                        _this._maybeAddToChanges(newSeqRecord, value);\n                    }\n                    else {\n                        newSeqRecord = new KeyValueChangeRecord(key);\n                        records.set(key, newSeqRecord);\n                        newSeqRecord.currentValue = value;\n                        _this._addToAdditions(newSeqRecord);\n                    }\n                }\n                if (seqChanged) {\n                    if (_this._isInRemovals(newSeqRecord)) {\n                        _this._removeFromRemovals(newSeqRecord);\n                    }\n                    if (lastNewSeqRecord == null) {\n                        _this._mapHead = newSeqRecord;\n                    }\n                    else {\n                        lastNewSeqRecord._next = newSeqRecord;\n                    }\n                }\n                lastOldSeqRecord = oldSeqRecord;\n                lastNewSeqRecord = newSeqRecord;\n                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;\n            });\n            this._truncate(lastOldSeqRecord, oldSeqRecord);\n            return this.isDirty;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._reset = function () {\n            if (this.isDirty) {\n                var record = void 0;\n                // Record the state of the mapping\n                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {\n                    record._nextPrevious = record._next;\n                }\n                for (record = this._changesHead; record !== null; record = record._nextChanged) {\n                    record.previousValue = record.currentValue;\n                }\n                for (record = this._additionsHead; record != null; record = record._nextAdded) {\n                    record.previousValue = record.currentValue;\n                }\n                this._changesHead = this._changesTail = null;\n                this._additionsHead = this._additionsTail = null;\n                this._removalsHead = this._removalsTail = null;\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {\n            while (record !== null) {\n                if (lastRecord === null) {\n                    this._mapHead = null;\n                }\n                else {\n                    lastRecord._next = null;\n                }\n                var nextRecord = record._next;\n                this._addToRemovals(record);\n                lastRecord = record;\n                record = nextRecord;\n            }\n            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {\n                rec.previousValue = rec.currentValue;\n                rec.currentValue = null;\n                this._records.delete(rec.key);\n            }\n        };\n        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {\n            if (!looseIdentical(newValue, record.currentValue)) {\n                record.previousValue = record.currentValue;\n                record.currentValue = newValue;\n                this._addToChanges(record);\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {\n            return record === this._removalsHead || record._nextRemoved !== null ||\n                record._prevRemoved !== null;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {\n            if (this._removalsHead === null) {\n                this._removalsHead = this._removalsTail = record;\n            }\n            else {\n                this._removalsTail._nextRemoved = record;\n                record._prevRemoved = this._removalsTail;\n                this._removalsTail = record;\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {\n            var next = record._next;\n            if (prev === null) {\n                this._mapHead = next;\n            }\n            else {\n                prev._next = next;\n            }\n            record._next = null;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {\n            var prev = record._prevRemoved;\n            var next = record._nextRemoved;\n            if (prev === null) {\n                this._removalsHead = next;\n            }\n            else {\n                prev._nextRemoved = next;\n            }\n            if (next === null) {\n                this._removalsTail = prev;\n            }\n            else {\n                next._prevRemoved = prev;\n            }\n            record._prevRemoved = record._nextRemoved = null;\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {\n            if (this._additionsHead === null) {\n                this._additionsHead = this._additionsTail = record;\n            }\n            else {\n                this._additionsTail._nextAdded = record;\n                this._additionsTail = record;\n            }\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {\n            if (this._changesHead === null) {\n                this._changesHead = this._changesTail = record;\n            }\n            else {\n                this._changesTail._nextChanged = record;\n                this._changesTail = record;\n            }\n        };\n        DefaultKeyValueDiffer.prototype.toString = function () {\n            var items = [];\n            var previous = [];\n            var changes = [];\n            var additions = [];\n            var removals = [];\n            var record;\n            for (record = this._mapHead; record !== null; record = record._next) {\n                items.push(stringify(record));\n            }\n            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n                previous.push(stringify(record));\n            }\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\n                changes.push(stringify(record));\n            }\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                additions.push(stringify(record));\n            }\n            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n                removals.push(stringify(record));\n            }\n            return 'map: ' + items.join(', ') + '\\n' +\n                'previous: ' + previous.join(', ') + '\\n' +\n                'additions: ' + additions.join(', ') + '\\n' +\n                'changes: ' + changes.join(', ') + '\\n' +\n                'removals: ' + removals.join(', ') + '\\n';\n        };\n        /** @internal */\n        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {\n            if (obj instanceof Map) {\n                obj.forEach(fn);\n            }\n            else {\n                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });\n            }\n        };\n        return DefaultKeyValueDiffer;\n    }());\n    /**\n     * @stable\n     */\n    var KeyValueChangeRecord = (function () {\n        function KeyValueChangeRecord(key) {\n            this.key = key;\n            this.previousValue = null;\n            this.currentValue = null;\n            /** @internal */\n            this._nextPrevious = null;\n            /** @internal */\n            this._next = null;\n            /** @internal */\n            this._nextAdded = null;\n            /** @internal */\n            this._nextRemoved = null;\n            /** @internal */\n            this._prevRemoved = null;\n            /** @internal */\n            this._nextChanged = null;\n        }\n        KeyValueChangeRecord.prototype.toString = function () {\n            return looseIdentical(this.previousValue, this.currentValue) ?\n                stringify(this.key) :\n                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +\n                    stringify(this.currentValue) + ']');\n        };\n        return KeyValueChangeRecord;\n    }());\n\n    /**\n     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n     * @stable\n     */\n    var IterableDiffers = (function () {\n        function IterableDiffers(factories) {\n            this.factories = factories;\n        }\n        IterableDiffers.create = function (factories, parent) {\n            if (isPresent(parent)) {\n                var copied = parent.factories.slice();\n                factories = factories.concat(copied);\n                return new IterableDiffers(factories);\n            }\n            else {\n                return new IterableDiffers(factories);\n            }\n        };\n        /**\n         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n         * inherited {@link IterableDiffers} instance with the provided factories and return a new\n         * {@link IterableDiffers} instance.\n         *\n         * The following example shows how to extend an existing list of factories,\n               * which will only be applied to the injector for this component and its children.\n               * This step is all that's required to make a new {@link IterableDiffer} available.\n         *\n         * ### Example\n         *\n         * ```\n         * @Component({\n         *   viewProviders: [\n         *     IterableDiffers.extend([new ImmutableListDiffer()])\n         *   ]\n         * })\n         * ```\n         */\n        IterableDiffers.extend = function (factories) {\n            return {\n                provide: IterableDiffers,\n                useFactory: function (parent) {\n                    if (!parent) {\n                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\n                        // to\n                        // bootstrap(), which would override default pipes instead of extending them.\n                        throw new Error('Cannot extend IterableDiffers without a parent injector');\n                    }\n                    return IterableDiffers.create(factories, parent);\n                },\n                // Dependency technically isn't optional, but we can provide a better error message this way.\n                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]\n            };\n        };\n        IterableDiffers.prototype.find = function (iterable) {\n            var factory = this.factories.find(function (f) { return f.supports(iterable); });\n            if (isPresent(factory)) {\n                return factory;\n            }\n            else {\n                throw new Error(\"Cannot find a differ supporting object '\" + iterable + \"' of type '\" + getTypeNameForDebugging(iterable) + \"'\");\n            }\n        };\n        return IterableDiffers;\n    }());\n\n    /**\n     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n     * @stable\n     */\n    var KeyValueDiffers = (function () {\n        function KeyValueDiffers(factories) {\n            this.factories = factories;\n        }\n        KeyValueDiffers.create = function (factories, parent) {\n            if (isPresent(parent)) {\n                var copied = parent.factories.slice();\n                factories = factories.concat(copied);\n                return new KeyValueDiffers(factories);\n            }\n            else {\n                return new KeyValueDiffers(factories);\n            }\n        };\n        /**\n         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n         * {@link KeyValueDiffers} instance.\n         *\n         * The following example shows how to extend an existing list of factories,\n               * which will only be applied to the injector for this component and its children.\n               * This step is all that's required to make a new {@link KeyValueDiffer} available.\n         *\n         * ### Example\n         *\n         * ```\n         * @Component({\n         *   viewProviders: [\n         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n         *   ]\n         * })\n         * ```\n         */\n        KeyValueDiffers.extend = function (factories) {\n            return {\n                provide: KeyValueDiffers,\n                useFactory: function (parent) {\n                    if (!parent) {\n                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed\n                        // to\n                        // bootstrap(), which would override default pipes instead of extending them.\n                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');\n                    }\n                    return KeyValueDiffers.create(factories, parent);\n                },\n                // Dependency technically isn't optional, but we can provide a better error message this way.\n                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]\n            };\n        };\n        KeyValueDiffers.prototype.find = function (kv) {\n            var factory = this.factories.find(function (f) { return f.supports(kv); });\n            if (isPresent(factory)) {\n                return factory;\n            }\n            else {\n                throw new Error(\"Cannot find a differ supporting object '\" + kv + \"'\");\n            }\n        };\n        return KeyValueDiffers;\n    }());\n\n    var UNINITIALIZED = {\n        toString: function () { return 'CD_INIT_VALUE'; }\n    };\n    function devModeEqual(a, b) {\n        if (isListLikeIterable(a) && isListLikeIterable(b)) {\n            return areIterablesEqual(a, b, devModeEqual);\n        }\n        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {\n            return true;\n        }\n        else {\n            return looseIdentical(a, b);\n        }\n    }\n    /**\n     * Indicates that the result of a {@link Pipe} transformation has changed even though the\n     * reference\n     * has not changed.\n     *\n     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.\n     *\n     * Example:\n     *\n     * ```\n     * if (this._latestValue === this._latestReturnedValue) {\n     *    return this._latestReturnedValue;\n     *  } else {\n     *    this._latestReturnedValue = this._latestValue;\n     *    return WrappedValue.wrap(this._latestValue); // this will force update\n     *  }\n     * ```\n     * @stable\n     */\n    var WrappedValue = (function () {\n        function WrappedValue(wrapped) {\n            this.wrapped = wrapped;\n        }\n        WrappedValue.wrap = function (value) { return new WrappedValue(value); };\n        return WrappedValue;\n    }());\n    /**\n     * Helper class for unwrapping WrappedValue s\n     */\n    var ValueUnwrapper = (function () {\n        function ValueUnwrapper() {\n            this.hasWrappedValue = false;\n        }\n        ValueUnwrapper.prototype.unwrap = function (value) {\n            if (value instanceof WrappedValue) {\n                this.hasWrappedValue = true;\n                return value.wrapped;\n            }\n            return value;\n        };\n        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };\n        return ValueUnwrapper;\n    }());\n    /**\n     * Represents a basic change from a previous to a new value.\n     * @stable\n     */\n    var SimpleChange = (function () {\n        function SimpleChange(previousValue, currentValue) {\n            this.previousValue = previousValue;\n            this.currentValue = currentValue;\n        }\n        /**\n         * Check whether the new value is the first value assigned.\n         */\n        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };\n        return SimpleChange;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @stable\n     */\n    var ChangeDetectorRef = (function () {\n        function ChangeDetectorRef() {\n        }\n        return ChangeDetectorRef;\n    }());\n\n    /**\n     * Structural diffing for `Object`s and `Map`s.\n     */\n    var keyValDiff = [new DefaultKeyValueDifferFactory()];\n    /**\n     * Structural diffing for `Iterable` types such as `Array`s.\n     */\n    var iterableDiff = [new DefaultIterableDifferFactory()];\n    var defaultIterableDiffers = new IterableDiffers(iterableDiff);\n    var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\n\n    /**\n     * @experimental\n     */\n    // TODO (matsko): add typing for the animation function\n    var RenderComponentType = (function () {\n        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {\n            this.id = id;\n            this.templateUrl = templateUrl;\n            this.slotCount = slotCount;\n            this.encapsulation = encapsulation;\n            this.styles = styles;\n            this.animations = animations;\n        }\n        return RenderComponentType;\n    }());\n    var RenderDebugInfo = (function () {\n        function RenderDebugInfo() {\n        }\n        Object.defineProperty(RenderDebugInfo.prototype, \"injector\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"component\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"providerTokens\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"references\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"context\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderDebugInfo.prototype, \"source\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return RenderDebugInfo;\n    }());\n    /**\n     * @experimental\n     */\n    var Renderer = (function () {\n        function Renderer() {\n        }\n        return Renderer;\n    }());\n    /**\n     * Injectable service that provides a low-level interface for modifying the UI.\n     *\n     * Use this service to bypass Angular's templating and make custom UI changes that can't be\n     * expressed declaratively. For example if you need to set a property or an attribute whose name is\n     * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}\n     * respectively.\n     *\n     * If you are implementing a custom renderer, you must implement this interface.\n     *\n     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\n     * @experimental\n     */\n    var RootRenderer = (function () {\n        function RootRenderer() {\n        }\n        return RootRenderer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n     * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n     * handled.\n     *\n     * See DomSanitizer for more details on security in Angular applications.\n     *\n     * @stable\n     */\n    exports.SecurityContext;\n    (function (SecurityContext) {\n        SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n        SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n        SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n        SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n        SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n        SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n    })(exports.SecurityContext || (exports.SecurityContext = {}));\n    /**\n     * Sanitizer is used by the views to sanitize potentially dangerous values.\n     *\n     * @stable\n     */\n    var Sanitizer = (function () {\n        function Sanitizer() {\n        }\n        return Sanitizer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$6 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * An error thrown if application changes model breaking the top-down data flow.\n     *\n     * This exception is only thrown in dev mode.\n     *\n     * <!-- TODO: Add a link once the dev mode option is configurable -->\n     *\n     * ### Example\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'parent',\n     *   template: '<child [prop]=\"parentProp\"></child>',\n     * })\n     * class Parent {\n     *   parentProp = 'init';\n     * }\n     *\n     * @Directive({selector: 'child', inputs: ['prop']})\n     * class Child {\n     *   constructor(public parent: Parent) {}\n     *\n     *   set prop(v) {\n     *     // this updates the parent property, which is disallowed during change detection\n     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError\n     *     this.parent.parentProp = 'updated';\n     *   }\n     * }\n     * ```\n     * @stable\n     */\n    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {\n        __extends$6(ExpressionChangedAfterItHasBeenCheckedError, _super);\n        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {\n            var msg = \"Expression has changed after it was checked. Previous value: '\" + oldValue + \"'. Current value: '\" + currValue + \"'.\";\n            if (oldValue === UNINITIALIZED) {\n                msg +=\n                    \" It seems like the view has been created after its parent and its children have been dirty checked.\" +\n                        \" Has it been created in a change detection hook ?\";\n            }\n            _super.call(this, msg);\n        }\n        return ExpressionChangedAfterItHasBeenCheckedError;\n    }(BaseError));\n    /**\n     * Thrown when an exception was raised during view creation, change detection or destruction.\n     *\n     * This error wraps the original exception to attach additional contextual information that can\n     * be useful for debugging.\n     * @stable\n     */\n    var ViewWrappedError = (function (_super) {\n        __extends$6(ViewWrappedError, _super);\n        function ViewWrappedError(originalError, context) {\n            _super.call(this, \"Error in \" + context.source, originalError);\n            this.context = context;\n        }\n        return ViewWrappedError;\n    }(WrappedError));\n    /**\n     * Thrown when a destroyed view is used.\n     *\n     * This error indicates a bug in the framework.\n     *\n     * This is an internal Angular error.\n     * @stable\n     */\n    var ViewDestroyedError = (function (_super) {\n        __extends$6(ViewDestroyedError, _super);\n        function ViewDestroyedError(details) {\n            _super.call(this, \"Attempt to use a destroyed view: \" + details);\n        }\n        return ViewDestroyedError;\n    }(BaseError));\n\n    var ViewUtils = (function () {\n        function ViewUtils(_renderer, sanitizer) {\n            this._renderer = _renderer;\n            this._nextCompTypeId = 0;\n            this.sanitizer = sanitizer;\n        }\n        /** @internal */\n        ViewUtils.prototype.renderComponent = function (renderComponentType) {\n            return this._renderer.renderComponent(renderComponentType);\n        };\n        ViewUtils.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        ViewUtils.ctorParameters = [\n            { type: RootRenderer, },\n            { type: Sanitizer, },\n        ];\n        return ViewUtils;\n    }());\n    var nextRenderComponentTypeId = 0;\n    function createRenderComponentType(templateUrl, slotCount, encapsulation, styles, animations) {\n        return new RenderComponentType(\"\" + nextRenderComponentTypeId++, templateUrl, slotCount, encapsulation, styles, animations);\n    }\n    function addToArray(e, array) {\n        array.push(e);\n    }\n    function interpolate(valueCount, constAndInterp) {\n        var result = '';\n        for (var i = 0; i < valueCount * 2; i = i + 2) {\n            result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);\n        }\n        return result + constAndInterp[valueCount * 2];\n    }\n    function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {\n        switch (valueCount) {\n            case 1:\n                return c0 + _toStringWithNull(a1) + c1;\n            case 2:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;\n            case 3:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3;\n            case 4:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4;\n            case 5:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;\n            case 6:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;\n            case 7:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n                    c6 + _toStringWithNull(a7) + c7;\n            case 8:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;\n            case 9:\n                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\n                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\n                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;\n            default:\n                throw new Error(\"Does not support more than 9 expressions\");\n        }\n    }\n    function _toStringWithNull(v) {\n        return v != null ? v.toString() : '';\n    }\n    function checkBinding(throwOnChange, oldValue, newValue) {\n        if (throwOnChange) {\n            if (!devModeEqual(oldValue, newValue)) {\n                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);\n            }\n            return false;\n        }\n        else {\n            return !looseIdentical(oldValue, newValue);\n        }\n    }\n    function castByValue(input, value) {\n        return input;\n    }\n    var EMPTY_ARRAY = [];\n    var EMPTY_MAP = {};\n    function pureProxy1(fn) {\n        var result;\n        var v0 = UNINITIALIZED;\n        return function (p0) {\n            if (!looseIdentical(v0, p0)) {\n                v0 = p0;\n                result = fn(p0);\n            }\n            return result;\n        };\n    }\n    function pureProxy2(fn) {\n        var result;\n        var v0 = UNINITIALIZED;\n        var v1 = UNINITIALIZED;\n        return function (p0, p1) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {\n                v0 = p0;\n                v1 = p1;\n                result = fn(p0, p1);\n            }\n            return result;\n        };\n    }\n    function pureProxy3(fn) {\n        var result;\n        var v0 = UNINITIALIZED;\n        var v1 = UNINITIALIZED;\n        var v2 = UNINITIALIZED;\n        return function (p0, p1, p2) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                result = fn(p0, p1, p2);\n            }\n            return result;\n        };\n    }\n    function pureProxy4(fn) {\n        var result;\n        var v0, v1, v2, v3;\n        v0 = v1 = v2 = v3 = UNINITIALIZED;\n        return function (p0, p1, p2, p3) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                result = fn(p0, p1, p2, p3);\n            }\n            return result;\n        };\n    }\n    function pureProxy5(fn) {\n        var result;\n        var v0, v1, v2, v3, v4;\n        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                result = fn(p0, p1, p2, p3, p4);\n            }\n            return result;\n        };\n    }\n    function pureProxy6(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5;\n        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                result = fn(p0, p1, p2, p3, p4, p5);\n            }\n            return result;\n        };\n    }\n    function pureProxy7(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                result = fn(p0, p1, p2, p3, p4, p5, p6);\n            }\n            return result;\n        };\n    }\n    function pureProxy8(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6, v7;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6, p7) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                v7 = p7;\n                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);\n            }\n            return result;\n        };\n    }\n    function pureProxy9(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6, v7, v8;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                v7 = p7;\n                v8 = p8;\n                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);\n            }\n            return result;\n        };\n    }\n    function pureProxy10(fn) {\n        var result;\n        var v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;\n        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;\n        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {\n            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||\n                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||\n                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||\n                !looseIdentical(v9, p9)) {\n                v0 = p0;\n                v1 = p1;\n                v2 = p2;\n                v3 = p3;\n                v4 = p4;\n                v5 = p5;\n                v6 = p6;\n                v7 = p7;\n                v8 = p8;\n                v9 = p9;\n                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n            }\n            return result;\n        };\n    }\n    function setBindingDebugInfoForChanges(renderer, el, changes) {\n        Object.keys(changes).forEach(function (propName) {\n            setBindingDebugInfo(renderer, el, propName, changes[propName].currentValue);\n        });\n    }\n    function setBindingDebugInfo(renderer, el, propName, value) {\n        try {\n            renderer.setBindingDebugInfo(el, \"ng-reflect-\" + camelCaseToDashCase(propName), value ? value.toString() : null);\n        }\n        catch (e) {\n            renderer.setBindingDebugInfo(el, \"ng-reflect-\" + camelCaseToDashCase(propName), '[ERROR] Exception while trying to serialize the value');\n        }\n    }\n    var CAMEL_CASE_REGEXP = /([A-Z])/g;\n    function camelCaseToDashCase(input) {\n        return input.replace(CAMEL_CASE_REGEXP, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i - 0] = arguments[_i];\n            }\n            return '-' + m[1].toLowerCase();\n        });\n    }\n    function createRenderElement(renderer, parentElement, name, attrs, debugInfo) {\n        var el = renderer.createElement(parentElement, name, debugInfo);\n        for (var i = 0; i < attrs.length; i += 2) {\n            renderer.setElementAttribute(el, attrs.get(i), attrs.get(i + 1));\n        }\n        return el;\n    }\n    function selectOrCreateRenderHostElement(renderer, elementName, attrs, rootSelectorOrNode, debugInfo) {\n        var hostElement;\n        if (isPresent(rootSelectorOrNode)) {\n            hostElement = renderer.selectRootElement(rootSelectorOrNode, debugInfo);\n            for (var i = 0; i < attrs.length; i += 2) {\n                renderer.setElementAttribute(hostElement, attrs.get(i), attrs.get(i + 1));\n            }\n        }\n        else {\n            hostElement = createRenderElement(renderer, null, elementName, attrs, debugInfo);\n        }\n        return hostElement;\n    }\n    function subscribeToRenderElement(view, element, eventNamesAndTargets, listener) {\n        var disposables = createEmptyInlineArray(eventNamesAndTargets.length / 2);\n        for (var i = 0; i < eventNamesAndTargets.length; i += 2) {\n            var eventName = eventNamesAndTargets.get(i);\n            var eventTarget = eventNamesAndTargets.get(i + 1);\n            var disposable = void 0;\n            if (eventTarget) {\n                disposable = view.renderer.listenGlobal(eventTarget, eventName, listener.bind(view, eventTarget + \":\" + eventName));\n            }\n            else {\n                disposable = view.renderer.listen(element, eventName, listener.bind(view, eventName));\n            }\n            disposables.set(i / 2, disposable);\n        }\n        return disposeInlineArray.bind(null, disposables);\n    }\n    function disposeInlineArray(disposables) {\n        for (var i = 0; i < disposables.length; i++) {\n            disposables.get(i)();\n        }\n    }\n    function noop() { }\n    function createEmptyInlineArray(length) {\n        var ctor;\n        if (length <= 2) {\n            ctor = InlineArray2;\n        }\n        else if (length <= 4) {\n            ctor = InlineArray4;\n        }\n        else if (length <= 8) {\n            ctor = InlineArray8;\n        }\n        else if (length <= 16) {\n            ctor = InlineArray16;\n        }\n        else {\n            ctor = InlineArrayDynamic;\n        }\n        return new ctor(length);\n    }\n    var InlineArray0 = (function () {\n        function InlineArray0() {\n            this.length = 0;\n        }\n        InlineArray0.prototype.get = function (index) { return undefined; };\n        InlineArray0.prototype.set = function (index, value) { };\n        return InlineArray0;\n    }());\n    var InlineArray2 = (function () {\n        function InlineArray2(length, _v0, _v1) {\n            this.length = length;\n            this._v0 = _v0;\n            this._v1 = _v1;\n        }\n        InlineArray2.prototype.get = function (index) {\n            switch (index) {\n                case 0:\n                    return this._v0;\n                case 1:\n                    return this._v1;\n                default:\n                    return undefined;\n            }\n        };\n        InlineArray2.prototype.set = function (index, value) {\n            switch (index) {\n                case 0:\n                    this._v0 = value;\n                    break;\n                case 1:\n                    this._v1 = value;\n                    break;\n            }\n        };\n        return InlineArray2;\n    }());\n    var InlineArray4 = (function () {\n        function InlineArray4(length, _v0, _v1, _v2, _v3) {\n            this.length = length;\n            this._v0 = _v0;\n            this._v1 = _v1;\n            this._v2 = _v2;\n            this._v3 = _v3;\n        }\n        InlineArray4.prototype.get = function (index) {\n            switch (index) {\n                case 0:\n                    return this._v0;\n                case 1:\n                    return this._v1;\n                case 2:\n                    return this._v2;\n                case 3:\n                    return this._v3;\n                default:\n                    return undefined;\n            }\n        };\n        InlineArray4.prototype.set = function (index, value) {\n            switch (index) {\n                case 0:\n                    this._v0 = value;\n                    break;\n                case 1:\n                    this._v1 = value;\n                    break;\n                case 2:\n                    this._v2 = value;\n                    break;\n                case 3:\n                    this._v3 = value;\n                    break;\n            }\n        };\n        return InlineArray4;\n    }());\n    var InlineArray8 = (function () {\n        function InlineArray8(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7) {\n            this.length = length;\n            this._v0 = _v0;\n            this._v1 = _v1;\n            this._v2 = _v2;\n            this._v3 = _v3;\n            this._v4 = _v4;\n            this._v5 = _v5;\n            this._v6 = _v6;\n            this._v7 = _v7;\n        }\n        InlineArray8.prototype.get = function (index) {\n            switch (index) {\n                case 0:\n                    return this._v0;\n                case 1:\n                    return this._v1;\n                case 2:\n                    return this._v2;\n                case 3:\n                    return this._v3;\n                case 4:\n                    return this._v4;\n                case 5:\n                    return this._v5;\n                case 6:\n                    return this._v6;\n                case 7:\n                    return this._v7;\n                default:\n                    return undefined;\n            }\n        };\n        InlineArray8.prototype.set = function (index, value) {\n            switch (index) {\n                case 0:\n                    this._v0 = value;\n                    break;\n                case 1:\n                    this._v1 = value;\n                    break;\n                case 2:\n                    this._v2 = value;\n                    break;\n                case 3:\n                    this._v3 = value;\n                    break;\n                case 4:\n                    this._v4 = value;\n                    break;\n                case 5:\n                    this._v5 = value;\n                    break;\n                case 6:\n                    this._v6 = value;\n                    break;\n                case 7:\n                    this._v7 = value;\n                    break;\n            }\n        };\n        return InlineArray8;\n    }());\n    var InlineArray16 = (function () {\n        function InlineArray16(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7, _v8, _v9, _v10, _v11, _v12, _v13, _v14, _v15) {\n            this.length = length;\n            this._v0 = _v0;\n            this._v1 = _v1;\n            this._v2 = _v2;\n            this._v3 = _v3;\n            this._v4 = _v4;\n            this._v5 = _v5;\n            this._v6 = _v6;\n            this._v7 = _v7;\n            this._v8 = _v8;\n            this._v9 = _v9;\n            this._v10 = _v10;\n            this._v11 = _v11;\n            this._v12 = _v12;\n            this._v13 = _v13;\n            this._v14 = _v14;\n            this._v15 = _v15;\n        }\n        InlineArray16.prototype.get = function (index) {\n            switch (index) {\n                case 0:\n                    return this._v0;\n                case 1:\n                    return this._v1;\n                case 2:\n                    return this._v2;\n                case 3:\n                    return this._v3;\n                case 4:\n                    return this._v4;\n                case 5:\n                    return this._v5;\n                case 6:\n                    return this._v6;\n                case 7:\n                    return this._v7;\n                case 8:\n                    return this._v8;\n                case 9:\n                    return this._v9;\n                case 10:\n                    return this._v10;\n                case 11:\n                    return this._v11;\n                case 12:\n                    return this._v12;\n                case 13:\n                    return this._v13;\n                case 14:\n                    return this._v14;\n                case 15:\n                    return this._v15;\n                default:\n                    return undefined;\n            }\n        };\n        InlineArray16.prototype.set = function (index, value) {\n            switch (index) {\n                case 0:\n                    this._v0 = value;\n                    break;\n                case 1:\n                    this._v1 = value;\n                    break;\n                case 2:\n                    this._v2 = value;\n                    break;\n                case 3:\n                    this._v3 = value;\n                    break;\n                case 4:\n                    this._v4 = value;\n                    break;\n                case 5:\n                    this._v5 = value;\n                    break;\n                case 6:\n                    this._v6 = value;\n                    break;\n                case 7:\n                    this._v7 = value;\n                    break;\n                case 8:\n                    this._v8 = value;\n                    break;\n                case 9:\n                    this._v9 = value;\n                    break;\n                case 10:\n                    this._v10 = value;\n                    break;\n                case 11:\n                    this._v11 = value;\n                    break;\n                case 12:\n                    this._v12 = value;\n                    break;\n                case 13:\n                    this._v13 = value;\n                    break;\n                case 14:\n                    this._v14 = value;\n                    break;\n                case 15:\n                    this._v15 = value;\n                    break;\n            }\n        };\n        return InlineArray16;\n    }());\n    var InlineArrayDynamic = (function () {\n        // Note: We still take the length argument so this class can be created\n        // in the same ways as the other classes!\n        function InlineArrayDynamic(length) {\n            var values = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                values[_i - 1] = arguments[_i];\n            }\n            this.length = length;\n            this._values = values;\n        }\n        InlineArrayDynamic.prototype.get = function (index) { return this._values[index]; };\n        InlineArrayDynamic.prototype.set = function (index, value) { this._values[index] = value; };\n        return InlineArrayDynamic;\n    }());\n    var EMPTY_INLINE_ARRAY = new InlineArray0();\n\n\n    var view_utils = Object.freeze({\n        ViewUtils: ViewUtils,\n        createRenderComponentType: createRenderComponentType,\n        addToArray: addToArray,\n        interpolate: interpolate,\n        inlineInterpolate: inlineInterpolate,\n        checkBinding: checkBinding,\n        castByValue: castByValue,\n        EMPTY_ARRAY: EMPTY_ARRAY,\n        EMPTY_MAP: EMPTY_MAP,\n        pureProxy1: pureProxy1,\n        pureProxy2: pureProxy2,\n        pureProxy3: pureProxy3,\n        pureProxy4: pureProxy4,\n        pureProxy5: pureProxy5,\n        pureProxy6: pureProxy6,\n        pureProxy7: pureProxy7,\n        pureProxy8: pureProxy8,\n        pureProxy9: pureProxy9,\n        pureProxy10: pureProxy10,\n        setBindingDebugInfoForChanges: setBindingDebugInfoForChanges,\n        setBindingDebugInfo: setBindingDebugInfo,\n        createRenderElement: createRenderElement,\n        selectOrCreateRenderHostElement: selectOrCreateRenderHostElement,\n        subscribeToRenderElement: subscribeToRenderElement,\n        noop: noop,\n        InlineArray2: InlineArray2,\n        InlineArray4: InlineArray4,\n        InlineArray8: InlineArray8,\n        InlineArray16: InlineArray16,\n        InlineArrayDynamic: InlineArrayDynamic,\n        EMPTY_INLINE_ARRAY: EMPTY_INLINE_ARRAY\n    });\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$5 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Represents an instance of a Component created via a {@link ComponentFactory}.\n     *\n     * `ComponentRef` provides access to the Component Instance as well other objects related to this\n     * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n     * method.\n     * @stable\n     */\n    var ComponentRef = (function () {\n        function ComponentRef() {\n        }\n        Object.defineProperty(ComponentRef.prototype, \"location\", {\n            /**\n             * Location of the Host Element of this Component Instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef.prototype, \"injector\", {\n            /**\n             * The injector on which the component instance exists.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef.prototype, \"instance\", {\n            /**\n             * The instance of the Component.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef.prototype, \"hostView\", {\n            /**\n             * The {@link ViewRef} of the Host View of this Component instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef.prototype, \"changeDetectorRef\", {\n            /**\n             * The {@link ChangeDetectorRef} of the Component instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef.prototype, \"componentType\", {\n            /**\n             * The component type.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return ComponentRef;\n    }());\n    var ComponentRef_ = (function (_super) {\n        __extends$5(ComponentRef_, _super);\n        function ComponentRef_(_index, _parentView, _nativeElement, _component) {\n            _super.call(this);\n            this._index = _index;\n            this._parentView = _parentView;\n            this._nativeElement = _nativeElement;\n            this._component = _component;\n        }\n        Object.defineProperty(ComponentRef_.prototype, \"location\", {\n            get: function () { return new ElementRef(this._nativeElement); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef_.prototype, \"injector\", {\n            get: function () { return this._parentView.injector(this._index); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ComponentRef_.prototype, \"instance\", {\n            get: function () { return this._component; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef_.prototype, \"hostView\", {\n            get: function () { return this._parentView.ref; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef_.prototype, \"changeDetectorRef\", {\n            get: function () { return this._parentView.ref; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ComponentRef_.prototype, \"componentType\", {\n            get: function () { return this._component.constructor; },\n            enumerable: true,\n            configurable: true\n        });\n        ComponentRef_.prototype.destroy = function () { this._parentView.detachAndDestroy(); };\n        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };\n        return ComponentRef_;\n    }(ComponentRef));\n    /**\n     * @stable\n     */\n    var ComponentFactory = (function () {\n        function ComponentFactory(selector, _viewClass, _componentType) {\n            this.selector = selector;\n            this._viewClass = _viewClass;\n            this._componentType = _componentType;\n        }\n        Object.defineProperty(ComponentFactory.prototype, \"componentType\", {\n            get: function () { return this._componentType; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Creates a new component.\n         */\n        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {\n            if (projectableNodes === void 0) { projectableNodes = null; }\n            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }\n            var vu = injector.get(ViewUtils);\n            if (!projectableNodes) {\n                projectableNodes = [];\n            }\n            var hostView = new this._viewClass(vu, null, null, null);\n            return hostView.createHostView(rootSelectorOrNode, injector, projectableNodes);\n        };\n        return ComponentFactory;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$7 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @stable\n     */\n    var NoComponentFactoryError = (function (_super) {\n        __extends$7(NoComponentFactoryError, _super);\n        function NoComponentFactoryError(component) {\n            _super.call(this, \"No component factory found for \" + stringify(component));\n            this.component = component;\n        }\n        return NoComponentFactoryError;\n    }(BaseError));\n    var _NullComponentFactoryResolver = (function () {\n        function _NullComponentFactoryResolver() {\n        }\n        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\n            throw new NoComponentFactoryError(component);\n        };\n        return _NullComponentFactoryResolver;\n    }());\n    /**\n     * @stable\n     */\n    var ComponentFactoryResolver = (function () {\n        function ComponentFactoryResolver() {\n        }\n        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();\n        return ComponentFactoryResolver;\n    }());\n    var CodegenComponentFactoryResolver = (function () {\n        function CodegenComponentFactoryResolver(factories, _parent) {\n            this._parent = _parent;\n            this._factories = new Map();\n            for (var i = 0; i < factories.length; i++) {\n                var factory = factories[i];\n                this._factories.set(factory.componentType, factory);\n            }\n        }\n        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\n            var result = this._factories.get(component);\n            if (!result) {\n                result = this._parent.resolveComponentFactory(component);\n            }\n            return result;\n        };\n        return CodegenComponentFactoryResolver;\n    }());\n\n    var trace;\n    var events;\n    function detectWTF() {\n        var wtf = global$1['wtf'];\n        if (wtf) {\n            trace = wtf['trace'];\n            if (trace) {\n                events = trace['events'];\n                return true;\n            }\n        }\n        return false;\n    }\n    function createScope(signature, flags) {\n        if (flags === void 0) { flags = null; }\n        return events.createScope(signature, flags);\n    }\n    function leave(scope, returnValue) {\n        trace.leaveScope(scope, returnValue);\n        return returnValue;\n    }\n    function startTimeRange(rangeType, action) {\n        return trace.beginTimeRange(rangeType, action);\n    }\n    function endTimeRange(range) {\n        trace.endTimeRange(range);\n    }\n\n    /**\n     * True if WTF is enabled.\n     */\n    var wtfEnabled = detectWTF();\n    function noopScope(arg0, arg1) {\n        return null;\n    }\n    /**\n     * Create trace scope.\n     *\n     * Scopes must be strictly nested and are analogous to stack frames, but\n     * do not have to follow the stack frames. Instead it is recommended that they follow logical\n     * nesting. You may want to use\n     * [Event\n     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n     * as they are defined in WTF.\n     *\n     * Used to mark scope entry. The return value is used to leave the scope.\n     *\n     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n     *\n     *     someMethod() {\n     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n     *        // DO SOME WORK HERE\n     *        return wtfLeave(s, 123); // Return value 123\n     *     }\n     *\n     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n     * negatively impact the performance of your application. For this reason we recommend that\n     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n     * exception, will produce incorrect trace, but presence of exception signifies logic error which\n     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n     * an exception is expected during normal execution while profiling.\n     *\n     * @experimental\n     */\n    var wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };\n    /**\n     * Used to mark end of Scope.\n     *\n     * - `scope` to end.\n     * - `returnValue` (optional) to be passed to the WTF.\n     *\n     * Returns the `returnValue for easy chaining.\n     * @experimental\n     */\n    var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };\n    /**\n     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n     * enabled.\n     *\n     *     someMethod() {\n     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n     *        var future = new Future.delay(5).then((_) {\n     *          wtfEndTimeRange(s);\n     *        });\n     *     }\n     * @experimental\n     */\n    var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };\n    /**\n     * Ends a async time range operation.\n     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n     * enabled.\n     * @experimental\n     */\n    var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$8 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Use by directives and components to emit custom Events.\n     *\n     * ### Examples\n     *\n     * In the following example, `Zippy` alternatively emits `open` and `close` events when its\n     * title gets clicked:\n     *\n     * ```\n     * @Component({\n     *   selector: 'zippy',\n     *   template: `\n     *   <div class=\"zippy\">\n     *     <div (click)=\"toggle()\">Toggle</div>\n     *     <div [hidden]=\"!visible\">\n     *       <ng-content></ng-content>\n     *     </div>\n     *  </div>`})\n     * export class Zippy {\n     *   visible: boolean = true;\n     *   @Output() open: EventEmitter<any> = new EventEmitter();\n     *   @Output() close: EventEmitter<any> = new EventEmitter();\n     *\n     *   toggle() {\n     *     this.visible = !this.visible;\n     *     if (this.visible) {\n     *       this.open.emit(null);\n     *     } else {\n     *       this.close.emit(null);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * The events payload can be accessed by the parameter `$event` on the components output event\n     * handler:\n     *\n     * ```\n     * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n     * ```\n     *\n     * Uses Rx.Observable but provides an adapter to make it work as specified here:\n     * https://github.com/jhusain/observable-spec\n     *\n     * Once a reference implementation of the spec is available, switch to it.\n     * @stable\n     */\n    var EventEmitter = (function (_super) {\n        __extends$8(EventEmitter, _super);\n        /**\n         * Creates an instance of [EventEmitter], which depending on [isAsync],\n         * delivers events synchronously or asynchronously.\n         */\n        function EventEmitter(isAsync) {\n            if (isAsync === void 0) { isAsync = false; }\n            _super.call(this);\n            this.__isAsync = isAsync;\n        }\n        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };\n        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {\n            var schedulerFn;\n            var errorFn = function (err) { return null; };\n            var completeFn = function () { return null; };\n            if (generatorOrNext && typeof generatorOrNext === 'object') {\n                schedulerFn = this.__isAsync ? function (value) {\n                    setTimeout(function () { return generatorOrNext.next(value); });\n                } : function (value) { generatorOrNext.next(value); };\n                if (generatorOrNext.error) {\n                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :\n                        function (err) { generatorOrNext.error(err); };\n                }\n                if (generatorOrNext.complete) {\n                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :\n                        function () { generatorOrNext.complete(); };\n                }\n            }\n            else {\n                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :\n                    function (value) { generatorOrNext(value); };\n                if (error) {\n                    errorFn =\n                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };\n                }\n                if (complete) {\n                    completeFn =\n                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };\n                }\n            }\n            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);\n        };\n        return EventEmitter;\n    }(rxjs_Subject.Subject));\n\n    /**\n     * An injectable service for executing work inside or outside of the Angular zone.\n     *\n     * The most common use of this service is to optimize performance when starting a work consisting of\n     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n     * Angular. Such tasks can be kicked off via {@link runOutsideAngular} and if needed, these tasks\n     * can reenter the Angular zone via {@link run}.\n     *\n     * <!-- TODO: add/fix links to:\n     *   - docs explaining zones and the use of zones in Angular and change-detection\n     *   - link to runOutsideAngular/run (throughout this file!)\n     *   -->\n     *\n     * ### Example\n     * ```\n     * import {Component, NgZone} from '@angular/core';\n     * import {NgIf} from '@angular/common';\n     *\n     * @Component({\n     *   selector: 'ng-zone-demo'.\n     *   template: `\n     *     <h2>Demo: NgZone</h2>\n     *\n     *     <p>Progress: {{progress}}%</p>\n     *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n     *\n     *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n     *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n     *   `,\n     * })\n     * export class NgZoneDemo {\n     *   progress: number = 0;\n     *   label: string;\n     *\n     *   constructor(private _ngZone: NgZone) {}\n     *\n     *   // Loop inside the Angular zone\n     *   // so the UI DOES refresh after each setTimeout cycle\n     *   processWithinAngularZone() {\n     *     this.label = 'inside';\n     *     this.progress = 0;\n     *     this._increaseProgress(() => console.log('Inside Done!'));\n     *   }\n     *\n     *   // Loop outside of the Angular zone\n     *   // so the UI DOES NOT refresh after each setTimeout cycle\n     *   processOutsideOfAngularZone() {\n     *     this.label = 'outside';\n     *     this.progress = 0;\n     *     this._ngZone.runOutsideAngular(() => {\n     *       this._increaseProgress(() => {\n     *       // reenter the Angular zone and display done\n     *       this._ngZone.run(() => {console.log('Outside Done!') });\n     *     }}));\n     *   }\n     *\n     *   _increaseProgress(doneCallback: () => void) {\n     *     this.progress += 1;\n     *     console.log(`Current progress: ${this.progress}%`);\n     *\n     *     if (this.progress < 100) {\n     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\n     *     } else {\n     *       doneCallback();\n     *     }\n     *   }\n     * }\n     * ```\n     * @experimental\n     */\n    var NgZone = (function () {\n        function NgZone(_a) {\n            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;\n            this._hasPendingMicrotasks = false;\n            this._hasPendingMacrotasks = false;\n            this._isStable = true;\n            this._nesting = 0;\n            this._onUnstable = new EventEmitter(false);\n            this._onMicrotaskEmpty = new EventEmitter(false);\n            this._onStable = new EventEmitter(false);\n            this._onErrorEvents = new EventEmitter(false);\n            if (typeof Zone == 'undefined') {\n                throw new Error('Angular requires Zone.js prolyfill.');\n            }\n            Zone.assertZonePatched();\n            this.outer = this.inner = Zone.current;\n            if (Zone['wtfZoneSpec']) {\n                this.inner = this.inner.fork(Zone['wtfZoneSpec']);\n            }\n            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {\n                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);\n            }\n            this.forkInnerZoneWithAngularBehavior();\n        }\n        NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };\n        NgZone.assertInAngularZone = function () {\n            if (!NgZone.isInAngularZone()) {\n                throw new Error('Expected to be in Angular Zone, but it is not!');\n            }\n        };\n        NgZone.assertNotInAngularZone = function () {\n            if (NgZone.isInAngularZone()) {\n                throw new Error('Expected to not be in Angular Zone, but it is!');\n            }\n        };\n        /**\n         * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n         * the function.\n         *\n         * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n         * outside of the Angular zone (typically started via {@link runOutsideAngular}).\n         *\n         * Any future tasks or microtasks scheduled from within this function will continue executing from\n         * within the Angular zone.\n         *\n         * If a synchronous error happens it will be rethrown and not reported via `onError`.\n         */\n        NgZone.prototype.run = function (fn) { return this.inner.run(fn); };\n        /**\n         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n         * rethrown.\n         */\n        NgZone.prototype.runGuarded = function (fn) { return this.inner.runGuarded(fn); };\n        /**\n         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n         * the function.\n         *\n         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that\n         * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n         *\n         * Any future tasks or microtasks scheduled from within this function will continue executing from\n         * outside of the Angular zone.\n         *\n         * Use {@link run} to reenter the Angular zone and do work that updates the application model.\n         */\n        NgZone.prototype.runOutsideAngular = function (fn) { return this.outer.run(fn); };\n        Object.defineProperty(NgZone.prototype, \"onUnstable\", {\n            /**\n             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n             */\n            get: function () { return this._onUnstable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"onMicrotaskEmpty\", {\n            /**\n             * Notifies when there is no more microtasks enqueue in the current VM Turn.\n             * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n             * For this reason this event can fire multiple times per VM Turn.\n             */\n            get: function () { return this._onMicrotaskEmpty; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"onStable\", {\n            /**\n             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n             * implies we are about to relinquish VM turn.\n             * This event gets called just once.\n             */\n            get: function () { return this._onStable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"onError\", {\n            /**\n             * Notify that an error has been delivered.\n             */\n            get: function () { return this._onErrorEvents; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"isStable\", {\n            /**\n             * Whether there are no outstanding microtasks or macrotasks.\n             */\n            get: function () { return this._isStable; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"hasPendingMicrotasks\", {\n            get: function () { return this._hasPendingMicrotasks; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgZone.prototype, \"hasPendingMacrotasks\", {\n            get: function () { return this._hasPendingMacrotasks; },\n            enumerable: true,\n            configurable: true\n        });\n        NgZone.prototype.checkStable = function () {\n            var _this = this;\n            if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {\n                try {\n                    this._nesting++;\n                    this._onMicrotaskEmpty.emit(null);\n                }\n                finally {\n                    this._nesting--;\n                    if (!this._hasPendingMicrotasks) {\n                        try {\n                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });\n                        }\n                        finally {\n                            this._isStable = true;\n                        }\n                    }\n                }\n            }\n        };\n        NgZone.prototype.forkInnerZoneWithAngularBehavior = function () {\n            var _this = this;\n            this.inner = this.inner.fork({\n                name: 'angular',\n                properties: { 'isAngularZone': true },\n                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {\n                    try {\n                        _this.onEnter();\n                        return delegate.invokeTask(target, task, applyThis, applyArgs);\n                    }\n                    finally {\n                        _this.onLeave();\n                    }\n                },\n                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                    try {\n                        _this.onEnter();\n                        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                    }\n                    finally {\n                        _this.onLeave();\n                    }\n                },\n                onHasTask: function (delegate, current, target, hasTaskState) {\n                    delegate.hasTask(target, hasTaskState);\n                    if (current === target) {\n                        // We are only interested in hasTask events which originate from our zone\n                        // (A child hasTask event is not interesting to us)\n                        if (hasTaskState.change == 'microTask') {\n                            _this.setHasMicrotask(hasTaskState.microTask);\n                        }\n                        else if (hasTaskState.change == 'macroTask') {\n                            _this.setHasMacrotask(hasTaskState.macroTask);\n                        }\n                    }\n                },\n                onHandleError: function (delegate, current, target, error) {\n                    delegate.handleError(target, error);\n                    _this.triggerError(error);\n                    return false;\n                }\n            });\n        };\n        NgZone.prototype.onEnter = function () {\n            this._nesting++;\n            if (this._isStable) {\n                this._isStable = false;\n                this._onUnstable.emit(null);\n            }\n        };\n        NgZone.prototype.onLeave = function () {\n            this._nesting--;\n            this.checkStable();\n        };\n        NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {\n            this._hasPendingMicrotasks = hasMicrotasks;\n            this.checkStable();\n        };\n        NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };\n        NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };\n        return NgZone;\n    }());\n\n    /**\n     * The Testability service provides testing hooks that can be accessed from\n     * the browser and by services such as Protractor. Each bootstrapped Angular\n     * application on the page will have an instance of Testability.\n     * @experimental\n     */\n    var Testability = (function () {\n        function Testability(_ngZone) {\n            this._ngZone = _ngZone;\n            /** @internal */\n            this._pendingCount = 0;\n            /** @internal */\n            this._isZoneStable = true;\n            /**\n             * Whether any work was done since the last 'whenStable' callback. This is\n             * useful to detect if this could have potentially destabilized another\n             * component while it is stabilizing.\n             * @internal\n             */\n            this._didWork = false;\n            /** @internal */\n            this._callbacks = [];\n            this._watchAngularEvents();\n        }\n        /** @internal */\n        Testability.prototype._watchAngularEvents = function () {\n            var _this = this;\n            this._ngZone.onUnstable.subscribe({\n                next: function () {\n                    _this._didWork = true;\n                    _this._isZoneStable = false;\n                }\n            });\n            this._ngZone.runOutsideAngular(function () {\n                _this._ngZone.onStable.subscribe({\n                    next: function () {\n                        NgZone.assertNotInAngularZone();\n                        scheduleMicroTask(function () {\n                            _this._isZoneStable = true;\n                            _this._runCallbacksIfReady();\n                        });\n                    }\n                });\n            });\n        };\n        Testability.prototype.increasePendingRequestCount = function () {\n            this._pendingCount += 1;\n            this._didWork = true;\n            return this._pendingCount;\n        };\n        Testability.prototype.decreasePendingRequestCount = function () {\n            this._pendingCount -= 1;\n            if (this._pendingCount < 0) {\n                throw new Error('pending async requests below zero');\n            }\n            this._runCallbacksIfReady();\n            return this._pendingCount;\n        };\n        Testability.prototype.isStable = function () {\n            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;\n        };\n        /** @internal */\n        Testability.prototype._runCallbacksIfReady = function () {\n            var _this = this;\n            if (this.isStable()) {\n                // Schedules the call backs in a new frame so that it is always async.\n                scheduleMicroTask(function () {\n                    while (_this._callbacks.length !== 0) {\n                        (_this._callbacks.pop())(_this._didWork);\n                    }\n                    _this._didWork = false;\n                });\n            }\n            else {\n                // Not Ready\n                this._didWork = true;\n            }\n        };\n        Testability.prototype.whenStable = function (callback) {\n            this._callbacks.push(callback);\n            this._runCallbacksIfReady();\n        };\n        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };\n        /** @deprecated use findProviders */\n        Testability.prototype.findBindings = function (using, provider, exactMatch) {\n            // TODO(juliemr): implement.\n            return [];\n        };\n        Testability.prototype.findProviders = function (using, provider, exactMatch) {\n            // TODO(juliemr): implement.\n            return [];\n        };\n        Testability.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        Testability.ctorParameters = [\n            { type: NgZone, },\n        ];\n        return Testability;\n    }());\n    /**\n     * A global registry of {@link Testability} instances for specific elements.\n     * @experimental\n     */\n    var TestabilityRegistry = (function () {\n        function TestabilityRegistry() {\n            /** @internal */\n            this._applications = new Map();\n            _testabilityGetter.addToWindow(this);\n        }\n        TestabilityRegistry.prototype.registerApplication = function (token, testability) {\n            this._applications.set(token, testability);\n        };\n        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };\n        TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };\n        TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };\n        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {\n            if (findInAncestors === void 0) { findInAncestors = true; }\n            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\n        };\n        TestabilityRegistry.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        TestabilityRegistry.ctorParameters = [];\n        return TestabilityRegistry;\n    }());\n    var _NoopGetTestability = (function () {\n        function _NoopGetTestability() {\n        }\n        _NoopGetTestability.prototype.addToWindow = function (registry) { };\n        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\n            return null;\n        };\n        return _NoopGetTestability;\n    }());\n    /**\n     * Set the {@link GetTestability} implementation used by the Angular testing framework.\n     * @experimental\n     */\n    function setTestabilityGetter(getter) {\n        _testabilityGetter = getter;\n    }\n    var _testabilityGetter = new _NoopGetTestability();\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _devMode = true;\n    var _runModeLocked = false;\n    var _platform;\n    /**\n     * Disable Angular's development mode, which turns off assertions and other\n     * checks within the framework.\n     *\n     * One important assertion this disables verifies that a change detection pass\n     * does not result in additional changes to any bindings (also known as\n     * unidirectional data flow).\n     *\n     * @stable\n     */\n    function enableProdMode() {\n        if (_runModeLocked) {\n            throw new Error('Cannot enable prod mode after platform setup.');\n        }\n        _devMode = false;\n    }\n    /**\n     * Returns whether Angular is in development mode. After called once,\n     * the value is locked and won't change any more.\n     *\n     * By default, this is true, unless a user calls `enableProdMode` before calling this.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function isDevMode() {\n        _runModeLocked = true;\n        return _devMode;\n    }\n    /**\n     * Creates a platform.\n     * Platforms have to be eagerly created via this function.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function createPlatform(injector) {\n        if (_platform && !_platform.destroyed) {\n            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');\n        }\n        _platform = injector.get(PlatformRef);\n        var inits = injector.get(PLATFORM_INITIALIZER, null);\n        if (inits)\n            inits.forEach(function (init) { return init(); });\n        return _platform;\n    }\n    /**\n     * Creates a factory for a platform\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function createPlatformFactory(parentPlaformFactory, name, providers) {\n        if (providers === void 0) { providers = []; }\n        var marker = new OpaqueToken(\"Platform: \" + name);\n        return function (extraProviders) {\n            if (extraProviders === void 0) { extraProviders = []; }\n            if (!getPlatform()) {\n                if (parentPlaformFactory) {\n                    parentPlaformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));\n                }\n                else {\n                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));\n                }\n            }\n            return assertPlatform(marker);\n        };\n    }\n    /**\n     * Checks that there currently is a platform\n     * which contains the given token as a provider.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function assertPlatform(requiredToken) {\n        var platform = getPlatform();\n        if (!platform) {\n            throw new Error('No platform exists!');\n        }\n        if (!platform.injector.get(requiredToken, null)) {\n            throw new Error('A platform with a different configuration has been created. Please destroy it first.');\n        }\n        return platform;\n    }\n    /**\n     * Destroy the existing platform.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function destroyPlatform() {\n        if (_platform && !_platform.destroyed) {\n            _platform.destroy();\n        }\n    }\n    /**\n     * Returns the current platform.\n     *\n     * @experimental APIs related to application bootstrap are currently under review.\n     */\n    function getPlatform() {\n        return _platform && !_platform.destroyed ? _platform : null;\n    }\n    /**\n     * The Angular platform is the entry point for Angular on a web page. Each page\n     * has exactly one platform, and services (such as reflection) which are common\n     * to every Angular application running on the page are bound in its scope.\n     *\n     * A page's platform is initialized implicitly when {@link bootstrap}() is called, or\n     * explicitly by calling {@link createPlatform}().\n     *\n     * @stable\n     */\n    var PlatformRef = (function () {\n        function PlatformRef() {\n        }\n        /**\n         * Creates an instance of an `@NgModule` for the given platform\n         * for offline compilation.\n         *\n         * ## Simple Example\n         *\n         * ```typescript\n         * my_module.ts:\n         *\n         * @NgModule({\n         *   imports: [BrowserModule]\n         * })\n         * class MyModule {}\n         *\n         * main.ts:\n         * import {MyModuleNgFactory} from './my_module.ngfactory';\n         * import {platformBrowser} from '@angular/platform-browser';\n         *\n         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\n         * ```\n         *\n         * @experimental APIs related to application bootstrap are currently under review.\n         */\n        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {\n            throw unimplemented();\n        };\n        /**\n         * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\n         *\n         * ## Simple Example\n         *\n         * ```typescript\n         * @NgModule({\n         *   imports: [BrowserModule]\n         * })\n         * class MyModule {}\n         *\n         * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n         * ```\n         * @stable\n         */\n        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {\n            if (compilerOptions === void 0) { compilerOptions = []; }\n            throw unimplemented();\n        };\n        Object.defineProperty(PlatformRef.prototype, \"injector\", {\n            /**\n             * Retrieve the platform {@link Injector}, which is the parent injector for\n             * every Angular application on the page and provides singleton providers.\n             */\n            get: function () { throw unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(PlatformRef.prototype, \"destroyed\", {\n            get: function () { throw unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return PlatformRef;\n    }());\n    function _callAndReportToErrorHandler(errorHandler, callback) {\n        try {\n            var result = callback();\n            if (isPromise(result)) {\n                return result.catch(function (e) {\n                    errorHandler.handleError(e);\n                    // rethrow as the exception handler might not do it\n                    throw e;\n                });\n            }\n            return result;\n        }\n        catch (e) {\n            errorHandler.handleError(e);\n            // rethrow as the exception handler might not do it\n            throw e;\n        }\n    }\n    var PlatformRef_ = (function (_super) {\n        __extends$3(PlatformRef_, _super);\n        function PlatformRef_(_injector) {\n            _super.call(this);\n            this._injector = _injector;\n            this._modules = [];\n            this._destroyListeners = [];\n            this._destroyed = false;\n        }\n        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\n        Object.defineProperty(PlatformRef_.prototype, \"injector\", {\n            get: function () { return this._injector; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PlatformRef_.prototype, \"destroyed\", {\n            get: function () { return this._destroyed; },\n            enumerable: true,\n            configurable: true\n        });\n        PlatformRef_.prototype.destroy = function () {\n            if (this._destroyed) {\n                throw new Error('The platform has already been destroyed!');\n            }\n            this._modules.slice().forEach(function (module) { return module.destroy(); });\n            this._destroyListeners.forEach(function (listener) { return listener(); });\n            this._destroyed = true;\n        };\n        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {\n            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);\n        };\n        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {\n            var _this = this;\n            // Note: We need to create the NgZone _before_ we instantiate the module,\n            // as instantiating the module creates some providers eagerly.\n            // So we create a mini parent injector that just contains the new NgZone and\n            // pass that as parent to the NgModuleFactory.\n            if (!ngZone)\n                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });\n            // Attention: Don't use ApplicationRef.run here,\n            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!\n            return ngZone.run(function () {\n                var ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);\n                var moduleRef = moduleFactory.create(ngZoneInjector);\n                var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);\n                if (!exceptionHandler) {\n                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');\n                }\n                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });\n                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });\n                return _callAndReportToErrorHandler(exceptionHandler, function () {\n                    var initStatus = moduleRef.injector.get(ApplicationInitStatus);\n                    return initStatus.donePromise.then(function () {\n                        _this._moduleDoBootstrap(moduleRef);\n                        return moduleRef;\n                    });\n                });\n            });\n        };\n        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {\n            if (compilerOptions === void 0) { compilerOptions = []; }\n            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);\n        };\n        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {\n            var _this = this;\n            if (compilerOptions === void 0) { compilerOptions = []; }\n            var compilerFactory = this.injector.get(CompilerFactory);\n            var compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);\n            // ugly internal api hack: generate host component factories for all declared components and\n            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all\n            // factories.\n            if (componentFactoryCallback) {\n                return compiler.compileModuleAndAllComponentsAsync(moduleType)\n                    .then(function (_a) {\n                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;\n                    componentFactoryCallback(componentFactories);\n                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);\n                });\n            }\n            return compiler.compileModuleAsync(moduleType)\n                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });\n        };\n        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {\n            var appRef = moduleRef.injector.get(ApplicationRef);\n            if (moduleRef.bootstrapFactories.length > 0) {\n                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });\n            }\n            else if (moduleRef.instance.ngDoBootstrap) {\n                moduleRef.instance.ngDoBootstrap(appRef);\n            }\n            else {\n                throw new Error((\"The module \" + stringify(moduleRef.instance.constructor) + \" was bootstrapped, but it does not declare \\\"@NgModule.bootstrap\\\" components nor a \\\"ngDoBootstrap\\\" method. \") +\n                    \"Please define one of these.\");\n            }\n        };\n        PlatformRef_.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        PlatformRef_.ctorParameters = [\n            { type: Injector, },\n        ];\n        return PlatformRef_;\n    }(PlatformRef));\n    /**\n     * A reference to an Angular application running on a page.\n     *\n     * For more about Angular applications, see the documentation for {@link bootstrap}.\n     *\n     * @stable\n     */\n    var ApplicationRef = (function () {\n        function ApplicationRef() {\n        }\n        Object.defineProperty(ApplicationRef.prototype, \"componentTypes\", {\n            /**\n             * Get a list of component types registered to this application.\n             * This list is populated even before the component is created.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(ApplicationRef.prototype, \"components\", {\n            /**\n             * Get a list of components registered to this application.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        return ApplicationRef;\n    }());\n    var ApplicationRef_ = (function (_super) {\n        __extends$3(ApplicationRef_, _super);\n        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {\n            var _this = this;\n            _super.call(this);\n            this._zone = _zone;\n            this._console = _console;\n            this._injector = _injector;\n            this._exceptionHandler = _exceptionHandler;\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._initStatus = _initStatus;\n            this._testabilityRegistry = _testabilityRegistry;\n            this._testability = _testability;\n            this._bootstrapListeners = [];\n            this._rootComponents = [];\n            this._rootComponentTypes = [];\n            this._changeDetectorRefs = [];\n            this._runningTick = false;\n            this._enforceNoNewChanges = false;\n            this._enforceNoNewChanges = isDevMode();\n            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });\n        }\n        ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {\n            this._changeDetectorRefs.push(changeDetector);\n        };\n        ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {\n            ListWrapper.remove(this._changeDetectorRefs, changeDetector);\n        };\n        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {\n            var _this = this;\n            if (!this._initStatus.done) {\n                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');\n            }\n            var componentFactory;\n            if (componentOrFactory instanceof ComponentFactory) {\n                componentFactory = componentOrFactory;\n            }\n            else {\n                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);\n            }\n            this._rootComponentTypes.push(componentFactory.componentType);\n            var compRef = componentFactory.create(this._injector, [], componentFactory.selector);\n            compRef.onDestroy(function () { _this._unloadComponent(compRef); });\n            var testability = compRef.injector.get(Testability, null);\n            if (testability) {\n                compRef.injector.get(TestabilityRegistry)\n                    .registerApplication(compRef.location.nativeElement, testability);\n            }\n            this._loadComponent(compRef);\n            if (isDevMode()) {\n                this._console.log(\"Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.\");\n            }\n            return compRef;\n        };\n        /** @internal */\n        ApplicationRef_.prototype._loadComponent = function (componentRef) {\n            this._changeDetectorRefs.push(componentRef.changeDetectorRef);\n            this.tick();\n            this._rootComponents.push(componentRef);\n            // Get the listeners lazily to prevent DI cycles.\n            var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, [])\n                .concat(this._bootstrapListeners);\n            listeners.forEach(function (listener) { return listener(componentRef); });\n        };\n        /** @internal */\n        ApplicationRef_.prototype._unloadComponent = function (componentRef) {\n            if (this._rootComponents.indexOf(componentRef) == -1) {\n                return;\n            }\n            this.unregisterChangeDetector(componentRef.changeDetectorRef);\n            ListWrapper.remove(this._rootComponents, componentRef);\n        };\n        ApplicationRef_.prototype.tick = function () {\n            if (this._runningTick) {\n                throw new Error('ApplicationRef.tick is called recursively');\n            }\n            var scope = ApplicationRef_._tickScope();\n            try {\n                this._runningTick = true;\n                this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });\n                if (this._enforceNoNewChanges) {\n                    this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });\n                }\n            }\n            finally {\n                this._runningTick = false;\n                wtfLeave(scope);\n            }\n        };\n        ApplicationRef_.prototype.ngOnDestroy = function () {\n            // TODO(alxhub): Dispose of the NgZone.\n            this._rootComponents.slice().forEach(function (component) { return component.destroy(); });\n        };\n        Object.defineProperty(ApplicationRef_.prototype, \"componentTypes\", {\n            get: function () { return this._rootComponentTypes; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ApplicationRef_.prototype, \"components\", {\n            get: function () { return this._rootComponents; },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');\n        ApplicationRef_.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        ApplicationRef_.ctorParameters = [\n            { type: NgZone, },\n            { type: Console, },\n            { type: Injector, },\n            { type: ErrorHandler, },\n            { type: ComponentFactoryResolver, },\n            { type: ApplicationInitStatus, },\n            { type: TestabilityRegistry, decorators: [{ type: Optional },] },\n            { type: Testability, decorators: [{ type: Optional },] },\n        ];\n        return ApplicationRef_;\n    }(ApplicationRef));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$9 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\n     *\n     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\n     * NgModule Instance.\n     *\n     * @stable\n     */\n    var NgModuleRef = (function () {\n        function NgModuleRef() {\n        }\n        Object.defineProperty(NgModuleRef.prototype, \"injector\", {\n            /**\n             * The injector that contains all of the providers of the NgModule.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModuleRef.prototype, \"componentFactoryResolver\", {\n            /**\n             * The ComponentFactoryResolver to get hold of the ComponentFactories\n             * declared in the `entryComponents` property of the module.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModuleRef.prototype, \"instance\", {\n            /**\n             * The NgModule instance.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return NgModuleRef;\n    }());\n    /**\n     * @experimental\n     */\n    var NgModuleFactory = (function () {\n        function NgModuleFactory(_injectorClass, _moduleType) {\n            this._injectorClass = _injectorClass;\n            this._moduleType = _moduleType;\n        }\n        Object.defineProperty(NgModuleFactory.prototype, \"moduleType\", {\n            get: function () { return this._moduleType; },\n            enumerable: true,\n            configurable: true\n        });\n        NgModuleFactory.prototype.create = function (parentInjector) {\n            if (!parentInjector) {\n                parentInjector = Injector.NULL;\n            }\n            var instance = new this._injectorClass(parentInjector);\n            instance.create();\n            return instance;\n        };\n        return NgModuleFactory;\n    }());\n    var _UNDEFINED = new Object();\n    var NgModuleInjector = (function (_super) {\n        __extends$9(NgModuleInjector, _super);\n        function NgModuleInjector(parent, factories, bootstrapFactories) {\n            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));\n            this.parent = parent;\n            this.bootstrapFactories = bootstrapFactories;\n            this._destroyListeners = [];\n            this._destroyed = false;\n        }\n        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };\n        NgModuleInjector.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\n            if (token === Injector || token === ComponentFactoryResolver) {\n                return this;\n            }\n            var result = this.getInternal(token, _UNDEFINED);\n            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;\n        };\n        Object.defineProperty(NgModuleInjector.prototype, \"injector\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModuleInjector.prototype, \"componentFactoryResolver\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        NgModuleInjector.prototype.destroy = function () {\n            if (this._destroyed) {\n                throw new Error(\"The ng module \" + stringify(this.instance.constructor) + \" has already been destroyed.\");\n            }\n            this._destroyed = true;\n            this.destroyInternal();\n            this._destroyListeners.forEach(function (listener) { return listener(); });\n        };\n        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\n        return NgModuleInjector;\n    }(CodegenComponentFactoryResolver));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Used to load ng module factories.\n     * @stable\n     */\n    var NgModuleFactoryLoader = (function () {\n        function NgModuleFactoryLoader() {\n        }\n        return NgModuleFactoryLoader;\n    }());\n    var moduleFactories = new Map();\n    /**\n     * Registers a loaded module. Should only be called from generated NgModuleFactory code.\n     * @experimental\n     */\n    function registerModuleFactory(id, factory) {\n        var existing = moduleFactories.get(id);\n        if (existing) {\n            throw new Error(\"Duplicate module registered for \" + id + \" - \" + existing.moduleType.name + \" vs \" + factory.moduleType.name);\n        }\n        moduleFactories.set(id, factory);\n    }\n    /**\n     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.\n     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module\n     * cannot be found.\n     * @experimental\n     */\n    function getModuleFactory(id) {\n        var factory = moduleFactories.get(id);\n        if (!factory)\n            throw new Error(\"No module with ID \" + id + \" loaded\");\n        return factory;\n    }\n\n    /**\n     * An unmodifiable list of items that Angular keeps up to date when the state\n     * of the application changes.\n     *\n     * The type of object that {@link Query} and {@link ViewQueryMetadata} provide.\n     *\n     * Implements an iterable interface, therefore it can be used in both ES6\n     * javascript `for (var i of items)` loops as well as in Angular templates with\n     * `*ngFor=\"let i of myList\"`.\n     *\n     * Changes can be observed by subscribing to the changes `Observable`.\n     *\n     * NOTE: In the future this class will implement an `Observable` interface.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))\n     * ```typescript\n     * @Component({...})\n     * class Container {\n     *   @ViewChildren(Item) items:QueryList<Item>;\n     * }\n     * ```\n     * @stable\n     */\n    var QueryList = (function () {\n        function QueryList() {\n            this._dirty = true;\n            this._results = [];\n            this._emitter = new EventEmitter();\n        }\n        Object.defineProperty(QueryList.prototype, \"changes\", {\n            get: function () { return this._emitter; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(QueryList.prototype, \"length\", {\n            get: function () { return this._results.length; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(QueryList.prototype, \"first\", {\n            get: function () { return this._results[0]; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(QueryList.prototype, \"last\", {\n            get: function () { return this._results[this.length - 1]; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * See\n         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n         */\n        QueryList.prototype.map = function (fn) { return this._results.map(fn); };\n        /**\n         * See\n         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n         */\n        QueryList.prototype.filter = function (fn) {\n            return this._results.filter(fn);\n        };\n        /**\n         * See\n         * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n         */\n        QueryList.prototype.find = function (fn) { return this._results.find(fn); };\n        /**\n         * See\n         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n         */\n        QueryList.prototype.reduce = function (fn, init) {\n            return this._results.reduce(fn, init);\n        };\n        /**\n         * See\n         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n         */\n        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };\n        /**\n         * See\n         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n         */\n        QueryList.prototype.some = function (fn) {\n            return this._results.some(fn);\n        };\n        QueryList.prototype.toArray = function () { return this._results.slice(); };\n        QueryList.prototype[getSymbolIterator()] = function () { return this._results[getSymbolIterator()](); };\n        QueryList.prototype.toString = function () { return this._results.toString(); };\n        QueryList.prototype.reset = function (res) {\n            this._results = ListWrapper.flatten(res);\n            this._dirty = false;\n        };\n        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };\n        /** internal */\n        QueryList.prototype.setDirty = function () { this._dirty = true; };\n        Object.defineProperty(QueryList.prototype, \"dirty\", {\n            /** internal */\n            get: function () { return this._dirty; },\n            enumerable: true,\n            configurable: true\n        });\n        return QueryList;\n    }());\n\n    var _SEPARATOR = '#';\n    var FACTORY_CLASS_SUFFIX = 'NgFactory';\n    /**\n     * Configuration for SystemJsNgModuleLoader.\n     * token.\n     *\n     * @experimental\n     */\n    var SystemJsNgModuleLoaderConfig = (function () {\n        function SystemJsNgModuleLoaderConfig() {\n        }\n        return SystemJsNgModuleLoaderConfig;\n    }());\n    var DEFAULT_CONFIG = {\n        factoryPathPrefix: '',\n        factoryPathSuffix: '.ngfactory',\n    };\n    /**\n     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory\n     * @experimental\n     */\n    var SystemJsNgModuleLoader = (function () {\n        function SystemJsNgModuleLoader(_compiler, config) {\n            this._compiler = _compiler;\n            this._config = config || DEFAULT_CONFIG;\n        }\n        SystemJsNgModuleLoader.prototype.load = function (path) {\n            var offlineMode = this._compiler instanceof Compiler;\n            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);\n        };\n        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {\n            var _this = this;\n            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];\n            if (exportName === undefined) {\n                exportName = 'default';\n            }\n            return System.import(module)\n                .then(function (module) { return module[exportName]; })\n                .then(function (type) { return checkNotEmpty(type, module, exportName); })\n                .then(function (type) { return _this._compiler.compileModuleAsync(type); });\n        };\n        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {\n            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];\n            var factoryClassSuffix = FACTORY_CLASS_SUFFIX;\n            if (exportName === undefined) {\n                exportName = 'default';\n                factoryClassSuffix = '';\n            }\n            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)\n                .then(function (module) { return module[exportName + factoryClassSuffix]; })\n                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });\n        };\n        SystemJsNgModuleLoader.decorators = [\n            { type: Injectable },\n        ];\n        /** @nocollapse */\n        SystemJsNgModuleLoader.ctorParameters = [\n            { type: Compiler, },\n            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },\n        ];\n        return SystemJsNgModuleLoader;\n    }());\n    function checkNotEmpty(value, modulePath, exportName) {\n        if (!value) {\n            throw new Error(\"Cannot find '\" + exportName + \"' in '\" + modulePath + \"'\");\n        }\n        return value;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$10 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Represents an Embedded Template that can be used to instantiate Embedded Views.\n     *\n     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or\n     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the\n     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the\n     * `TemplateRef` from a Component or a Directive via {@link Query}.\n     *\n     * To instantiate Embedded Views based on a Template, use\n     * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the\n     * View Container.\n     * @stable\n     */\n    var TemplateRef = (function () {\n        function TemplateRef() {\n        }\n        Object.defineProperty(TemplateRef.prototype, \"elementRef\", {\n            /**\n             * The location in the View where the Embedded View logically belongs to.\n             *\n             * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`\n             * inherit from the contexts of this location.\n             *\n             * Typically new Embedded Views are attached to the View Container of this location, but in\n             * advanced use-cases, the View can be attached to a different container while keeping the\n             * data-binding and injection context from the original location.\n             *\n             */\n            // TODO(i): rename to anchor or location\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        return TemplateRef;\n    }());\n    var TemplateRef_ = (function (_super) {\n        __extends$10(TemplateRef_, _super);\n        function TemplateRef_(_parentView, _nodeIndex, _nativeElement) {\n            _super.call(this);\n            this._parentView = _parentView;\n            this._nodeIndex = _nodeIndex;\n            this._nativeElement = _nativeElement;\n        }\n        TemplateRef_.prototype.createEmbeddedView = function (context) {\n            var view = this._parentView.createEmbeddedViewInternal(this._nodeIndex);\n            view.create(context || {});\n            return view.ref;\n        };\n        Object.defineProperty(TemplateRef_.prototype, \"elementRef\", {\n            get: function () { return new ElementRef(this._nativeElement); },\n            enumerable: true,\n            configurable: true\n        });\n        return TemplateRef_;\n    }(TemplateRef));\n\n    /**\n     * Represents a container where one or more Views can be attached.\n     *\n     * The container can contain two kinds of Views. Host Views, created by instantiating a\n     * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an\n     * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.\n     *\n     * The location of the View Container within the containing View is specified by the Anchor\n     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only\n     * have a single View Container.\n     *\n     * Root elements of Views attached to this container become siblings of the Anchor Element in\n     * the Rendered View.\n     *\n     * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected\n     * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.\n     * @stable\n     */\n    var ViewContainerRef = (function () {\n        function ViewContainerRef() {\n        }\n        Object.defineProperty(ViewContainerRef.prototype, \"element\", {\n            /**\n             * Anchor element that specifies the location of this container in the containing View.\n             * <!-- TODO: rename to anchorElement -->\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef.prototype, \"injector\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef.prototype, \"parentInjector\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef.prototype, \"length\", {\n            /**\n             * Returns the number of Views currently attached to this container.\n             */\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        return ViewContainerRef;\n    }());\n    var ViewContainerRef_ = (function () {\n        function ViewContainerRef_(_element) {\n            this._element = _element;\n            /** @internal */\n            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');\n            /** @internal */\n            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');\n            /** @internal */\n            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');\n            /** @internal */\n            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');\n        }\n        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };\n        Object.defineProperty(ViewContainerRef_.prototype, \"length\", {\n            get: function () {\n                var views = this._element.nestedViews;\n                return isPresent(views) ? views.length : 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef_.prototype, \"element\", {\n            get: function () { return this._element.elementRef; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef_.prototype, \"injector\", {\n            get: function () { return this._element.injector; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainerRef_.prototype, \"parentInjector\", {\n            get: function () { return this._element.parentInjector; },\n            enumerable: true,\n            configurable: true\n        });\n        // TODO(rado): profile and decide whether bounds checks should be added\n        // to the methods below.\n        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {\n            if (context === void 0) { context = null; }\n            if (index === void 0) { index = -1; }\n            var viewRef = templateRef.createEmbeddedView(context);\n            this.insert(viewRef, index);\n            return viewRef;\n        };\n        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {\n            if (index === void 0) { index = -1; }\n            if (injector === void 0) { injector = null; }\n            if (projectableNodes === void 0) { projectableNodes = null; }\n            var s = this._createComponentInContainerScope();\n            var contextInjector = injector || this._element.parentInjector;\n            var componentRef = componentFactory.create(contextInjector, projectableNodes);\n            this.insert(componentRef.hostView, index);\n            return wtfLeave(s, componentRef);\n        };\n        // TODO(i): refactor insert+remove into move\n        ViewContainerRef_.prototype.insert = function (viewRef, index) {\n            if (index === void 0) { index = -1; }\n            var s = this._insertScope();\n            if (index == -1)\n                index = this.length;\n            var viewRef_ = viewRef;\n            this._element.attachView(viewRef_.internalView, index);\n            return wtfLeave(s, viewRef_);\n        };\n        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {\n            var s = this._insertScope();\n            if (currentIndex == -1)\n                return;\n            var viewRef_ = viewRef;\n            this._element.moveView(viewRef_.internalView, currentIndex);\n            return wtfLeave(s, viewRef_);\n        };\n        ViewContainerRef_.prototype.indexOf = function (viewRef) {\n            return this._element.nestedViews.indexOf(viewRef.internalView);\n        };\n        // TODO(i): rename to destroy\n        ViewContainerRef_.prototype.remove = function (index) {\n            if (index === void 0) { index = -1; }\n            var s = this._removeScope();\n            if (index == -1)\n                index = this.length - 1;\n            var view = this._element.detachView(index);\n            view.destroy();\n            // view is intentionally not returned to the client.\n            wtfLeave(s);\n        };\n        // TODO(i): refactor insert+remove into move\n        ViewContainerRef_.prototype.detach = function (index) {\n            if (index === void 0) { index = -1; }\n            var s = this._detachScope();\n            if (index == -1)\n                index = this.length - 1;\n            var view = this._element.detachView(index);\n            return wtfLeave(s, view.ref);\n        };\n        ViewContainerRef_.prototype.clear = function () {\n            for (var i = this.length - 1; i >= 0; i--) {\n                this.remove(i);\n            }\n        };\n        return ViewContainerRef_;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var _queuedAnimations = [];\n    /** @internal */\n    function queueAnimationGlobally(player) {\n        _queuedAnimations.push(player);\n    }\n    /** @internal */\n    function triggerQueuedAnimations() {\n        // this code is wrapped into a single promise such that the\n        // onStart and onDone player callbacks are triggered outside\n        // of the digest cycle of animations\n        if (_queuedAnimations.length) {\n            Promise.resolve(null).then(_triggerAnimations);\n        }\n    }\n    function _triggerAnimations() {\n        for (var i = 0; i < _queuedAnimations.length; i++) {\n            var player = _queuedAnimations[i];\n            player.play();\n        }\n        _queuedAnimations = [];\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$11 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @stable\n     */\n    var ViewRef = (function () {\n        function ViewRef() {\n        }\n        Object.defineProperty(ViewRef.prototype, \"destroyed\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return ViewRef;\n    }());\n    /**\n     * Represents an Angular View.\n     *\n     * <!-- TODO: move the next two paragraphs to the dev guide -->\n     * A View is a fundamental building block of the application UI. It is the smallest grouping of\n     * Elements which are created and destroyed together.\n     *\n     * Properties of elements in a View can change, but the structure (number and order) of elements in\n     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or\n     * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.\n     * <!-- /TODO -->\n     *\n     * ### Example\n     *\n     * Given this template...\n     *\n     * ```\n     * Count: {{items.length}}\n     * <ul>\n     *   <li *ngFor=\"let  item of items\">{{item}}</li>\n     * </ul>\n     * ```\n     *\n     * We have two {@link TemplateRef}s:\n     *\n     * Outer {@link TemplateRef}:\n     * ```\n     * Count: {{items.length}}\n     * <ul>\n     *   <template ngFor let-item [ngForOf]=\"items\"></template>\n     * </ul>\n     * ```\n     *\n     * Inner {@link TemplateRef}:\n     * ```\n     *   <li>{{item}}</li>\n     * ```\n     *\n     * Notice that the original template is broken down into two separate {@link TemplateRef}s.\n     *\n     * The outer/inner {@link TemplateRef}s are then assembled into views like so:\n     *\n     * ```\n     * <!-- ViewRef: outer-0 -->\n     * Count: 2\n     * <ul>\n     *   <template view-container-ref></template>\n     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n     * </ul>\n     * <!-- /ViewRef: outer-0 -->\n     * ```\n     * @experimental\n     */\n    var EmbeddedViewRef = (function (_super) {\n        __extends$11(EmbeddedViewRef, _super);\n        function EmbeddedViewRef() {\n            _super.apply(this, arguments);\n        }\n        Object.defineProperty(EmbeddedViewRef.prototype, \"context\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EmbeddedViewRef.prototype, \"rootNodes\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        return EmbeddedViewRef;\n    }(ViewRef));\n    var ViewRef_ = (function () {\n        function ViewRef_(_view) {\n            this._view = _view;\n            this._view = _view;\n            this._originalMode = this._view.cdMode;\n        }\n        Object.defineProperty(ViewRef_.prototype, \"internalView\", {\n            get: function () { return this._view; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewRef_.prototype, \"rootNodes\", {\n            get: function () { return this._view.flatRootNodes; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewRef_.prototype, \"context\", {\n            get: function () { return this._view.context; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewRef_.prototype, \"destroyed\", {\n            get: function () { return this._view.destroyed; },\n            enumerable: true,\n            configurable: true\n        });\n        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };\n        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };\n        ViewRef_.prototype.detectChanges = function () {\n            this._view.detectChanges(false);\n            triggerQueuedAnimations();\n        };\n        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };\n        ViewRef_.prototype.reattach = function () {\n            this._view.cdMode = this._originalMode;\n            this.markForCheck();\n        };\n        ViewRef_.prototype.onDestroy = function (callback) {\n            if (!this._view.disposables) {\n                this._view.disposables = [];\n            }\n            this._view.disposables.push(callback);\n        };\n        ViewRef_.prototype.destroy = function () { this._view.detachAndDestroy(); };\n        return ViewRef_;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$12 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var EventListener = (function () {\n        function EventListener(name, callback) {\n            this.name = name;\n            this.callback = callback;\n        }\n        ;\n        return EventListener;\n    }());\n    /**\n     * @experimental All debugging apis are currently experimental.\n     */\n    var DebugNode = (function () {\n        function DebugNode(nativeNode, parent, _debugInfo) {\n            this._debugInfo = _debugInfo;\n            this.nativeNode = nativeNode;\n            if (parent && parent instanceof DebugElement) {\n                parent.addChild(this);\n            }\n            else {\n                this.parent = null;\n            }\n            this.listeners = [];\n        }\n        Object.defineProperty(DebugNode.prototype, \"injector\", {\n            get: function () { return this._debugInfo ? this._debugInfo.injector : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"componentInstance\", {\n            get: function () { return this._debugInfo ? this._debugInfo.component : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"context\", {\n            get: function () { return this._debugInfo ? this._debugInfo.context : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"references\", {\n            get: function () {\n                return this._debugInfo ? this._debugInfo.references : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"providerTokens\", {\n            get: function () { return this._debugInfo ? this._debugInfo.providerTokens : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugNode.prototype, \"source\", {\n            get: function () { return this._debugInfo ? this._debugInfo.source : null; },\n            enumerable: true,\n            configurable: true\n        });\n        return DebugNode;\n    }());\n    /**\n     * @experimental All debugging apis are currently experimental.\n     */\n    var DebugElement = (function (_super) {\n        __extends$12(DebugElement, _super);\n        function DebugElement(nativeNode, parent, _debugInfo) {\n            _super.call(this, nativeNode, parent, _debugInfo);\n            this.properties = {};\n            this.attributes = {};\n            this.classes = {};\n            this.styles = {};\n            this.childNodes = [];\n            this.nativeElement = nativeNode;\n        }\n        DebugElement.prototype.addChild = function (child) {\n            if (child) {\n                this.childNodes.push(child);\n                child.parent = this;\n            }\n        };\n        DebugElement.prototype.removeChild = function (child) {\n            var childIndex = this.childNodes.indexOf(child);\n            if (childIndex !== -1) {\n                child.parent = null;\n                this.childNodes.splice(childIndex, 1);\n            }\n        };\n        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {\n            var siblingIndex = this.childNodes.indexOf(child);\n            if (siblingIndex !== -1) {\n                var previousChildren = this.childNodes.slice(0, siblingIndex + 1);\n                var nextChildren = this.childNodes.slice(siblingIndex + 1);\n                this.childNodes = previousChildren.concat(newChildren, nextChildren);\n                for (var i = 0; i < newChildren.length; ++i) {\n                    var newChild = newChildren[i];\n                    if (newChild.parent) {\n                        newChild.parent.removeChild(newChild);\n                    }\n                    newChild.parent = this;\n                }\n            }\n        };\n        DebugElement.prototype.query = function (predicate) {\n            var results = this.queryAll(predicate);\n            return results[0] || null;\n        };\n        DebugElement.prototype.queryAll = function (predicate) {\n            var matches = [];\n            _queryElementChildren(this, predicate, matches);\n            return matches;\n        };\n        DebugElement.prototype.queryAllNodes = function (predicate) {\n            var matches = [];\n            _queryNodeChildren(this, predicate, matches);\n            return matches;\n        };\n        Object.defineProperty(DebugElement.prototype, \"children\", {\n            get: function () {\n                return this.childNodes.filter(function (node) { return node instanceof DebugElement; });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {\n            this.listeners.forEach(function (listener) {\n                if (listener.name == eventName) {\n                    listener.callback(eventObj);\n                }\n            });\n        };\n        return DebugElement;\n    }(DebugNode));\n    /**\n     * @experimental\n     */\n    function asNativeElements(debugEls) {\n        return debugEls.map(function (el) { return el.nativeElement; });\n    }\n    function _queryElementChildren(element, predicate, matches) {\n        element.childNodes.forEach(function (node) {\n            if (node instanceof DebugElement) {\n                if (predicate(node)) {\n                    matches.push(node);\n                }\n                _queryElementChildren(node, predicate, matches);\n            }\n        });\n    }\n    function _queryNodeChildren(parentNode, predicate, matches) {\n        if (parentNode instanceof DebugElement) {\n            parentNode.childNodes.forEach(function (node) {\n                if (predicate(node)) {\n                    matches.push(node);\n                }\n                if (node instanceof DebugElement) {\n                    _queryNodeChildren(node, predicate, matches);\n                }\n            });\n        }\n    }\n    // Need to keep the nodes in a global Map so that multiple angular apps are supported.\n    var _nativeNodeToDebugNode = new Map();\n    /**\n     * @experimental\n     */\n    function getDebugNode(nativeNode) {\n        return _nativeNodeToDebugNode.get(nativeNode);\n    }\n    function indexDebugNode(node) {\n        _nativeNodeToDebugNode.set(node.nativeNode, node);\n    }\n    function removeDebugNodeFromIndex(node) {\n        _nativeNodeToDebugNode.delete(node.nativeNode);\n    }\n\n    function _reflector() {\n        return reflector;\n    }\n    var _CORE_PLATFORM_PROVIDERS = [\n        PlatformRef_,\n        { provide: PlatformRef, useExisting: PlatformRef_ },\n        { provide: Reflector, useFactory: _reflector, deps: [] },\n        { provide: ReflectorReader, useExisting: Reflector },\n        TestabilityRegistry,\n        Console,\n    ];\n    /**\n     * This platform has to be included in any other platform\n     *\n     * @experimental\n     */\n    var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);\n\n    /**\n     * @experimental i18n support is experimental.\n     */\n    var LOCALE_ID = new OpaqueToken('LocaleId');\n    /**\n     * @experimental i18n support is experimental.\n     */\n    var TRANSLATIONS = new OpaqueToken('Translations');\n    /**\n     * @experimental i18n support is experimental.\n     */\n    var TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');\n\n    function _iterableDiffersFactory() {\n        return defaultIterableDiffers;\n    }\n    function _keyValueDiffersFactory() {\n        return defaultKeyValueDiffers;\n    }\n    /**\n     * This module includes the providers of @angular/core that are needed\n     * to bootstrap components via `ApplicationRef`.\n     *\n     * @experimental\n     */\n    var ApplicationModule = (function () {\n        function ApplicationModule() {\n        }\n        ApplicationModule.decorators = [\n            { type: NgModule, args: [{\n                        providers: [\n                            ApplicationRef_,\n                            { provide: ApplicationRef, useExisting: ApplicationRef_ },\n                            ApplicationInitStatus,\n                            Compiler,\n                            APP_ID_RANDOM_PROVIDER,\n                            ViewUtils,\n                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },\n                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },\n                            { provide: LOCALE_ID, useValue: 'en-US' },\n                        ]\n                    },] },\n        ];\n        /** @nocollapse */\n        ApplicationModule.ctorParameters = [];\n        return ApplicationModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean\n    var ANY_STATE = '*';\n    var DEFAULT_STATE = '*';\n    var EMPTY_STATE = 'void';\n\n    var AnimationGroupPlayer = (function () {\n        function AnimationGroupPlayer(_players) {\n            var _this = this;\n            this._players = _players;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._finished = false;\n            this._started = false;\n            this._destroyed = false;\n            this.parentPlayer = null;\n            var count = 0;\n            var total = this._players.length;\n            if (total == 0) {\n                scheduleMicroTask(function () { return _this._onFinish(); });\n            }\n            else {\n                this._players.forEach(function (player) {\n                    player.parentPlayer = _this;\n                    player.onDone(function () {\n                        if (++count >= total) {\n                            _this._onFinish();\n                        }\n                    });\n                });\n            }\n        }\n        AnimationGroupPlayer.prototype._onFinish = function () {\n            if (!this._finished) {\n                this._finished = true;\n                this._onDoneFns.forEach(function (fn) { return fn(); });\n                this._onDoneFns = [];\n            }\n        };\n        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };\n        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };\n        AnimationGroupPlayer.prototype.play = function () {\n            if (!isPresent(this.parentPlayer)) {\n                this.init();\n            }\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n                this._started = true;\n            }\n            this._players.forEach(function (player) { return player.play(); });\n        };\n        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };\n        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };\n        AnimationGroupPlayer.prototype.finish = function () {\n            this._onFinish();\n            this._players.forEach(function (player) { return player.finish(); });\n        };\n        AnimationGroupPlayer.prototype.destroy = function () {\n            if (!this._destroyed) {\n                this._onFinish();\n                this._players.forEach(function (player) { return player.destroy(); });\n                this._destroyed = true;\n            }\n        };\n        AnimationGroupPlayer.prototype.reset = function () {\n            this._players.forEach(function (player) { return player.reset(); });\n            this._destroyed = false;\n            this._finished = false;\n            this._started = false;\n        };\n        AnimationGroupPlayer.prototype.setPosition = function (p /** TODO #9100 */) {\n            this._players.forEach(function (player) { player.setPosition(p); });\n        };\n        AnimationGroupPlayer.prototype.getPosition = function () {\n            var min = 0;\n            this._players.forEach(function (player) {\n                var p = player.getPosition();\n                min = Math.min(p, min);\n            });\n            return min;\n        };\n        return AnimationGroupPlayer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var AnimationKeyframe = (function () {\n        function AnimationKeyframe(offset, styles) {\n            this.offset = offset;\n            this.styles = styles;\n        }\n        return AnimationKeyframe;\n    }());\n\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationPlayer = (function () {\n        function AnimationPlayer() {\n        }\n        Object.defineProperty(AnimationPlayer.prototype, \"parentPlayer\", {\n            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },\n            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationPlayer;\n    }());\n    var NoOpAnimationPlayer = (function () {\n        function NoOpAnimationPlayer() {\n            var _this = this;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._started = false;\n            this.parentPlayer = null;\n            scheduleMicroTask(function () { return _this._onFinish(); });\n        }\n        /** @internal */\n        NoOpAnimationPlayer.prototype._onFinish = function () {\n            this._onDoneFns.forEach(function (fn) { return fn(); });\n            this._onDoneFns = [];\n        };\n        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };\n        NoOpAnimationPlayer.prototype.init = function () { };\n        NoOpAnimationPlayer.prototype.play = function () {\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n            }\n            this._started = true;\n        };\n        NoOpAnimationPlayer.prototype.pause = function () { };\n        NoOpAnimationPlayer.prototype.restart = function () { };\n        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };\n        NoOpAnimationPlayer.prototype.destroy = function () { };\n        NoOpAnimationPlayer.prototype.reset = function () { };\n        NoOpAnimationPlayer.prototype.setPosition = function (p /** TODO #9100 */) { };\n        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };\n        return NoOpAnimationPlayer;\n    }());\n\n    var AnimationSequencePlayer = (function () {\n        function AnimationSequencePlayer(_players) {\n            var _this = this;\n            this._players = _players;\n            this._currentIndex = 0;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._finished = false;\n            this._started = false;\n            this._destroyed = false;\n            this.parentPlayer = null;\n            this._players.forEach(function (player) { player.parentPlayer = _this; });\n            this._onNext(false);\n        }\n        AnimationSequencePlayer.prototype._onNext = function (start) {\n            var _this = this;\n            if (this._finished)\n                return;\n            if (this._players.length == 0) {\n                this._activePlayer = new NoOpAnimationPlayer();\n                scheduleMicroTask(function () { return _this._onFinish(); });\n            }\n            else if (this._currentIndex >= this._players.length) {\n                this._activePlayer = new NoOpAnimationPlayer();\n                this._onFinish();\n            }\n            else {\n                var player = this._players[this._currentIndex++];\n                player.onDone(function () { return _this._onNext(true); });\n                this._activePlayer = player;\n                if (start) {\n                    player.play();\n                }\n            }\n        };\n        AnimationSequencePlayer.prototype._onFinish = function () {\n            if (!this._finished) {\n                this._finished = true;\n                this._onDoneFns.forEach(function (fn) { return fn(); });\n                this._onDoneFns = [];\n            }\n        };\n        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };\n        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };\n        AnimationSequencePlayer.prototype.play = function () {\n            if (!isPresent(this.parentPlayer)) {\n                this.init();\n            }\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n                this._started = true;\n            }\n            this._activePlayer.play();\n        };\n        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };\n        AnimationSequencePlayer.prototype.restart = function () {\n            this.reset();\n            if (this._players.length > 0) {\n                this._players[0].restart();\n            }\n        };\n        AnimationSequencePlayer.prototype.reset = function () {\n            this._players.forEach(function (player) { return player.reset(); });\n            this._destroyed = false;\n            this._finished = false;\n            this._started = false;\n        };\n        AnimationSequencePlayer.prototype.finish = function () {\n            this._onFinish();\n            this._players.forEach(function (player) { return player.finish(); });\n        };\n        AnimationSequencePlayer.prototype.destroy = function () {\n            if (!this._destroyed) {\n                this._onFinish();\n                this._players.forEach(function (player) { return player.destroy(); });\n                this._destroyed = true;\n                this._activePlayer = new NoOpAnimationPlayer();\n            }\n        };\n        AnimationSequencePlayer.prototype.setPosition = function (p /** TODO #9100 */) { this._players[0].setPosition(p); };\n        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };\n        return AnimationSequencePlayer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$13 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AUTO_STYLE = '*';\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link trigger trigger\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationEntryMetadata = (function () {\n        function AnimationEntryMetadata(name, definitions) {\n            this.name = name;\n            this.definitions = definitions;\n        }\n        return AnimationEntryMetadata;\n    }());\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStateMetadata = (function () {\n        function AnimationStateMetadata() {\n        }\n        return AnimationStateMetadata;\n    }());\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link state state animation\n     * function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStateDeclarationMetadata = (function (_super) {\n        __extends$13(AnimationStateDeclarationMetadata, _super);\n        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {\n            _super.call(this);\n            this.stateNameExpr = stateNameExpr;\n            this.styles = styles;\n        }\n        return AnimationStateDeclarationMetadata;\n    }(AnimationStateMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the\n     * {@link transition transition animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStateTransitionMetadata = (function (_super) {\n        __extends$13(AnimationStateTransitionMetadata, _super);\n        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {\n            _super.call(this);\n            this.stateChangeExpr = stateChangeExpr;\n            this.steps = steps;\n        }\n        return AnimationStateTransitionMetadata;\n    }(AnimationStateMetadata));\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationMetadata = (function () {\n        function AnimationMetadata() {\n        }\n        return AnimationMetadata;\n    }());\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationKeyframesSequenceMetadata = (function (_super) {\n        __extends$13(AnimationKeyframesSequenceMetadata, _super);\n        function AnimationKeyframesSequenceMetadata(steps) {\n            _super.call(this);\n            this.steps = steps;\n        }\n        return AnimationKeyframesSequenceMetadata;\n    }(AnimationMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link style style animation\n     * function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationStyleMetadata = (function (_super) {\n        __extends$13(AnimationStyleMetadata, _super);\n        function AnimationStyleMetadata(styles, offset) {\n            if (offset === void 0) { offset = null; }\n            _super.call(this);\n            this.styles = styles;\n            this.offset = offset;\n        }\n        return AnimationStyleMetadata;\n    }(AnimationMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link animate animate\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationAnimateMetadata = (function (_super) {\n        __extends$13(AnimationAnimateMetadata, _super);\n        function AnimationAnimateMetadata(timings, styles) {\n            _super.call(this);\n            this.timings = timings;\n            this.styles = styles;\n        }\n        return AnimationAnimateMetadata;\n    }(AnimationMetadata));\n    /**\n     * @experimental Animation support is experimental.\n     */\n    var AnimationWithStepsMetadata = (function (_super) {\n        __extends$13(AnimationWithStepsMetadata, _super);\n        function AnimationWithStepsMetadata() {\n            _super.call(this);\n        }\n        Object.defineProperty(AnimationWithStepsMetadata.prototype, \"steps\", {\n            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationWithStepsMetadata;\n    }(AnimationMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link sequence sequence\n     * animation function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationSequenceMetadata = (function (_super) {\n        __extends$13(AnimationSequenceMetadata, _super);\n        function AnimationSequenceMetadata(_steps) {\n            _super.call(this);\n            this._steps = _steps;\n        }\n        Object.defineProperty(AnimationSequenceMetadata.prototype, \"steps\", {\n            get: function () { return this._steps; },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationSequenceMetadata;\n    }(AnimationWithStepsMetadata));\n    /**\n     * Metadata representing the entry of animations.\n     * Instances of this class are provided via the animation DSL when the {@link group group animation\n     * function} is called.\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationGroupMetadata = (function (_super) {\n        __extends$13(AnimationGroupMetadata, _super);\n        function AnimationGroupMetadata(_steps) {\n            _super.call(this);\n            this._steps = _steps;\n        }\n        Object.defineProperty(AnimationGroupMetadata.prototype, \"steps\", {\n            get: function () { return this._steps; },\n            enumerable: true,\n            configurable: true\n        });\n        return AnimationGroupMetadata;\n    }(AnimationWithStepsMetadata));\n    /**\n     * `animate` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `animate` specifies an animation step that will apply the provided `styles` data for a given\n     * amount of\n     * time based on the provided `timing` expression value. Calls to `animate` are expected to be\n     * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition\n     * transition}.\n     *\n     * ### Usage\n     *\n     * The `animate` function accepts two input parameters: `timing` and `styles`:\n     *\n     * - `timing` is a string based value that can be a combination of a duration with optional\n     * delay and easing values. The format for the expression breaks down to `duration delay easing`\n     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,\n     * delay=100, easing=ease-out`.\n     * If a numeric value is provided then that will be used as the `duration` value in millisecond\n     * form.\n     * - `styles` is the style input data which can either be a call to {@link style style} or {@link\n     * keyframes keyframes}.\n     * If left empty then the styles from the destination state will be collected and used (this is\n     * useful when\n     * describing an animation step that will complete an animation by {@link\n     * transition#the-final-animate-call animating to the final state}).\n     *\n     * ```typescript\n     * // various functions for specifying timing data\n     * animate(500, style(...))\n     * animate(\"1s\", style(...))\n     * animate(\"100ms 0.5s\", style(...))\n     * animate(\"5s ease\", style(...))\n     * animate(\"5s 10ms cubic-bezier(.17,.67,.88,.1)\", style(...))\n     *\n     * // either style() of keyframes() can be used\n     * animate(500, style({ background: \"red\" }))\n     * animate(500, keyframes([\n     *   style({ background: \"blue\" })),\n     *   style({ background: \"red\" }))\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function animate(timing, styles) {\n        if (styles === void 0) { styles = null; }\n        var stylesEntry = styles;\n        if (!isPresent(stylesEntry)) {\n            var EMPTY_STYLE = {};\n            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);\n        }\n        return new AnimationAnimateMetadata(timing, stylesEntry);\n    }\n    /**\n     * `group` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations\n     * are useful when a series of styles must be animated/closed off\n     * at different statrting/ending times.\n     *\n     * The `group` function can either be used within a {@link sequence sequence} or a {@link transition\n     * transition}\n     * and it will only continue to the next instruction once all of the inner animation steps\n     * have completed.\n     *\n     * ### Usage\n     *\n     * The `steps` data that is passed into the `group` animation function can either consist\n     * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or\n     * `animate()`\n     * within a group will be executed instantly (use {@link keyframes keyframes} or a\n     * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later\n     * time).\n     *\n     * ```typescript\n     * group([\n     *   animate(\"1s\", { background: \"black\" }))\n     *   animate(\"2s\", { color: \"white\" }))\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function group(steps) {\n        return new AnimationGroupMetadata(steps);\n    }\n    /**\n     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used\n     * by default when an array is passed as animation data into {@link transition transition}.)\n     *\n     * The `sequence` function can either be used within a {@link group group} or a {@link transition\n     * transition}\n     * and it will only continue to the next instruction once each of the inner animation steps\n     * have completed.\n     *\n     * To perform animation styling in parallel with other animation steps then\n     * have a look at the {@link group group} animation function.\n     *\n     * ### Usage\n     *\n     * The `steps` data that is passed into the `sequence` animation function can either consist\n     * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply\n     * the\n     * provided styling data immediately while a call to `animate()` will apply its styling\n     * data over a given time depending on its timing data.\n     *\n     * ```typescript\n     * sequence([\n     *   style({ opacity: 0 })),\n     *   animate(\"1s\", { opacity: 1 }))\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function sequence(steps) {\n        return new AnimationSequenceMetadata(steps);\n    }\n    /**\n     * `style` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `style` declares a key/value object containing CSS properties/styles that can then\n     * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as\n     * styling data for both {@link animate animate} and {@link keyframes keyframes}.\n     *\n     * ### Usage\n     *\n     * `style` takes in a key/value string map as data and expects one or more CSS property/value\n     * pairs to be defined.\n     *\n     * ```typescript\n     * // string values are used for css properties\n     * style({ background: \"red\", color: \"blue\" })\n     *\n     * // numerical (pixel) values are also supported\n     * style({ width: 100, height: 0 })\n     * ```\n     *\n     * #### Auto-styles (using `*`)\n     *\n     * When an asterix (`*`) character is used as a value then it will be detected from the element\n     * being animated\n     * and applied as animation data when the animation starts.\n     *\n     * This feature proves useful for a state depending on layout and/or environment factors; in such\n     * cases\n     * the styles are calculated just before the animation starts.\n     *\n     * ```typescript\n     * // the steps below will animate from 0 to the\n     * // actual height of the element\n     * style({ height: 0 }),\n     * animate(\"1s\", style({ height: \"*\" }))\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function style(tokens) {\n        var input;\n        var offset = null;\n        if (typeof tokens === 'string') {\n            input = [tokens];\n        }\n        else {\n            if (Array.isArray(tokens)) {\n                input = tokens;\n            }\n            else {\n                input = [tokens];\n            }\n            input.forEach(function (entry) {\n                var entryOffset = entry['offset'];\n                if (isPresent(entryOffset)) {\n                    offset = offset == null ? parseFloat(entryOffset) : offset;\n                }\n            });\n        }\n        return new AnimationStyleMetadata(input, offset);\n    }\n    /**\n     * `state` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `state` declares an animation state within the given trigger. When a state is\n     * active within a component then its associated styles will persist on\n     * the element that the trigger is attached to (even when the animation ends).\n     *\n     * To animate between states, have a look at the animation {@link transition transition}\n     * DSL function. To register states to an animation trigger please have a look\n     * at the {@link trigger trigger} function.\n     *\n     * #### The `void` state\n     *\n     * The `void` state value is a reserved word that angular uses to determine when the element is not\n     * apart\n     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the\n     * associated element\n     * is void).\n     *\n     * #### The `*` (default) state\n     *\n     * The `*` state (when styled) is a fallback state that will be used if\n     * the state that is being animated is not declared within the trigger.\n     *\n     * ### Usage\n     *\n     * `state` will declare an animation state with its associated styles\n     * within the given trigger.\n     *\n     * - `stateNameExpr` can be one or more state names separated by commas.\n     * - `styles` refers to the {@link style styling data} that will be persisted on the element once\n     * the state\n     * has been reached.\n     *\n     * ```typescript\n     * // \"void\" is a reserved name for a state and is used to represent\n     * // the state in which an element is detached from from the application.\n     * state(\"void\", style({ height: 0 }))\n     *\n     * // user-defined states\n     * state(\"closed\", style({ height: 0 }))\n     * state(\"open, visible\", style({ height: \"*\" }))\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function state(stateNameExpr, styles) {\n        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);\n    }\n    /**\n     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `keyframes` specifies a collection of {@link style style} entries each optionally characterized\n     * by an `offset` value.\n     *\n     * ### Usage\n     *\n     * The `keyframes` animation function is designed to be used alongside the {@link animate animate}\n     * animation function. Instead of applying animations from where they are\n     * currently to their destination, keyframes can describe how each style entry is applied\n     * and at what point within the animation arc (much like CSS Keyframe Animations do).\n     *\n     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at\n     * what percentage of the animate time the styles will be applied.\n     *\n     * ```typescript\n     * // the provided offset values describe when each backgroundColor value is applied.\n     * animate(\"5s\", keyframes([\n     *   style({ backgroundColor: \"red\", offset: 0 }),\n     *   style({ backgroundColor: \"blue\", offset: 0.2 }),\n     *   style({ backgroundColor: \"orange\", offset: 0.3 }),\n     *   style({ backgroundColor: \"black\", offset: 1 })\n     * ]))\n     * ```\n     *\n     * Alternatively, if there are no `offset` values used within the style entries then the offsets\n     * will\n     * be calculated automatically.\n     *\n     * ```typescript\n     * animate(\"5s\", keyframes([\n     *   style({ backgroundColor: \"red\" }) // offset = 0\n     *   style({ backgroundColor: \"blue\" }) // offset = 0.33\n     *   style({ backgroundColor: \"orange\" }) // offset = 0.66\n     *   style({ backgroundColor: \"black\" }) // offset = 1\n     * ]))\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function keyframes(steps) {\n        return new AnimationKeyframesSequenceMetadata(steps);\n    }\n    /**\n     * `transition` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `transition` declares the {@link sequence sequence of animation steps} that will be run when the\n     * provided\n     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`\n     * which consists\n     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).\n     *\n     * Animation transitions are placed within an {@link trigger animation trigger}. For an transition\n     * to animate to\n     * a state value and persist its styles then one or more {@link state animation states} is expected\n     * to be defined.\n     *\n     * ### Usage\n     *\n     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on\n     * what the\n     * previous state is and what the current state has become. In other words, if a transition is\n     * defined that\n     * matches the old/current state criteria then the associated animation will be triggered.\n     *\n     * ```typescript\n     * // all transition/state changes are defined within an animation trigger\n     * trigger(\"myAnimationTrigger\", [\n     *   // if a state is defined then its styles will be persisted when the\n     *   // animation has fully completed itself\n     *   state(\"on\", style({ background: \"green\" })),\n     *   state(\"off\", style({ background: \"grey\" })),\n     *\n     *   // a transition animation that will be kicked off when the state value\n     *   // bound to \"myAnimationTrigger\" changes from \"on\" to \"off\"\n     *   transition(\"on => off\", animate(500)),\n     *\n     *   // it is also possible to do run the same animation for both directions\n     *   transition(\"on <=> off\", animate(500)),\n     *\n     *   // or to define multiple states pairs separated by commas\n     *   transition(\"on => off, off => void\", animate(500)),\n     *\n     *   // this is a catch-all state change for when an element is inserted into\n     *   // the page and the destination state is unknown\n     *   transition(\"void => *\", [\n     *     style({ opacity: 0 }),\n     *     animate(500)\n     *   ]),\n     *\n     *   // this will capture a state change between any states\n     *   transition(\"* => *\", animate(\"1s 0s\")),\n     * ])\n     * ```\n     *\n     * The template associated with this component will make use of the `myAnimationTrigger`\n     * animation trigger by binding to an element within its template code.\n     *\n     * ```html\n     * <!-- somewhere inside of my-component-tpl.html -->\n     * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\n     * ```\n     *\n     * #### The final `animate` call\n     *\n     * If the final step within the transition steps is a call to `animate()` that **only**\n     * uses a timing value with **no style data** then it will be automatically used as the final\n     * animation\n     * arc for the element to animate itself to the final state. This involves an automatic mix of\n     * adding/removing CSS styles so that the element will be in the exact state it should be for the\n     * applied state to be presented correctly.\n     *\n     * ```\n     * // start off by hiding the element, but make sure that it animates properly to whatever state\n     * // is currently active for \"myAnimationTrigger\"\n     * transition(\"void => *\", [\n     *   style({ opacity: 0 }),\n     *   animate(500)\n     * ])\n     * ```\n     *\n     * ### Transition Aliases (`:enter` and `:leave`)\n     *\n     * Given that enter (insertion) and leave (removal) animations are so common,\n     * the `transition` function accepts both `:enter` and `:leave` values which\n     * are aliases for the `void => *` and `* => void` state changes.\n     *\n     * ```\n     * transition(\":enter\", [\n     *   style({ opacity: 0 }),\n     *   animate(500, style({ opacity: 1 }))\n     * ])\n     * transition(\":leave\", [\n     *   animate(500, style({ opacity: 0 }))\n     * ])\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function transition(stateChangeExpr, steps) {\n        var animationData = Array.isArray(steps) ? new AnimationSequenceMetadata(steps) : steps;\n        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);\n    }\n    /**\n     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's\n     * animation\n     * DSL language. If this information is new, please navigate to the\n     * {@link Component#animations-anchor component animations metadata\n     * page} to gain a better understanding of how animations in Angular2 are used.\n     *\n     * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link\n     * transition transition}\n     * entries that will be evaluated when the expression bound to the trigger changes.\n     *\n     * Triggers are registered within the component annotation data under the\n     * {@link Component#animations-anchor animations section}. An animation trigger can\n     * be placed on an element within a template by referencing the name of the\n     * trigger followed by the expression value that the trigger is bound to\n     * (in the form of `[@triggerName]=\"expression\"`.\n     *\n     * ### Usage\n     *\n     * `trigger` will create an animation trigger reference based on the provided `name` value.\n     * The provided `animation` value is expected to be an array consisting of {@link state state} and\n     * {@link transition transition}\n     * declarations.\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'my-component',\n     *   templateUrl: 'my-component-tpl.html',\n     *   animations: [\n     *     trigger(\"myAnimationTrigger\", [\n     *       state(...),\n     *       state(...),\n     *       transition(...),\n     *       transition(...)\n     *     ])\n     *   ]\n     * })\n     * class MyComponent {\n     *   myStatusExp = \"something\";\n     * }\n     * ```\n     *\n     * The template associated with this component will make use of the `myAnimationTrigger`\n     * animation trigger by binding to an element within its template code.\n     *\n     * ```html\n     * <!-- somewhere inside of my-component-tpl.html -->\n     * <div [@myAnimationTrigger]=\"myStatusExp\">...</div>\n     * ```\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))\n     *\n     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}\n     *\n     * @experimental Animation support is experimental.\n     */\n    function trigger(name, animation) {\n        return new AnimationEntryMetadata(name, animation);\n    }\n\n    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {\n        if (nullValue === void 0) { nullValue = null; }\n        var finalStyles = {};\n        Object.keys(newStyles).forEach(function (prop) {\n            var value = newStyles[prop];\n            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();\n        });\n        Object.keys(previousStyles).forEach(function (prop) {\n            if (!isPresent(finalStyles[prop])) {\n                finalStyles[prop] = nullValue;\n            }\n        });\n        return finalStyles;\n    }\n    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {\n        var limit = keyframes.length - 1;\n        var firstKeyframe = keyframes[0];\n        // phase 1: copy all the styles from the first keyframe into the lookup map\n        var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);\n        var extraFirstKeyframeStyles = {};\n        var hasExtraFirstStyles = false;\n        Object.keys(collectedStyles).forEach(function (prop) {\n            var value = collectedStyles[prop];\n            // if the style is already defined in the first keyframe then\n            // we do not replace it.\n            if (!flatenedFirstKeyframeStyles[prop]) {\n                flatenedFirstKeyframeStyles[prop] = value;\n                extraFirstKeyframeStyles[prop] = value;\n                hasExtraFirstStyles = true;\n            }\n        });\n        var keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);\n        // phase 2: normalize the final keyframe\n        var finalKeyframe = keyframes[limit];\n        finalKeyframe.styles.styles.unshift(finalStateStyles);\n        var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);\n        var extraFinalKeyframeStyles = {};\n        var hasExtraFinalStyles = false;\n        Object.keys(keyframeCollectedStyles).forEach(function (prop) {\n            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {\n                extraFinalKeyframeStyles[prop] = AUTO_STYLE;\n                hasExtraFinalStyles = true;\n            }\n        });\n        if (hasExtraFinalStyles) {\n            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);\n        }\n        Object.keys(flatenedFinalKeyframeStyles).forEach(function (prop) {\n            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {\n                extraFirstKeyframeStyles[prop] = AUTO_STYLE;\n                hasExtraFirstStyles = true;\n            }\n        });\n        if (hasExtraFirstStyles) {\n            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);\n        }\n        return keyframes;\n    }\n    function clearStyles(styles) {\n        var finalStyles = {};\n        Object.keys(styles).forEach(function (key) { finalStyles[key] = null; });\n        return finalStyles;\n    }\n    function collectAndResolveStyles(collection, styles) {\n        return styles.map(function (entry) {\n            var stylesObj = {};\n            Object.keys(entry).forEach(function (prop) {\n                var value = entry[prop];\n                if (value == FILL_STYLE_FLAG) {\n                    value = collection[prop];\n                    if (!isPresent(value)) {\n                        value = AUTO_STYLE;\n                    }\n                }\n                collection[prop] = value;\n                stylesObj[prop] = value;\n            });\n            return stylesObj;\n        });\n    }\n    function renderStyles(element, renderer, styles) {\n        Object.keys(styles).forEach(function (prop) { renderer.setElementStyle(element, prop, styles[prop]); });\n    }\n    function flattenStyles(styles) {\n        var finalStyles = {};\n        styles.forEach(function (entry) {\n            Object.keys(entry).forEach(function (prop) { finalStyles[prop] = entry[prop]; });\n        });\n        return finalStyles;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var AnimationStyles = (function () {\n        function AnimationStyles(styles) {\n            this.styles = styles;\n        }\n        return AnimationStyles;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * An instance of this class is returned as an event parameter when an animation\n     * callback is captured for an animation either during the start or done phase.\n     *\n     * ```typescript\n     * @Component({\n     *   host: {\n     *     '[@myAnimationTrigger]': 'someExpression',\n     *     '(@myAnimationTrigger.start)': 'captureStartEvent($event)',\n     *     '(@myAnimationTrigger.done)': 'captureDoneEvent($event)',\n     *   },\n     *   animations: [\n     *     trigger(\"myAnimationTrigger\", [\n     *        // ...\n     *     ])\n     *   ]\n     * })\n     * class MyComponent {\n     *   someExpression: any = false;\n     *   captureStartEvent(event: AnimationTransitionEvent) {\n     *     // the toState, fromState and totalTime data is accessible from the event variable\n     *   }\n     *\n     *   captureDoneEvent(event: AnimationTransitionEvent) {\n     *     // the toState, fromState and totalTime data is accessible from the event variable\n     *   }\n     * }\n     * ```\n     *\n     * @experimental Animation support is experimental.\n     */\n    var AnimationTransitionEvent = (function () {\n        function AnimationTransitionEvent(_a) {\n            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime, phaseName = _a.phaseName;\n            this.fromState = fromState;\n            this.toState = toState;\n            this.totalTime = totalTime;\n            this.phaseName = phaseName;\n        }\n        return AnimationTransitionEvent;\n    }());\n\n    var AnimationTransition = (function () {\n        function AnimationTransition(_player, _fromState, _toState, _totalTime) {\n            this._player = _player;\n            this._fromState = _fromState;\n            this._toState = _toState;\n            this._totalTime = _totalTime;\n        }\n        AnimationTransition.prototype._createEvent = function (phaseName) {\n            return new AnimationTransitionEvent({\n                fromState: this._fromState,\n                toState: this._toState,\n                totalTime: this._totalTime,\n                phaseName: phaseName\n            });\n        };\n        AnimationTransition.prototype.onStart = function (callback) {\n            var event = this._createEvent('start');\n            this._player.onStart(function () { return callback(event); });\n        };\n        AnimationTransition.prototype.onDone = function (callback) {\n            var event = this._createEvent('done');\n            this._player.onDone(function () { return callback(event); });\n        };\n        return AnimationTransition;\n    }());\n\n    var DebugDomRootRenderer = (function () {\n        function DebugDomRootRenderer(_delegate) {\n            this._delegate = _delegate;\n        }\n        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {\n            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));\n        };\n        return DebugDomRootRenderer;\n    }());\n    var DebugDomRenderer = (function () {\n        function DebugDomRenderer(_delegate) {\n            this._delegate = _delegate;\n        }\n        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {\n            var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);\n            var debugEl = new DebugElement(nativeEl, null, debugInfo);\n            indexDebugNode(debugEl);\n            return nativeEl;\n        };\n        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {\n            var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);\n            var debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);\n            debugEl.name = name;\n            indexDebugNode(debugEl);\n            return nativeEl;\n        };\n        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };\n        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {\n            var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);\n            var debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);\n            indexDebugNode(debugEl);\n            return comment;\n        };\n        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {\n            var text = this._delegate.createText(parentElement, value, debugInfo);\n            var debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);\n            indexDebugNode(debugEl);\n            return text;\n        };\n        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {\n            var debugParent = getDebugNode(parentElement);\n            if (isPresent(debugParent) && debugParent instanceof DebugElement) {\n                var debugElement_1 = debugParent;\n                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });\n            }\n            this._delegate.projectNodes(parentElement, nodes);\n        };\n        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {\n            var debugNode = getDebugNode(node);\n            if (isPresent(debugNode)) {\n                var debugParent = debugNode.parent;\n                if (viewRootNodes.length > 0 && isPresent(debugParent)) {\n                    var debugViewRootNodes_1 = [];\n                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes_1.push(getDebugNode(rootNode)); });\n                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes_1);\n                }\n            }\n            this._delegate.attachViewAfter(node, viewRootNodes);\n        };\n        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {\n            viewRootNodes.forEach(function (node) {\n                var debugNode = getDebugNode(node);\n                if (isPresent(debugNode) && isPresent(debugNode.parent)) {\n                    debugNode.parent.removeChild(debugNode);\n                }\n            });\n            this._delegate.detachView(viewRootNodes);\n        };\n        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {\n            viewAllNodes = viewAllNodes || [];\n            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });\n            this._delegate.destroyView(hostElement, viewAllNodes);\n        };\n        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl)) {\n                debugEl.listeners.push(new EventListener(name, callback));\n            }\n            return this._delegate.listen(renderElement, name, callback);\n        };\n        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {\n            return this._delegate.listenGlobal(target, name, callback);\n        };\n        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.properties[propertyName] = propertyValue;\n            }\n            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);\n        };\n        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.attributes[attributeName] = attributeValue;\n            }\n            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);\n        };\n        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {\n            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);\n        };\n        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.classes[className] = isAdd;\n            }\n            this._delegate.setElementClass(renderElement, className, isAdd);\n        };\n        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {\n            var debugEl = getDebugNode(renderElement);\n            if (isPresent(debugEl) && debugEl instanceof DebugElement) {\n                debugEl.styles[styleName] = styleValue;\n            }\n            this._delegate.setElementStyle(renderElement, styleName, styleValue);\n        };\n        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {\n            this._delegate.invokeElementMethod(renderElement, methodName, args);\n        };\n        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };\n        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);\n        };\n        return DebugDomRenderer;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ViewType;\n    (function (ViewType) {\n        // A view that contains the host element with bound component directive.\n        // Contains a COMPONENT view\n        ViewType[ViewType[\"HOST\"] = 0] = \"HOST\";\n        // The view of the component\n        // Can contain 0 to n EMBEDDED views\n        ViewType[ViewType[\"COMPONENT\"] = 1] = \"COMPONENT\";\n        // A view that is embedded into another View via a <template> element\n        // inside of a COMPONENT view\n        ViewType[ViewType[\"EMBEDDED\"] = 2] = \"EMBEDDED\";\n    })(ViewType || (ViewType = {}));\n\n    var StaticNodeDebugInfo = (function () {\n        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {\n            this.providerTokens = providerTokens;\n            this.componentToken = componentToken;\n            this.refTokens = refTokens;\n        }\n        return StaticNodeDebugInfo;\n    }());\n    var DebugContext = (function () {\n        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {\n            this._view = _view;\n            this._nodeIndex = _nodeIndex;\n            this._tplRow = _tplRow;\n            this._tplCol = _tplCol;\n        }\n        Object.defineProperty(DebugContext.prototype, \"_staticNodeInfo\", {\n            get: function () {\n                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"context\", {\n            get: function () { return this._view.context; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"component\", {\n            get: function () {\n                var staticNodeInfo = this._staticNodeInfo;\n                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {\n                    return this.injector.get(staticNodeInfo.componentToken);\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"componentRenderElement\", {\n            get: function () {\n                var componentView = this._view;\n                while (isPresent(componentView.parentView) && componentView.type !== ViewType.COMPONENT) {\n                    componentView = componentView.parentView;\n                }\n                return componentView.parentElement;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"injector\", {\n            get: function () { return this._view.injector(this._nodeIndex); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"renderNode\", {\n            get: function () {\n                if (isPresent(this._nodeIndex) && this._view.allNodes) {\n                    return this._view.allNodes[this._nodeIndex];\n                }\n                else {\n                    return null;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"providerTokens\", {\n            get: function () {\n                var staticNodeInfo = this._staticNodeInfo;\n                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"source\", {\n            get: function () {\n                return this._view.componentType.templateUrl + \":\" + this._tplRow + \":\" + this._tplCol;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DebugContext.prototype, \"references\", {\n            get: function () {\n                var _this = this;\n                var varValues = {};\n                var staticNodeInfo = this._staticNodeInfo;\n                if (isPresent(staticNodeInfo)) {\n                    var refs_1 = staticNodeInfo.refTokens;\n                    Object.keys(refs_1).forEach(function (refName) {\n                        var refToken = refs_1[refName];\n                        var varValue;\n                        if (isBlank(refToken)) {\n                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;\n                        }\n                        else {\n                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);\n                        }\n                        varValues[refName] = varValue;\n                    });\n                }\n                return varValues;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return DebugContext;\n    }());\n\n    var ViewAnimationMap = (function () {\n        function ViewAnimationMap() {\n            this._map = new Map();\n            this._allPlayers = [];\n        }\n        ViewAnimationMap.prototype.find = function (element, animationName) {\n            var playersByAnimation = this._map.get(element);\n            if (isPresent(playersByAnimation)) {\n                return playersByAnimation[animationName];\n            }\n        };\n        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {\n            var el = this._map.get(element);\n            return el ? Object.keys(el).map(function (k) { return el[k]; }) : [];\n        };\n        ViewAnimationMap.prototype.set = function (element, animationName, player) {\n            var playersByAnimation = this._map.get(element);\n            if (!isPresent(playersByAnimation)) {\n                playersByAnimation = {};\n            }\n            var existingEntry = playersByAnimation[animationName];\n            if (isPresent(existingEntry)) {\n                this.remove(element, animationName);\n            }\n            playersByAnimation[animationName] = player;\n            this._allPlayers.push(player);\n            this._map.set(element, playersByAnimation);\n        };\n        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };\n        ViewAnimationMap.prototype.remove = function (element, animationName) {\n            var playersByAnimation = this._map.get(element);\n            if (playersByAnimation) {\n                var player = playersByAnimation[animationName];\n                delete playersByAnimation[animationName];\n                var index = this._allPlayers.indexOf(player);\n                this._allPlayers.splice(index, 1);\n                if (Object.keys(playersByAnimation).length === 0) {\n                    this._map.delete(element);\n                }\n            }\n        };\n        return ViewAnimationMap;\n    }());\n\n    var AnimationViewContext = (function () {\n        function AnimationViewContext() {\n            this._players = new ViewAnimationMap();\n        }\n        AnimationViewContext.prototype.onAllActiveAnimationsDone = function (callback) {\n            var activeAnimationPlayers = this._players.getAllPlayers();\n            // we check for the length to avoid having GroupAnimationPlayer\n            // issue an unnecessary microtask when zero players are passed in\n            if (activeAnimationPlayers.length) {\n                new AnimationGroupPlayer(activeAnimationPlayers).onDone(function () { return callback(); });\n            }\n            else {\n                callback();\n            }\n        };\n        AnimationViewContext.prototype.queueAnimation = function (element, animationName, player) {\n            queueAnimationGlobally(player);\n            this._players.set(element, animationName, player);\n        };\n        AnimationViewContext.prototype.cancelActiveAnimation = function (element, animationName, removeAllAnimations) {\n            if (removeAllAnimations === void 0) { removeAllAnimations = false; }\n            if (removeAllAnimations) {\n                this._players.findAllPlayersByElement(element).forEach(function (player) { return player.destroy(); });\n            }\n            else {\n                var player = this._players.find(element, animationName);\n                if (player) {\n                    player.destroy();\n                }\n            }\n        };\n        return AnimationViewContext;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$15 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var ElementInjector = (function (_super) {\n        __extends$15(ElementInjector, _super);\n        function ElementInjector(_view, _nodeIndex) {\n            _super.call(this);\n            this._view = _view;\n            this._nodeIndex = _nodeIndex;\n        }\n        ElementInjector.prototype.get = function (token, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\n            return this._view.injectorGet(token, this._nodeIndex, notFoundValue);\n        };\n        return ElementInjector;\n    }(Injector));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$14 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _scope_check = wtfCreateScope(\"AppView#check(ascii id)\");\n    /**\n     * @experimental\n     */\n    var EMPTY_CONTEXT$1 = new Object();\n    var UNDEFINED$1 = new Object();\n    /**\n     * Cost of making objects: http://jsperf.com/instantiate-size-of-object\n     *\n     */\n    var AppView = (function () {\n        function AppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentElement, cdMode, declaredViewContainer) {\n            if (declaredViewContainer === void 0) { declaredViewContainer = null; }\n            this.clazz = clazz;\n            this.componentType = componentType;\n            this.type = type;\n            this.viewUtils = viewUtils;\n            this.parentView = parentView;\n            this.parentIndex = parentIndex;\n            this.parentElement = parentElement;\n            this.cdMode = cdMode;\n            this.declaredViewContainer = declaredViewContainer;\n            this.viewContainer = null;\n            this.numberOfChecks = 0;\n            this.ref = new ViewRef_(this);\n            if (type === ViewType.COMPONENT || type === ViewType.HOST) {\n                this.renderer = viewUtils.renderComponent(componentType);\n            }\n            else {\n                this.renderer = parentView.renderer;\n            }\n            this._directRenderer = this.renderer.directRenderer;\n        }\n        Object.defineProperty(AppView.prototype, \"animationContext\", {\n            get: function () {\n                if (!this._animationContext) {\n                    this._animationContext = new AnimationViewContext();\n                }\n                return this._animationContext;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AppView.prototype, \"destroyed\", {\n            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },\n            enumerable: true,\n            configurable: true\n        });\n        AppView.prototype.create = function (context) {\n            this.context = context;\n            return this.createInternal(null);\n        };\n        AppView.prototype.createHostView = function (rootSelectorOrNode, hostInjector, projectableNodes) {\n            this.context = EMPTY_CONTEXT$1;\n            this._hasExternalHostElement = isPresent(rootSelectorOrNode);\n            this._hostInjector = hostInjector;\n            this._hostProjectableNodes = projectableNodes;\n            return this.createInternal(rootSelectorOrNode);\n        };\n        /**\n         * Overwritten by implementations.\n         * Returns the ComponentRef for the host element for ViewType.HOST.\n         */\n        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };\n        /**\n         * Overwritten by implementations.\n         */\n        AppView.prototype.createEmbeddedViewInternal = function (templateNodeIndex) { return null; };\n        AppView.prototype.init = function (lastRootNode, allNodes, disposables) {\n            this.lastRootNode = lastRootNode;\n            this.allNodes = allNodes;\n            this.disposables = disposables;\n            if (this.type === ViewType.COMPONENT) {\n                this.dirtyParentQueriesInternal();\n            }\n        };\n        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundValue) {\n            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\n            var result = UNDEFINED$1;\n            var view = this;\n            while (result === UNDEFINED$1) {\n                if (isPresent(nodeIndex)) {\n                    result = view.injectorGetInternal(token, nodeIndex, UNDEFINED$1);\n                }\n                if (result === UNDEFINED$1 && view.type === ViewType.HOST) {\n                    result = view._hostInjector.get(token, notFoundValue);\n                }\n                nodeIndex = view.parentIndex;\n                view = view.parentView;\n            }\n            return result;\n        };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {\n            return notFoundResult;\n        };\n        AppView.prototype.injector = function (nodeIndex) { return new ElementInjector(this, nodeIndex); };\n        AppView.prototype.detachAndDestroy = function () {\n            if (this._hasExternalHostElement) {\n                this.detach();\n            }\n            else if (isPresent(this.viewContainer)) {\n                this.viewContainer.detachView(this.viewContainer.nestedViews.indexOf(this));\n            }\n            this.destroy();\n        };\n        AppView.prototype.destroy = function () {\n            var _this = this;\n            if (this.cdMode === ChangeDetectorStatus.Destroyed) {\n                return;\n            }\n            var hostElement = this.type === ViewType.COMPONENT ? this.parentElement : null;\n            if (this.disposables) {\n                for (var i = 0; i < this.disposables.length; i++) {\n                    this.disposables[i]();\n                }\n            }\n            this.destroyInternal();\n            this.dirtyParentQueriesInternal();\n            if (this._animationContext) {\n                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.destroyView(hostElement, _this.allNodes); });\n            }\n            else {\n                this.renderer.destroyView(hostElement, this.allNodes);\n            }\n            this.cdMode = ChangeDetectorStatus.Destroyed;\n        };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.destroyInternal = function () { };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.detachInternal = function () { };\n        AppView.prototype.detach = function () {\n            var _this = this;\n            this.detachInternal();\n            if (this._animationContext) {\n                this._animationContext.onAllActiveAnimationsDone(function () { return _this._renderDetach(); });\n            }\n            else {\n                this._renderDetach();\n            }\n            if (this.declaredViewContainer && this.declaredViewContainer !== this.viewContainer) {\n                var projectedViews = this.declaredViewContainer.projectedViews;\n                var index = projectedViews.indexOf(this);\n                // perf: pop is faster than splice!\n                if (index >= projectedViews.length - 1) {\n                    projectedViews.pop();\n                }\n                else {\n                    projectedViews.splice(index, 1);\n                }\n            }\n            this.viewContainer = null;\n            this.dirtyParentQueriesInternal();\n        };\n        AppView.prototype._renderDetach = function () {\n            if (this._directRenderer) {\n                this.visitRootNodesInternal(this._directRenderer.remove, null);\n            }\n            else {\n                this.renderer.detachView(this.flatRootNodes);\n            }\n        };\n        AppView.prototype.attachAfter = function (viewContainer, prevView) {\n            this._renderAttach(viewContainer, prevView);\n            this.viewContainer = viewContainer;\n            if (this.declaredViewContainer && this.declaredViewContainer !== viewContainer) {\n                if (!this.declaredViewContainer.projectedViews) {\n                    this.declaredViewContainer.projectedViews = [];\n                }\n                this.declaredViewContainer.projectedViews.push(this);\n            }\n            this.dirtyParentQueriesInternal();\n        };\n        AppView.prototype.moveAfter = function (viewContainer, prevView) {\n            this._renderAttach(viewContainer, prevView);\n            this.dirtyParentQueriesInternal();\n        };\n        AppView.prototype._renderAttach = function (viewContainer, prevView) {\n            var prevNode = prevView ? prevView.lastRootNode : viewContainer.nativeElement;\n            if (this._directRenderer) {\n                var nextSibling = this._directRenderer.nextSibling(prevNode);\n                if (nextSibling) {\n                    this.visitRootNodesInternal(this._directRenderer.insertBefore, nextSibling);\n                }\n                else {\n                    this.visitRootNodesInternal(this._directRenderer.appendChild, this._directRenderer.parentElement(prevNode));\n                }\n            }\n            else {\n                this.renderer.attachViewAfter(prevNode, this.flatRootNodes);\n            }\n        };\n        Object.defineProperty(AppView.prototype, \"changeDetectorRef\", {\n            get: function () { return this.ref; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AppView.prototype, \"flatRootNodes\", {\n            get: function () {\n                var nodes = [];\n                this.visitRootNodesInternal(addToArray, nodes);\n                return nodes;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        AppView.prototype.projectNodes = function (parentElement, ngContentIndex) {\n            if (this._directRenderer) {\n                this.visitProjectedNodes(ngContentIndex, this._directRenderer.appendChild, parentElement);\n            }\n            else {\n                var nodes = [];\n                this.visitProjectedNodes(ngContentIndex, addToArray, nodes);\n                this.renderer.projectNodes(parentElement, nodes);\n            }\n        };\n        AppView.prototype.visitProjectedNodes = function (ngContentIndex, cb, c) {\n            switch (this.type) {\n                case ViewType.EMBEDDED:\n                    this.parentView.visitProjectedNodes(ngContentIndex, cb, c);\n                    break;\n                case ViewType.COMPONENT:\n                    if (this.parentView.type === ViewType.HOST) {\n                        var nodes = this.parentView._hostProjectableNodes[ngContentIndex] || [];\n                        for (var i = 0; i < nodes.length; i++) {\n                            cb(nodes[i], c);\n                        }\n                    }\n                    else {\n                        this.parentView.visitProjectableNodesInternal(this.parentIndex, ngContentIndex, cb, c);\n                    }\n                    break;\n            }\n        };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.visitRootNodesInternal = function (cb, c) { };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.visitProjectableNodesInternal = function (nodeIndex, ngContentIndex, cb, c) { };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.dirtyParentQueriesInternal = function () { };\n        AppView.prototype.detectChanges = function (throwOnChange) {\n            var s = _scope_check(this.clazz);\n            if (this.cdMode === ChangeDetectorStatus.Checked ||\n                this.cdMode === ChangeDetectorStatus.Errored ||\n                this.cdMode === ChangeDetectorStatus.Detached)\n                return;\n            if (this.cdMode === ChangeDetectorStatus.Destroyed) {\n                this.throwDestroyedError('detectChanges');\n            }\n            this.detectChangesInternal(throwOnChange);\n            if (this.cdMode === ChangeDetectorStatus.CheckOnce)\n                this.cdMode = ChangeDetectorStatus.Checked;\n            this.numberOfChecks++;\n            wtfLeave(s);\n        };\n        /**\n         * Overwritten by implementations\n         */\n        AppView.prototype.detectChangesInternal = function (throwOnChange) { };\n        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };\n        AppView.prototype.markPathToRootAsCheckOnce = function () {\n            var c = this;\n            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {\n                if (c.cdMode === ChangeDetectorStatus.Checked) {\n                    c.cdMode = ChangeDetectorStatus.CheckOnce;\n                }\n                if (c.type === ViewType.COMPONENT) {\n                    c = c.parentView;\n                }\n                else {\n                    c = c.viewContainer ? c.viewContainer.parentView : null;\n                }\n            }\n        };\n        AppView.prototype.eventHandler = function (cb) {\n            return cb;\n        };\n        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };\n        return AppView;\n    }());\n    var DebugAppView = (function (_super) {\n        __extends$14(DebugAppView, _super);\n        function DebugAppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, staticNodeDebugInfos, declaredViewContainer) {\n            if (declaredViewContainer === void 0) { declaredViewContainer = null; }\n            _super.call(this, clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, declaredViewContainer);\n            this.staticNodeDebugInfos = staticNodeDebugInfos;\n            this._currentDebugContext = null;\n        }\n        DebugAppView.prototype.create = function (context) {\n            this._resetDebug();\n            try {\n                return _super.prototype.create.call(this, context);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.createHostView = function (rootSelectorOrNode, injector, projectableNodes) {\n            if (projectableNodes === void 0) { projectableNodes = null; }\n            this._resetDebug();\n            try {\n                return _super.prototype.createHostView.call(this, rootSelectorOrNode, injector, projectableNodes);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {\n            this._resetDebug();\n            try {\n                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.detach = function () {\n            this._resetDebug();\n            try {\n                _super.prototype.detach.call(this);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.destroy = function () {\n            this._resetDebug();\n            try {\n                _super.prototype.destroy.call(this);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype.detectChanges = function (throwOnChange) {\n            this._resetDebug();\n            try {\n                _super.prototype.detectChanges.call(this, throwOnChange);\n            }\n            catch (e) {\n                this._rethrowWithContext(e);\n                throw e;\n            }\n        };\n        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };\n        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {\n            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);\n        };\n        DebugAppView.prototype._rethrowWithContext = function (e) {\n            if (!(e instanceof ViewWrappedError)) {\n                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {\n                    this.cdMode = ChangeDetectorStatus.Errored;\n                }\n                if (isPresent(this._currentDebugContext)) {\n                    throw new ViewWrappedError(e, this._currentDebugContext);\n                }\n            }\n        };\n        DebugAppView.prototype.eventHandler = function (cb) {\n            var _this = this;\n            var superHandler = _super.prototype.eventHandler.call(this, cb);\n            return function (eventName, event) {\n                _this._resetDebug();\n                try {\n                    return superHandler.call(_this, eventName, event);\n                }\n                catch (e) {\n                    _this._rethrowWithContext(e);\n                    throw e;\n                }\n            };\n        };\n        return DebugAppView;\n    }(AppView));\n\n    /**\n     * A ViewContainer is created for elements that have a ViewContainerRef\n     * to keep track of the nested views.\n     */\n    var ViewContainer = (function () {\n        function ViewContainer(index, parentIndex, parentView, nativeElement) {\n            this.index = index;\n            this.parentIndex = parentIndex;\n            this.parentView = parentView;\n            this.nativeElement = nativeElement;\n        }\n        Object.defineProperty(ViewContainer.prototype, \"elementRef\", {\n            get: function () { return new ElementRef(this.nativeElement); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainer.prototype, \"vcRef\", {\n            get: function () { return new ViewContainerRef_(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainer.prototype, \"parentInjector\", {\n            get: function () { return this.parentView.injector(this.parentIndex); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViewContainer.prototype, \"injector\", {\n            get: function () { return this.parentView.injector(this.index); },\n            enumerable: true,\n            configurable: true\n        });\n        ViewContainer.prototype.detectChangesInNestedViews = function (throwOnChange) {\n            if (this.nestedViews) {\n                for (var i = 0; i < this.nestedViews.length; i++) {\n                    this.nestedViews[i].detectChanges(throwOnChange);\n                }\n            }\n        };\n        ViewContainer.prototype.destroyNestedViews = function () {\n            if (this.nestedViews) {\n                for (var i = 0; i < this.nestedViews.length; i++) {\n                    this.nestedViews[i].destroy();\n                }\n            }\n        };\n        ViewContainer.prototype.visitNestedViewRootNodes = function (cb, c) {\n            if (this.nestedViews) {\n                for (var i = 0; i < this.nestedViews.length; i++) {\n                    this.nestedViews[i].visitRootNodesInternal(cb, c);\n                }\n            }\n        };\n        ViewContainer.prototype.mapNestedViews = function (nestedViewClass, callback) {\n            var result = [];\n            if (this.nestedViews) {\n                for (var i = 0; i < this.nestedViews.length; i++) {\n                    var nestedView = this.nestedViews[i];\n                    if (nestedView.clazz === nestedViewClass) {\n                        result.push(callback(nestedView));\n                    }\n                }\n            }\n            if (this.projectedViews) {\n                for (var i = 0; i < this.projectedViews.length; i++) {\n                    var projectedView = this.projectedViews[i];\n                    if (projectedView.clazz === nestedViewClass) {\n                        result.push(callback(projectedView));\n                    }\n                }\n            }\n            return result;\n        };\n        ViewContainer.prototype.moveView = function (view, currentIndex) {\n            var previousIndex = this.nestedViews.indexOf(view);\n            if (view.type === ViewType.COMPONENT) {\n                throw new Error(\"Component views can't be moved!\");\n            }\n            var nestedViews = this.nestedViews;\n            if (nestedViews == null) {\n                nestedViews = [];\n                this.nestedViews = nestedViews;\n            }\n            nestedViews.splice(previousIndex, 1);\n            nestedViews.splice(currentIndex, 0, view);\n            var prevView = currentIndex > 0 ? nestedViews[currentIndex - 1] : null;\n            view.moveAfter(this, prevView);\n        };\n        ViewContainer.prototype.attachView = function (view, viewIndex) {\n            if (view.type === ViewType.COMPONENT) {\n                throw new Error(\"Component views can't be moved!\");\n            }\n            var nestedViews = this.nestedViews;\n            if (nestedViews == null) {\n                nestedViews = [];\n                this.nestedViews = nestedViews;\n            }\n            // perf: array.push is faster than array.splice!\n            if (viewIndex >= nestedViews.length) {\n                nestedViews.push(view);\n            }\n            else {\n                nestedViews.splice(viewIndex, 0, view);\n            }\n            var prevView = viewIndex > 0 ? nestedViews[viewIndex - 1] : null;\n            view.attachAfter(this, prevView);\n        };\n        ViewContainer.prototype.detachView = function (viewIndex) {\n            var view = this.nestedViews[viewIndex];\n            // perf: array.pop is faster than array.splice!\n            if (viewIndex >= this.nestedViews.length - 1) {\n                this.nestedViews.pop();\n            }\n            else {\n                this.nestedViews.splice(viewIndex, 1);\n            }\n            if (view.type === ViewType.COMPONENT) {\n                throw new Error(\"Component views can't be moved!\");\n            }\n            view.detach();\n            return view;\n        };\n        return ViewContainer;\n    }());\n\n    var __core_private__ = {\n        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,\n        ChangeDetectorStatus: ChangeDetectorStatus,\n        constructDependencies: constructDependencies,\n        LifecycleHooks: LifecycleHooks,\n        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,\n        ReflectorReader: ReflectorReader,\n        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,\n        ComponentRef_: ComponentRef_,\n        ViewContainer: ViewContainer,\n        AppView: AppView,\n        DebugAppView: DebugAppView,\n        NgModuleInjector: NgModuleInjector,\n        registerModuleFactory: registerModuleFactory,\n        ViewType: ViewType,\n        view_utils: view_utils,\n        ViewMetadata: ViewMetadata,\n        DebugContext: DebugContext,\n        StaticNodeDebugInfo: StaticNodeDebugInfo,\n        devModeEqual: devModeEqual,\n        UNINITIALIZED: UNINITIALIZED,\n        ValueUnwrapper: ValueUnwrapper,\n        RenderDebugInfo: RenderDebugInfo,\n        TemplateRef_: TemplateRef_,\n        ReflectionCapabilities: ReflectionCapabilities,\n        makeDecorator: makeDecorator,\n        DebugDomRootRenderer: DebugDomRootRenderer,\n        Console: Console,\n        reflector: reflector,\n        Reflector: Reflector,\n        NoOpAnimationPlayer: NoOpAnimationPlayer,\n        AnimationPlayer: AnimationPlayer,\n        AnimationSequencePlayer: AnimationSequencePlayer,\n        AnimationGroupPlayer: AnimationGroupPlayer,\n        AnimationKeyframe: AnimationKeyframe,\n        prepareFinalAnimationStyles: prepareFinalAnimationStyles,\n        balanceAnimationKeyframes: balanceAnimationKeyframes,\n        flattenStyles: flattenStyles,\n        clearStyles: clearStyles,\n        renderStyles: renderStyles,\n        collectAndResolveStyles: collectAndResolveStyles,\n        APP_ID_RANDOM_PROVIDER: APP_ID_RANDOM_PROVIDER,\n        AnimationStyles: AnimationStyles,\n        ANY_STATE: ANY_STATE,\n        DEFAULT_STATE: DEFAULT_STATE,\n        EMPTY_STATE: EMPTY_STATE,\n        FILL_STYLE_FLAG: FILL_STYLE_FLAG,\n        ComponentStillLoadingError: ComponentStillLoadingError,\n        isPromise: isPromise,\n        AnimationTransition: AnimationTransition\n    };\n\n    exports.createPlatform = createPlatform;\n    exports.assertPlatform = assertPlatform;\n    exports.destroyPlatform = destroyPlatform;\n    exports.getPlatform = getPlatform;\n    exports.PlatformRef = PlatformRef;\n    exports.ApplicationRef = ApplicationRef;\n    exports.enableProdMode = enableProdMode;\n    exports.isDevMode = isDevMode;\n    exports.createPlatformFactory = createPlatformFactory;\n    exports.APP_ID = APP_ID;\n    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;\n    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;\n    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;\n    exports.APP_INITIALIZER = APP_INITIALIZER;\n    exports.ApplicationInitStatus = ApplicationInitStatus;\n    exports.DebugElement = DebugElement;\n    exports.DebugNode = DebugNode;\n    exports.asNativeElements = asNativeElements;\n    exports.getDebugNode = getDebugNode;\n    exports.Testability = Testability;\n    exports.TestabilityRegistry = TestabilityRegistry;\n    exports.setTestabilityGetter = setTestabilityGetter;\n    exports.TRANSLATIONS = TRANSLATIONS;\n    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;\n    exports.LOCALE_ID = LOCALE_ID;\n    exports.ApplicationModule = ApplicationModule;\n    exports.wtfCreateScope = wtfCreateScope;\n    exports.wtfLeave = wtfLeave;\n    exports.wtfStartTimeRange = wtfStartTimeRange;\n    exports.wtfEndTimeRange = wtfEndTimeRange;\n    exports.Type = Type;\n    exports.EventEmitter = EventEmitter;\n    exports.ErrorHandler = ErrorHandler;\n    exports.AnimationTransitionEvent = AnimationTransitionEvent;\n    exports.AnimationPlayer = AnimationPlayer;\n    exports.Sanitizer = Sanitizer;\n    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;\n    exports.Attribute = Attribute;\n    exports.ContentChild = ContentChild;\n    exports.ContentChildren = ContentChildren;\n    exports.Query = Query;\n    exports.ViewChild = ViewChild;\n    exports.ViewChildren = ViewChildren;\n    exports.Component = Component;\n    exports.Directive = Directive;\n    exports.HostBinding = HostBinding;\n    exports.HostListener = HostListener;\n    exports.Input = Input;\n    exports.Output = Output;\n    exports.Pipe = Pipe;\n    exports.AfterContentChecked = AfterContentChecked;\n    exports.AfterContentInit = AfterContentInit;\n    exports.AfterViewChecked = AfterViewChecked;\n    exports.AfterViewInit = AfterViewInit;\n    exports.DoCheck = DoCheck;\n    exports.OnChanges = OnChanges;\n    exports.OnDestroy = OnDestroy;\n    exports.OnInit = OnInit;\n    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;\n    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;\n    exports.NgModule = NgModule;\n    exports.Class = Class;\n    exports.forwardRef = forwardRef;\n    exports.resolveForwardRef = resolveForwardRef;\n    exports.Injector = Injector;\n    exports.ReflectiveInjector = ReflectiveInjector;\n    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;\n    exports.ReflectiveKey = ReflectiveKey;\n    exports.OpaqueToken = OpaqueToken;\n    exports.Inject = Inject;\n    exports.Optional = Optional;\n    exports.Injectable = Injectable;\n    exports.Self = Self;\n    exports.SkipSelf = SkipSelf;\n    exports.Host = Host;\n    exports.NgZone = NgZone;\n    exports.RenderComponentType = RenderComponentType;\n    exports.Renderer = Renderer;\n    exports.RootRenderer = RootRenderer;\n    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;\n    exports.Compiler = Compiler;\n    exports.CompilerFactory = CompilerFactory;\n    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;\n    exports.ComponentFactory = ComponentFactory;\n    exports.ComponentRef = ComponentRef;\n    exports.ComponentFactoryResolver = ComponentFactoryResolver;\n    exports.ElementRef = ElementRef;\n    exports.NgModuleFactory = NgModuleFactory;\n    exports.NgModuleRef = NgModuleRef;\n    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;\n    exports.getModuleFactory = getModuleFactory;\n    exports.QueryList = QueryList;\n    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;\n    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;\n    exports.TemplateRef = TemplateRef;\n    exports.ViewContainerRef = ViewContainerRef;\n    exports.EmbeddedViewRef = EmbeddedViewRef;\n    exports.ViewRef = ViewRef;\n    exports.ChangeDetectorRef = ChangeDetectorRef;\n    exports.CollectionChangeRecord = CollectionChangeRecord;\n    exports.DefaultIterableDiffer = DefaultIterableDiffer;\n    exports.IterableDiffers = IterableDiffers;\n    exports.KeyValueChangeRecord = KeyValueChangeRecord;\n    exports.KeyValueDiffers = KeyValueDiffers;\n    exports.SimpleChange = SimpleChange;\n    exports.WrappedValue = WrappedValue;\n    exports.platformCore = platformCore;\n    exports.__core_private__ = __core_private__;\n    exports.AUTO_STYLE = AUTO_STYLE;\n    exports.AnimationEntryMetadata = AnimationEntryMetadata;\n    exports.AnimationStateMetadata = AnimationStateMetadata;\n    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;\n    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;\n    exports.AnimationMetadata = AnimationMetadata;\n    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;\n    exports.AnimationStyleMetadata = AnimationStyleMetadata;\n    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;\n    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;\n    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;\n    exports.AnimationGroupMetadata = AnimationGroupMetadata;\n    exports.animate = animate;\n    exports.group = group;\n    exports.sequence = sequence;\n    exports.style = style;\n    exports.state = state;\n    exports.keyframes = keyframes;\n    exports.transition = transition;\n    exports.trigger = trigger;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2NvcmUvYnVuZGxlcy9jb3JlLnVtZC5qcz9lMmE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUNBQXVDO0FBQ2hGLENBQUMsd0RBQXdEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwRUFBMEU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0RBQW9EO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdDQUF3QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWtFO0FBQzlFO0FB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Q0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixFQUFFO0FBQzFEO0FBQ0E7QUFDQSx3Q0FBd0MsNkNBQTZDLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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aUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9EO0FBQ0Esd0NBQXdDLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMEJBQTBCLEVBQUU7QUFDOUY7QUFDQSwwRUFBMEUsOEJBQThCLEVBQUU7QUFDMUc7QUFDQSx1RUFBdUUsK0JBQStCLEVBQUU7QUFDeEc7QUFDQSx1RUFBdUUsMkJBQTJCLEVBQUU7QUFDcEc7QUFDQSx5RUFBeUUsOEJBQThCLEVBQUU7QUFDekc7QUFDQSw0RUFBNEUscUNBQXFDLEVBQUU7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEIsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDBEQUEwRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RSw4REFBOEQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRCQUE0Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhCQUE4QiwyQkFBMkIsRUFBRTtBQUMzRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhCQUE4Qiw2Q0FBNkMsRUFBRTtBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjIuMFxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3J4anMvU3ViamVjdCcsICdyeGpzL09ic2VydmFibGUnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5jb3JlID0gZ2xvYmFsLm5nLmNvcmUgfHwge30pLGdsb2JhbC5SeCxnbG9iYWwuUngpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMscnhqc19TdWJqZWN0LHJ4anNfT2JzZXJ2YWJsZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIGdsb2JhbFNjb3BlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gZ2xvYmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNaWNyb1Rhc2soZm4pIHtcbiAgICAgICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdzY2hlZHVsZU1pY3JvdGFzaycsIGZuKTtcbiAgICB9XG4gICAgLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4gICAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgICB2YXIgZ2xvYmFsJDEgPSBnbG9iYWxTY29wZTtcbiAgICBmdW5jdGlvbiBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlWyduYW1lJ10gfHwgdHlwZW9mIHR5cGU7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlbW92ZSBjYWxscyB0byBhc3NlcnQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxuICAgIC8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuICAgIC8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG4gICAgZ2xvYmFsJDEuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVJbmRleCA9PT0gLTEgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG4gICAgfVxuICAgIC8vIEpTIGhhcyBOYU4gIT09IE5hTlxuICAgIGZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbyA9PT0gJ29iamVjdCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmludChvYmopIHtcbiAgICAgICAgY29uc29sZS5sb2cob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybihvYmopIHtcbiAgICAgICAgY29uc29sZS53YXJuKG9iaik7XG4gICAgfVxuICAgIHZhciBfc3ltYm9sSXRlcmF0b3IgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICAgICAgICBpZiAoIV9zeW1ib2xJdGVyYXRvcikge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFNjb3BlLlN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVba2V5XSA9PT0gTWFwLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zeW1ib2xJdGVyYXRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xuICAgIH1cblxuICAgIHZhciBfbmV4dENsYXNzSWQgPSAwO1xuICAgIHZhciBSZWZsZWN0ID0gZ2xvYmFsJDEuUmVmbGVjdDtcbiAgICBmdW5jdGlvbiBleHRyYWN0QW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBhbm5vdGF0aW9uLmhhc093blByb3BlcnR5KCdhbm5vdGF0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIGl0IGlzIGEgZGVjb3JhdG9yLCBleHRyYWN0IGFubm90YXRpb25cbiAgICAgICAgICAgIGFubm90YXRpb24gPSBhbm5vdGF0aW9uLmFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5UGFyYW1zKGZuT3JBcnJheSwga2V5KSB7XG4gICAgICAgIGlmIChmbk9yQXJyYXkgPT09IE9iamVjdCB8fCBmbk9yQXJyYXkgPT09IFN0cmluZyB8fCBmbk9yQXJyYXkgPT09IEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICBmbk9yQXJyYXkgPT09IE51bWJlciB8fCBmbk9yQXJyYXkgPT09IEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVzZSBuYXRpdmUgXCIgKyBzdHJpbmdpZnkoZm5PckFycmF5KSArIFwiIGFzIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZm5PckFycmF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZm5PckFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZuT3JBcnJheSkpIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IGZuT3JBcnJheTtcbiAgICAgICAgICAgIHZhciBhbm5vTGVuZ3RoID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBmbiA9IGZuT3JBcnJheVthbm5vTGVuZ3RoXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHBvc2l0aW9uIG9mIENsYXNzIG1ldGhvZCBhcnJheSBtdXN0IGJlIEZ1bmN0aW9uIGluIGtleSBcIiArIGtleSArIFwiIHdhcyAnXCIgKyBzdHJpbmdpZnkoZm4pICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFubm9MZW5ndGggIT0gZm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIGFubm90YXRpb25zIChcIiArIGFubm9MZW5ndGggKyBcIikgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mIGFyZ3VtZW50cyAoXCIgKyBmbi5sZW5ndGggKyBcIikgaW4gdGhlIGZ1bmN0aW9uOiBcIiArIHN0cmluZ2lmeShmbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmFtc0Fubm90YXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgcGFyYW1zQW5ub3RhdGlvbnMucHVzaChwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5ub3RhdGlvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb25bal0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5ub3RhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbUFubm90YXRpb25zLnB1c2goZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbXNBbm5vdGF0aW9ucywgZm4pO1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgRnVuY3Rpb24gb3IgQXJyYXkgaXMgc3VwcG9ydGVkIGluIENsYXNzIGRlZmluaXRpb24gZm9yIGtleSAnXCIgKyBrZXkgKyBcIicgaXMgJ1wiICsgc3RyaW5naWZ5KGZuT3JBcnJheSkgKyBcIidcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgd2F5IGZvciBleHByZXNzaW5nIEVTNiBjbGFzc2VzIHdpdGggcGFyYW1ldGVyIGFubm90YXRpb25zIGluIEVTNS5cbiAgICAgKlxuICAgICAqICMjIEJhc2ljIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBHcmVldGVyID0gbmcuQ2xhc3Moe1xuICAgICAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiAgIH0sXG4gICAgICpcbiAgICAgKiAgIGdyZWV0OiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBFUzY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjbGFzcyBHcmVldGVyIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgZ3JlZXQoKSB7XG4gICAgICogICAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBvciBlcXVpdmFsZW50IHRvIEVTNTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBHcmVldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgKiAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogR3JlZXRlci5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICBhbGVydCgnSGVsbG8gJyArIHRoaXMubmFtZSArICchJyk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgd2l0aCBwYXJhbWV0ZXIgYW5ub3RhdGlvbnNcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBNeVNlcnZpY2UgPSBuZy5DbGFzcyh7XG4gICAgICogICBjb25zdHJ1Y3RvcjogW1N0cmluZywgW25ldyBPcHRpb25hbCgpLCBTZXJ2aWNlXSwgZnVuY3Rpb24obmFtZSwgbXlTZXJ2aWNlKSB7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgfV1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gRVM2OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgTXlTZXJ2aWNlIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgQE9wdGlvbmFsKCkgbXlTZXJ2aWNlOiBTZXJ2aWNlKSB7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIHdpdGggaW5oZXJpdGFuY2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBTaGFwZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiAoY29sb3IpIHtcbiAgICAgKiAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIFNxdWFyZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGV4dGVuZHM6IFNoYXBlLFxuICAgICAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGNvbG9yLCBzaXplKSB7XG4gICAgICogICAgIFNoYXBlLmNhbGwodGhpcywgY29sb3IpO1xuICAgICAqICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzcyhjbHNEZWYpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYXBwbHlQYXJhbXMoY2xzRGVmLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpID8gY2xzRGVmLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLCAnY29uc3RydWN0b3InKTtcbiAgICAgICAgdmFyIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICBpZiAoY2xzRGVmLmhhc093blByb3BlcnR5KCdleHRlbmRzJykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xzRGVmLmV4dGVuZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBwcm90byA9XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY2xzRGVmLmV4dGVuZHMucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsYXNzIGRlZmluaXRpb24gJ2V4dGVuZHMnIHByb3BlcnR5IG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3YXM6IFwiICsgc3RyaW5naWZ5KGNsc0RlZi5leHRlbmRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNsc0RlZikge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2V4dGVuZHMnICYmIGtleSAhPT0gJ3Byb3RvdHlwZScgJiYgY2xzRGVmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm90b1trZXldID0gYXBwbHlQYXJhbXMoY2xzRGVmW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5hbm5vdGF0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHRoaXMuYW5ub3RhdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gY29uc3RydWN0b3JbJ25hbWUnXTtcbiAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvck5hbWUgfHwgY29uc3RydWN0b3JOYW1lID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvclsnb3ZlcnJpZGRlbk5hbWUnXSA9IFwiY2xhc3NcIiArIF9uZXh0Q2xhc3NJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZURlY29yYXRvcihuYW1lLCBwcm9wcywgcGFyZW50Q2xhc3MsIGNoYWluRm4pIHtcbiAgICAgICAgaWYgKGNoYWluRm4gPT09IHZvaWQgMCkgeyBjaGFpbkZuID0gbnVsbDsgfVxuICAgICAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKFtwcm9wc10pO1xuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0b3JGYWN0b3J5KG9iak9yVHlwZSkge1xuICAgICAgICAgICAgaWYgKCEoUmVmbGVjdCAmJiBSZWZsZWN0LmdldE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdyZWZsZWN0LW1ldGFkYXRhIHNoaW0gaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBjbGFzcyBkZWNvcmF0b3JzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRGVjb3JhdG9yRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIG1ldGFDdG9yLmNhbGwodGhpcywgb2JqT3JUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uSW5zdGFuY2UgPSBuZXcgRGVjb3JhdG9yRmFjdG9yeShvYmpPclR5cGUpO1xuICAgICAgICAgICAgdmFyIGNoYWluQW5ub3RhdGlvbiA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nICYmIEFycmF5LmlzQXJyYXkodGhpcy5hbm5vdGF0aW9ucykgPyB0aGlzLmFubm90YXRpb25zIDogW107XG4gICAgICAgICAgICBjaGFpbkFubm90YXRpb24ucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgdmFyIFR5cGVEZWNvcmF0b3IgPSBmdW5jdGlvbiBUeXBlRGVjb3JhdG9yKGNscykge1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgY2xzKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgnYW5ub3RhdGlvbnMnLCBhbm5vdGF0aW9ucywgY2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFR5cGVEZWNvcmF0b3IuYW5ub3RhdGlvbnMgPSBjaGFpbkFubm90YXRpb247XG4gICAgICAgICAgICBUeXBlRGVjb3JhdG9yLkNsYXNzID0gQ2xhc3M7XG4gICAgICAgICAgICBpZiAoY2hhaW5GbilcbiAgICAgICAgICAgICAgICBjaGFpbkZuKFR5cGVEZWNvcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVEZWNvcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENsYXNzKSB7XG4gICAgICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChcIkBcIiArIG5hbWUpOyB9O1xuICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBEZWNvcmF0b3JGYWN0b3J5O1xuICAgICAgICByZXR1cm4gRGVjb3JhdG9yRmFjdG9yeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZU1ldGFkYXRhQ3Rvcihwcm9wcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3RvcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdWYWwgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWluIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICBfdGhpc1twcm9wWzBdXSA9IGFyZ1ZhbCA9PT0gdW5kZWZpbmVkID8gcHJvcFsxXSA6IGFyZ1ZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzW3Byb3BOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnVmFsICYmIGFyZ1ZhbC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBhcmdWYWxbcHJvcE5hbWVdIDogcHJvcFtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVBhcmFtRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcykge1xuICAgICAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3JGYWN0b3J5KCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUGFyYW1EZWNvcmF0b3JGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgbWV0YUN0b3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkluc3RhbmNlID0gbmV3ICgoX2EgPSBQYXJhbURlY29yYXRvckZhY3RvcnkpLmJpbmQuYXBwbHkoX2EsIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICAgICAgICBQYXJhbURlY29yYXRvci5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbkluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yO1xuICAgICAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3IoY2xzLCB1bnVzZWRLZXksIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgY2xzKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBnYXBzIGlmIHNvbWUgaW4gYmV0d2VlbiBwYXJhbWV0ZXJzIGRvIG5vdCBoYXZlIGFubm90YXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIHdlIHBhZCB3aXRoIG51bGxzLlxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJhbWV0ZXJzLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbaW5kZXhdID0gcGFyYW1ldGVyc1tpbmRleF0gfHwgW107XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc1tpbmRleF0ucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbWV0ZXJzLCBjbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENsYXNzKSB7XG4gICAgICAgICAgICBQYXJhbURlY29yYXRvckZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIFBhcmFtRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoXCJAXCIgKyBuYW1lKTsgfTtcbiAgICAgICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBQYXJhbURlY29yYXRvckZhY3Rvcnk7XG4gICAgICAgIHJldHVybiBQYXJhbURlY29yYXRvckZhY3Rvcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VQcm9wRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcykge1xuICAgICAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICAgICAgZnVuY3Rpb24gUHJvcERlY29yYXRvckZhY3RvcnkoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBQcm9wRGVjb3JhdG9yRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIG1ldGFDdG9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY29yYXRvckluc3RhbmNlID0gbmV3ICgoX2EgPSBQcm9wRGVjb3JhdG9yRmFjdG9yeSkuYmluZC5hcHBseShfYSwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBQcm9wRGVjb3JhdG9yKHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRhID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdGFyZ2V0LmNvbnN0cnVjdG9yKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBtZXRhW25hbWVdID0gbWV0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBtZXRhW25hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIG1ldGFbbmFtZV0udW5zaGlmdChkZWNvcmF0b3JJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgbWV0YSwgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENsYXNzKSB7XG4gICAgICAgICAgICBQcm9wRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgUHJvcERlY29yYXRvckZhY3RvcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFwiQFwiICsgbmFtZSk7IH07XG4gICAgICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBQcm9wRGVjb3JhdG9yRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIFByb3BEZWNvcmF0b3JGYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEluamVjdCA9IG1ha2VQYXJhbURlY29yYXRvcignSW5qZWN0JywgW1sndG9rZW4nLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBPcHRpb25hbCA9IG1ha2VQYXJhbURlY29yYXRvcignT3B0aW9uYWwnLCBbXSk7XG4gICAgLyoqXG4gICAgICogSW5qZWN0YWJsZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEluamVjdGFibGUgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0luamVjdGFibGUnLCBbXSk7XG4gICAgLyoqXG4gICAgICogU2VsZiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIFNlbGYgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ1NlbGYnLCBbXSk7XG4gICAgLyoqXG4gICAgICogU2tpcFNlbGYgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBTa2lwU2VsZiA9IG1ha2VQYXJhbURlY29yYXRvcignU2tpcFNlbGYnLCBbXSk7XG4gICAgLyoqXG4gICAgICogSG9zdCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEhvc3QgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0hvc3QnLCBbXSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCBpbiBhIERJIFByb3ZpZGVyLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1lzOWV6WHBqMk1ub3kzVWM4S0JwP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIHQgPSBuZXcgT3BhcXVlVG9rZW4oXCJ2YWx1ZVwiKTtcbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAqICAge3Byb3ZpZGU6IHQsIHVzZVZhbHVlOiBcImJpbmRpbmdWYWx1ZVwifVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldCh0KSkudG9FcXVhbChcImJpbmRpbmdWYWx1ZVwiKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzaW5nIGFuIGBPcGFxdWVUb2tlbmAgaXMgcHJlZmVyYWJsZSB0byB1c2luZyBzdHJpbmdzIGFzIHRva2VucyBiZWNhdXNlIG9mIHBvc3NpYmxlIGNvbGxpc2lvbnNcbiAgICAgKiBjYXVzZWQgYnkgbXVsdGlwbGUgcHJvdmlkZXJzIHVzaW5nIHRoZSBzYW1lIHN0cmluZyBhcyB0d28gZGlmZmVyZW50IHRva2Vucy5cbiAgICAgKlxuICAgICAqIFVzaW5nIGFuIGBPcGFxdWVUb2tlbmAgaXMgcHJlZmVyYWJsZSB0byB1c2luZyBhbiBgT2JqZWN0YCBhcyB0b2tlbnMgYmVjYXVzZSBpdCBwcm92aWRlcyBiZXR0ZXJcbiAgICAgKiBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgLy8gc28gdGhhdCBtZXRhZGF0YSBpcyBnYXRoZXJlZCBmb3IgdGhpcyBjbGFzc1xuICAgIHZhciBPcGFxdWVUb2tlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9wYXF1ZVRva2VuKF9kZXNjKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXNjID0gX2Rlc2M7XG4gICAgICAgIH1cbiAgICAgICAgT3BhcXVlVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUb2tlbiBcIiArIHRoaXMuX2Rlc2M7IH07XG4gICAgICAgIE9wYXF1ZVRva2VuLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE9wYXF1ZVRva2VuLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE9wYXF1ZVRva2VuO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHRva2VuIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIHZpcnR1YWwgcHJvdmlkZXIgdGhhdCB3aWxsIHBvcHVsYXRlIHRoZVxuICAgICAqIGBlbnRyeUNvbXBvbmVudHNgIGZpZWxkcyBvZiBjb21wb25lbnRzIGFuZCBuZyBtb2R1bGVzIGJhc2VkIG9uIGl0cyBgdXNlVmFsdWVgLlxuICAgICAqIEFsbCBjb21wb25lbnRzIHRoYXQgYXJlIHJlZmVyZW5jZWQgaW4gdGhlIGB1c2VWYWx1ZWAgdmFsdWUgKGVpdGhlciBkaXJlY3RseVxuICAgICAqIG9yIGluIGEgbmVzdGVkIGFycmF5IG9yIG1hcCkgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGVudHJ5Q29tcG9uZW50c2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdGhlIHJvdXRlciBjYW4gcG9wdWxhdGUgdGhlIGBlbnRyeUNvbXBvbmVudHNgXG4gICAgICogZmllbGQgb2YgYW4gTmdNb2R1bGUgYmFzZWQgb24gdGhlIHJvdXRlciBjb25maWd1cmF0aW9uIHdoaWNoIHJlZmVyc1xuICAgICAqIHRvIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gaGVscGVyIGZ1bmN0aW9uIGluc2lkZSB0aGUgcm91dGVyXG4gICAgICogZnVuY3Rpb24gcHJvdmlkZVJvdXRlcyhyb3V0ZXMpIHtcbiAgICAgKiAgIHJldHVybiBbXG4gICAgICogICAgIHtwcm92aWRlOiBST1VURVMsIHVzZVZhbHVlOiByb3V0ZXN9LFxuICAgICAqICAgICB7cHJvdmlkZTogQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUywgdXNlVmFsdWU6IHJvdXRlcywgbXVsdGk6IHRydWV9XG4gICAgICogICBdO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzZXIgY29kZVxuICAgICAqIGxldCByb3V0ZXMgPSBbXG4gICAgICogICB7cGF0aDogJy9yb290JywgY29tcG9uZW50OiBSb290Q29tcH0sXG4gICAgICogICB7cGF0aDogJy90ZWFtcycsIGNvbXBvbmVudDogVGVhbXNDb21wfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgcHJvdmlkZXJzOiBbcHJvdmlkZVJvdXRlcyhyb3V0ZXMpXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTW9kdWxlV2l0aFJvdXRlcyB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0gbmV3IE9wYXF1ZVRva2VuKCdBbmFseXplRm9yRW50cnlDb21wb25lbnRzJyk7XG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgQXR0cmlidXRlID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdBdHRyaWJ1dGUnLCBbWydhdHRyaWJ1dGVOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIHF1ZXJ5IG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBDb250ZW50Q2hpbGRyZW59LCB7QGxpbmsgQ29udGVudENoaWxkfSwge0BsaW5rIFZpZXdDaGlsZHJlbn0sIHtAbGluayBWaWV3Q2hpbGR9IGZvclxuICAgICAqIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFF1ZXJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUXVlcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQ29udGVudENoaWxkcmVuIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqICBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBDb250ZW50Q2hpbGRyZW4gPSBtYWtlUHJvcERlY29yYXRvcignQ29udGVudENoaWxkcmVuJywgW1xuICAgICAgICBbJ3NlbGVjdG9yJywgdW5kZWZpbmVkXSwge1xuICAgICAgICAgICAgZmlyc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNWaWV3UXVlcnk6IGZhbHNlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IGZhbHNlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9jb250ZW50Q2hpbGQvY29udGVudF9jaGlsZF9ob3d0by50cyByZWdpb249J0hvd1RvJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgQ29udGVudENoaWxkIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvciB0aGUgZGlyZWN0aXZlIG1hdGNoaW5nIHRoZSBzZWxlY3RvciBmcm9tIHRoZVxuICAgICAqIGNvbnRlbnQgRE9NLiBJZiB0aGUgY29udGVudCBET00gY2hhbmdlcywgYW5kIGEgbmV3IGNoaWxkIG1hdGNoZXMgdGhlIHNlbGVjdG9yLFxuICAgICAqIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBDb250ZW50IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBuZ0FmdGVyQ29udGVudEluaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqICoqTWV0YWRhdGEgUHJvcGVydGllcyoqOlxuICAgICAqXG4gICAgICogKiAqKnNlbGVjdG9yKiogLSB0aGUgZGlyZWN0aXZlIHR5cGUgb3IgdGhlIG5hbWUgdXNlZCBmb3IgcXVlcnlpbmcuXG4gICAgICogKiAqKnJlYWQqKiAtIHJlYWQgYSBkaWZmZXJlbnQgdG9rZW4gZnJvbSB0aGUgcXVlcmllZCBlbGVtZW50LlxuICAgICAqXG4gICAgICogTGV0J3MgbG9vayBhdCBhbiBleGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvY29udGVudENoaWxkL2NvbnRlbnRfY2hpbGRfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9jb3JlYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIENvbnRlbnRDaGlsZCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdDb250ZW50Q2hpbGQnLCBbXG4gICAgICAgIFsnc2VsZWN0b3InLCB1bmRlZmluZWRdLCB7XG4gICAgICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiB0cnVlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENvbmZpZ3VyZXMgYSB2aWV3IHF1ZXJ5LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy92aWV3Q2hpbGRyZW4vdmlld19jaGlsZHJlbl9ob3d0by50cyByZWdpb249J0hvd1RvJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgVmlld0NoaWxkcmVuIHRvIGdldCB0aGUge0BsaW5rIFF1ZXJ5TGlzdH0gb2YgZWxlbWVudHMgb3IgZGlyZWN0aXZlcyBmcm9tIHRoZVxuICAgICAqIHZpZXcgRE9NLiBBbnkgdGltZSBhIGNoaWxkIGVsZW1lbnQgaXMgYWRkZWQsIHJlbW92ZWQsIG9yIG1vdmVkLCB0aGUgcXVlcnkgbGlzdCB3aWxsIGJlIHVwZGF0ZWQsXG4gICAgICogYW5kIHRoZSBjaGFuZ2VzIG9ic2VydmFibGUgb2YgdGhlIHF1ZXJ5IGxpc3Qgd2lsbCBlbWl0IGEgbmV3IHZhbHVlLlxuICAgICAqXG4gICAgICogVmlldyBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgbmdBZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAqKk1ldGFkYXRhIFByb3BlcnRpZXMqKjpcbiAgICAgKlxuICAgICAqICogKipzZWxlY3RvcioqIC0gdGhlIGRpcmVjdGl2ZSB0eXBlIG9yIHRoZSBuYW1lIHVzZWQgZm9yIHF1ZXJ5aW5nLlxuICAgICAqICogKipyZWFkKiogLSByZWFkIGEgZGlmZmVyZW50IHRva2VuIGZyb20gdGhlIHF1ZXJpZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBMZXQncyBsb29rIGF0IGFuIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy92aWV3Q2hpbGRyZW4vdmlld19jaGlsZHJlbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2NvcmVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgVmlld0NoaWxkcmVuID0gbWFrZVByb3BEZWNvcmF0b3IoJ1ZpZXdDaGlsZHJlbicsIFtcbiAgICAgICAgWydzZWxlY3RvcicsIHVuZGVmaW5lZF0sIHtcbiAgICAgICAgICAgIGZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiB0cnVlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHRydWUsXG4gICAgICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICBdLCBRdWVyeSk7XG4gICAgLyoqXG4gICAgICogVmlld0NoaWxkIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgVmlld0NoaWxkID0gbWFrZVByb3BEZWNvcmF0b3IoJ1ZpZXdDaGlsZCcsIFtcbiAgICAgICAgWydzZWxlY3RvcicsIHVuZGVmaW5lZF0sIHtcbiAgICAgICAgICAgIGZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgaXNWaWV3UXVlcnk6IHRydWUsXG4gICAgICAgICAgICBkZXNjZW5kYW50czogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIF0sIFF1ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB3aXRoaW4gdGhlIGNoYW5nZSBkZXRlY3RvciB3aGljaCBzdHJhdGVneSB3aWxsIGJlIHVzZWQgdGhlIG5leHQgdGltZSBjaGFuZ2VcbiAgICAgKiBkZXRlY3Rpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuICAgIChmdW5jdGlvbiAoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBPblB1c2hgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvcidzIG1vZGUgd2lsbCBiZSBzZXQgdG8gYENoZWNrT25jZWAgZHVyaW5nIGh5ZHJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoXCJdID0gMF0gPSBcIk9uUHVzaFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYERlZmF1bHRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvcidzIG1vZGUgd2lsbCBiZSBzZXQgdG8gYENoZWNrQWx3YXlzYCBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJEZWZhdWx0XCJdID0gMV0gPSBcIkRlZmF1bHRcIjtcbiAgICB9KShleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgdGhlIHN0YXR1cyBvZiB0aGUgZGV0ZWN0b3IuXG4gICAgICovXG4gICAgdmFyIENoYW5nZURldGVjdG9yU3RhdHVzO1xuICAgIChmdW5jdGlvbiAoQ2hhbmdlRGV0ZWN0b3JTdGF0dXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBDaGVja09uY2VgIG1lYW5zIHRoYXQgYWZ0ZXIgY2FsbGluZyBkZXRlY3RDaGFuZ2VzIHRoZSBtb2RlIG9mIHRoZSBjaGFuZ2UgZGV0ZWN0b3JcbiAgICAgICAgICogd2lsbCBiZWNvbWUgYENoZWNrZWRgLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJDaGVja09uY2VcIl0gPSAwXSA9IFwiQ2hlY2tPbmNlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQ2hlY2tlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIHNob3VsZCBiZSBza2lwcGVkIHVudGlsIGl0cyBtb2RlIGNoYW5nZXMgdG9cbiAgICAgICAgICogYENoZWNrT25jZWAuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkNoZWNrZWRcIl0gPSAxXSA9IFwiQ2hlY2tlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYENoZWNrQWx3YXlzYCBtZWFucyB0aGF0IGFmdGVyIGNhbGxpbmcgZGV0ZWN0Q2hhbmdlcyB0aGUgbW9kZSBvZiB0aGUgY2hhbmdlIGRldGVjdG9yXG4gICAgICAgICAqIHdpbGwgcmVtYWluIGBDaGVja0Fsd2F5c2AuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkNoZWNrQWx3YXlzXCJdID0gMl0gPSBcIkNoZWNrQWx3YXlzXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgRGV0YWNoZWRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBzdWIgdHJlZSBpcyBub3QgYSBwYXJ0IG9mIHRoZSBtYWluIHRyZWUgYW5kXG4gICAgICAgICAqIHNob3VsZCBiZSBza2lwcGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJEZXRhY2hlZFwiXSA9IDNdID0gXCJEZXRhY2hlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYEVycm9yZWRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBlbmNvdW50ZXJlZCBhbiBlcnJvciBjaGVja2luZyBhIGJpbmRpbmdcbiAgICAgICAgICogb3IgY2FsbGluZyBhIGRpcmVjdGl2ZSBsaWZlY3ljbGUgbWV0aG9kIGFuZCBpcyBub3cgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBDaGFuZ2VcbiAgICAgICAgICogZGV0ZWN0b3JzIGluIHRoaXMgc3RhdGUgd2lsbCBubyBsb25nZXIgZGV0ZWN0IGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkVycm9yZWRcIl0gPSA0XSA9IFwiRXJyb3JlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYERlc3Ryb3llZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzW1wiRGVzdHJveWVkXCJdID0gNV0gPSBcIkRlc3Ryb3llZFwiO1xuICAgIH0pKENoYW5nZURldGVjdG9yU3RhdHVzIHx8IChDaGFuZ2VEZXRlY3RvclN0YXR1cyA9IHt9KSk7XG4gICAgZnVuY3Rpb24gaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgcmV0dXJuIGlzQmxhbmsoY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHx8XG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9PT0gZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIERpcmVjdGl2ZSA9IG1ha2VEZWNvcmF0b3IoJ0RpcmVjdGl2ZScsIHtcbiAgICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRzOiB1bmRlZmluZWQsXG4gICAgICAgIG91dHB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgaG9zdDogdW5kZWZpbmVkLFxuICAgICAgICBwcm92aWRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZXhwb3J0QXM6IHVuZGVmaW5lZCxcbiAgICAgICAgcXVlcmllczogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50ID0gbWFrZURlY29yYXRvcignQ29tcG9uZW50Jywge1xuICAgICAgICBzZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgb3V0cHV0czogdW5kZWZpbmVkLFxuICAgICAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgICAgIGV4cG9ydEFzOiB1bmRlZmluZWQsXG4gICAgICAgIG1vZHVsZUlkOiB1bmRlZmluZWQsXG4gICAgICAgIHByb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICB2aWV3UHJvdmlkZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICBxdWVyaWVzOiB1bmRlZmluZWQsXG4gICAgICAgIHRlbXBsYXRlVXJsOiB1bmRlZmluZWQsXG4gICAgICAgIHRlbXBsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHN0eWxlVXJsczogdW5kZWZpbmVkLFxuICAgICAgICBzdHlsZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgYW5pbWF0aW9uczogdW5kZWZpbmVkLFxuICAgICAgICBlbmNhcHN1bGF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGludGVycG9sYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiB1bmRlZmluZWRcbiAgICB9LCBEaXJlY3RpdmUpO1xuICAgIC8qKlxuICAgICAqIFBpcGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBQaXBlID0gbWFrZURlY29yYXRvcignUGlwZScsIHtcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBwdXJlOiB0cnVlLFxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIElucHV0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSW5wdXQgPSBtYWtlUHJvcERlY29yYXRvcignSW5wdXQnLCBbWydiaW5kaW5nUHJvcGVydHlOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIE91dHB1dCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIE91dHB1dCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdPdXRwdXQnLCBbWydiaW5kaW5nUHJvcGVydHlOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIEhvc3RCaW5kaW5nIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSG9zdEJpbmRpbmcgPSBtYWtlUHJvcERlY29yYXRvcignSG9zdEJpbmRpbmcnLCBbWydob3N0UHJvcGVydHlOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIEhvc3RCaW5kaW5nIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSG9zdExpc3RlbmVyID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RMaXN0ZW5lcicsIFtbJ2V2ZW50TmFtZScsIHVuZGVmaW5lZF0sIFsnYXJncycsIFtdXV0pO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTGlmZWN5Y2xlSG9va3M7XG4gICAgKGZ1bmN0aW9uIChMaWZlY3ljbGVIb29rcykge1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uSW5pdFwiXSA9IDBdID0gXCJPbkluaXRcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJPbkRlc3Ryb3lcIl0gPSAxXSA9IFwiT25EZXN0cm95XCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiRG9DaGVja1wiXSA9IDJdID0gXCJEb0NoZWNrXCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25DaGFuZ2VzXCJdID0gM10gPSBcIk9uQ2hhbmdlc1wiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyQ29udGVudEluaXRcIl0gPSA0XSA9IFwiQWZ0ZXJDb250ZW50SW5pdFwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyQ29udGVudENoZWNrZWRcIl0gPSA1XSA9IFwiQWZ0ZXJDb250ZW50Q2hlY2tlZFwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0luaXRcIl0gPSA2XSA9IFwiQWZ0ZXJWaWV3SW5pdFwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0NoZWNrZWRcIl0gPSA3XSA9IFwiQWZ0ZXJWaWV3Q2hlY2tlZFwiO1xuICAgIH0pKExpZmVjeWNsZUhvb2tzIHx8IChMaWZlY3ljbGVIb29rcyA9IHt9KSk7XG4gICAgdmFyIExJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBbXG4gICAgICAgIExpZmVjeWNsZUhvb2tzLk9uSW5pdCwgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95LCBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrLCBMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMsXG4gICAgICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQsIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQsIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQsXG4gICAgICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWRcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gYW55IGRhdGEtYm91bmQgcHJvcGVydHkgb2YgYSBkaXJlY3RpdmUgY2hhbmdlcy5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J09uQ2hhbmdlcyd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdPbkNoYW5nZXNgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGUgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBjaGVja2VkIGFuZCBiZWZvcmUgdmlld1xuICAgICAqIGFuZCBjb250ZW50IGNoaWxkcmVuIGFyZSBjaGVja2VkIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGhhcyBjaGFuZ2VkLlxuICAgICAqIFRoZSBgY2hhbmdlc2AgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3Mjb25jaGFuZ2VzIFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBPbkNoYW5nZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPbkNoYW5nZXMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9uQ2hhbmdlcztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiBhIGRpcmVjdGl2ZSBhcmVcbiAgICAgKiBpbml0aWFsaXplZC5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J09uSW5pdCd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdPbkluaXRgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGUgZGlyZWN0aXZlJ3MgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBjaGVja2VkIGZvciB0aGVcbiAgICAgKiBmaXJzdCB0aW1lLCBhbmQgYmVmb3JlIGFueSBvZiBpdHMgY2hpbGRyZW4gaGF2ZSBiZWVuIGNoZWNrZWQuIEl0IGlzIGludm9rZWQgb25seSBvbmNlIHdoZW4gdGhlXG4gICAgICogZGlyZWN0aXZlIGlzIGluc3RhbnRpYXRlZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgT25Jbml0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT25Jbml0KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPbkluaXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCB3aGVuIEFuZ3VsYXIgZGlydHkgY2hlY2tzIGEgZGlyZWN0aXZlLlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nRG9DaGVjayd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdEb0NoZWNrYCBnZXRzIGNhbGxlZCB0byBjaGVjayB0aGUgY2hhbmdlcyBpbiB0aGUgZGlyZWN0aXZlcyBpbiBhZGRpdGlvbiB0byB0aGUgZGVmYXVsdFxuICAgICAqIGFsZ29yaXRobS4gVGhlIGRlZmF1bHQgY2hhbmdlIGRldGVjdGlvbiBhbGdvcml0aG0gbG9va3MgZm9yIGRpZmZlcmVuY2VzIGJ5IGNvbXBhcmluZ1xuICAgICAqIGJvdW5kLXByb3BlcnR5IHZhbHVlcyBieSByZWZlcmVuY2UgYWNyb3NzIGNoYW5nZSBkZXRlY3Rpb24gcnVucy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhIGRpcmVjdGl2ZSB0eXBpY2FsbHkgc2hvdWxkIG5vdCB1c2UgYm90aCBgRG9DaGVja2AgYW5kIHtAbGluayBPbkNoYW5nZXN9IHRvIHJlc3BvbmQgdG9cbiAgICAgKiBjaGFuZ2VzIG9uIHRoZSBzYW1lIGlucHV0LCBhcyBgbmdPbkNoYW5nZXNgIHdpbGwgY29udGludWUgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGRlZmF1bHQgY2hhbmdlXG4gICAgICogZGV0ZWN0b3IgZGV0ZWN0cyBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBLZXlWYWx1ZURpZmZlcnN9IGFuZCB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBmb3IgaW1wbGVtZW50aW5nIGN1c3RvbSBkaXJ0eSBjaGVja2luZ1xuICAgICAqIGZvciBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNkb2NoZWNrIFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEb0NoZWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9DaGVjaygpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRG9DaGVjaztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBkaXJlY3RpdmUgb3IgcGlwZSBpcyBkZXN0cm95ZWQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdPbkRlc3Ryb3knfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogYG5nT25EZXN0cm95YCBjYWxsYmFjayBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgYW55IGN1c3RvbSBjbGVhbnVwIHRoYXQgbmVlZHMgdG8gb2NjdXIgd2hlbiB0aGVcbiAgICAgKiBpbnN0YW5jZSBpcyBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE9uRGVzdHJveSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9uRGVzdHJveSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT25EZXN0cm95O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBhIGRpcmVjdGl2ZSdzIGNvbnRlbnQgaGFzIGJlZW4gZnVsbHlcbiAgICAgKiBpbml0aWFsaXplZC5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J0FmdGVyQ29udGVudEluaXQnfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2FmdGVyY29udGVudCBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWZ0ZXJDb250ZW50SW5pdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFmdGVyQ29udGVudEluaXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBldmVyeSBjaGVjayBvZiBhIGRpcmVjdGl2ZSdzIGNvbnRlbnQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlckNvbnRlbnRDaGVja2VkJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNhZnRlcmNvbnRlbnQgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFmdGVyQ29udGVudENoZWNrZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZnRlckNvbnRlbnRDaGVja2VkO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQncyB2aWV3IGhhcyBiZWVuIGZ1bGx5XG4gICAgICogaW5pdGlhbGl6ZWQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlclZpZXdJbml0J31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNhZnRlcnZpZXcgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFmdGVyVmlld0luaXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZnRlclZpZXdJbml0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgZXZlcnkgY2hlY2sgb2YgYSBjb21wb25lbnQncyB2aWV3LlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nQWZ0ZXJWaWV3Q2hlY2tlZCd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjYWZ0ZXJ2aWV3IFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBZnRlclZpZXdDaGVja2VkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWZ0ZXJWaWV3Q2hlY2tlZDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIHNjaGVtYSB0aGF0IHdpbGwgYWxsb3c6XG4gICAgICogLSBhbnkgbm9uLUFuZ3VsYXIgZWxlbWVudHMgd2l0aCBhIGAtYCBpbiB0aGVpciBuYW1lLFxuICAgICAqIC0gYW55IHByb3BlcnRpZXMgb24gZWxlbWVudHMgd2l0aCBhIGAtYCBpbiB0aGVpciBuYW1lIHdoaWNoIGlzIHRoZSBjb21tb24gcnVsZSBmb3IgY3VzdG9tXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgPSB7XG4gICAgICAgIG5hbWU6ICdjdXN0b20tZWxlbWVudHMnXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgc2NoZW1hIHRoYXQgd2lsbCBhbGxvdyBhbnkgcHJvcGVydHkgb24gYW55IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5PX0VSUk9SU19TQ0hFTUEgPSB7XG4gICAgICAgIG5hbWU6ICduby1lcnJvcnMtc2NoZW1hJ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTmdNb2R1bGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBOZ01vZHVsZSA9IG1ha2VEZWNvcmF0b3IoJ05nTW9kdWxlJywge1xuICAgICAgICBwcm92aWRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVjbGFyYXRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgIGltcG9ydHM6IHVuZGVmaW5lZCxcbiAgICAgICAgZXhwb3J0czogdW5kZWZpbmVkLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IHVuZGVmaW5lZCxcbiAgICAgICAgYm9vdHN0cmFwOiB1bmRlZmluZWQsXG4gICAgICAgIHNjaGVtYXM6IHVuZGVmaW5lZCxcbiAgICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRlbXBsYXRlIGFuZCBzdHlsZSBlbmNhcHN1bGF0aW9uIG9wdGlvbnMgYXZhaWxhYmxlIGZvciBDb21wb25lbnQncyB7QGxpbmsgQ29tcG9uZW50fS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgVmlld01ldGFkYXRhI2VuY2Fwc3VsYXRpb259LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uO1xuICAgIChmdW5jdGlvbiAoVmlld0VuY2Fwc3VsYXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtdWxhdGUgYE5hdGl2ZWAgc2NvcGluZyBvZiBzdHlsZXMgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBjb250YWluaW5nIHN1cnJvZ2F0ZSBpZCB0byB0aGUgSG9zdFxuICAgICAgICAgKiBFbGVtZW50IGFuZCBwcmUtcHJvY2Vzc2luZyB0aGUgc3R5bGUgcnVsZXMgcHJvdmlkZWQgdmlhXG4gICAgICAgICAqIHtAbGluayBWaWV3TWV0YWRhdGEjc3R5bGVzfSBvciB7QGxpbmsgVmlld01ldGFkYXRhI3N0eWxlc1VybHN9LCBhbmQgYWRkaW5nIHRoZSBuZXcgSG9zdCBFbGVtZW50XG4gICAgICAgICAqIGF0dHJpYnV0ZSB0byBhbGwgc2VsZWN0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IG9wdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiRW11bGF0ZWRcIl0gPSAwXSA9IFwiRW11bGF0ZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGUgbmF0aXZlIGVuY2Fwc3VsYXRpb24gbWVjaGFuaXNtIG9mIHRoZSByZW5kZXJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBET00gdGhpcyBtZWFucyB1c2luZyBbU2hhZG93IERPTV0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9zaGFkb3cvKSBhbmRcbiAgICAgICAgICogY3JlYXRpbmcgYSBTaGFkb3dSb290IGZvciBDb21wb25lbnQncyBIb3N0IEVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5hdGl2ZVwiXSA9IDFdID0gXCJOYXRpdmVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvbid0IHByb3ZpZGUgYW55IHRlbXBsYXRlIG9yIHN0eWxlIGVuY2Fwc3VsYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5vbmVcIl0gPSAyXSA9IFwiTm9uZVwiO1xuICAgIH0pKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gfHwgKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHByb3BlcnRpZXMgYXZhaWxhYmxlIGZvciBjb25maWd1cmluZyBWaWV3cy5cbiAgICAgKlxuICAgICAqIEZvciBkZXRhaWxzIG9uIHRoZSBgQENvbXBvbmVudGAgYW5ub3RhdGlvbiwgc2VlIHtAbGluayBDb21wb25lbnR9LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICdncmVldCcsXG4gICAgICogICB0ZW1wbGF0ZTogJ0hlbGxvIHt7bmFtZX19IScsXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBHcmVldCB7XG4gICAgICogICBuYW1lOiBzdHJpbmc7XG4gICAgICpcbiAgICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSAnV29ybGQnO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBDb21wb25lbnQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIHtAbGluayBDb21wb25lbnR9XG4gICAgICovXG4gICAgdmFyIFZpZXdNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdNZXRhZGF0YShfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHRlbXBsYXRlVXJsID0gX2IudGVtcGxhdGVVcmwsIHRlbXBsYXRlID0gX2IudGVtcGxhdGUsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgYW5pbWF0aW9ucyA9IF9iLmFuaW1hdGlvbnMsIGludGVycG9sYXRpb24gPSBfYi5pbnRlcnBvbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlld01ldGFkYXRhO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gcmVmZXIgdG8gcmVmZXJlbmNlcyB3aGljaCBhcmUgbm90IHlldCBkZWZpbmVkLlxuICAgICAqXG4gICAgICogRm9yIGluc3RhbmNlLCBgZm9yd2FyZFJlZmAgaXMgdXNlZCB3aGVuIHRoZSBgdG9rZW5gIHdoaWNoIHdlIG5lZWQgdG8gcmVmZXIgdG8gZm9yIHRoZSBwdXJwb3NlcyBvZlxuICAgICAqIERJIGlzIGRlY2xhcmVkLFxuICAgICAqIGJ1dCBub3QgeWV0IGRlZmluZWQuIEl0IGlzIGFsc28gdXNlZCB3aGVuIHRoZSBgdG9rZW5gIHdoaWNoIHdlIHVzZSB3aGVuIGNyZWF0aW5nIGEgcXVlcnkgaXMgbm90XG4gICAgICogeWV0IGRlZmluZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL2ZvcndhcmRfcmVmL2ZvcndhcmRfcmVmX3NwZWMudHMgcmVnaW9uPSdmb3J3YXJkX3JlZid9XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvcndhcmRSZWYoZm9yd2FyZFJlZkZuKSB7XG4gICAgICAgIGZvcndhcmRSZWZGbi5fX2ZvcndhcmRfcmVmX18gPSBmb3J3YXJkUmVmO1xuICAgICAgICBmb3J3YXJkUmVmRm4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnkodGhpcygpKTsgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmRSZWZGbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6aWx5IHJldHJpZXZlcyB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYSBmb3J3YXJkUmVmLlxuICAgICAqXG4gICAgICogQWN0cyBhcyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gd2hlbiBnaXZlbiBhIG5vbi1mb3J3YXJkLXJlZiB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HVTcybUpyazFmaW9kQ2hjbWlEUj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvZm9yd2FyZF9yZWYvZm9yd2FyZF9yZWZfc3BlYy50cyByZWdpb249J3Jlc29sdmVfZm9yd2FyZF9yZWYnfVxuICAgICAqXG4gICAgICogU2VlOiB7QGxpbmsgZm9yd2FyZFJlZn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSkge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX19mb3J3YXJkX3JlZl9fJykgJiZcbiAgICAgICAgICAgIHR5cGUuX19mb3J3YXJkX3JlZl9fID09PSBmb3J3YXJkUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEJhc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCYXNlRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJhc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBFcnJvcnMgZG9uJ3QgdXNlIGN1cnJlbnQgdGhpcywgaW5zdGVhZCB0aGV5IGNyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gZm9yd2FyZCBhbGwgb2Ygb3VyIGFwaSB0byB0aGUgbmF0aXZlSW5zdGFuY2UuXG4gICAgICAgICAgICB2YXIgbmF0aXZlRXJyb3IgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm5hbWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLnN0YWNrOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fbmF0aXZlRXJyb3Iuc3RhY2sgPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYXRpdmVFcnJvci50b1N0cmluZygpOyB9O1xuICAgICAgICByZXR1cm4gQmFzZUVycm9yO1xuICAgIH0oRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFdyYXBwZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhXcmFwcGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFdyYXBwZWRFcnJvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSArIFwiIGNhdXNlZCBieTogXCIgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFcnJvci5wcm90b3R5cGUsIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm9yaWdpbmFsRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRoaXMub3JpZ2luYWxFcnJvciA6IHRoaXMuX25hdGl2ZUVycm9yKVxuICAgICAgICAgICAgICAgICAgICAuc3RhY2s7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFdyYXBwZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuXG4gICAgdmFyIF9USFJPV19JRl9OT1RfRk9VTkQgPSBuZXcgT2JqZWN0KCk7XG4gICAgdmFyIFRIUk9XX0lGX05PVF9GT1VORCA9IF9USFJPV19JRl9OT1RfRk9VTkQ7XG4gICAgdmFyIF9OdWxsSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTnVsbEluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIF9OdWxsSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gX1RIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IF9USFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnkodG9rZW4pICsgXCIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfTnVsbEluamVjdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgSW5qZWN0b3IgaW50ZXJmYWNlXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogY29uc3QgaW5qZWN0b3I6IEluamVjdG9yID0gLi4uO1xuICAgICAqIGluamVjdG9yLmdldCguLi4pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSB7QGxpbmtEb2NzIGd1aWRlL2RlcGVuZGVuY3ktaW5qZWN0aW9uIFwiRGVwZW5kZW5jeSBJbmplY3Rpb24gR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J0luamVjdG9yJ31cbiAgICAgKlxuICAgICAqIGBJbmplY3RvcmAgcmV0dXJucyBpdHNlbGYgd2hlbiBnaXZlbiBgSW5qZWN0b3JgIGFzIGEgdG9rZW46XG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J2luamVjdEluamVjdG9yJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmplY3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gdGhlIGluamVjdG9yIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0b2tlbi5cbiAgICAgICAgICogSWYgbm90IGZvdW5kOlxuICAgICAgICAgKiAtIFRocm93cyB7QGxpbmsgTm9Qcm92aWRlckVycm9yfSBpZiBubyBgbm90Rm91bmRWYWx1ZWAgdGhhdCBpcyBub3QgZXF1YWwgdG9cbiAgICAgICAgICogSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EIGlzIGdpdmVuXG4gICAgICAgICAqIC0gUmV0dXJucyB0aGUgYG5vdEZvdW5kVmFsdWVgIG90aGVyd2lzZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkQgPSBfVEhST1dfSUZfTk9UX0ZPVU5EO1xuICAgICAgICBJbmplY3Rvci5OVUxMID0gbmV3IF9OdWxsSW5qZWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIEluamVjdG9yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZmluZEZpcnN0Q2xvc2VkQ3ljbGUoa2V5cykge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHJlcy5pbmRleE9mKGtleXNbaV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciByZXZlcnNlZCA9IGZpbmRGaXJzdENsb3NlZEN5Y2xlKGtleXMuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgdmFyIHRva2VuU3RycyA9IHJldmVyc2VkLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gc3RyaW5naWZ5KGsudG9rZW4pOyB9KTtcbiAgICAgICAgICAgIHJldHVybiAnICgnICsgdG9rZW5TdHJzLmpvaW4oJyAtPiAnKSArICcpJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGFsbCBlcnJvcnMgYXJpc2luZyBmcm9tIG1pc2NvbmZpZ3VyZWQgcHJvdmlkZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQWJzdHJhY3RQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdFByb3ZpZGVyRXJyb3IoaW5qZWN0b3IsIGtleSwgY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0RJIEVycm9yJyk7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzID0gW2luamVjdG9yXTtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSA9IGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBBYnN0cmFjdFByb3ZpZGVyRXJyb3IucHJvdG90eXBlLmFkZEtleSA9IGZ1bmN0aW9uIChpbmplY3Rvciwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0UHJvdmlkZXJFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIHRyeWluZyB0byByZXRyaWV2ZSBhIGRlcGVuZGVuY3kgYnkga2V5IGZyb20ge0BsaW5rIEluamVjdG9yfSwgYnV0IHRoZVxuICAgICAqIHtAbGluayBJbmplY3Rvcn0gZG9lcyBub3QgaGF2ZSBhIHtAbGluayBQcm92aWRlcn0gZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvdnE4RDNGUkI5YUdibldKcXRFUEU/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGI6Qikge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5vUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE5vUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTm9Qcm92aWRlckVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluamVjdG9yLCBrZXksIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gc3RyaW5naWZ5KGtleXNbMF0udG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIHByb3ZpZGVyIGZvciBcIiArIGZpcnN0ICsgXCIhXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vUHJvdmlkZXJFcnJvcjtcbiAgICB9KEFic3RyYWN0UHJvdmlkZXJFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGRlcGVuZGVuY2llcyBmb3JtIGEgY3ljbGUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvd1lRZE5vczBUenFsM2VpMUVWOWo/cD1pbmZvKSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHtwcm92aWRlOiBcIm9uZVwiLCB1c2VGYWN0b3J5OiAodHdvKSA9PiBcInR3b1wiLCBkZXBzOiBbW25ldyBJbmplY3QoXCJ0d29cIildXX0sXG4gICAgICogICB7cHJvdmlkZTogXCJ0d29cIiwgdXNlRmFjdG9yeTogKG9uZSkgPT4gXCJvbmVcIiwgZGVwczogW1tuZXcgSW5qZWN0KFwib25lXCIpXV19XG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0KFwib25lXCIpKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJldHJpZXZpbmcgYEFgIG9yIGBCYCB0aHJvd3MgYSBgQ3ljbGljRGVwZW5kZW5jeUVycm9yYCBhcyB0aGUgZ3JhcGggYWJvdmUgY2Fubm90IGJlIGNvbnN0cnVjdGVkLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ3ljbGljRGVwZW5kZW5jeUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQ3ljbGljRGVwZW5kZW5jeUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDeWNsaWNEZXBlbmRlbmN5RXJyb3IoaW5qZWN0b3IsIGtleSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEN5Y2xpY0RlcGVuZGVuY3lFcnJvcjtcbiAgICB9KEFic3RyYWN0UHJvdmlkZXJFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGEgY29uc3RydWN0aW5nIHR5cGUgcmV0dXJucyB3aXRoIGFuIEVycm9yLlxuICAgICAqXG4gICAgICogVGhlIGBJbnN0YW50aWF0aW9uRXJyb3JgIGNsYXNzIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBlcnJvciBwbHVzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHdoaWNoIGNhdXNlZFxuICAgICAqIHRoaXMgb2JqZWN0IHRvIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC83YVdZZGNxVFFzUDBlTnFFZFVBZj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEEge1xuICAgICAqICAgY29uc3RydWN0b3IoKSB7XG4gICAgICogICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZScpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcblxuICAgICAqIHRyeSB7XG4gICAgICogICBpbmplY3Rvci5nZXQoQSk7XG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgZXhwZWN0KGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0aW9uRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICogICBleHBlY3QoZS5vcmlnaW5hbEV4Y2VwdGlvbi5tZXNzYWdlKS50b0VxdWFsKFwibWVzc2FnZVwiKTtcbiAgICAgKiAgIGV4cGVjdChlLm9yaWdpbmFsU3RhY2spLnRvQmVEZWZpbmVkKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW5zdGFudGlhdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoSW5zdGFudGlhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbnN0YW50aWF0aW9uRXJyb3IoaW5qZWN0b3IsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdESSBFcnJvcicsIG9yaWdpbmFsRXhjZXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtrZXldO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvcnMgPSBbaW5qZWN0b3JdO1xuICAgICAgICB9XG4gICAgICAgIEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUuYWRkS2V5ID0gZnVuY3Rpb24gKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBzdHJpbmdpZnkodGhpcy5rZXlzWzBdLnRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEVycm9yLm1lc3NhZ2UgKyBcIjogRXJyb3IgZHVyaW5nIGluc3RhbnRpYXRpb24gb2YgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aCh0aGlzLmtleXMpICsgXCIuXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwiY2F1c2VLZXlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXNbMF07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSW5zdGFudGlhdGlvbkVycm9yO1xuICAgIH0oV3JhcHBlZEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYW4gb2JqZWN0IG90aGVyIHRoZW4ge0BsaW5rIFByb3ZpZGVyfSAob3IgYFR5cGVgKSBpcyBwYXNzZWQgdG8ge0BsaW5rIEluamVjdG9yfVxuICAgICAqIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1lhdENGYlBBTUNMMEpTU1E0bXZIP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1wibm90IGEgdHlwZVwiXSkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW52YWxpZFByb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShJbnZhbGlkUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW52YWxpZFByb3ZpZGVyRXJyb3IocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW52YWxpZCBwcm92aWRlciAtIG9ubHkgaW5zdGFuY2VzIG9mIFByb3ZpZGVyIGFuZCBUeXBlIGFyZSBhbGxvd2VkLCBnb3Q6IFwiICsgcHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnZhbGlkUHJvdmlkZXJFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIHRoZSBjbGFzcyBoYXMgbm8gYW5ub3RhdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIExhY2sgb2YgYW5ub3RhdGlvbiBpbmZvcm1hdGlvbiBwcmV2ZW50cyB0aGUge0BsaW5rIEluamVjdG9yfSBmcm9tIGRldGVybWluaW5nIHdoaWNoIGRlcGVuZGVuY2llc1xuICAgICAqIG5lZWQgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvckhuWnRsTlM3dkpPUFE2cGNWa20/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGIpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGVycm9yIGlzIGFsc28gdGhyb3duIHdoZW4gdGhlIGNsYXNzIG5vdCBtYXJrZWQgd2l0aCB7QGxpbmsgSW5qZWN0YWJsZX0gaGFzIHBhcmFtZXRlciB0eXBlcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBCIHt9XG4gICAgICpcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGI6Qikge30gLy8gbm8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhcmFtZXRlciB0eXBlcyBvZiBBIGlzIGF2YWlsYWJsZSBhdCBydW50aW1lLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBLEJdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOb0Fubm90YXRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE5vQW5ub3RhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIE5vQW5ub3RhdGlvbkVycm9yLl9nZW5NZXNzYWdlKHR5cGVPckZ1bmMsIHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICAgIE5vQW5ub3RhdGlvbkVycm9yLl9nZW5NZXNzYWdlID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFyYW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1ldGVyIHx8IHBhcmFtZXRlci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUucHVzaCgnPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLnB1c2gocGFyYW1ldGVyLm1hcChzdHJpbmdpZnkpLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdDYW5ub3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgXFwnJyArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArICdcXCcoJyArXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLmpvaW4oJywgJykgKyAnKS4gJyArXG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgcGFyYW1ldGVycyBhcmUgZGVjb3JhdGVkIHdpdGggSW5qZWN0IG9yIGhhdmUgdmFsaWQgdHlwZSBhbm5vdGF0aW9ucyBhbmQgdGhhdCBcXCcnICtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodHlwZU9yRnVuYykgKyAnXFwnIGlzIGRlY29yYXRlZCB3aXRoIEluamVjdGFibGUuJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5vQW5ub3RhdGlvbkVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gZ2V0dGluZyBhbiBvYmplY3QgYnkgaW5kZXguXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvYlJzMFNYMk9UUWlKenF2amdsOFA/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHt9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0QXQoMTAwKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBPdXRPZkJvdW5kc0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoT3V0T2ZCb3VuZHNFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gT3V0T2ZCb3VuZHNFcnJvcihpbmRleCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbmRleCBcIiArIGluZGV4ICsgXCIgaXMgb3V0LW9mLWJvdW5kcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE91dE9mQm91bmRzRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvLyBUT0RPOiBhZGQgYSB3b3JraW5nIGV4YW1wbGUgYWZ0ZXIgYWxwaGEzOCBpcyByZWxlYXNlZFxuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGEgbXVsdGkgcHJvdmlkZXIgYW5kIGEgcmVndWxhciBwcm92aWRlciBhcmUgYm91bmQgdG8gdGhlIHNhbWUgdG9rZW4uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHsgcHJvdmlkZTogXCJTdHJpbmdzXCIsIHVzZVZhbHVlOiBcInN0cmluZzFcIiwgbXVsdGk6IHRydWV9LFxuICAgICAqICAgeyBwcm92aWRlOiBcIlN0cmluZ3NcIiwgdXNlVmFsdWU6IFwic3RyaW5nMlwiLCBtdWx0aTogZmFsc2V9XG4gICAgICogXSkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihwcm92aWRlcjEsIHByb3ZpZGVyMikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0Nhbm5vdCBtaXggbXVsdGkgcHJvdmlkZXJzIGFuZCByZWd1bGFyIHByb3ZpZGVycywgZ290OiAnICsgcHJvdmlkZXIxLnRvU3RyaW5nKCkgKyAnICcgK1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyMi50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBvYmplY3QgdXNlZCBmb3IgcmV0cmlldmluZyBpdGVtcyBmcm9tIHRoZSB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfS5cbiAgICAgKlxuICAgICAqIEtleXMgaGF2ZTpcbiAgICAgKiAtIGEgc3lzdGVtLXdpZGUgdW5pcXVlIGBpZGAuXG4gICAgICogLSBhIGB0b2tlbmAuXG4gICAgICpcbiAgICAgKiBgS2V5YCBpcyB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIFJlZmxlY3RpdmVJbmplY3Rvcn0gYmVjYXVzZSBpdHMgc3lzdGVtLXdpZGUgdW5pcXVlIGBpZGAgYWxsb3dzXG4gICAgICogdGhlXG4gICAgICogaW5qZWN0b3IgdG8gc3RvcmUgY3JlYXRlZCBvYmplY3RzIGluIGEgbW9yZSBlZmZpY2llbnQgd2F5LlxuICAgICAqXG4gICAgICogYEtleWAgc2hvdWxkIG5vdCBiZSBjcmVhdGVkIGRpcmVjdGx5LiB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfSBjcmVhdGVzIGtleXMgYXV0b21hdGljYWxseSB3aGVuXG4gICAgICogcmVzb2x2aW5nXG4gICAgICogcHJvdmlkZXJzLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdGl2ZUtleSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlS2V5KHRva2VuLCBpZCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlS2V5LnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmdpZmllZCB0b2tlbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnkodGhpcy50b2tlbik7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgYEtleWAgZm9yIGEgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlS2V5LmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWxLZXlSZWdpc3RyeS5nZXQocmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVLZXksIFwibnVtYmVyT2ZLZXlzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybnMgdGhlIG51bWJlciBvZiBrZXlzIHJlZ2lzdGVyZWQgaW4gdGhlIHN5c3RlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfZ2xvYmFsS2V5UmVnaXN0cnkubnVtYmVyT2ZLZXlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVLZXk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB2YXIgS2V5UmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBLZXlSZWdpc3RyeSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsbEtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgS2V5UmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgUmVmbGVjdGl2ZUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxsS2V5cy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbEtleXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdLZXkgPSBuZXcgUmVmbGVjdGl2ZUtleSh0b2tlbiwgUmVmbGVjdGl2ZUtleS5udW1iZXJPZktleXMpO1xuICAgICAgICAgICAgdGhpcy5fYWxsS2V5cy5zZXQodG9rZW4sIG5ld0tleSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3S2V5O1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5UmVnaXN0cnkucHJvdG90eXBlLCBcIm51bWJlck9mS2V5c1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FsbEtleXMuc2l6ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBLZXlSZWdpc3RyeTtcbiAgICB9KCkpO1xuICAgIHZhciBfZ2xvYmFsS2V5UmVnaXN0cnkgPSBuZXcgS2V5UmVnaXN0cnkoKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBSZXByZXNlbnRzIGEgdHlwZSB0aGF0IGEgQ29tcG9uZW50IG9yIG90aGVyIG9iamVjdCBpcyBpbnN0YW5jZXMgb2YuXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEFuIGV4YW1wbGUgb2YgYSBgVHlwZWAgaXMgYE15Q3VzdG9tQ29tcG9uZW50YCBjbGFzcywgd2hpY2ggaW4gSmF2YVNjcmlwdCBpcyBiZSByZXByZXNlbnRlZCBieVxuICAgICAqIHRoZSBgTXlDdXN0b21Db21wb25lbnRgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBUeXBlID0gRnVuY3Rpb247XG5cbiAgICB2YXIgUmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMocmVmbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdCA9IHJlZmxlY3QgfHwgZ2xvYmFsJDEuUmVmbGVjdDtcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pc1JlZmxlY3Rpb25FbmFibGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyAodC5iaW5kLmFwcGx5KHQsIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICAgIH07IH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuX3ppcFR5cGVzQW5kQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAocGFyYW1UeXBlcywgcGFyYW1Bbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkocGFyYW1Bbm5vdGF0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHBhcmFtVHlwZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVFMgb3V0cHV0cyBPYmplY3QgZm9yIHBhcmFtZXRlcnMgd2l0aG91dCB0eXBlcywgd2hpbGUgVHJhY2V1ciBvbWl0c1xuICAgICAgICAgICAgICAgIC8vIHRoZSBhbm5vdGF0aW9ucy4gRm9yIG5vdyB3ZSBwcmVzZXJ2ZSB0aGUgVHJhY2V1ciBiZWhhdmlvciB0byBhaWRcbiAgICAgICAgICAgICAgICAvLyBtaWdyYXRpb24sIGJ1dCB0aGlzIGNhbiBiZSByZXZpc2l0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbVR5cGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1UeXBlc1tpXSAhPSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gW3BhcmFtVHlwZXNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbUFubm90YXRpb25zICYmIGlzUHJlc2VudChwYXJhbUFubm90YXRpb25zW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0uY29uY2F0KHBhcmFtQW5ub3RhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICAgICAgaWYgKHR5cGUucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgb2YgdHNpY2tsZSBmb3IgbG93ZXJpbmcgZGVjb3JhdG9ycyB0byBwcm9wZXJ0aWVzIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIGlmICh0eXBlLmN0b3JQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0b3JQYXJhbWV0ZXJzID0gdHlwZS5jdG9yUGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1UeXBlcyA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtKSB7IHJldHVybiBjdG9yUGFyYW0gJiYgY3RvclBhcmFtLnR5cGU7IH0pO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gY3RvclBhcmFtZXRlcnMubWFwKGZ1bmN0aW9uIChjdG9yUGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0b3JQYXJhbSAmJiBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YShjdG9yUGFyYW0uZGVjb3JhdG9ycyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ppcFR5cGVzQW5kQW5ub3RhdGlvbnMocGFyYW1UeXBlcywgcGFyYW1Bbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QpICYmIGlzUHJlc2VudCh0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncGFyYW1ldGVycycsIHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbVR5cGVzID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1UeXBlcyB8fCBwYXJhbUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96aXBUeXBlc0FuZEFubm90YXRpb25zKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBhcnJheSBoYXMgdG8gYmUgZmlsbGVkIHdpdGggYHVuZGVmaW5lZGAgYmVjYXVzZSBob2xlcyB3b3VsZCBiZSBza2lwcGVkIGJ5IGBzb21lYFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSh0eXBlLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXG4gICAgICAgICAgICBpZiAodHlwZU9yRnVuYy5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHR5cGVPckZ1bmMuYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9ucyA9PT0gJ2Z1bmN0aW9uJyAmJiBhbm5vdGF0aW9ucy5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmFubm90YXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgb2YgdHNpY2tsZSBmb3IgbG93ZXJpbmcgZGVjb3JhdG9ycyB0byBwcm9wZXJ0aWVzIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIGlmICh0eXBlT3JGdW5jLmRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEodHlwZU9yRnVuYy5kZWNvcmF0b3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBmb3IgbWV0YWRhdGEgY3JlYXRlZCBieSBpbnZva2luZyB0aGUgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWZsZWN0ICYmIHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICAgICAgaWYgKHR5cGVPckZ1bmMucHJvcE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BNZXRhZGF0YSA9IHR5cGVPckZ1bmMucHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcE1ldGFkYXRhID09PSAnZnVuY3Rpb24nICYmIHByb3BNZXRhZGF0YS5wcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhID0gcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBvZiB0c2lja2xlIGZvciBsb3dlcmluZyBkZWNvcmF0b3JzIHRvIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLlxuICAgICAgICAgICAgaWYgKHR5cGVPckZ1bmMucHJvcERlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcERlY29yYXRvcnNfMSA9IHR5cGVPckZ1bmMucHJvcERlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BNZXRhZGF0YV8xID0ge307XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcERlY29yYXRvcnNfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wTWV0YWRhdGFfMVtwcm9wXSA9IGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKHByb3BEZWNvcmF0b3JzXzFbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGFfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBmb3IgbWV0YWRhdGEgY3JlYXRlZCBieSBpbnZva2luZyB0aGUgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWZsZWN0ICYmIHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BNZXRhZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY1Byb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGUgJiYgbGNQcm9wZXJ0eSBpbiB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuZ2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICdyZXR1cm4gby4nICsgbmFtZSArICc7Jyk7IH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ3YnLCAncmV0dXJuIG8uJyArIG5hbWUgKyAnID0gdjsnKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbkJvZHkgPSBcImlmICghby5cIiArIG5hbWUgKyBcIikgdGhyb3cgbmV3IEVycm9yKCdcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIHVuZGVmaW5lZCcpO1xcbiAgICAgICAgcmV0dXJuIG8uXCIgKyBuYW1lICsgXCIuYXBwbHkobywgYXJncyk7XCI7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ2FyZ3MnLCBmdW5jdGlvbkJvZHkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUaGVyZSBpcyBub3QgYSBjb25jZXB0IG9mIGltcG9ydCB1cmkgaW4gSnMsIGJ1dCB0aGlzIGlzIHVzZWZ1bCBpbiBkZXZlbG9waW5nIERhcnQgYXBwbGljYXRpb25zLlxuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgLy8gU3RhdGljU3ltYm9sXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGVbJ2ZpbGVQYXRoJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVsnZmlsZVBhdGgnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJ1bnRpbWUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIFwiLi9cIiArIHN0cmluZ2lmeSh0eXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucmVzb2x2ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlVXJsLCBydW50aW1lKSB7IHJldHVybiBydW50aW1lOyB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5yZXNvbHZlRW51bSA9IGZ1bmN0aW9uIChlbnVtSWRlbnRpZmllciwgbmFtZSkgeyByZXR1cm4gZW51bUlkZW50aWZpZXJbbmFtZV07IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEoZGVjb3JhdG9ySW52b2NhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkZWNvcmF0b3JJbnZvY2F0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3JJbnZvY2F0aW9ucy5tYXAoZnVuY3Rpb24gKGRlY29yYXRvckludm9jYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBkZWNvcmF0b3JUeXBlID0gZGVjb3JhdG9ySW52b2NhdGlvbi50eXBlO1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb25DbHMgPSBkZWNvcmF0b3JUeXBlLmFubm90YXRpb25DbHM7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkFyZ3MgPSBkZWNvcmF0b3JJbnZvY2F0aW9uLmFyZ3MgPyBkZWNvcmF0b3JJbnZvY2F0aW9uLmFyZ3MgOiBbXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKGFubm90YXRpb25DbHMuYmluZC5hcHBseShhbm5vdGF0aW9uQ2xzLCBbdm9pZCAwXS5jb25jYXQoYW5ub3RhdGlvbkFyZ3MpKSkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHJlYWQtb25seSBhY2Nlc3MgdG8gcmVmbGVjdGlvbiBkYXRhIGFib3V0IHN5bWJvbHMuIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyXG4gICAgICogdG8gcG93ZXIgZGVwZW5kZW5jeSBpbmplY3Rpb24gYW5kIGNvbXBpbGF0aW9uLlxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0b3JSZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0b3JSZWFkZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZmxlY3RvclJlYWRlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFjY2VzcyB0byByZWZsZWN0aW9uIGRhdGEgYWJvdXQgc3ltYm9scy4gVXNlZCBpbnRlcm5hbGx5IGJ5IEFuZ3VsYXJcbiAgICAgKiB0byBwb3dlciBkZXBlbmRlbmN5IGluamVjdGlvbiBhbmQgY29tcGlsYXRpb24uXG4gICAgICovXG4gICAgdmFyIFJlZmxlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQyKFJlZmxlY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdG9yKHJlZmxlY3Rpb25DYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gcmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnVwZGF0ZUNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uIChjYXBzKSB7IHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IGNhcHM7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZmFjdG9yeSh0eXBlKTsgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucGFyYW1ldGVycyh0eXBlT3JGdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmFubm90YXRpb25zKHR5cGVPckZ1bmMpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3BNZXRhZGF0YSh0eXBlT3JGdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5oYXNMaWZlY3ljbGVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGxjUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaGFzTGlmZWN5Y2xlSG9vayh0eXBlLCBsY1Byb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmdldHRlcihuYW1lKTsgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnNldHRlcihuYW1lKTsgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLm1ldGhvZChuYW1lKTsgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmltcG9ydFVyaSh0eXBlKTsgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5yZXNvbHZlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChuYW1lLCBtb2R1bGVVcmwsIHJ1bnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucmVzb2x2ZUlkZW50aWZpZXIobmFtZSwgbW9kdWxlVXJsLCBydW50aW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5yZXNvbHZlRW51bSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnJlc29sdmVFbnVtKGlkZW50aWZpZXIsIG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdG9yO1xuICAgIH0oUmVmbGVjdG9yUmVhZGVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIFJlZmxlY3Rvcn0gdXNlZCBpbnRlcm5hbGx5IGluIEFuZ3VsYXIgdG8gYWNjZXNzIG1ldGFkYXRhXG4gICAgICogYWJvdXQgc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgcmVmbGVjdG9yID0gbmV3IFJlZmxlY3RvcihuZXcgUmVmbGVjdGlvbkNhcGFiaWxpdGllcygpKTtcblxuICAgIC8qKlxuICAgICAqIGBEZXBlbmRlbmN5YCBpcyB1c2VkIGJ5IHRoZSBmcmFtZXdvcmsgdG8gZXh0ZW5kIERJLlxuICAgICAqIFRoaXMgaXMgaW50ZXJuYWwgdG8gQW5ndWxhciBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0aXZlRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVEZXBlbmRlbmN5KGtleSwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgcHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmRWaXNpYmlsaXR5ID0gbG93ZXJCb3VuZFZpc2liaWxpdHk7XG4gICAgICAgICAgICB0aGlzLnVwcGVyQm91bmRWaXNpYmlsaXR5ID0gdXBwZXJCb3VuZFZpc2liaWxpdHk7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3RpdmVEZXBlbmRlbmN5LmZyb21LZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVEZXBlbmRlbmN5KGtleSwgZmFsc2UsIG51bGwsIG51bGwsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVEZXBlbmRlbmN5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9FTVBUWV9MSVNUID0gW107XG4gICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhrZXksIHJlc29sdmVkRmFjdG9yaWVzLCBtdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRGYWN0b3JpZXMgPSByZXNvbHZlZEZhY3RvcmllcztcbiAgICAgICAgICAgIHRoaXMubXVsdGlQcm92aWRlciA9IG11bHRpUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXy5wcm90b3R5cGUsIFwicmVzb2x2ZWRGYWN0b3J5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yZXNvbHZlZEZhY3Rvcmllc1swXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl87XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCByZXNvbHZlZCByZXByZXNlbnRhdGlvbiBvZiBhIGZhY3RvcnkgZnVuY3Rpb24gY3JlYXRlZCBieSByZXNvbHZpbmcge0BsaW5rXG4gICAgICogUHJvdmlkZXJ9LlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkoXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggY2FuIHJldHVybiBhbiBpbnN0YW5jZSBvZiBhbiBvYmplY3QgcmVwcmVzZW50ZWQgYnkgYSBrZXkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZhY3RvcnksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFyZ3VtZW50cyAoZGVwZW5kZW5jaWVzKSB0byB0aGUgYGZhY3RvcnlgIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFJlc29sdmUgYSBzaW5nbGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJlZmxlY3RpdmVGYWN0b3J5KHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBmYWN0b3J5Rm47XG4gICAgICAgIHZhciByZXNvbHZlZERlcHM7XG4gICAgICAgIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgdmFyIHVzZUNsYXNzID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIudXNlQ2xhc3MpO1xuICAgICAgICAgICAgZmFjdG9yeUZuID0gcmVmbGVjdG9yLmZhY3RvcnkodXNlQ2xhc3MpO1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gX2RlcGVuZGVuY2llc0Zvcih1c2VDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uIChhbGlhc0luc3RhbmNlKSB7IHJldHVybiBhbGlhc0luc3RhbmNlOyB9O1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gW1JlZmxlY3RpdmVEZXBlbmRlbmN5LmZyb21LZXkoUmVmbGVjdGl2ZUtleS5nZXQocHJvdmlkZXIudXNlRXhpc3RpbmcpKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgZmFjdG9yeUZuID0gcHJvdmlkZXIudXNlRmFjdG9yeTtcbiAgICAgICAgICAgIHJlc29sdmVkRGVwcyA9IGNvbnN0cnVjdERlcGVuZGVuY2llcyhwcm92aWRlci51c2VGYWN0b3J5LCBwcm92aWRlci5kZXBzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyLnVzZVZhbHVlOyB9O1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gX0VNUFRZX0xJU1Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5KGZhY3RvcnlGbiwgcmVzb2x2ZWREZXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHtAbGluayBQcm92aWRlcn0gaW50byB7QGxpbmsgUmVzb2x2ZWRQcm92aWRlcn0uXG4gICAgICpcbiAgICAgKiB7QGxpbmsgSW5qZWN0b3J9IGludGVybmFsbHkgb25seSB1c2VzIHtAbGluayBSZXNvbHZlZFByb3ZpZGVyfSwge0BsaW5rIFByb3ZpZGVyfSBjb250YWluc1xuICAgICAqIGNvbnZlbmllbmNlIHByb3ZpZGVyIHN5bnRheC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfKFJlZmxlY3RpdmVLZXkuZ2V0KHByb3ZpZGVyLnByb3ZpZGUpLCBbcmVzb2x2ZVJlZmxlY3RpdmVGYWN0b3J5KHByb3ZpZGVyKV0sIHByb3ZpZGVyLm11bHRpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhIGxpc3Qgb2YgUHJvdmlkZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycykge1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXJzLCBbXSk7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IG5vcm1hbGl6ZWQubWFwKHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXIpO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlck1hcCA9IG1lcmdlUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKHJlc29sdmVkLCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyZXNvbHZlZFByb3ZpZGVyTWFwLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGEgbGlzdCBvZiBSZXNvbHZlZFByb3ZpZGVycyBpbnRvIGEgbGlzdCB3aGVyZVxuICAgICAqIGVhY2gga2V5IGlzIGNvbnRhaW5lZCBleGFjdGx5IG9uY2UgYW5kIG11bHRpIHByb3ZpZGVyc1xuICAgICAqIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzLCBub3JtYWxpemVkUHJvdmlkZXJzTWFwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBwcm92aWRlcnNbaV07XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBub3JtYWxpemVkUHJvdmlkZXJzTWFwLmdldChwcm92aWRlci5rZXkuaWQpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIgIT09IGV4aXN0aW5nLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihleGlzdGluZywgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZXNvbHZlZEZhY3Rvcmllcy5wdXNoKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3ZpZGVyc01hcC5zZXQocHJvdmlkZXIua2V5LmlkLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8ocHJvdmlkZXIua2V5LCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllcy5zbGljZSgpLCBwcm92aWRlci5tdWx0aVByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3ZpZGVyc01hcC5zZXQocHJvdmlkZXIua2V5LmlkLCByZXNvbHZlZFByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFByb3ZpZGVyc01hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlcnMsIHJlcykge1xuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goeyBwcm92aWRlOiBiLCB1c2VDbGFzczogYiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcgJiYgYi5wcm92aWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIF9ub3JtYWxpemVQcm92aWRlcnMoYiwgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvdmlkZXJFcnJvcihiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdERlcGVuZGVuY2llcyh0eXBlT3JGdW5jLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfZGVwZW5kZW5jaWVzRm9yKHR5cGVPckZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcmFtc18xID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gW3RdOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHQsIHBhcmFtc18xKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2RlcGVuZGVuY2llc0Zvcih0eXBlT3JGdW5jKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSByZWZsZWN0b3IucGFyYW1ldGVycyh0eXBlT3JGdW5jKTtcbiAgICAgICAgaWYgKCFwYXJhbXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGlmIChwYXJhbXMuc29tZShmdW5jdGlvbiAocCkgeyByZXR1cm4gcCA9PSBudWxsOyB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQW5ub3RhdGlvbkVycm9yKHR5cGVPckZ1bmMsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIF9leHRyYWN0VG9rZW4odHlwZU9yRnVuYywgcCwgcGFyYW1zKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leHRyYWN0VG9rZW4odHlwZU9yRnVuYywgbWV0YWRhdGEsIHBhcmFtcykge1xuICAgICAgICB2YXIgZGVwUHJvcHMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gbnVsbDtcbiAgICAgICAgdmFyIG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSBpbnN0YW5jZW9mIEluamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeShtZXRhZGF0YS50b2tlbiwgb3B0aW9uYWwsIG51bGwsIG51bGwsIGRlcFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeShtZXRhZGF0YSwgb3B0aW9uYWwsIG51bGwsIG51bGwsIGRlcFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbG93ZXJCb3VuZFZpc2liaWxpdHkgPSBudWxsO1xuICAgICAgICB2YXIgdXBwZXJCb3VuZFZpc2liaWxpdHkgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1NZXRhZGF0YSA9IG1ldGFkYXRhW2ldO1xuICAgICAgICAgICAgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbU1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIEluamVjdCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1NZXRhZGF0YS50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBTZWxmKSB7XG4gICAgICAgICAgICAgICAgdXBwZXJCb3VuZFZpc2liaWxpdHkgPSBwYXJhbU1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIEhvc3QpIHtcbiAgICAgICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgICBsb3dlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XG4gICAgICAgIGlmICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4sIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9jcmVhdGVEZXBlbmRlbmN5KHRva2VuLCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXBQcm9wcykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVEZXBlbmRlbmN5KFJlZmxlY3RpdmVLZXkuZ2V0KHRva2VuKSwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpO1xuICAgIH1cblxuICAgIC8vIFRocmVzaG9sZCBmb3IgdGhlIGR5bmFtaWMgdmVyc2lvblxuICAgIHZhciBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSID0gMTA7XG4gICAgdmFyIFVOREVGSU5FRCA9IG5ldyBPYmplY3QoKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kocHJvdG9FSSwgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyOCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyOSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkOCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkOSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcHJvdmlkZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjAgPSBwcm92aWRlcnNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDAgPSBwcm92aWRlcnNbMF0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IHByb3ZpZGVyc1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkMSA9IHByb3ZpZGVyc1sxXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIyID0gcHJvdmlkZXJzWzJdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQyID0gcHJvdmlkZXJzWzJdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjMgPSBwcm92aWRlcnNbM107XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDMgPSBwcm92aWRlcnNbM10ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IHByb3ZpZGVyc1s0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNCA9IHByb3ZpZGVyc1s0XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI1ID0gcHJvdmlkZXJzWzVdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ1ID0gcHJvdmlkZXJzWzVdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjYgPSBwcm92aWRlcnNbNl07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDYgPSBwcm92aWRlcnNbNl0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IHByb3ZpZGVyc1s3XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNyA9IHByb3ZpZGVyc1s3XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI4ID0gcHJvdmlkZXJzWzhdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ4ID0gcHJvdmlkZXJzWzhdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjkgPSBwcm92aWRlcnNbOV07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDkgPSBwcm92aWRlcnNbOV0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIwO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIyO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIzO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI0O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI1O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI2O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI3O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI4O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5ID0gZnVuY3Rpb24gKGluamVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5KGluamVjdG9yLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b0luaiwgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5rZXlJZHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkc1tpXSA9IHByb3ZpZGVyc1tpXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnNbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSA9IGZ1bmN0aW9uIChlaSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kodGhpcywgZWkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZQcm92aWRlcnMgPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBwcm92aWRlcnMubGVuZ3RoID4gX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUiA/XG4gICAgICAgICAgICAgICAgbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycykgOlxuICAgICAgICAgICAgICAgIG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuZ2V0UHJvdmlkZXJBdEluZGV4KGluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHByb3RvU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMucHJvdG9TdHJhdGVneSA9IHByb3RvU3RyYXRlZ3k7XG4gICAgICAgICAgICB0aGlzLm9iajAgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajEgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajIgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajMgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajQgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajUgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajYgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajcgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajggPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajkgPSBVTkRFRklORUQ7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmplY3Rvci5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7IH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5fbmV3KHByb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wcm90b1N0cmF0ZWd5O1xuICAgICAgICAgICAgdmFyIGluaiA9IHRoaXMuaW5qZWN0b3I7XG4gICAgICAgICAgICBpZiAocC5rZXlJZDAgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMCA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMCA9IGluai5fbmV3KHAucHJvdmlkZXIwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkMSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmoxID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoxID0gaW5qLl9uZXcocC5wcm92aWRlcjEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQyID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajIgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajIgPSBpbmouX25ldyhwLnByb3ZpZGVyMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDMgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMyA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMyA9IGluai5fbmV3KHAucHJvdmlkZXIzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNCA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo0ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo0ID0gaW5qLl9uZXcocC5wcm92aWRlcjQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ1ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajUgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajUgPSBpbmouX25ldyhwLnByb3ZpZGVyNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDYgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqNiA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqNiA9IGluai5fbmV3KHAucHJvdmlkZXI2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNyA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo3ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo3ID0gaW5qLl9uZXcocC5wcm92aWRlcjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ4ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajggPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajggPSBpbmouX25ldyhwLnByb3ZpZGVyOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDkgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqOSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqOSA9IGluai5fbmV3KHAucHJvdmlkZXI5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmowO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmozO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNDtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA1KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo2O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA4KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gOSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUjsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b1N0cmF0ZWd5LCBpbmplY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub2JqcyA9IG5ldyBBcnJheShwcm90b1N0cmF0ZWd5LnByb3ZpZGVycy5sZW5ndGgpLmZpbGwoVU5ERUZJTkVEKTtcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmplY3Rvci5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7IH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuaW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuX25ldyhwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0T2JqQnlLZXlJZCA9IGZ1bmN0aW9uIChrZXlJZCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnByb3RvU3RyYXRlZ3k7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAua2V5SWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAua2V5SWRzW2ldID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmpzW2ldID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Jqc1tpXSA9IHRoaXMuaW5qZWN0b3IuX25ldyhwLnByb3ZpZGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Jqc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVU5ERUZJTkVEO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5vYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ianNbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE1heE51bWJlck9mT2JqZWN0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub2Jqcy5sZW5ndGg7IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIFJlZmxlY3RpdmVEZXBlbmRlbmN5IGluamVjdGlvbiBjb250YWluZXIgdXNlZCBmb3IgaW5zdGFudGlhdGluZyBvYmplY3RzIGFuZCByZXNvbHZpbmdcbiAgICAgKiBkZXBlbmRlbmNpZXMuXG4gICAgICpcbiAgICAgKiBBbiBgSW5qZWN0b3JgIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGEgYG5ld2Agb3BlcmF0b3IsIHdoaWNoIGNhbiBhdXRvbWF0aWNhbGx5IHJlc29sdmUgdGhlXG4gICAgICogY29uc3RydWN0b3IgZGVwZW5kZW5jaWVzLlxuICAgICAqXG4gICAgICogSW4gdHlwaWNhbCB1c2UsIGFwcGxpY2F0aW9uIGNvZGUgYXNrcyBmb3IgdGhlIGRlcGVuZGVuY2llcyBpbiB0aGUgY29uc3RydWN0b3IgYW5kIHRoZXkgYXJlXG4gICAgICogcmVzb2x2ZWQgYnkgdGhlIGBJbmplY3RvcmAuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvanpqZWMwP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhbiBgSW5qZWN0b3JgIGNvbmZpZ3VyZWQgdG8gY3JlYXRlIGBFbmdpbmVgIGFuZCBgQ2FyYC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgQ2FyIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtDYXIsIEVuZ2luZV0pO1xuICAgICAqIHZhciBjYXIgPSBpbmplY3Rvci5nZXQoQ2FyKTtcbiAgICAgKiBleHBlY3QoY2FyIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAqIGV4cGVjdChjYXIuZW5naW5lIGluc3RhbmNlb2YgRW5naW5lKS50b0JlKHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90aWNlLCB3ZSBkb24ndCB1c2UgdGhlIGBuZXdgIG9wZXJhdG9yIGJlY2F1c2Ugd2UgZXhwbGljaXRseSB3YW50IHRvIGhhdmUgdGhlIGBJbmplY3RvcmBcbiAgICAgKiByZXNvbHZlIGFsbCBvZiB0aGUgb2JqZWN0J3MgZGVwZW5kZW5jaWVzIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVJbmplY3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHVybnMgYW4gYXJyYXkgb2YgcHJvdmlkZXIgZGVmaW5pdGlvbnMgaW50byBhbiBhcnJheSBvZiByZXNvbHZlZCBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgcmVzb2x1dGlvbiBpcyBhIHByb2Nlc3Mgb2YgZmxhdHRlbmluZyBtdWx0aXBsZSBuZXN0ZWQgYXJyYXlzIGFuZCBjb252ZXJ0aW5nIGluZGl2aWR1YWxcbiAgICAgICAgICogcHJvdmlkZXJzIGludG8gYW4gYXJyYXkgb2Yge0BsaW5rIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyfXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9BaVhUSGk/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBDYXIge1xuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwcm92aWRlcnMgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbQ2FyLCBbW0VuZ2luZV1dXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnMubGVuZ3RoKS50b0VxdWFsKDIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdIGluc3RhbmNlb2YgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0ua2V5LmRpc3BsYXlOYW1lKS50b0JlKFwiQ2FyXCIpO1xuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmRlcGVuZGVuY2llcy5sZW5ndGgpLnRvRXF1YWwoMSk7XG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0uZmFjdG9yeSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1sxXS5rZXkuZGlzcGxheU5hbWUpLnRvQmUoXCJFbmdpbmVcIik7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIHtAbGluayBSZWZsZWN0aXZlSW5qZWN0b3IjZnJvbVJlc29sdmVkUHJvdmlkZXJzfSBmb3IgbW9yZSBpbmZvLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIGFuIGFycmF5IG9mIHByb3ZpZGVycyBhbmQgY3JlYXRlcyBhbiBpbmplY3RvciBmcm9tIHRob3NlIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgY2FuIGJlIGFuIGFycmF5IG9mIGBUeXBlYCwge0BsaW5rIFByb3ZpZGVyfSxcbiAgICAgICAgICogb3IgYSByZWN1cnNpdmUgYXJyYXkgb2YgbW9yZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9lUE9jY0E/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBDYXIge1xuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtDYXIsIEVuZ2luZV0pO1xuICAgICAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHNsb3dlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGBmcm9tUmVzb2x2ZWRQcm92aWRlcnNgXG4gICAgICAgICAqIGJlY2F1c2UgaXQgbmVlZHMgdG8gcmVzb2x2ZSB0aGUgcGFzc2VkLWluIHByb3ZpZGVycyBmaXJzdC5cbiAgICAgICAgICogU2VlIHtAbGluayBJbmplY3RvciNyZXNvbHZlfSBhbmQge0BsaW5rIEluamVjdG9yI2Zyb21SZXNvbHZlZFByb3ZpZGVyc30uXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShwcm92aWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMoUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzLCBwYXJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbmplY3RvciBmcm9tIHByZXZpb3VzbHkgcmVzb2x2ZWQgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIEFQSSBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGNvbnN0cnVjdCBpbmplY3RvcnMgaW4gcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIHBhcnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS3JTTWNpP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NhciwgRW5naW5lXSk7XG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocHJvdmlkZXJzKTtcbiAgICAgICAgICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZUluamVjdG9yXyhSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocHJvdmlkZXJzKSwgcGFyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFyZW50IG9mIHRoaXMgaW5qZWN0b3IuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cbiAgICAgICAgICAgICAqIC0tPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9lb3NNR28/cD1wcmV2aWV3KSlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAgICAgKiB2YXIgcGFyZW50ID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW10pO1xuICAgICAgICAgICAgICogdmFyIGNoaWxkID0gcGFyZW50LnJlc29sdmVBbmRDcmVhdGVDaGlsZChbXSk7XG4gICAgICAgICAgICAgKiBleHBlY3QoY2hpbGQucGFyZW50KS50b0JlKHBhcmVudCk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZXMgYW4gYXJyYXkgb2YgcHJvdmlkZXJzIGFuZCBjcmVhdGVzIGEgY2hpbGQgaW5qZWN0b3IgZnJvbSB0aG9zZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byB0aGUgc2VjdGlvbiBvZiB0aGUgdXNlciBndWlkZSB0YWxraW5nIGFib3V0IGhpZXJhcmNoaWNhbCBpbmplY3Rpb24uXG4gICAgICAgICAqIC0tPlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcGFzc2VkLWluIHByb3ZpZGVycyBjYW4gYmUgYW4gYXJyYXkgb2YgYFR5cGVgLCB7QGxpbmsgUHJvdmlkZXJ9LFxuICAgICAgICAgKiBvciBhIHJlY3Vyc2l2ZSBhcnJheSBvZiBtb3JlIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L29wQjNUND9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIGNsYXNzIFBhcmVudFByb3ZpZGVyIHt9XG4gICAgICAgICAqIGNsYXNzIENoaWxkUHJvdmlkZXIge31cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHBhcmVudCA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtQYXJlbnRQcm92aWRlcl0pO1xuICAgICAgICAgKiB2YXIgY2hpbGQgPSBwYXJlbnQucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKFtDaGlsZFByb3ZpZGVyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpIGluc3RhbmNlb2YgUGFyZW50UHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoQ2hpbGRQcm92aWRlcikgaW5zdGFuY2VvZiBDaGlsZFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSkudG9CZShwYXJlbnQuZ2V0KFBhcmVudFByb3ZpZGVyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHNsb3dlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGBjcmVhdGVDaGlsZEZyb21SZXNvbHZlZGBcbiAgICAgICAgICogYmVjYXVzZSBpdCBuZWVkcyB0byByZXNvbHZlIHRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGZpcnN0LlxuICAgICAgICAgKiBTZWUge0BsaW5rIEluamVjdG9yI3Jlc29sdmV9IGFuZCB7QGxpbmsgSW5qZWN0b3IjY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWR9LlxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY2hpbGQgaW5qZWN0b3IgZnJvbSBwcmV2aW91c2x5IHJlc29sdmVkIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cbiAgICAgICAgICogLS0+XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9WaHlmak4/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBjbGFzcyBQYXJlbnRQcm92aWRlciB7fVxuICAgICAgICAgKiBjbGFzcyBDaGlsZFByb3ZpZGVyIHt9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwYXJlbnRQcm92aWRlcnMgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbUGFyZW50UHJvdmlkZXJdKTtcbiAgICAgICAgICogdmFyIGNoaWxkUHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NoaWxkUHJvdmlkZXJdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHBhcmVudCA9IFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocGFyZW50UHJvdmlkZXJzKTtcbiAgICAgICAgICogdmFyIGNoaWxkID0gcGFyZW50LmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKGNoaWxkUHJvdmlkZXJzKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikgaW5zdGFuY2VvZiBQYXJlbnRQcm92aWRlcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLmdldChDaGlsZFByb3ZpZGVyKSBpbnN0YW5jZW9mIENoaWxkUHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpKS50b0JlKHBhcmVudC5nZXQoUGFyZW50UHJvdmlkZXIpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIGEgcHJvdmlkZXIgYW5kIGluc3RhbnRpYXRlcyBhbiBvYmplY3QgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGluamVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY3JlYXRlZCBvYmplY3QgZG9lcyBub3QgZ2V0IGNhY2hlZCBieSB0aGUgaW5qZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC95dlZYb0I/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBDYXIge1xuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtFbmdpbmVdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGNhciA9IGluamVjdG9yLnJlc29sdmVBbmRJbnN0YW50aWF0ZShDYXIpO1xuICAgICAgICAgKiBleHBlY3QoY2FyLmVuZ2luZSkudG9CZShpbmplY3Rvci5nZXQoRW5naW5lKSk7XG4gICAgICAgICAqIGV4cGVjdChjYXIpLm5vdC50b0JlKGluamVjdG9yLnJlc29sdmVBbmRJbnN0YW50aWF0ZShDYXIpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLnJlc29sdmVBbmRJbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFudGlhdGVzIGFuIG9iamVjdCB1c2luZyBhIHJlc29sdmVkIHByb3ZpZGVyIGluIHRoZSBjb250ZXh0IG9mIHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNyZWF0ZWQgb2JqZWN0IGRvZXMgbm90IGdldCBjYWNoZWQgYnkgdGhlIGluamVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvcHRDSW1RP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRW5naW5lXSk7XG4gICAgICAgICAqIHZhciBjYXJQcm92aWRlciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXJdKVswXTtcbiAgICAgICAgICogdmFyIGNhciA9IGluamVjdG9yLmluc3RhbnRpYXRlUmVzb2x2ZWQoY2FyUHJvdmlkZXIpO1xuICAgICAgICAgKiBleHBlY3QoY2FyLmVuZ2luZSkudG9CZShpbmplY3Rvci5nZXQoRW5naW5lKSk7XG4gICAgICAgICAqIGV4cGVjdChjYXIpLm5vdC50b0JlKGluamVjdG9yLmluc3RhbnRpYXRlUmVzb2x2ZWQoY2FyUHJvdmlkZXIpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLmluc3RhbnRpYXRlUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3RvcjtcbiAgICB9KCkpO1xuICAgIHZhciBSZWZsZWN0aXZlSW5qZWN0b3JfID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVJbmplY3Rvcl8oX3Byb3RvIC8qIFByb3RvSW5qZWN0b3IgKi8sIF9wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChfcGFyZW50ID09PSB2b2lkIDApIHsgX3BhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcHJvdG8gPSBfcHJvdG87XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBfcHJvdG8uX3N0cmF0ZWd5LmNyZWF0ZUluamVjdG9yU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBUSFJPV19JRl9OT1RfRk9VTkQ7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleShSZWZsZWN0aXZlS2V5LmdldCh0b2tlbiksIG51bGwsIG51bGwsIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5nZXRBdCA9IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuZ2V0T2JqQXRJbmRleChpbmRleCk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUsIFwiaW50ZXJuYWxTdHJhdGVneVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgICAgICogSW50ZXJuYWwuIERvIG5vdCB1c2UuXG4gICAgICAgICAgICAgKiBXZSByZXR1cm4gYGFueWAgbm90IHRvIGV4cG9ydCB0aGUgSW5qZWN0b3JTdHJhdGVneSB0eXBlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUucmVzb2x2ZUFuZENyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZChSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBwcm90byA9IG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpO1xuICAgICAgICAgICAgdmFyIGluaiA9IG5ldyBSZWZsZWN0aXZlSW5qZWN0b3JfKHByb3RvKTtcbiAgICAgICAgICAgIGluai5fcGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBpbmo7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnJlc29sdmVBbmRJbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFudGlhdGVSZXNvbHZlZChSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbcHJvdmlkZXJdKVswXSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmluc3RhbnRpYXRlUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50aWF0ZVByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fbmV3ID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29uc3RydWN0aW9uQ291bnRlcisrID4gdGhpcy5fc3RyYXRlZ3kuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ3ljbGljRGVwZW5kZW5jeUVycm9yKHRoaXMsIHByb3ZpZGVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkocHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXSA9IHRoaXMuX2luc3RhbnRpYXRlKHByb3ZpZGVyLCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGUocHJvdmlkZXIsIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2luc3RhbnRpYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkuZmFjdG9yeTtcbiAgICAgICAgICAgIHZhciBkZXBzID0gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeS5kZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZGVwcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZDA7XG4gICAgICAgICAgICB2YXIgZDE7XG4gICAgICAgICAgICB2YXIgZDI7XG4gICAgICAgICAgICB2YXIgZDM7XG4gICAgICAgICAgICB2YXIgZDQ7XG4gICAgICAgICAgICB2YXIgZDU7XG4gICAgICAgICAgICB2YXIgZDY7XG4gICAgICAgICAgICB2YXIgZDc7XG4gICAgICAgICAgICB2YXIgZDg7XG4gICAgICAgICAgICB2YXIgZDk7XG4gICAgICAgICAgICB2YXIgZDEwO1xuICAgICAgICAgICAgdmFyIGQxMTtcbiAgICAgICAgICAgIHZhciBkMTI7XG4gICAgICAgICAgICB2YXIgZDEzO1xuICAgICAgICAgICAgdmFyIGQxNDtcbiAgICAgICAgICAgIHZhciBkMTU7XG4gICAgICAgICAgICB2YXIgZDE2O1xuICAgICAgICAgICAgdmFyIGQxNztcbiAgICAgICAgICAgIHZhciBkMTg7XG4gICAgICAgICAgICB2YXIgZDE5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkMCA9IGxlbmd0aCA+IDAgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzBdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDEgPSBsZW5ndGggPiAxID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQyID0gbGVuZ3RoID4gMiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMl0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMyA9IGxlbmd0aCA+IDMgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzNdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDQgPSBsZW5ndGggPiA0ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s0XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ1ID0gbGVuZ3RoID4gNSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkNiA9IGxlbmd0aCA+IDYgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzZdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDcgPSBsZW5ndGggPiA3ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s3XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ4ID0gbGVuZ3RoID4gOCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbOF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkOSA9IGxlbmd0aCA+IDkgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzldKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDEwID0gbGVuZ3RoID4gMTAgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzEwXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxMSA9IGxlbmd0aCA+IDExID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTIgPSBsZW5ndGggPiAxMiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTJdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDEzID0gbGVuZ3RoID4gMTMgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzEzXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxNCA9IGxlbmd0aCA+IDE0ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTUgPSBsZW5ndGggPiAxNSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTVdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE2ID0gbGVuZ3RoID4gMTYgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE2XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxNyA9IGxlbmd0aCA+IDE3ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxN10pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTggPSBsZW5ndGggPiAxOCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMThdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE5ID0gbGVuZ3RoID4gMTkgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE5XSkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFic3RyYWN0UHJvdmlkZXJFcnJvciB8fCBlIGluc3RhbmNlb2YgSW5zdGFudGlhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuYWRkS2V5KHRoaXMsIHByb3ZpZGVyLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2JqO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDksIGQxMCwgZDExLCBkMTIsIGQxMywgZDE0LCBkMTUsIGQxNiwgZDE3LCBkMTgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNywgZDE4LCBkMTkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgJ1wiICsgcHJvdmlkZXIua2V5LmRpc3BsYXlOYW1lICsgXCInIGJlY2F1c2UgaXQgaGFzIG1vcmUgdGhhbiAyMCBkZXBlbmRlbmNpZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdGFudGlhdGlvbkVycm9yKHRoaXMsIGUsIGUuc3RhY2ssIHByb3ZpZGVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChwcm92aWRlciwgZGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXkoZGVwLmtleSwgZGVwLmxvd2VyQm91bmRWaXNpYmlsaXR5LCBkZXAudXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcC5vcHRpb25hbCA/IG51bGwgOiBUSFJPV19JRl9OT1RfRk9VTkQpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXkgPSBmdW5jdGlvbiAoa2V5LCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IElOSkVDVE9SX0tFWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwcGVyQm91bmRWaXNpYmlsaXR5IGluc3RhbmNlb2YgU2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleVNlbGYoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleURlZmF1bHQoa2V5LCBub3RGb3VuZFZhbHVlLCBsb3dlckJvdW5kVmlzaWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX3Rocm93T3JOdWxsID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgIT09IFRIUk9XX0lGX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RGb3VuZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vUHJvdmlkZXJFcnJvcih0aGlzLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRCeUtleVNlbGYgPSBmdW5jdGlvbiAoa2V5LCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5fc3RyYXRlZ3kuZ2V0T2JqQnlLZXlJZChrZXkuaWQpO1xuICAgICAgICAgICAgcmV0dXJuIChvYmogIT09IFVOREVGSU5FRCkgPyBvYmogOiB0aGlzLl90aHJvd09yTnVsbChrZXksIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRCeUtleURlZmF1bHQgPSBmdW5jdGlvbiAoa2V5LCBub3RGb3VuZFZhbHVlLCBsb3dlckJvdW5kVmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgdmFyIGluajtcbiAgICAgICAgICAgIGlmIChsb3dlckJvdW5kVmlzaWJpbGl0eSBpbnN0YW5jZW9mIFNraXBTZWxmKSB7XG4gICAgICAgICAgICAgICAgaW5qID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5qID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpbmogaW5zdGFuY2VvZiBSZWZsZWN0aXZlSW5qZWN0b3JfKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlual8gPSBpbmo7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IGlual8uX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqICE9PSBVTkRFRklORUQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgaW5qID0gaW5qXy5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmouZ2V0KGtleS50b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dPck51bGwoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlcnMgPSBfbWFwUHJvdmlkZXJzKHRoaXMsIGZ1bmN0aW9uIChiKSB7IHJldHVybiAnIFwiJyArIGIua2V5LmRpc3BsYXlOYW1lICsgJ1wiICc7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlJlZmxlY3RpdmVJbmplY3Rvcihwcm92aWRlcnM6IFtcIiArIHByb3ZpZGVycyArIFwiXSlcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzcGxheU5hbWU7IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3JfO1xuICAgIH0oKSk7XG4gICAgdmFyIElOSkVDVE9SX0tFWSA9IFJlZmxlY3RpdmVLZXkuZ2V0KEluamVjdG9yKTtcbiAgICBmdW5jdGlvbiBfbWFwUHJvdmlkZXJzKGluamVjdG9yLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KGluamVjdG9yLl9wcm90by5udW1iZXJPZlByb3ZpZGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0b3IuX3Byb3RvLm51bWJlck9mUHJvdmlkZXJzOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGZuKGluamVjdG9yLl9wcm90by5nZXRQcm92aWRlckF0SW5kZXgoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFByb3ZpZGVzIGEgaG9vayBmb3IgY2VudHJhbGl6ZWQgZXhjZXB0aW9uIGhhbmRsaW5nLlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgRXJyb3JIYW5kbGVyYCBwcmludHMgZXJyb3IgbWVzc2FnZXMgdG8gdGhlIGBjb25zb2xlYC4gVG9cbiAgICAgKiBpbnRlcmNlcHQgZXJyb3IgaGFuZGxpbmcsIHdyaXRlIGEgY3VzdG9tIGV4Y2VwdGlvbiBoYW5kbGVyIHRoYXQgcmVwbGFjZXMgdGhpcyBkZWZhdWx0IGFzXG4gICAgICogYXBwcm9wcmlhdGUgZm9yIHlvdXIgYXBwLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNsYXNzIE15RXJyb3JIYW5kbGVyIGltcGxlbWVudHMgRXJyb3JIYW5kbGVyIHtcbiAgICAgKiAgIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBleGNlcHRpb25cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IEVycm9ySGFuZGxlciwgdXNlQ2xhc3M6IE15RXJyb3JIYW5kbGVyfV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE15TW9kdWxlIHt9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEVycm9ySGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVycm9ySGFuZGxlcihyZXRocm93RXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChyZXRocm93RXJyb3IgPT09IHZvaWQgMCkgeyByZXRocm93RXJyb3IgPSB0cnVlOyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlID0gY29uc29sZTtcbiAgICAgICAgICAgIHRoaXMucmV0aHJvd0Vycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEVycm9yID0gdGhpcy5fZmluZE9yaWdpbmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU3RhY2sgPSB0aGlzLl9maW5kT3JpZ2luYWxTdGFjayhlcnJvcik7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2ZpbmRDb250ZXh0KGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoXCJFWENFUFRJT046IFwiICsgdGhpcy5fZXh0cmFjdE1lc3NhZ2UoZXJyb3IpKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcihcIk9SSUdJTkFMIEVYQ0VQVElPTjogXCIgKyB0aGlzLl9leHRyYWN0TWVzc2FnZShvcmlnaW5hbEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoJ09SSUdJTkFMIFNUQUNLVFJBQ0U6Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcihvcmlnaW5hbFN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcignRVJST1IgQ09OVEVYVDonKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgcmV0aHJvdyBleGNlcHRpb25zLCBzbyBvcGVyYXRpb25zIGxpa2UgJ2Jvb3RzdHJhcCcgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIHdoZW4gYW4gZXJyb3IgaGFwcGVucy4gSWYgd2UgZG8gbm90IHJldGhyb3csIGJvb3RzdHJhcCB3aWxsIGFsd2F5cyBzdWNjZWVkLlxuICAgICAgICAgICAgaWYgKHRoaXMucmV0aHJvd0Vycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuX2V4dHJhY3RNZXNzYWdlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuX2ZpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IuY29udGV4dCA/IGVycm9yLmNvbnRleHQgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5kQ29udGV4dChlcnJvci5vcmlnaW5hbEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuX2ZpbmRPcmlnaW5hbEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yLm9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICB3aGlsZSAoZSAmJiBlLm9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlID0gZS5vcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsU3RhY2sgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvcjtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGUuc3RhY2s7XG4gICAgICAgICAgICB3aGlsZSAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUub3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgICAgIGUgPSBlLm9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrID0gZS5zdGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFcnJvckhhbmRsZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xuICAgICAqL1xuICAgIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0xW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IE9iamVjdC5rZXlzKG0yKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhtMSk7XG4gICAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gazFbaV07XG4gICAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihpdGVtc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoZmxhdCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBmbGF0SXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBMaXN0V3JhcHBlci5mbGF0dGVuKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdC5jb25jYXQoZmxhdEl0ZW0pO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBpc0xpc3RMaWtlSXRlcmFibGUob2JqKSB7XG4gICAgICAgIGlmICghaXNKc09iamVjdChvYmopKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgICAgICAgICAoIShvYmogaW5zdGFuY2VvZiBNYXApICYmXG4gICAgICAgICAgICAgICAgZ2V0U3ltYm9sSXRlcmF0b3IoKSBpbiBvYmopOyAvLyBKUyBJdGVyYWJsZSBoYXZlIGEgU3ltYm9sLml0ZXJhdG9yIHByb3BcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlSXRlcmFibGVzRXF1YWwoYSwgYiwgY29tcGFyYXRvcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IxID0gYVtnZXRTeW1ib2xJdGVyYXRvcigpXSgpO1xuICAgICAgICB2YXIgaXRlcmF0b3IyID0gYltnZXRTeW1ib2xJdGVyYXRvcigpXSgpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0xID0gaXRlcmF0b3IxLm5leHQoKTtcbiAgICAgICAgICAgIHZhciBpdGVtMiA9IGl0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbTEuZG9uZSAmJiBpdGVtMi5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGl0ZW0xLmRvbmUgfHwgaXRlbTIuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmF0b3IoaXRlbTEudmFsdWUsIGl0ZW0yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxpc3RMaWtlKG9iaiwgZm4pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbihvYmpbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gb2JqW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICghKChpdGVtID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSkge1xuICAgICAgICAgICAgICAgIGZuKGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICAgICAgLy8gYWxsb3cgYW55IFByb21pc2UvQSsgY29tcGxpYW50IHRoZW5hYmxlLlxuICAgICAgICAvLyBJdCdzIHVwIHRvIHRoZSBjYWxsZXIgdG8gZW5zdXJlIHRoYXQgb2JqLnRoZW4gY29uZm9ybXMgdG8gdGhlIHNwZWNcbiAgICAgICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGFuIGFwcGxpY2F0aW9uIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0lOSVRJQUxJWkVSID0gbmV3IE9wYXF1ZVRva2VuKCdBcHBsaWNhdGlvbiBJbml0aWFsaXplcicpO1xuICAgIC8qKlxuICAgICAqIEEgY2xhc3MgdGhhdCByZWZsZWN0cyB0aGUgc3RhdGUgb2YgcnVubmluZyB7QGxpbmsgQVBQX0lOSVRJQUxJWkVSfXMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyhhcHBJbml0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhc3luY0luaXRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGFwcEluaXRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHBJbml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFJlc3VsdCA9IGFwcEluaXRzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UoaW5pdFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jSW5pdFByb21pc2VzLnB1c2goaW5pdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kb25lUHJvbWlzZSA9IFByb21pc2UuYWxsKGFzeW5jSW5pdFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHsgX3RoaXMuX2RvbmUgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGlmIChhc3luY0luaXRQcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25Jbml0U3RhdHVzLnByb3RvdHlwZSwgXCJkb25lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9uZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvbkluaXRTdGF0dXMucHJvdG90eXBlLCBcImRvbmVQcm9taXNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9uZVByb21pc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQXBwbGljYXRpb25Jbml0U3RhdHVzLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbQVBQX0lOSVRJQUxJWkVSLF0gfSwgeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uSW5pdFN0YXR1cztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBESSBUb2tlbiByZXByZXNlbnRpbmcgYSB1bmlxdWUgc3RyaW5nIGlkIGFzc2lnbmVkIHRvIHRoZSBhcHBsaWNhdGlvbiBieSBBbmd1bGFyIGFuZCB1c2VkXG4gICAgICogcHJpbWFyaWx5IGZvciBwcmVmaXhpbmcgYXBwbGljYXRpb24gYXR0cmlidXRlcyBhbmQgQ1NTIHN0eWxlcyB3aGVuXG4gICAgICoge0BsaW5rIFZpZXdFbmNhcHN1bGF0aW9uI0VtdWxhdGVkfSBpcyBiZWluZyB1c2VkLlxuICAgICAqXG4gICAgICogSWYgeW91IG5lZWQgdG8gYXZvaWQgcmFuZG9tbHkgZ2VuZXJhdGVkIHZhbHVlIHRvIGJlIHVzZWQgYXMgYW4gYXBwbGljYXRpb24gaWQsIHlvdSBjYW4gcHJvdmlkZVxuICAgICAqIGEgY3VzdG9tIHZhbHVlIHZpYSBhIERJIHByb3ZpZGVyIDwhLS0gVE9ETzogcHJvdmlkZXIgLS0+IGNvbmZpZ3VyaW5nIHRoZSByb290IHtAbGluayBJbmplY3Rvcn1cbiAgICAgKiB1c2luZyB0aGlzIHRva2VuLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0lEID0gbmV3IE9wYXF1ZVRva2VuKCdBcHBJZCcpO1xuICAgIGZ1bmN0aW9uIF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBfcmFuZG9tQ2hhcigpICsgX3JhbmRvbUNoYXIoKSArIF9yYW5kb21DaGFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyB0aGF0IHdpbGwgZ2VuZXJhdGUgYSByYW5kb20gQVBQX0lEX1RPS0VOLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0lEX1JBTkRPTV9QUk9WSURFUiA9IHtcbiAgICAgICAgcHJvdmlkZTogQVBQX0lELFxuICAgICAgICB1c2VGYWN0b3J5OiBfYXBwSWRSYW5kb21Qcm92aWRlckZhY3RvcnksXG4gICAgICAgIGRlcHM6IFtdLFxuICAgIH07XG4gICAgZnVuY3Rpb24gX3JhbmRvbUNoYXIoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUExBVEZPUk1fSU5JVElBTElaRVIgPSBuZXcgT3BhcXVlVG9rZW4oJ1BsYXRmb3JtIEluaXRpYWxpemVyJyk7XG4gICAgLyoqXG4gICAgICogQWxsIGNhbGxiYWNrcyBwcm92aWRlZCB2aWEgdGhpcyB0b2tlbiB3aWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgY29tcG9uZW50IHRoYXQgaXMgYm9vdHN0cmFwcGVkLlxuICAgICAqIFNpZ25hdHVyZSBvZiB0aGUgY2FsbGJhY2s6XG4gICAgICpcbiAgICAgKiBgKGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmKSA9PiB2b2lkYC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0JPT1RTVFJBUF9MSVNURU5FUiA9IG5ldyBPcGFxdWVUb2tlbignYXBwQm9vdHN0cmFwTGlzdGVuZXInKTtcbiAgICAvKipcbiAgICAgKiBBIHRva2VuIHdoaWNoIGluZGljYXRlcyB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBQQUNLQUdFX1JPT1RfVVJMID0gbmV3IE9wYXF1ZVRva2VuKCdBcHBsaWNhdGlvbiBQYWNrYWdlcyBSb290IFVSTCcpO1xuXG4gICAgdmFyIENvbnNvbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb25zb2xlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbnNvbGUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHByaW50KG1lc3NhZ2UpOyB9O1xuICAgICAgICAvLyBOb3RlOiBmb3IgcmVwb3J0aW5nIGVycm9ycyB1c2UgYERPTS5sb2dFcnJvcigpYCBhcyBpdCBpcyBwbGF0Zm9ybSBzcGVjaWZpY1xuICAgICAgICBDb25zb2xlLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgd2FybihtZXNzYWdlKTsgfTtcbiAgICAgICAgQ29uc29sZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBDb25zb2xlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBDb25zb2xlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb21wb25lbnQgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIGluIGEgc3luY2hyb25vdXMgY29tcGlsZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNChDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IoY29tcFR5cGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQ2FuJ3QgY29tcGlsZSBzeW5jaHJvbm91c2x5IGFzIFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIHN0aWxsIGJlaW5nIGxvYWRlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmNvbXBUeXBlID0gY29tcFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogQ29tYmluYXRpb24gb2YgTmdNb2R1bGVGYWN0b3J5IGFuZCBDb21wb25lbnRGYWN0b3J5cy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMobmdNb2R1bGVGYWN0b3J5LCBjb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMubmdNb2R1bGVGYWN0b3J5ID0gbmdNb2R1bGVGYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3JpZXMgPSBjb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfdGhyb3dFcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVudGltZSBjb21waWxlciBpcyBub3QgbG9hZGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgc2VydmljZSBmb3IgcnVubmluZyB0aGUgYW5ndWxhciBjb21waWxlciBkdXJpbmcgcnVudGltZVxuICAgICAqIHRvIGNyZWF0ZSB7QGxpbmsgQ29tcG9uZW50RmFjdG9yeX1zLCB3aGljaFxuICAgICAqIGNhbiBsYXRlciBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgcmVuZGVyIGEgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogRWFjaCBgQE5nTW9kdWxlYCBwcm92aWRlcyBhbiBvd24gYENvbXBpbGVyYCB0byBpdHMgaW5qZWN0b3IsXG4gICAgICogdGhhdCB3aWxsIHVzZSB0aGUgZGlyZWN0aXZlcy9waXBlcyBvZiB0aGUgbmcgbW9kdWxlIGZvciBjb21waWxhdGlvblxuICAgICAqIG9mIGNvbXBvbmVudHMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBpbGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlcyB0aGUgZ2l2ZW4gTmdNb2R1bGUgYW5kIGFsbCBvZiBpdHMgY29tcG9uZW50cy4gQWxsIHRlbXBsYXRlcyBvZiB0aGUgY29tcG9uZW50cyBsaXN0ZWRcbiAgICAgICAgICogaW4gYGVudHJ5Q29tcG9uZW50c2BcbiAgICAgICAgICogaGF2ZSB0byBiZSBpbmxpbmVkLiBPdGhlcndpc2UgdGhyb3dzIGEge0BsaW5rIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yfS5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlcyB0aGUgZ2l2ZW4gTmdNb2R1bGUgYW5kIGFsbCBvZiBpdHMgY29tcG9uZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHtAbGluayBjb21waWxlTW9kdWxlU3luY30gYnV0IGFsc28gY3JlYXRlcyBDb21wb25lbnRGYWN0b3JpZXMgZm9yIGFsbCBjb21wb25lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB7QGxpbmsgY29tcGlsZU1vZHVsZUFzeW5jfSBidXQgYWxzbyBjcmVhdGVzIENvbXBvbmVudEZhY3RvcmllcyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBjYWNoZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyB0aGUgY2FjaGUgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQvbmdNb2R1bGUuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7IH07XG4gICAgICAgIHJldHVybiBDb21waWxlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRva2VuIHRvIHByb3ZpZGUgQ29tcGlsZXJPcHRpb25zIGluIHRoZSBwbGF0Zm9ybSBpbmplY3Rvci5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQ09NUElMRVJfT1BUSU9OUyA9IG5ldyBPcGFxdWVUb2tlbignY29tcGlsZXJPcHRpb25zJyk7XG4gICAgLyoqXG4gICAgICogQSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIENvbXBpbGVyXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIENvbXBpbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBpbGVyRmFjdG9yeSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcGlsZXJGYWN0b3J5O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGFyb3VuZCBhIG5hdGl2ZSBlbGVtZW50IGluc2lkZSBvZiBhIFZpZXcuXG4gICAgICpcbiAgICAgKiBBbiBgRWxlbWVudFJlZmAgaXMgYmFja2VkIGJ5IGEgcmVuZGVyLXNwZWNpZmljIGVsZW1lbnQuIEluIHRoZSBicm93c2VyLCB0aGlzIGlzIHVzdWFsbHkgYSBET01cbiAgICAgKiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHNlY3VyaXR5IFBlcm1pdHRpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgRE9NIGNhbiBtYWtlIHlvdXIgYXBwbGljYXRpb24gbW9yZSB2dWxuZXJhYmxlIHRvXG4gICAgICogWFNTIGF0dGFja3MuIENhcmVmdWxseSByZXZpZXcgYW55IHVzZSBvZiBgRWxlbWVudFJlZmAgaW4geW91ciBjb2RlLiBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGVcbiAgICAgKiBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBleHBvc2UgdGhpbmdzIGxpa2UgYEluamVjdG9yYCwgYFZpZXdDb250YWluZXJgLCAuLi4gaGVyZSxcbiAgICAvLyBpLmUuIHVzZXJzIGhhdmUgdG8gYXNrIGZvciB3aGF0IHRoZXkgbmVlZC4gV2l0aCB0aGF0LCB3ZSBjYW4gYnVpbGQgYmV0dGVyIGFuYWx5c2lzIHRvb2xzXG4gICAgLy8gYW5kIGNvdWxkIGRvIGJldHRlciBjb2RlZ2VuIGluIHRoZSBmdXR1cmUuXG4gICAgdmFyIEVsZW1lbnRSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFbGVtZW50UmVmKG5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVsZW1lbnRSZWY7XG4gICAgfSgpKTtcblxuICAgIHZhciBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSgpIHtcbiAgICAgICAgfVxuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGlzTGlzdExpa2VJdGVyYWJsZShvYmopOyB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYsIHRyYWNrQnlGbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXIodHJhY2tCeUZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICB2YXIgdHJhY2tCeUlkZW50aXR5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7IHJldHVybiBpdGVtOyB9O1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyKF90cmFja0J5Rm4pIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrQnlGbiA9IF90cmFja0J5Rm47XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdXNlZCByZWNvcmRzIGF0IGFueSBwb2ludCBpbiB0aW1lIChkdXJpbmcgJiBhY3Jvc3MgYF9jaGVjaygpYCBjYWxscylcbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMgPSBudWxsO1xuICAgICAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHJlbW92ZWQgcmVjb3JkcyBhdCBhbnkgcG9pbnQgaW4gdGltZSBkdXJpbmcgYF9jaGVjaygpYCBjYWxscy5cbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0l0SGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgcmVjb3JkcyB3aGVyZSBjdXN0b20gdHJhY2sgYnkgaXMgdGhlIHNhbWUsIGJ1dCBpdGVtIGlkZW50aXR5IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tCeUZuID0gdGhpcy5fdHJhY2tCeUZuIHx8IHRyYWNrQnlJZGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJjb2xsZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hPcGVyYXRpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBuZXh0SXQgPSB0aGlzLl9pdEhlYWQ7XG4gICAgICAgICAgICB2YXIgbmV4dFJlbW92ZSA9IHRoaXMuX3JlbW92YWxzSGVhZDtcbiAgICAgICAgICAgIHZhciBhZGRSZW1vdmVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIG1vdmVPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0SXQgfHwgbmV4dFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggaXMgdGhlIG5leHQgcmVjb3JkIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBPcmRlcjogcmVtb3ZlLCBhZGQsIG1vdmVcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gIW5leHRSZW1vdmUgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV4dEl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SXQuY3VycmVudEluZGV4IDwgZ2V0UHJldmlvdXNJbmRleChuZXh0UmVtb3ZlLCBhZGRSZW1vdmVPZmZzZXQsIG1vdmVPZmZzZXRzKSA/XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdCA6XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZW1vdmU7XG4gICAgICAgICAgICAgICAgdmFyIGFkalByZXZpb3VzSW5kZXggPSBnZXRQcmV2aW91c0luZGV4KHJlY29yZCwgYWRkUmVtb3ZlT2Zmc2V0LCBtb3ZlT2Zmc2V0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgaXRlbSwgYW5kIGFkanVzdCB0aGUgYWRkUmVtb3ZlT2Zmc2V0IGFuZCB1cGRhdGUgbW92ZURpc3RhbmNlIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgPT09IG5leHRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlT2Zmc2V0LS07XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZW1vdmUgPSBuZXh0UmVtb3ZlLl9uZXh0UmVtb3ZlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdCA9IG5leHRJdC5fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSU5WQVJJQU5UOiAgY3VycmVudEluZGV4IDwgcHJldmlvdXNJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3ZlT2Zmc2V0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsTW92ZVByZXZpb3VzSW5kZXggPSBhZGpQcmV2aW91c0luZGV4IC0gYWRkUmVtb3ZlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsQ3VycmVudEluZGV4ID0gY3VycmVudEluZGV4IC0gYWRkUmVtb3ZlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsTW92ZVByZXZpb3VzSW5kZXggIT0gbG9jYWxDdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsTW92ZVByZXZpb3VzSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSA8IG1vdmVPZmZzZXRzLmxlbmd0aCA/IG1vdmVPZmZzZXRzW2ldIDogKG1vdmVPZmZzZXRzW2ldID0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG9mZnNldCArIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEN1cnJlbnRJbmRleCA8PSBpbmRleCAmJiBpbmRleCA8IGxvY2FsTW92ZVByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXRzW2ldID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IHJlY29yZC5wcmV2aW91c0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXRzW3ByZXZpb3VzSW5kZXhdID0gbG9jYWxDdXJyZW50SW5kZXggLSBsb2NhbE1vdmVQcmV2aW91c0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGpQcmV2aW91c0luZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4ocmVjb3JkLCBhZGpQcmV2aW91c0luZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUHJldmlvdXNJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c0l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEFkZGVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaE1vdmVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dE1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUmVtb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0SWRlbnRpdHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsoY29sbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc0xpc3RMaWtlSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBjb2xsZWN0aW9uICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2soY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLy8gdG9kbyh2aWNiKTogb3B0aW0gZm9yIFVubW9kaWZpYWJsZUxpc3RWaWV3IChmcm96ZW4gYXJyYXlzKVxuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2l0SGVhZDtcbiAgICAgICAgICAgIHZhciBtYXlCZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgIHZhciBpdGVtVHJhY2tCeTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBjb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4XzEgPSAwOyBpbmRleF8xIDwgdGhpcy5fbGVuZ3RoOyBpbmRleF8xKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGxpc3RbaW5kZXhfMV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UcmFja0J5ID0gdGhpcy5fdHJhY2tCeUZuKGluZGV4XzEsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsb29zZUlkZW50aWNhbChyZWNvcmQudHJhY2tCeUlkLCBpdGVtVHJhY2tCeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5QmVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5QmVEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fdmVyaWZ5UmVpbnNlcnRpb24ocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXhfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZUxpc3RMaWtlKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UcmFja0J5ID0gX3RoaXMuX3RyYWNrQnlGbihpbmRleCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgPT09IG51bGwgfHwgIWxvb3NlSWRlbnRpY2FsKHJlY29yZC50cmFja0J5SWQsIGl0ZW1UcmFja0J5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gX3RoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heUJlRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG1pc2tvKTogY2FuIHdlIGxpbWl0IHRoaXMgdG8gZHVwbGljYXRlcyBvbmx5P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IF90aGlzLl92ZXJpZnlSZWluc2VydGlvbihyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90cnVuY2F0ZShyZWNvcmQpO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0RpcnR5O1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qIENvbGxlY3Rpb25DaGFuZ2VzIGlzIGNvbnNpZGVyZWQgZGlydHkgaWYgaXQgaGFzIGFueSBhZGRpdGlvbnMsIG1vdmVzLCByZW1vdmFscywgb3IgaWRlbnRpdHlcbiAgICAgICAgICAgICAqIGNoYW5nZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRpdGlvbnNIZWFkICE9PSBudWxsIHx8IHRoaXMuX21vdmVzSGVhZCAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGwgfHwgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBjaGFuZ2Ugb2JqZWN0cyB0byBzaG93IG5vIGNoYW5nZXMuIFRoaXMgbWVhbnMgc2V0IHByZXZpb3VzS2V5IHRvXG4gICAgICAgICAqIGN1cnJlbnRLZXksIGFuZCBjbGVhciBhbGwgb2YgdGhlIHF1ZXVlcyAoYWRkaXRpb25zLCBtb3ZlcywgcmVtb3ZhbHMpLlxuICAgICAgICAgKiBTZXQgdGhlIHByZXZpb3VzSW5kZXhlcyBvZiBtb3ZlZCBhbmQgYWRkZWQgaXRlbXMgdG8gdGhlaXIgY3VycmVudEluZGV4ZXNcbiAgICAgICAgICogUmVzZXQgdGhlIGxpc3Qgb2YgYWRkaXRpb25zLCBtb3ZlcyBhbmQgcmVtb3ZhbHNcbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNJdEhlYWQgPSB0aGlzLl9pdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzSW5kZXggPSByZWNvcmQuY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gbmV4dFJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHRNb3ZlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZXNIZWFkID0gdGhpcy5fbW92ZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgZnVuY3Rpb24gd2hpY2ggaGFuZGxlcyBkaWZmZXJlbmNlcyBiZXR3ZWVuIGNvbGxlY3Rpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGByZWNvcmRgIGlzIHRoZSByZWNvcmQgd2hpY2ggd2Ugc2F3IGF0IHRoaXMgcG9zaXRpb24gbGFzdCB0aW1lLiBJZiBudWxsIHRoZW4gaXQgaXMgYSBuZXdcbiAgICAgICAgICogICBpdGVtLlxuICAgICAgICAgKiAtIGBpdGVtYCBpcyB0aGUgY3VycmVudCBpdGVtIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAqIC0gYGluZGV4YCBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9taXNtYXRjaCA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCkge1xuICAgICAgICAgICAgLy8gVGhlIHByZXZpb3VzIHJlY29yZCBhZnRlciB3aGljaCB3ZSB3aWxsIGFwcGVuZCB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSZWNvcmQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZWNvcmQgPSB0aGlzLl9pdFRhaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JlY29yZCA9IHJlY29yZC5fcHJldjtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHJlY29yZCBmcm9tIHRoZSBjb2xsZWN0aW9uIHNpbmNlIHdlIGtub3cgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGl0ZW0uXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHNlZSBpZiB3ZSBoYXZlIHNlZW4gdGhlIGl0ZW0gYmVmb3JlLlxuICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgc2VlbiB0aGlzIGJlZm9yZSwgd2UgbmVlZCB0byBtb3ZlIGl0IGZvcndhcmQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gQnV0IGZpcnN0IHdlIG5lZWQgdG8gY2hlY2sgaWYgaWRlbnRpdHkgY2hhbmdlZCwgc28gd2UgY2FuIHVwZGF0ZSBpbiB2aWV3IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZXZlciBzZWVuIGl0LCBjaGVjayBldmljdGVkIGxpc3QuXG4gICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fdW5saW5rZWRSZWNvcmRzID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3VubGlua2VkUmVjb3Jkcy5nZXQoaXRlbVRyYWNrQnkpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gaXRlbSB3aGljaCB3ZSBoYXZlIGV2aWN0ZWQgZWFybGllcjogcmVpbnNlcnQgaXQgYmFjayBpbnRvIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgZmlyc3Qgd2UgbmVlZCB0byBjaGVjayBpZiBpZGVudGl0eSBjaGFuZ2VkLCBzbyB3ZSBjYW4gdXBkYXRlIGluIHZpZXcgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVpbnNlcnRBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhIG5ldyBpdGVtOiBhZGQgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRBZnRlcihuZXcgQ29sbGVjdGlvbkNoYW5nZVJlY29yZChpdGVtLCBpdGVtVHJhY2tCeSksIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2hlY2sgaXMgb25seSBuZWVkZWQgaWYgYW4gYXJyYXkgY29udGFpbnMgZHVwbGljYXRlcy4gKFNob3J0IGNpcmN1aXQgb2Ygbm90aGluZyBkaXJ0eSlcbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIGNhc2U6IGBbYSwgYV1gID0+IGBbYiwgYSwgYV1gXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHdlIGRpZCBub3QgaGF2ZSB0aGlzIGNoZWNrIHRoZW4gdGhlIGluc2VydGlvbiBvZiBgYmAgd291bGQ6XG4gICAgICAgICAqICAgMSkgZXZpY3QgZmlyc3QgYGFgXG4gICAgICAgICAqICAgMikgaW5zZXJ0IGBiYCBhdCBgMGAgaW5kZXguXG4gICAgICAgICAqICAgMykgbGVhdmUgYGFgIGF0IGluZGV4IGAxYCBhcyBpcy4gPC0tIHRoaXMgaXMgd3JvbmchXG4gICAgICAgICAqICAgMykgcmVpbnNlcnQgYGFgIGF0IGluZGV4IDIuIDwtLSB0aGlzIGlzIHdyb25nIVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY29ycmVjdCBiZWhhdmlvciBpczpcbiAgICAgICAgICogICAxKSBldmljdCBmaXJzdCBgYWBcbiAgICAgICAgICogICAyKSBpbnNlcnQgYGJgIGF0IGAwYCBpbmRleC5cbiAgICAgICAgICogICAzKSByZWluc2VydCBgYWAgYXQgaW5kZXggMS5cbiAgICAgICAgICogICAzKSBtb3ZlIGBhYCBhdCBmcm9tIGAxYCB0byBgMmAuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIERvdWJsZSBjaGVjayB0aGF0IHdlIGhhdmUgbm90IGV2aWN0ZWQgYSBkdXBsaWNhdGUgaXRlbS4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgaXRlbSB0eXBlIG1heVxuICAgICAgICAgKiBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkOlxuICAgICAgICAgKiBUaGUgaW5zZXJ0aW9uIG9mIGIgd2lsbCBldmljdCB0aGUgZmlyc3QgJ2EnLiBJZiB3ZSBkb24ndCByZWluc2VydCBpdCBub3cgaXQgd2lsbCBiZSByZWluc2VydGVkXG4gICAgICAgICAqIGF0IHRoZSBlbmQuIFdoaWNoIHdpbGwgc2hvdyB1cCBhcyB0aGUgdHdvICdhJ3Mgc3dpdGNoaW5nIHBvc2l0aW9uLiBUaGlzIGlzIGluY29ycmVjdCwgc2luY2UgYVxuICAgICAgICAgKiBiZXR0ZXIgd2F5IHRvIHRoaW5rIG9mIGl0IGlzIGFzIGluc2VydCBvZiAnYicgcmF0aGVyIHRoZW4gc3dpdGNoICdhJyB3aXRoICdiJyBhbmQgdGhlbiBhZGQgJ2EnXG4gICAgICAgICAqIGF0IHRoZSBlbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdmVyaWZ5UmVpbnNlcnRpb24gPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZWluc2VydFJlY29yZCA9IHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl91bmxpbmtlZFJlY29yZHMuZ2V0KGl0ZW1UcmFja0J5KTtcbiAgICAgICAgICAgIGlmIChyZWluc2VydFJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3JlaW5zZXJ0QWZ0ZXIocmVpbnNlcnRSZWNvcmQsIHJlY29yZC5fcHJldiwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjb3JkLmN1cnJlbnRJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5jdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCByaWQgb2YgYW55IGV4Y2VzcyB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH1zIGZyb20gdGhlIHByZXZpb3VzIGNvbGxlY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogLSBgcmVjb3JkYCBUaGUgZmlyc3QgZXhjZXNzIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl90cnVuY2F0ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGFmdGVyIHRoYXQgbmVlZHMgdG8gYmUgcmVtb3ZlZDtcbiAgICAgICAgICAgIHdoaWxlIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcbiAgICAgICAgICAgICAgICByZWNvcmQgPSBuZXh0UmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbC5fbmV4dE1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pdFRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5yZW1vdmUocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2UmVtb3ZlZDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0UmVtb3ZlZDtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHRSZW1vdmVkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXZSZW1vdmVkID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luc2VydEFmdGVyKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fbW92ZUFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGluayhyZWNvcmQpO1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hZGRpdGlvbnNUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLl9hZGRpdGlvbnNIZWFkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dEFkZGVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkICE9IHByZXZSZWNvcmQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9wcmV2ID09PSBudWxsKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcHJldlJlY29yZCA9PT0gbnVsbCA/IHRoaXMuX2l0SGVhZCA6IHByZXZSZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQobmV4dCAhPSByZWNvcmQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHByZXZSZWNvcmQgIT0gcmVjb3JkKTtcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICByZWNvcmQuX3ByZXYgPSBwcmV2UmVjb3JkO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2ID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZSZWNvcmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2UmVjb3JkLl9uZXh0ID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzID0gbmV3IF9EdXBsaWNhdGVNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucHV0KHJlY29yZCk7XG4gICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl91bmxpbmsgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldjtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KChyZWNvcmQuX3ByZXYgPSBudWxsKSA9PT0gbnVsbCk7XG4gICAgICAgICAgICAvLyBhc3NlcnQoKHJlY29yZC5fbmV4dCA9IG51bGwpID09PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dC5fcHJldiA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZFRvTW92ZXMgPSBmdW5jdGlvbiAocmVjb3JkLCB0b0luZGV4KSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0TW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c0luZGV4ID09PSB0b0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3Zlc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9tb3Zlc0hlYWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IHRoaXMuX21vdmVzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX21vdmVzVGFpbC5fbmV4dE1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwgPSB0aGlzLl9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMgPSBuZXcgX0R1cGxpY2F0ZU1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLnB1dChyZWNvcmQpO1xuICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgICAgICAgICByZWNvcmQuX25leHRSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9yZW1vdmFsc0hlYWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRSZW1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gdGhpcy5fcmVtb3ZhbHNUYWlsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZElkZW50aXR5Q2hhbmdlID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSkge1xuICAgICAgICAgICAgcmVjb3JkLml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEl0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gbGlzdC5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hQcmV2aW91c0l0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gcHJldmlvdXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBhZGRpdGlvbnMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciBtb3ZlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoTW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIG1vdmVzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIHJlbW92YWxzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgaWRlbnRpdHlDaGFuZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hJZGVudGl0eUNoYW5nZShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBpZGVudGl0eUNoYW5nZXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiAnY29sbGVjdGlvbjogJyArIGxpc3Quam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAncHJldmlvdXM6ICcgKyBwcmV2aW91cy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdhZGRpdGlvbnM6ICcgKyBhZGRpdGlvbnMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnbW92ZXM6ICcgKyBtb3Zlcy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdyZW1vdmFsczogJyArIHJlbW92YWxzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2lkZW50aXR5Q2hhbmdlczogJyArIGlkZW50aXR5Q2hhbmdlcy5qb2luKCcsICcpICsgJ1xcbic7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0SXRlcmFibGVEaWZmZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkKGl0ZW0sIHRyYWNrQnlJZCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCeUlkID0gdHJhY2tCeUlkO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldkR1cCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3ByZXZSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRBZGRlZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0TW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dElkZW50aXR5Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzSW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4ID8gc3RyaW5naWZ5KHRoaXMuaXRlbSkgOlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh0aGlzLml0ZW0pICsgJ1snICtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMucHJldmlvdXNJbmRleCkgKyAnLT4nICsgc3RyaW5naWZ5KHRoaXMuY3VycmVudEluZGV4KSArICddJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQ7XG4gICAgfSgpKTtcbiAgICAvLyBBIGxpbmtlZCBsaXN0IG9mIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmRzIHdpdGggdGhlIHNhbWUgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5pdGVtXG4gICAgdmFyIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCgpIHtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGVuZCB0aGUgcmVjb3JkIHRvIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IGJ5IGRlc2lnbiBhbGwgcmVjb3JkcyBpbiB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIGhvbGQgdGhlIHNhbWUgdmFsdWUgaW4gcmVjb3JkLml0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXZEdXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuaXRlbSA9PSAgX2hlYWQuaXRlbSB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgIHJlY29yZC5pdGVtIGlzIG51bSAmJiByZWNvcmQuaXRlbS5pc05hTiAmJiBfaGVhZC5pdGVtIGlzIG51bSAmJiBfaGVhZC5pdGVtLmlzTmFOKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsLl9uZXh0RHVwID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZXR1cm5zIGEgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCBoYXZpbmcgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC50cmFja0J5SWQgPT0gdHJhY2tCeUlkIGFuZFxuICAgICAgICAvLyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLmN1cnJlbnRJbmRleCA+PSBhZnRlckluZGV4XG4gICAgICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRyYWNrQnlJZCwgYWZ0ZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHREdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoKGFmdGVySW5kZXggPT09IG51bGwgfHwgYWZ0ZXJJbmRleCA8IHJlY29yZC5jdXJyZW50SW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlSWRlbnRpY2FsKHJlY29yZC50cmFja0J5SWQsIHRyYWNrQnlJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBvbmUge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaXMgZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydCgoKSB7XG4gICAgICAgICAgICAvLyAgLy8gdmVyaWZ5IHRoYXQgdGhlIHJlY29yZCBiZWluZyByZW1vdmVkIGlzIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgLy8gIGZvciAoQ29sbGVjdGlvbkNoYW5nZVJlY29yZCBjdXJzb3IgPSBfaGVhZDsgY3Vyc29yICE9IG51bGw7IGN1cnNvciA9IGN1cnNvci5fbmV4dER1cCkge1xuICAgICAgICAgICAgLy8gICAgaWYgKGlkZW50aWNhbChjdXJzb3IsIHJlY29yZCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgLy8gIH1cbiAgICAgICAgICAgIC8vICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXZEdXA7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dER1cDtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0RHVwID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2RHVwID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkID09PSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0O1xuICAgIH0oKSk7XG4gICAgdmFyIF9EdXBsaWNhdGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfRHVwbGljYXRlTWFwKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHJlY29yZC50cmFja0J5SWQ7XG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFkdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlcyA9IG5ldyBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCBkdXBsaWNhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cGxpY2F0ZXMuYWRkKHJlY29yZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgYHZhbHVlYCB1c2luZyBrZXkuIEJlY2F1c2UgdGhlIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgdmFsdWUgbWF5IGJlIG9uZSB3aGljaCB3ZVxuICAgICAgICAgKiBoYXZlIGFscmVhZHkgaXRlcmF0ZWQgb3Zlciwgd2UgdXNlIHRoZSBhZnRlckluZGV4IHRvIHByZXRlbmQgaXQgaXMgbm90IHRoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2UgY2FzZTogYFthLCBiLCBjLCBhLCBhXWAgaWYgd2UgYXJlIGF0IGluZGV4IGAzYCB3aGljaCBpcyB0aGUgc2Vjb25kIGBhYCB0aGVuIGFza2luZyBpZiB3ZVxuICAgICAgICAgKiBoYXZlIGFueSBtb3JlIGBhYHMgbmVlZHMgdG8gcmV0dXJuIHRoZSBsYXN0IGBhYCBub3QgdGhlIGZpcnN0IG9yIHNlY29uZC5cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0cmFja0J5SWQsIGFmdGVySW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChhZnRlckluZGV4ID09PSB2b2lkIDApIHsgYWZ0ZXJJbmRleCA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBrZXkgPSB0cmFja0J5SWQ7XG4gICAgICAgICAgICB2YXIgcmVjb3JkTGlzdCA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZExpc3QgPyByZWNvcmRMaXN0LmdldCh0cmFja0J5SWQsIGFmdGVySW5kZXgpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0gZnJvbSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBkdXBsaWNhdGVzIGFsc28gaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgaWYgaXQgZ2V0cyBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSByZWNvcmQudHJhY2tCeUlkO1xuICAgICAgICAgICAgdmFyIHJlY29yZExpc3QgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIHdoZW4gaXQgZ2V0cyBlbXB0eVxuICAgICAgICAgICAgaWYgKHJlY29yZExpc3QucmVtb3ZlKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfRHVwbGljYXRlTWFwLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tYXAuc2l6ZSA9PT0gMDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLm1hcC5jbGVhcigpOyB9O1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdfRHVwbGljYXRlTWFwKCcgKyBzdHJpbmdpZnkodGhpcy5tYXApICsgJyknOyB9O1xuICAgICAgICByZXR1cm4gX0R1cGxpY2F0ZU1hcDtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGdldFByZXZpb3VzSW5kZXgoaXRlbSwgYWRkUmVtb3ZlT2Zmc2V0LCBtb3ZlT2Zmc2V0cykge1xuICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IGl0ZW0ucHJldmlvdXNJbmRleDtcbiAgICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNJbmRleDtcbiAgICAgICAgdmFyIG1vdmVPZmZzZXQgPSAwO1xuICAgICAgICBpZiAobW92ZU9mZnNldHMgJiYgcHJldmlvdXNJbmRleCA8IG1vdmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZU9mZnNldCA9IG1vdmVPZmZzZXRzW3ByZXZpb3VzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c0luZGV4ICsgYWRkUmVtb3ZlT2Zmc2V0ICsgbW92ZU9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogaW5zdGFuY2VvZiBNYXAgfHwgaXNKc09iamVjdChvYmopOyB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYpIHsgcmV0dXJuIG5ldyBEZWZhdWx0S2V5VmFsdWVEaWZmZXIoKTsgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICB2YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNNYXBIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRpdGlvbnNIZWFkICE9PSBudWxsIHx8IHRoaXMuX2NoYW5nZXNIZWFkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNNYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoQ2hhbmdlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hSZW1vdmVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEobWFwIGluc3RhbmNlb2YgTWFwIHx8IGlzSnNPYmplY3QobWFwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBtYXAgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVjayhtYXApID8gdGhpcyA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHM7XG4gICAgICAgICAgICB2YXIgb2xkU2VxUmVjb3JkID0gdGhpcy5fbWFwSGVhZDtcbiAgICAgICAgICAgIHZhciBsYXN0T2xkU2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsYXN0TmV3U2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBzZXFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoKG1hcCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRTZXFSZWNvcmQgJiYga2V5ID09PSBvbGRTZXFSZWNvcmQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IG9sZFNlcVJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21heWJlQWRkVG9DaGFuZ2VzKG5ld1NlcVJlY29yZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTZXFSZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVGcm9tU2VxKGxhc3RPbGRTZXFSZWNvcmQsIG9sZFNlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9SZW1vdmFscyhvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSByZWNvcmRzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21heWJlQWRkVG9DaGFuZ2VzKG5ld1NlcVJlY29yZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gbmV3IEtleVZhbHVlQ2hhbmdlUmVjb3JkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChrZXksIG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9BZGRpdGlvbnMobmV3U2VxUmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VxQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzSW5SZW1vdmFscyhuZXdTZXFSZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVJlbW92YWxzKG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3ROZXdTZXFSZWNvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21hcEhlYWQgPSBuZXdTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TmV3U2VxUmVjb3JkLl9uZXh0ID0gbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RPbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZCA9IG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICBvbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQgJiYgb2xkU2VxUmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90cnVuY2F0ZShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNEaXJ0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgc3RhdGUgb2YgdGhlIG1hcHBpbmdcbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZCA9IHRoaXMuX21hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gdGhpcy5fY2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3RydW5jYXRlID0gZnVuY3Rpb24gKGxhc3RSZWNvcmQsIHJlY29yZCkge1xuICAgICAgICAgICAgd2hpbGUgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlY29yZC5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvUmVtb3ZhbHMocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBsYXN0UmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciByZWMgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlYyAhPT0gbnVsbDsgcmVjID0gcmVjLl9uZXh0UmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHJlYy5wcmV2aW91c1ZhbHVlID0gcmVjLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZWMuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvcmRzLmRlbGV0ZShyZWMua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fbWF5YmVBZGRUb0NoYW5nZXMgPSBmdW5jdGlvbiAocmVjb3JkLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChuZXdWYWx1ZSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ2hhbmdlcyhyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2lzSW5SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQgPT09IHRoaXMuX3JlbW92YWxzSGVhZCB8fCByZWNvcmQuX25leHRSZW1vdmVkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCAhPT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IHRoaXMuX3JlbW92YWxzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVNlcSA9IGZ1bmN0aW9uIChwcmV2LCByZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmVGcm9tUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldlJlbW92ZWQ7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dFJlbW92ZWQ7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9BZGRpdGlvbnMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9DaGFuZ2VzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZXNIZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsLl9uZXh0Q2hhbmdlZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gW107XG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlbW92YWxzID0gW107XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5wdXNoKHN0cmluZ2lmeShyZWNvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ21hcDogJyArIGl0ZW1zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzOiAnICsgcHJldmlvdXMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25zOiAnICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2NoYW5nZXM6ICcgKyBjaGFuZ2VzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3JlbW92YWxzOiAnICsgcmVtb3ZhbHMuam9pbignLCAnKSArICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIG9iai5mb3JFYWNoKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gZm4ob2JqW2tdLCBrKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEtleVZhbHVlQ2hhbmdlUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gS2V5VmFsdWVDaGFuZ2VSZWNvcmQoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dENoYW5nZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIEtleVZhbHVlQ2hhbmdlUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUlkZW50aWNhbCh0aGlzLnByZXZpb3VzVmFsdWUsIHRoaXMuY3VycmVudFZhbHVlKSA/XG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMua2V5KSA6XG4gICAgICAgICAgICAgICAgKHN0cmluZ2lmeSh0aGlzLmtleSkgKyAnWycgKyBzdHJpbmdpZnkodGhpcy5wcmV2aW91c1ZhbHVlKSArICctPicgK1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5jdXJyZW50VmFsdWUpICsgJ10nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEtleVZhbHVlQ2hhbmdlUmVjb3JkO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlcG9zaXRvcnkgb2YgZGlmZmVyZW50IGl0ZXJhYmxlIGRpZmZpbmcgc3RyYXRlZ2llcyB1c2VkIGJ5IE5nRm9yLCBOZ0NsYXNzLCBhbmQgb3RoZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSXRlcmFibGVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcGllZCA9IHBhcmVudC5mYWN0b3JpZXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmYWN0b3JpZXMgPSBmYWN0b3JpZXMuY29uY2F0KGNvcGllZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhbiBhcnJheSBvZiB7QGxpbmsgSXRlcmFibGVEaWZmZXJGYWN0b3J5fSBhbmQgcmV0dXJucyBhIHByb3ZpZGVyIHVzZWQgdG8gZXh0ZW5kIHRoZVxuICAgICAgICAgKiBpbmhlcml0ZWQge0BsaW5rIEl0ZXJhYmxlRGlmZmVyc30gaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgZmFjdG9yaWVzIGFuZCByZXR1cm4gYSBuZXdcbiAgICAgICAgICoge0BsaW5rIEl0ZXJhYmxlRGlmZmVyc30gaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGxpc3Qgb2YgZmFjdG9yaWVzLFxuICAgICAgICAgICAgICAgKiB3aGljaCB3aWxsIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgaW5qZWN0b3IgZm9yIHRoaXMgY29tcG9uZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAqIFRoaXMgc3RlcCBpcyBhbGwgdGhhdCdzIHJlcXVpcmVkIHRvIG1ha2UgYSBuZXcge0BsaW5rIEl0ZXJhYmxlRGlmZmVyfSBhdmFpbGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgICAgICogICB2aWV3UHJvdmlkZXJzOiBbXG4gICAgICAgICAqICAgICBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kKFtuZXcgSW1tdXRhYmxlTGlzdERpZmZlcigpXSlcbiAgICAgICAgICogICBdXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCA9IGZ1bmN0aW9uIChmYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSB3b3VsZCBvY2N1ciB3aGVuIGNhbGxpbmcgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCBpbnNpZGUgb2YgZGVwZW5kZW5jaWVzIHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvb3RzdHJhcCgpLCB3aGljaCB3b3VsZCBvdmVycmlkZSBkZWZhdWx0IHBpcGVzIGluc3RlYWQgb2YgZXh0ZW5kaW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgSXRlcmFibGVEaWZmZXJzIHdpdGhvdXQgYSBwYXJlbnQgaW5qZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSXRlcmFibGVEaWZmZXJzLmNyZWF0ZShmYWN0b3JpZXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBEZXBlbmRlbmN5IHRlY2huaWNhbGx5IGlzbid0IG9wdGlvbmFsLCBidXQgd2UgY2FuIHByb3ZpZGUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB0aGlzIHdheS5cbiAgICAgICAgICAgICAgICBkZXBzOiBbW0l0ZXJhYmxlRGlmZmVycywgbmV3IFNraXBTZWxmKCksIG5ldyBPcHRpb25hbCgpXV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIEl0ZXJhYmxlRGlmZmVycy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLmZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnN1cHBvcnRzKGl0ZXJhYmxlKTsgfSk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCAnXCIgKyBpdGVyYWJsZSArIFwiJyBvZiB0eXBlICdcIiArIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKGl0ZXJhYmxlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlRGlmZmVycztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSByZXBvc2l0b3J5IG9mIGRpZmZlcmVudCBNYXAgZGlmZmluZyBzdHJhdGVnaWVzIHVzZWQgYnkgTmdDbGFzcywgTmdTdHlsZSwgYW5kIG90aGVycy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEtleVZhbHVlRGlmZmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xuICAgICAgICB9XG4gICAgICAgIEtleVZhbHVlRGlmZmVycy5jcmVhdGUgPSBmdW5jdGlvbiAoZmFjdG9yaWVzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBjb3BpZWQgPSBwYXJlbnQuZmFjdG9yaWVzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgZmFjdG9yaWVzID0gZmFjdG9yaWVzLmNvbmNhdChjb3BpZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYW4gYXJyYXkgb2Yge0BsaW5rIEtleVZhbHVlRGlmZmVyRmFjdG9yeX0gYW5kIHJldHVybnMgYSBwcm92aWRlciB1c2VkIHRvIGV4dGVuZCB0aGVcbiAgICAgICAgICogaW5oZXJpdGVkIHtAbGluayBLZXlWYWx1ZURpZmZlcnN9IGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGZhY3RvcmllcyBhbmQgcmV0dXJuIGEgbmV3XG4gICAgICAgICAqIHtAbGluayBLZXlWYWx1ZURpZmZlcnN9IGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGV4dGVuZCBhbiBleGlzdGluZyBsaXN0IG9mIGZhY3RvcmllcyxcbiAgICAgICAgICAgICAgICogd2hpY2ggd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluamVjdG9yIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgKiBUaGlzIHN0ZXAgaXMgYWxsIHRoYXQncyByZXF1aXJlZCB0byBtYWtlIGEgbmV3IHtAbGluayBLZXlWYWx1ZURpZmZlcn0gYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQENvbXBvbmVudCh7XG4gICAgICAgICAqICAgdmlld1Byb3ZpZGVyczogW1xuICAgICAgICAgKiAgICAgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZChbbmV3IEltbXV0YWJsZU1hcERpZmZlcigpXSlcbiAgICAgICAgICogICBdXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZCA9IGZ1bmN0aW9uIChmYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogS2V5VmFsdWVEaWZmZXJzLFxuICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSB3b3VsZCBvY2N1ciB3aGVuIGNhbGxpbmcgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZCBpbnNpZGUgb2YgZGVwZW5kZW5jaWVzIHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvb3RzdHJhcCgpLCB3aGljaCB3b3VsZCBvdmVycmlkZSBkZWZhdWx0IHBpcGVzIGluc3RlYWQgb2YgZXh0ZW5kaW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgS2V5VmFsdWVEaWZmZXJzIHdpdGhvdXQgYSBwYXJlbnQgaW5qZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gS2V5VmFsdWVEaWZmZXJzLmNyZWF0ZShmYWN0b3JpZXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBEZXBlbmRlbmN5IHRlY2huaWNhbGx5IGlzbid0IG9wdGlvbmFsLCBidXQgd2UgY2FuIHByb3ZpZGUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB0aGlzIHdheS5cbiAgICAgICAgICAgICAgICBkZXBzOiBbW0tleVZhbHVlRGlmZmVycywgbmV3IFNraXBTZWxmKCksIG5ldyBPcHRpb25hbCgpXV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIEtleVZhbHVlRGlmZmVycy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrdikge1xuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLmZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnN1cHBvcnRzKGt2KTsgfSk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCAnXCIgKyBrdiArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEtleVZhbHVlRGlmZmVycztcbiAgICB9KCkpO1xuXG4gICAgdmFyIFVOSU5JVElBTElaRUQgPSB7XG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnQ0RfSU5JVF9WQUxVRSc7IH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRldk1vZGVFcXVhbChhLCBiKSB7XG4gICAgICAgIGlmIChpc0xpc3RMaWtlSXRlcmFibGUoYSkgJiYgaXNMaXN0TGlrZUl0ZXJhYmxlKGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlSXRlcmFibGVzRXF1YWwoYSwgYiwgZGV2TW9kZUVxdWFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNMaXN0TGlrZUl0ZXJhYmxlKGEpICYmICFpc1ByaW1pdGl2ZShhKSAmJiAhaXNMaXN0TGlrZUl0ZXJhYmxlKGIpICYmICFpc1ByaW1pdGl2ZShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9vc2VJZGVudGljYWwoYSwgYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHJlc3VsdCBvZiBhIHtAbGluayBQaXBlfSB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZCBldmVuIHRob3VnaCB0aGVcbiAgICAgKiByZWZlcmVuY2VcbiAgICAgKiBoYXMgbm90IGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlZCB2YWx1ZSB3aWxsIGJlIHVud3JhcHBlZCBieSBjaGFuZ2UgZGV0ZWN0aW9uLCBhbmQgdGhlIHVud3JhcHBlZCB2YWx1ZSB3aWxsIGJlIHN0b3JlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpZiAodGhpcy5fbGF0ZXN0VmFsdWUgPT09IHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZTtcbiAgICAgKiAgfSBlbHNlIHtcbiAgICAgKiAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICogICAgcmV0dXJuIFdyYXBwZWRWYWx1ZS53cmFwKHRoaXMuX2xhdGVzdFZhbHVlKTsgLy8gdGhpcyB3aWxsIGZvcmNlIHVwZGF0ZVxuICAgICAqICB9XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBXcmFwcGVkVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXcmFwcGVkVmFsdWUod3JhcHBlZCkge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVkID0gd3JhcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBXcmFwcGVkVmFsdWUud3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFdyYXBwZWRWYWx1ZSh2YWx1ZSk7IH07XG4gICAgICAgIHJldHVybiBXcmFwcGVkVmFsdWU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgY2xhc3MgZm9yIHVud3JhcHBpbmcgV3JhcHBlZFZhbHVlIHNcbiAgICAgKi9cbiAgICB2YXIgVmFsdWVVbndyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWYWx1ZVVud3JhcHBlcigpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzV3JhcHBlZFZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgVmFsdWVVbndyYXBwZXIucHJvdG90eXBlLnVud3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNXcmFwcGVkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS53cmFwcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBWYWx1ZVVud3JhcHBlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaGFzV3JhcHBlZFZhbHVlID0gZmFsc2U7IH07XG4gICAgICAgIHJldHVybiBWYWx1ZVVud3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBiYXNpYyBjaGFuZ2UgZnJvbSBhIHByZXZpb3VzIHRvIGEgbmV3IHZhbHVlLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2ltcGxlQ2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2ltcGxlQ2hhbmdlKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBuZXcgdmFsdWUgaXMgdGhlIGZpcnN0IHZhbHVlIGFzc2lnbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU2ltcGxlQ2hhbmdlLnByb3RvdHlwZS5pc0ZpcnN0Q2hhbmdlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wcmV2aW91c1ZhbHVlID09PSBVTklOSVRJQUxJWkVEOyB9O1xuICAgICAgICByZXR1cm4gU2ltcGxlQ2hhbmdlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDaGFuZ2VEZXRlY3RvclJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdG9yUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDaGFuZ2VEZXRlY3RvclJlZjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgT2JqZWN0YHMgYW5kIGBNYXBgcy5cbiAgICAgKi9cbiAgICB2YXIga2V5VmFsRGlmZiA9IFtuZXcgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSgpXTtcbiAgICAvKipcbiAgICAgKiBTdHJ1Y3R1cmFsIGRpZmZpbmcgZm9yIGBJdGVyYWJsZWAgdHlwZXMgc3VjaCBhcyBgQXJyYXlgcy5cbiAgICAgKi9cbiAgICB2YXIgaXRlcmFibGVEaWZmID0gW25ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KCldO1xuICAgIHZhciBkZWZhdWx0SXRlcmFibGVEaWZmZXJzID0gbmV3IEl0ZXJhYmxlRGlmZmVycyhpdGVyYWJsZURpZmYpO1xuICAgIHZhciBkZWZhdWx0S2V5VmFsdWVEaWZmZXJzID0gbmV3IEtleVZhbHVlRGlmZmVycyhrZXlWYWxEaWZmKTtcblxuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICAvLyBUT0RPIChtYXRza28pOiBhZGQgdHlwaW5nIGZvciB0aGUgYW5pbWF0aW9uIGZ1bmN0aW9uXG4gICAgdmFyIFJlbmRlckNvbXBvbmVudFR5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZW5kZXJDb21wb25lbnRUeXBlKGlkLCB0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMsIGFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcbiAgICAgICAgICAgIHRoaXMuc2xvdENvdW50ID0gc2xvdENvdW50O1xuICAgICAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVuZGVyQ29tcG9uZW50VHlwZTtcbiAgICB9KCkpO1xuICAgIHZhciBSZW5kZXJEZWJ1Z0luZm8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZW5kZXJEZWJ1Z0luZm8oKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJjb21wb25lbnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJwcm92aWRlclRva2Vuc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwic291cmNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlbmRlckRlYnVnSW5mbztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBJbmplY3RhYmxlIHNlcnZpY2UgdGhhdCBwcm92aWRlcyBhIGxvdy1sZXZlbCBpbnRlcmZhY2UgZm9yIG1vZGlmeWluZyB0aGUgVUkuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBzZXJ2aWNlIHRvIGJ5cGFzcyBBbmd1bGFyJ3MgdGVtcGxhdGluZyBhbmQgbWFrZSBjdXN0b20gVUkgY2hhbmdlcyB0aGF0IGNhbid0IGJlXG4gICAgICogZXhwcmVzc2VkIGRlY2xhcmF0aXZlbHkuIEZvciBleGFtcGxlIGlmIHlvdSBuZWVkIHRvIHNldCBhIHByb3BlcnR5IG9yIGFuIGF0dHJpYnV0ZSB3aG9zZSBuYW1lIGlzXG4gICAgICogbm90IHN0YXRpY2FsbHkga25vd24sIHVzZSB7QGxpbmsgI3NldEVsZW1lbnRQcm9wZXJ0eX0gb3Ige0BsaW5rICNzZXRFbGVtZW50QXR0cmlidXRlfVxuICAgICAqIHJlc3BlY3RpdmVseS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBhcmUgaW1wbGVtZW50aW5nIGEgY3VzdG9tIHJlbmRlcmVyLCB5b3UgbXVzdCBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBSZW5kZXJlciBpbXBsZW1lbnRhdGlvbiBpcyBgRG9tUmVuZGVyZXJgLiBBbHNvIGF2YWlsYWJsZSBpcyBgV2ViV29ya2VyUmVuZGVyZXJgLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm9vdFJlbmRlcmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSb290UmVuZGVyZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIFNlY3VyaXR5Q29udGV4dCBtYXJrcyBhIGxvY2F0aW9uIHRoYXQgaGFzIGRhbmdlcm91cyBzZWN1cml0eSBpbXBsaWNhdGlvbnMsIGUuZy4gYSBET00gcHJvcGVydHlcbiAgICAgKiBsaWtlIGBpbm5lckhUTUxgIHRoYXQgY291bGQgY2F1c2UgQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgKFhTUykgc2VjdXJpdHkgYnVncyB3aGVuIGltcHJvcGVybHlcbiAgICAgKiBoYW5kbGVkLlxuICAgICAqXG4gICAgICogU2VlIERvbVNhbml0aXplciBmb3IgbW9yZSBkZXRhaWxzIG9uIHNlY3VyaXR5IGluIEFuZ3VsYXIgYXBwbGljYXRpb25zLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIGV4cG9ydHMuU2VjdXJpdHlDb250ZXh0O1xuICAgIChmdW5jdGlvbiAoU2VjdXJpdHlDb250ZXh0KSB7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICAgICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIkhUTUxcIl0gPSAxXSA9IFwiSFRNTFwiO1xuICAgICAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiU1RZTEVcIl0gPSAyXSA9IFwiU1RZTEVcIjtcbiAgICAgICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlNDUklQVFwiXSA9IDNdID0gXCJTQ1JJUFRcIjtcbiAgICAgICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlVSTFwiXSA9IDRdID0gXCJVUkxcIjtcbiAgICAgICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlJFU09VUkNFX1VSTFwiXSA9IDVdID0gXCJSRVNPVVJDRV9VUkxcIjtcbiAgICB9KShleHBvcnRzLlNlY3VyaXR5Q29udGV4dCB8fCAoZXhwb3J0cy5TZWN1cml0eUNvbnRleHQgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFNhbml0aXplciBpcyB1c2VkIGJ5IHRoZSB2aWV3cyB0byBzYW5pdGl6ZSBwb3RlbnRpYWxseSBkYW5nZXJvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBTYW5pdGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTYW5pdGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNhbml0aXplcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIHRocm93biBpZiBhcHBsaWNhdGlvbiBjaGFuZ2VzIG1vZGVsIGJyZWFraW5nIHRoZSB0b3AtZG93biBkYXRhIGZsb3cuXG4gICAgICpcbiAgICAgKiBUaGlzIGV4Y2VwdGlvbiBpcyBvbmx5IHRocm93biBpbiBkZXYgbW9kZS5cbiAgICAgKlxuICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayBvbmNlIHRoZSBkZXYgbW9kZSBvcHRpb24gaXMgY29uZmlndXJhYmxlIC0tPlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAncGFyZW50JyxcbiAgICAgKiAgIHRlbXBsYXRlOiAnPGNoaWxkIFtwcm9wXT1cInBhcmVudFByb3BcIj48L2NoaWxkPicsXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBQYXJlbnQge1xuICAgICAqICAgcGFyZW50UHJvcCA9ICdpbml0JztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2NoaWxkJywgaW5wdXRzOiBbJ3Byb3AnXX0pXG4gICAgICogY2xhc3MgQ2hpbGQge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIHBhcmVudDogUGFyZW50KSB7fVxuICAgICAqXG4gICAgICogICBzZXQgcHJvcCh2KSB7XG4gICAgICogICAgIC8vIHRoaXMgdXBkYXRlcyB0aGUgcGFyZW50IHByb3BlcnR5LCB3aGljaCBpcyBkaXNhbGxvd2VkIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICogICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvclxuICAgICAqICAgICB0aGlzLnBhcmVudC5wYXJlbnRQcm9wID0gJ3VwZGF0ZWQnO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKG9sZFZhbHVlLCBjdXJyVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBcIkV4cHJlc3Npb24gaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWQuIFByZXZpb3VzIHZhbHVlOiAnXCIgKyBvbGRWYWx1ZSArIFwiJy4gQ3VycmVudCB2YWx1ZTogJ1wiICsgY3VyclZhbHVlICsgXCInLlwiO1xuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09PSBVTklOSVRJQUxJWkVEKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9XG4gICAgICAgICAgICAgICAgICAgIFwiIEl0IHNlZW1zIGxpa2UgdGhlIHZpZXcgaGFzIGJlZW4gY3JlYXRlZCBhZnRlciBpdHMgcGFyZW50IGFuZCBpdHMgY2hpbGRyZW4gaGF2ZSBiZWVuIGRpcnR5IGNoZWNrZWQuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgSGFzIGl0IGJlZW4gY3JlYXRlZCBpbiBhIGNoYW5nZSBkZXRlY3Rpb24gaG9vayA/XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYW4gZXhjZXB0aW9uIHdhcyByYWlzZWQgZHVyaW5nIHZpZXcgY3JlYXRpb24sIGNoYW5nZSBkZXRlY3Rpb24gb3IgZGVzdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGVycm9yIHdyYXBzIHRoZSBvcmlnaW5hbCBleGNlcHRpb24gdG8gYXR0YWNoIGFkZGl0aW9uYWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiB0aGF0IGNhblxuICAgICAqIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld1dyYXBwZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KFZpZXdXcmFwcGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdXcmFwcGVkRXJyb3Iob3JpZ2luYWxFcnJvciwgY29udGV4dCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJFcnJvciBpbiBcIiArIGNvbnRleHQuc291cmNlLCBvcmlnaW5hbEVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFZpZXdXcmFwcGVkRXJyb3I7XG4gICAgfShXcmFwcGVkRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhIGRlc3Ryb3llZCB2aWV3IGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGVycm9yIGluZGljYXRlcyBhIGJ1ZyBpbiB0aGUgZnJhbWV3b3JrLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBBbmd1bGFyIGVycm9yLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld0Rlc3Ryb3llZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoVmlld0Rlc3Ryb3llZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBWaWV3RGVzdHJveWVkRXJyb3IoZGV0YWlscykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJBdHRlbXB0IHRvIHVzZSBhIGRlc3Ryb3llZCB2aWV3OiBcIiArIGRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaWV3RGVzdHJveWVkRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcblxuICAgIHZhciBWaWV3VXRpbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3VXRpbHMoX3JlbmRlcmVyLCBzYW5pdGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fbmV4dENvbXBUeXBlSWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBWaWV3VXRpbHMucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChyZW5kZXJDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucmVuZGVyQ29tcG9uZW50KHJlbmRlckNvbXBvbmVudFR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3VXRpbHMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVmlld1V0aWxzLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBSb290UmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNhbml0aXplciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFZpZXdVdGlscztcbiAgICB9KCkpO1xuICAgIHZhciBuZXh0UmVuZGVyQ29tcG9uZW50VHlwZUlkID0gMDtcbiAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJDb21wb25lbnRUeXBlKHRlbXBsYXRlVXJsLCBzbG90Q291bnQsIGVuY2Fwc3VsYXRpb24sIHN0eWxlcywgYW5pbWF0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFJlbmRlckNvbXBvbmVudFR5cGUoXCJcIiArIG5leHRSZW5kZXJDb21wb25lbnRUeXBlSWQrKywgdGVtcGxhdGVVcmwsIHNsb3RDb3VudCwgZW5jYXBzdWxhdGlvbiwgc3R5bGVzLCBhbmltYXRpb25zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVG9BcnJheShlLCBhcnJheSkge1xuICAgICAgICBhcnJheS5wdXNoKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh2YWx1ZUNvdW50LCBjb25zdEFuZEludGVycCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVDb3VudCAqIDI7IGkgPSBpICsgMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgY29uc3RBbmRJbnRlcnBbaV0gKyBfdG9TdHJpbmdXaXRoTnVsbChjb25zdEFuZEludGVycFtpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBjb25zdEFuZEludGVycFt2YWx1ZUNvdW50ICogMl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlubGluZUludGVycG9sYXRlKHZhbHVlQ291bnQsIGMwLCBhMSwgYzEsIGEyLCBjMiwgYTMsIGMzLCBhNCwgYzQsIGE1LCBjNSwgYTYsIGM2LCBhNywgYzcsIGE4LCBjOCwgYTksIGM5KSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWVDb3VudCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzI7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgICAgIGMzO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0O1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzU7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgICAgIGMzICsgX3RvU3RyaW5nV2l0aE51bGwoYTQpICsgYzQgKyBfdG9TdHJpbmdXaXRoTnVsbChhNSkgKyBjNSArIF90b1N0cmluZ1dpdGhOdWxsKGE2KSArIGM2O1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3O1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3ICsgX3RvU3RyaW5nV2l0aE51bGwoYTgpICsgYzg7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgICAgIGMzICsgX3RvU3RyaW5nV2l0aE51bGwoYTQpICsgYzQgKyBfdG9TdHJpbmdXaXRoTnVsbChhNSkgKyBjNSArIF90b1N0cmluZ1dpdGhOdWxsKGE2KSArXG4gICAgICAgICAgICAgICAgICAgIGM2ICsgX3RvU3RyaW5nV2l0aE51bGwoYTcpICsgYzcgKyBfdG9TdHJpbmdXaXRoTnVsbChhOCkgKyBjOCArIF90b1N0cmluZ1dpdGhOdWxsKGE5KSArIGM5O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb2VzIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiA5IGV4cHJlc3Npb25zXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90b1N0cmluZ1dpdGhOdWxsKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgIT0gbnVsbCA/IHYudG9TdHJpbmcoKSA6ICcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0JpbmRpbmcodGhyb3dPbkNoYW5nZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIWRldk1vZGVFcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3Iob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhbG9vc2VJZGVudGljYWwob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYXN0QnlWYWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICB2YXIgRU1QVFlfQVJSQVkgPSBbXTtcbiAgICB2YXIgRU1QVFlfTUFQID0ge307XG4gICAgZnVuY3Rpb24gcHVyZVByb3h5MShmbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdjAgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTIoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIHYxID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVyZVByb3h5Myhmbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdjAgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICB2YXIgdjEgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICB2YXIgdjIgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVyZVByb3h5NChmbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdjAsIHYxLCB2MiwgdjM7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMykge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTUoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NDtcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVyZVByb3h5Nihmbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NTtcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgcDQsIHA1KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgICAgICB2NSA9IHA1O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVyZVByb3h5Nyhmbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjY7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IHY2ID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNikge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjYsIHA2KSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgICAgICB2NSA9IHA1O1xuICAgICAgICAgICAgICAgIHY2ID0gcDY7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVyZVByb3h5OChmbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IHY3ID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikgfHwgIWxvb3NlSWRlbnRpY2FsKHY3LCBwNykpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTkoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2Nywgdjg7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IHY2ID0gdjcgPSB2OCA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3LCBwOCkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjYsIHA2KSB8fCAhbG9vc2VJZGVudGljYWwodjcsIHA3KSB8fCAhbG9vc2VJZGVudGljYWwodjgsIHA4KSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgICAgICB2NSA9IHA1O1xuICAgICAgICAgICAgICAgIHY2ID0gcDY7XG4gICAgICAgICAgICAgICAgdjcgPSBwNztcbiAgICAgICAgICAgICAgICB2OCA9IHA4O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVyZVByb3h5MTAoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IHY3ID0gdjggPSB2OSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3LCBwOCwgcDkpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikgfHwgIWxvb3NlSWRlbnRpY2FsKHY3LCBwNykgfHwgIWxvb3NlSWRlbnRpY2FsKHY4LCBwOCkgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjksIHA5KSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgICAgICB2NSA9IHA1O1xuICAgICAgICAgICAgICAgIHY2ID0gcDY7XG4gICAgICAgICAgICAgICAgdjcgPSBwNztcbiAgICAgICAgICAgICAgICB2OCA9IHA4O1xuICAgICAgICAgICAgICAgIHY5ID0gcDk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3LCBwOCwgcDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXMocmVuZGVyZXIsIGVsLCBjaGFuZ2VzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICBzZXRCaW5kaW5nRGVidWdJbmZvKHJlbmRlcmVyLCBlbCwgcHJvcE5hbWUsIGNoYW5nZXNbcHJvcE5hbWVdLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRCaW5kaW5nRGVidWdJbmZvKHJlbmRlcmVyLCBlbCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRCaW5kaW5nRGVidWdJbmZvKGVsLCBcIm5nLXJlZmxlY3QtXCIgKyBjYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BOYW1lKSwgdmFsdWUgPyB2YWx1ZS50b1N0cmluZygpIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEJpbmRpbmdEZWJ1Z0luZm8oZWwsIFwibmctcmVmbGVjdC1cIiArIGNhbWVsQ2FzZVRvRGFzaENhc2UocHJvcE5hbWUpLCAnW0VSUk9SXSBFeGNlcHRpb24gd2hpbGUgdHJ5aW5nIHRvIHNlcmlhbGl6ZSB0aGUgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgQ0FNRUxfQ0FTRV9SRUdFWFAgPSAvKFtBLVpdKS9nO1xuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaENhc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoQ0FNRUxfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIG1bX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJy0nICsgbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyRWxlbWVudChyZW5kZXJlciwgcGFyZW50RWxlbWVudCwgbmFtZSwgYXR0cnMsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgZWwgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KHBhcmVudEVsZW1lbnQsIG5hbWUsIGRlYnVnSW5mbyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEVsZW1lbnRBdHRyaWJ1dGUoZWwsIGF0dHJzLmdldChpKSwgYXR0cnMuZ2V0KGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50KHJlbmRlcmVyLCBlbGVtZW50TmFtZSwgYXR0cnMsIHJvb3RTZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKSB7XG4gICAgICAgIHZhciBob3N0RWxlbWVudDtcbiAgICAgICAgaWYgKGlzUHJlc2VudChyb290U2VsZWN0b3JPck5vZGUpKSB7XG4gICAgICAgICAgICBob3N0RWxlbWVudCA9IHJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KHJvb3RTZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50QXR0cmlidXRlKGhvc3RFbGVtZW50LCBhdHRycy5nZXQoaSksIGF0dHJzLmdldChpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdEVsZW1lbnQgPSBjcmVhdGVSZW5kZXJFbGVtZW50KHJlbmRlcmVyLCBudWxsLCBlbGVtZW50TmFtZSwgYXR0cnMsIGRlYnVnSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvc3RFbGVtZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmVUb1JlbmRlckVsZW1lbnQodmlldywgZWxlbWVudCwgZXZlbnROYW1lc0FuZFRhcmdldHMsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBkaXNwb3NhYmxlcyA9IGNyZWF0ZUVtcHR5SW5saW5lQXJyYXkoZXZlbnROYW1lc0FuZFRhcmdldHMubGVuZ3RoIC8gMik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnROYW1lc0FuZFRhcmdldHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudE5hbWVzQW5kVGFyZ2V0cy5nZXQoaSk7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBldmVudE5hbWVzQW5kVGFyZ2V0cy5nZXQoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGRpc3Bvc2FibGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdmlldy5yZW5kZXJlci5saXN0ZW5HbG9iYWwoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXIuYmluZCh2aWV3LCBldmVudFRhcmdldCArIFwiOlwiICsgZXZlbnROYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdmlldy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgZXZlbnROYW1lLCBsaXN0ZW5lci5iaW5kKHZpZXcsIGV2ZW50TmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcG9zYWJsZXMuc2V0KGkgLyAyLCBkaXNwb3NhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcG9zZUlubGluZUFycmF5LmJpbmQobnVsbCwgZGlzcG9zYWJsZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwb3NlSW5saW5lQXJyYXkoZGlzcG9zYWJsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwb3NhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGlzcG9zYWJsZXMuZ2V0KGkpKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVtcHR5SW5saW5lQXJyYXkobGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdG9yO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheTQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDgpIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheTg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDE2KSB7XG4gICAgICAgICAgICBjdG9yID0gSW5saW5lQXJyYXkxNjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheUR5bmFtaWM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKGxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBJbmxpbmVBcnJheTAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTAoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXkwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICAgICAgSW5saW5lQXJyYXkwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7IH07XG4gICAgICAgIHJldHVybiBJbmxpbmVBcnJheTA7XG4gICAgfSgpKTtcbiAgICB2YXIgSW5saW5lQXJyYXkyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSW5saW5lQXJyYXkyKGxlbmd0aCwgX3YwLCBfdjEpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdjAgPSBfdjA7XG4gICAgICAgICAgICB0aGlzLl92MSA9IF92MTtcbiAgICAgICAgfVxuICAgICAgICBJbmxpbmVBcnJheTIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIElubGluZUFycmF5Mi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIElubGluZUFycmF5MjtcbiAgICB9KCkpO1xuICAgIHZhciBJbmxpbmVBcnJheTQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTQobGVuZ3RoLCBfdjAsIF92MSwgX3YyLCBfdjMpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdjAgPSBfdjA7XG4gICAgICAgICAgICB0aGlzLl92MSA9IF92MTtcbiAgICAgICAgICAgIHRoaXMuX3YyID0gX3YyO1xuICAgICAgICAgICAgdGhpcy5fdjMgPSBfdjM7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXk0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBJbmxpbmVBcnJheTQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSW5saW5lQXJyYXk0O1xuICAgIH0oKSk7XG4gICAgdmFyIElubGluZUFycmF5OCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIElubGluZUFycmF5OChsZW5ndGgsIF92MCwgX3YxLCBfdjIsIF92MywgX3Y0LCBfdjUsIF92NiwgX3Y3KSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3YwID0gX3YwO1xuICAgICAgICAgICAgdGhpcy5fdjEgPSBfdjE7XG4gICAgICAgICAgICB0aGlzLl92MiA9IF92MjtcbiAgICAgICAgICAgIHRoaXMuX3YzID0gX3YzO1xuICAgICAgICAgICAgdGhpcy5fdjQgPSBfdjQ7XG4gICAgICAgICAgICB0aGlzLl92NSA9IF92NTtcbiAgICAgICAgICAgIHRoaXMuX3Y2ID0gX3Y2O1xuICAgICAgICAgICAgdGhpcy5fdjcgPSBfdjc7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXk4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NDtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NjtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBJbmxpbmVBcnJheTgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92NSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Y2ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjcgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBJbmxpbmVBcnJheTg7XG4gICAgfSgpKTtcbiAgICB2YXIgSW5saW5lQXJyYXkxNiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIElubGluZUFycmF5MTYobGVuZ3RoLCBfdjAsIF92MSwgX3YyLCBfdjMsIF92NCwgX3Y1LCBfdjYsIF92NywgX3Y4LCBfdjksIF92MTAsIF92MTEsIF92MTIsIF92MTMsIF92MTQsIF92MTUpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdjAgPSBfdjA7XG4gICAgICAgICAgICB0aGlzLl92MSA9IF92MTtcbiAgICAgICAgICAgIHRoaXMuX3YyID0gX3YyO1xuICAgICAgICAgICAgdGhpcy5fdjMgPSBfdjM7XG4gICAgICAgICAgICB0aGlzLl92NCA9IF92NDtcbiAgICAgICAgICAgIHRoaXMuX3Y1ID0gX3Y1O1xuICAgICAgICAgICAgdGhpcy5fdjYgPSBfdjY7XG4gICAgICAgICAgICB0aGlzLl92NyA9IF92NztcbiAgICAgICAgICAgIHRoaXMuX3Y4ID0gX3Y4O1xuICAgICAgICAgICAgdGhpcy5fdjkgPSBfdjk7XG4gICAgICAgICAgICB0aGlzLl92MTAgPSBfdjEwO1xuICAgICAgICAgICAgdGhpcy5fdjExID0gX3YxMTtcbiAgICAgICAgICAgIHRoaXMuX3YxMiA9IF92MTI7XG4gICAgICAgICAgICB0aGlzLl92MTMgPSBfdjEzO1xuICAgICAgICAgICAgdGhpcy5fdjE0ID0gX3YxNDtcbiAgICAgICAgICAgIHRoaXMuX3YxNSA9IF92MTU7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXkxNi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjA7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjE7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjI7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjM7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjQ7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjU7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjY7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjc7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjg7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjk7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjExO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTI7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxMztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjE0O1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgSW5saW5lQXJyYXkxNi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92NCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Y1ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92NyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Y4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjEwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YxMSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MTIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjEzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YxNCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MTUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBJbmxpbmVBcnJheTE2O1xuICAgIH0oKSk7XG4gICAgdmFyIElubGluZUFycmF5RHluYW1pYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5vdGU6IFdlIHN0aWxsIHRha2UgdGhlIGxlbmd0aCBhcmd1bWVudCBzbyB0aGlzIGNsYXNzIGNhbiBiZSBjcmVhdGVkXG4gICAgICAgIC8vIGluIHRoZSBzYW1lIHdheXMgYXMgdGhlIG90aGVyIGNsYXNzZXMhXG4gICAgICAgIGZ1bmN0aW9uIElubGluZUFycmF5RHluYW1pYyhsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgSW5saW5lQXJyYXlEeW5hbWljLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tpbmRleF07IH07XG4gICAgICAgIElubGluZUFycmF5RHluYW1pYy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkgeyB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7IH07XG4gICAgICAgIHJldHVybiBJbmxpbmVBcnJheUR5bmFtaWM7XG4gICAgfSgpKTtcbiAgICB2YXIgRU1QVFlfSU5MSU5FX0FSUkFZID0gbmV3IElubGluZUFycmF5MCgpO1xuXG5cbiAgICB2YXIgdmlld191dGlscyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBWaWV3VXRpbHM6IFZpZXdVdGlscyxcbiAgICAgICAgY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZTogY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZSxcbiAgICAgICAgYWRkVG9BcnJheTogYWRkVG9BcnJheSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICBpbmxpbmVJbnRlcnBvbGF0ZTogaW5saW5lSW50ZXJwb2xhdGUsXG4gICAgICAgIGNoZWNrQmluZGluZzogY2hlY2tCaW5kaW5nLFxuICAgICAgICBjYXN0QnlWYWx1ZTogY2FzdEJ5VmFsdWUsXG4gICAgICAgIEVNUFRZX0FSUkFZOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgRU1QVFlfTUFQOiBFTVBUWV9NQVAsXG4gICAgICAgIHB1cmVQcm94eTE6IHB1cmVQcm94eTEsXG4gICAgICAgIHB1cmVQcm94eTI6IHB1cmVQcm94eTIsXG4gICAgICAgIHB1cmVQcm94eTM6IHB1cmVQcm94eTMsXG4gICAgICAgIHB1cmVQcm94eTQ6IHB1cmVQcm94eTQsXG4gICAgICAgIHB1cmVQcm94eTU6IHB1cmVQcm94eTUsXG4gICAgICAgIHB1cmVQcm94eTY6IHB1cmVQcm94eTYsXG4gICAgICAgIHB1cmVQcm94eTc6IHB1cmVQcm94eTcsXG4gICAgICAgIHB1cmVQcm94eTg6IHB1cmVQcm94eTgsXG4gICAgICAgIHB1cmVQcm94eTk6IHB1cmVQcm94eTksXG4gICAgICAgIHB1cmVQcm94eTEwOiBwdXJlUHJveHkxMCxcbiAgICAgICAgc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXM6IHNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzLFxuICAgICAgICBzZXRCaW5kaW5nRGVidWdJbmZvOiBzZXRCaW5kaW5nRGVidWdJbmZvLFxuICAgICAgICBjcmVhdGVSZW5kZXJFbGVtZW50OiBjcmVhdGVSZW5kZXJFbGVtZW50LFxuICAgICAgICBzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50OiBzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50LFxuICAgICAgICBzdWJzY3JpYmVUb1JlbmRlckVsZW1lbnQ6IHN1YnNjcmliZVRvUmVuZGVyRWxlbWVudCxcbiAgICAgICAgbm9vcDogbm9vcCxcbiAgICAgICAgSW5saW5lQXJyYXkyOiBJbmxpbmVBcnJheTIsXG4gICAgICAgIElubGluZUFycmF5NDogSW5saW5lQXJyYXk0LFxuICAgICAgICBJbmxpbmVBcnJheTg6IElubGluZUFycmF5OCxcbiAgICAgICAgSW5saW5lQXJyYXkxNjogSW5saW5lQXJyYXkxNixcbiAgICAgICAgSW5saW5lQXJyYXlEeW5hbWljOiBJbmxpbmVBcnJheUR5bmFtaWMsXG4gICAgICAgIEVNUFRZX0lOTElORV9BUlJBWTogRU1QVFlfSU5MSU5FX0FSUkFZXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhIENvbXBvbmVudCBjcmVhdGVkIHZpYSBhIHtAbGluayBDb21wb25lbnRGYWN0b3J5fS5cbiAgICAgKlxuICAgICAqIGBDb21wb25lbnRSZWZgIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgQ29tcG9uZW50IEluc3RhbmNlIGFzIHdlbGwgb3RoZXIgb2JqZWN0cyByZWxhdGVkIHRvIHRoaXNcbiAgICAgKiBDb21wb25lbnQgSW5zdGFuY2UgYW5kIGFsbG93cyB5b3UgdG8gZGVzdHJveSB0aGUgQ29tcG9uZW50IEluc3RhbmNlIHZpYSB0aGUge0BsaW5rICNkZXN0cm95fVxuICAgICAqIG1ldGhvZC5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvY2F0aW9uIG9mIHRoZSBIb3N0IEVsZW1lbnQgb2YgdGhpcyBDb21wb25lbnQgSW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5qZWN0b3Igb24gd2hpY2ggdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5zdGFuY2Ugb2YgdGhlIENvbXBvbmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImhvc3RWaWV3XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHtAbGluayBWaWV3UmVmfSBvZiB0aGUgSG9zdCBWaWV3IG9mIHRoaXMgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUge0BsaW5rIENoYW5nZURldGVjdG9yUmVmfSBvZiB0aGUgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBDb21wb25lbnRSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDUoQ29tcG9uZW50UmVmXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50UmVmXyhfaW5kZXgsIF9wYXJlbnRWaWV3LCBfbmF0aXZlRWxlbWVudCwgX2NvbXBvbmVudCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IF9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudFZpZXcgPSBfcGFyZW50VmlldztcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUVsZW1lbnQgPSBfbmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudCA9IF9jb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImxvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVsZW1lbnRSZWYodGhpcy5fbmF0aXZlRWxlbWVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnRWaWV3LmluamVjdG9yKHRoaXMuX2luZGV4KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbXBvbmVudDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImhvc3RWaWV3XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Vmlldy5yZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJjaGFuZ2VEZXRlY3RvclJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudFZpZXcucmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbXBvbmVudC5jb25zdHJ1Y3RvcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIENvbXBvbmVudFJlZl8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BhcmVudFZpZXcuZGV0YWNoQW5kRGVzdHJveSgpOyB9O1xuICAgICAgICBDb21wb25lbnRSZWZfLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5ob3N0Vmlldy5vbkRlc3Ryb3koY2FsbGJhY2spOyB9O1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50UmVmXztcbiAgICB9KENvbXBvbmVudFJlZikpO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIF92aWV3Q2xhc3MsIF9jb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q2xhc3MgPSBfdmlld0NsYXNzO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50VHlwZSA9IF9jb21wb25lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRGYWN0b3J5LnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29tcG9uZW50VHlwZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvamVjdGFibGVOb2RlcyA9PT0gdm9pZCAwKSB7IHByb2plY3RhYmxlTm9kZXMgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAocm9vdFNlbGVjdG9yT3JOb2RlID09PSB2b2lkIDApIHsgcm9vdFNlbGVjdG9yT3JOb2RlID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIHZ1ID0gaW5qZWN0b3IuZ2V0KFZpZXdVdGlscyk7XG4gICAgICAgICAgICBpZiAoIXByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG9zdFZpZXcgPSBuZXcgdGhpcy5fdmlld0NsYXNzKHZ1LCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBob3N0Vmlldy5jcmVhdGVIb3N0Vmlldyhyb290U2VsZWN0b3JPck5vZGUsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3Rvcnk7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5vQ29tcG9uZW50RmFjdG9yeUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDcoTm9Db21wb25lbnRGYWN0b3J5RXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5vQ29tcG9uZW50RmFjdG9yeUVycm9yKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJObyBjb21wb25lbnQgZmFjdG9yeSBmb3VuZCBmb3IgXCIgKyBzdHJpbmdpZnkoY29tcG9uZW50KSk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9Db21wb25lbnRGYWN0b3J5RXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICB2YXIgX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9Db21wb25lbnRGYWN0b3J5RXJyb3IoY29tcG9uZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLk5VTEwgPSBuZXcgX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9KCkpO1xuICAgIHZhciBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihmYWN0b3JpZXMsIF9wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gZmFjdG9yaWVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhY3Rvcmllcy5zZXQoZmFjdG9yeS5jb21wb25lbnRUeXBlLCBmYWN0b3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mYWN0b3JpZXMuZ2V0KGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3BhcmVudC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciB0cmFjZTtcbiAgICB2YXIgZXZlbnRzO1xuICAgIGZ1bmN0aW9uIGRldGVjdFdURigpIHtcbiAgICAgICAgdmFyIHd0ZiA9IGdsb2JhbCQxWyd3dGYnXTtcbiAgICAgICAgaWYgKHd0Zikge1xuICAgICAgICAgICAgdHJhY2UgPSB3dGZbJ3RyYWNlJ107XG4gICAgICAgICAgICBpZiAodHJhY2UpIHtcbiAgICAgICAgICAgICAgICBldmVudHMgPSB0cmFjZVsnZXZlbnRzJ107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVTY29wZShzaWduYXR1cmUsIGZsYWdzKSB7XG4gICAgICAgIGlmIChmbGFncyA9PT0gdm9pZCAwKSB7IGZsYWdzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gZXZlbnRzLmNyZWF0ZVNjb3BlKHNpZ25hdHVyZSwgZmxhZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZWF2ZShzY29wZSwgcmV0dXJuVmFsdWUpIHtcbiAgICAgICAgdHJhY2UubGVhdmVTY29wZShzY29wZSwgcmV0dXJuVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0VGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cmFjZS5iZWdpblRpbWVSYW5nZShyYW5nZVR5cGUsIGFjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZFRpbWVSYW5nZShyYW5nZSkge1xuICAgICAgICB0cmFjZS5lbmRUaW1lUmFuZ2UocmFuZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgV1RGIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgdmFyIHd0ZkVuYWJsZWQgPSBkZXRlY3RXVEYoKTtcbiAgICBmdW5jdGlvbiBub29wU2NvcGUoYXJnMCwgYXJnMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRyYWNlIHNjb3BlLlxuICAgICAqXG4gICAgICogU2NvcGVzIG11c3QgYmUgc3RyaWN0bHkgbmVzdGVkIGFuZCBhcmUgYW5hbG9nb3VzIHRvIHN0YWNrIGZyYW1lcywgYnV0XG4gICAgICogZG8gbm90IGhhdmUgdG8gZm9sbG93IHRoZSBzdGFjayBmcmFtZXMuIEluc3RlYWQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB0aGV5IGZvbGxvdyBsb2dpY2FsXG4gICAgICogbmVzdGluZy4gWW91IG1heSB3YW50IHRvIHVzZVxuICAgICAqIFtFdmVudFxuICAgICAqIFNpZ25hdHVyZXNdKGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL3RyYWNpbmctZnJhbWV3b3JrL2luc3RydW1lbnRpbmctY29kZS5odG1sI2N1c3RvbS1ldmVudHMpXG4gICAgICogYXMgdGhleSBhcmUgZGVmaW5lZCBpbiBXVEYuXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIG1hcmsgc2NvcGUgZW50cnkuIFRoZSByZXR1cm4gdmFsdWUgaXMgdXNlZCB0byBsZWF2ZSB0aGUgc2NvcGUuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIG15U2NvcGUgPSB3dGZDcmVhdGVTY29wZSgnTXlDbGFzcyNteU1ldGhvZChhc2NpaSBzb21lVmFsKScpO1xuICAgICAqXG4gICAgICogICAgIHNvbWVNZXRob2QoKSB7XG4gICAgICogICAgICAgIHZhciBzID0gbXlTY29wZSgnRm9vJyk7IC8vICdGb28nIGdldHMgc3RvcmVkIGluIHRyYWNpbmcgVUlcbiAgICAgKiAgICAgICAgLy8gRE8gU09NRSBXT1JLIEhFUkVcbiAgICAgKiAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIDEyMyk7IC8vIFJldHVybiB2YWx1ZSAxMjNcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogTm90ZSwgYWRkaW5nIHRyeS1maW5hbGx5IGJsb2NrIGFyb3VuZCB0aGUgd29yayB0byBlbnN1cmUgdGhhdCBgd3RmTGVhdmVgIGdldHMgY2FsbGVkIGNhblxuICAgICAqIG5lZ2F0aXZlbHkgaW1wYWN0IHRoZSBwZXJmb3JtYW5jZSBvZiB5b3VyIGFwcGxpY2F0aW9uLiBGb3IgdGhpcyByZWFzb24gd2UgcmVjb21tZW5kIHRoYXRcbiAgICAgKiB5b3UgZG9uJ3QgYWRkIHRoZW0gdG8gZW5zdXJlIHRoYXQgYHd0ZkxlYXZlYCBnZXRzIGNhbGxlZC4gSW4gcHJvZHVjdGlvbiBgd3RmTGVhdmVgIGlzIGEgbm9vcCBhbmRcbiAgICAgKiBzbyB0cnktZmluYWxseSBibG9jayBoYXMgbm8gdmFsdWUuIFdoZW4gZGVidWdnaW5nIHBlcmYgaXNzdWVzLCBza2lwcGluZyBgd3RmTGVhdmVgLCBkbyB0b1xuICAgICAqIGV4Y2VwdGlvbiwgd2lsbCBwcm9kdWNlIGluY29ycmVjdCB0cmFjZSwgYnV0IHByZXNlbmNlIG9mIGV4Y2VwdGlvbiBzaWduaWZpZXMgbG9naWMgZXJyb3Igd2hpY2hcbiAgICAgKiBuZWVkcyB0byBiZSBmaXhlZCBiZWZvcmUgdGhlIGFwcCBzaG91bGQgYmUgcHJvZmlsZWQuIEFkZCB0cnktZmluYWxseSBvbmx5IHdoZW4geW91IGV4cGVjdCB0aGF0XG4gICAgICogYW4gZXhjZXB0aW9uIGlzIGV4cGVjdGVkIGR1cmluZyBub3JtYWwgZXhlY3V0aW9uIHdoaWxlIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmQ3JlYXRlU2NvcGUgPSB3dGZFbmFibGVkID8gY3JlYXRlU2NvcGUgOiBmdW5jdGlvbiAoc2lnbmF0dXJlLCBmbGFncykgeyByZXR1cm4gbm9vcFNjb3BlOyB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbWFyayBlbmQgb2YgU2NvcGUuXG4gICAgICpcbiAgICAgKiAtIGBzY29wZWAgdG8gZW5kLlxuICAgICAqIC0gYHJldHVyblZhbHVlYCAob3B0aW9uYWwpIHRvIGJlIHBhc3NlZCB0byB0aGUgV1RGLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgYHJldHVyblZhbHVlIGZvciBlYXN5IGNoYWluaW5nLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmTGVhdmUgPSB3dGZFbmFibGVkID8gbGVhdmUgOiBmdW5jdGlvbiAocywgcikgeyByZXR1cm4gcjsgfTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIG1hcmsgQXN5bmMgc3RhcnQuIEFzeW5jIGFyZSBzaW1pbGFyIHRvIHNjb3BlIGJ1dCB0aGV5IGRvbid0IGhhdmUgdG8gYmUgc3RyaWN0bHkgbmVzdGVkLlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbiB0aGUgY2FsbCB0byBbZW5kQXN5bmNdLiBBc3luYyByYW5nZXMgb25seSB3b3JrIGlmIFdURiBoYXMgYmVlblxuICAgICAqIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiAgICAgc29tZU1ldGhvZCgpIHtcbiAgICAgKiAgICAgICAgdmFyIHMgPSB3dGZTdGFydFRpbWVSYW5nZSgnSFRUUDpHRVQnLCAnc29tZS51cmwnKTtcbiAgICAgKiAgICAgICAgdmFyIGZ1dHVyZSA9IG5ldyBGdXR1cmUuZGVsYXkoNSkudGhlbigoXykge1xuICAgICAqICAgICAgICAgIHd0ZkVuZFRpbWVSYW5nZShzKTtcbiAgICAgKiAgICAgICAgfSk7XG4gICAgICogICAgIH1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIHd0ZlN0YXJ0VGltZVJhbmdlID0gd3RmRW5hYmxlZCA/IHN0YXJ0VGltZVJhbmdlIDogZnVuY3Rpb24gKHJhbmdlVHlwZSwgYWN0aW9uKSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEVuZHMgYSBhc3luYyB0aW1lIHJhbmdlIG9wZXJhdGlvbi5cbiAgICAgKiBbcmFuZ2VdIGlzIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBbd3RmU3RhcnRUaW1lUmFuZ2VdIEFzeW5jIHJhbmdlcyBvbmx5IHdvcmsgaWYgV1RGIGhhcyBiZWVuXG4gICAgICogZW5hYmxlZC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIHd0ZkVuZFRpbWVSYW5nZSA9IHd0ZkVuYWJsZWQgPyBlbmRUaW1lUmFuZ2UgOiBmdW5jdGlvbiAocikgeyByZXR1cm4gbnVsbDsgfTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgYnkgZGlyZWN0aXZlcyBhbmQgY29tcG9uZW50cyB0byBlbWl0IGN1c3RvbSBFdmVudHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgYFppcHB5YCBhbHRlcm5hdGl2ZWx5IGVtaXRzIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgd2hlbiBpdHNcbiAgICAgKiB0aXRsZSBnZXRzIGNsaWNrZWQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnemlwcHknLFxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJ6aXBweVwiPlxuICAgICAqICAgICA8ZGl2IChjbGljayk9XCJ0b2dnbGUoKVwiPlRvZ2dsZTwvZGl2PlxuICAgICAqICAgICA8ZGl2IFtoaWRkZW5dPVwiIXZpc2libGVcIj5cbiAgICAgKiAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICA8L2Rpdj5gfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgWmlwcHkge1xuICAgICAqICAgdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgICogICBAT3V0cHV0KCkgb3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICogICBAT3V0cHV0KCkgY2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqXG4gICAgICogICB0b2dnbGUoKSB7XG4gICAgICogICAgIHRoaXMudmlzaWJsZSA9ICF0aGlzLnZpc2libGU7XG4gICAgICogICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgKiAgICAgICB0aGlzLm9wZW4uZW1pdChudWxsKTtcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICB0aGlzLmNsb3NlLmVtaXQobnVsbCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnRzIHBheWxvYWQgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZSBwYXJhbWV0ZXIgYCRldmVudGAgb24gdGhlIGNvbXBvbmVudHMgb3V0cHV0IGV2ZW50XG4gICAgICogaGFuZGxlcjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDx6aXBweSAob3Blbik9XCJvbk9wZW4oJGV2ZW50KVwiIChjbG9zZSk9XCJvbkNsb3NlKCRldmVudClcIj48L3ppcHB5PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVXNlcyBSeC5PYnNlcnZhYmxlIGJ1dCBwcm92aWRlcyBhbiBhZGFwdGVyIHRvIG1ha2UgaXQgd29yayBhcyBzcGVjaWZpZWQgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vamh1c2Fpbi9vYnNlcnZhYmxlLXNwZWNcbiAgICAgKlxuICAgICAqIE9uY2UgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWMgaXMgYXZhaWxhYmxlLCBzd2l0Y2ggdG8gaXQuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChFdmVudEVtaXR0ZXIsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFtFdmVudEVtaXR0ZXJdLCB3aGljaCBkZXBlbmRpbmcgb24gW2lzQXN5bmNdLFxuICAgICAgICAgKiBkZWxpdmVycyBldmVudHMgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihpc0FzeW5jKSB7XG4gICAgICAgICAgICBpZiAoaXNBc3luYyA9PT0gdm9pZCAwKSB7IGlzQXN5bmMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9faXNBc3luYyA9IGlzQXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTsgfTtcbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgICAgIHZhciBzY2hlZHVsZXJGbjtcbiAgICAgICAgICAgIHZhciBlcnJvckZuID0gZnVuY3Rpb24gKGVycikgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZUZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQgJiYgdHlwZW9mIGdlbmVyYXRvck9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0Lm5leHQodmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uIChlcnIpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikgeyBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoZXJyKTsgfSk7IH0gOiBmdW5jdGlvbiAoZXJyKSB7IGVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBsZXRlKCk7IH0pOyB9IDogZnVuY3Rpb24gKCkgeyBjb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnN1YnNjcmliZS5jYWxsKHRoaXMsIHNjaGVkdWxlckZuLCBlcnJvckZuLCBjb21wbGV0ZUZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9KHJ4anNfU3ViamVjdC5TdWJqZWN0KSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgZm9yIGV4ZWN1dGluZyB3b3JrIGluc2lkZSBvciBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICpcbiAgICAgKiBUaGUgbW9zdCBjb21tb24gdXNlIG9mIHRoaXMgc2VydmljZSBpcyB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSB3aGVuIHN0YXJ0aW5nIGEgd29yayBjb25zaXN0aW5nIG9mXG4gICAgICogb25lIG9yIG1vcmUgYXN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgcmVxdWlyZSBVSSB1cGRhdGVzIG9yIGVycm9yIGhhbmRsaW5nIHRvIGJlIGhhbmRsZWQgYnlcbiAgICAgKiBBbmd1bGFyLiBTdWNoIHRhc2tzIGNhbiBiZSBraWNrZWQgb2ZmIHZpYSB7QGxpbmsgcnVuT3V0c2lkZUFuZ3VsYXJ9IGFuZCBpZiBuZWVkZWQsIHRoZXNlIHRhc2tzXG4gICAgICogY2FuIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSB2aWEge0BsaW5rIHJ1bn0uXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IGFkZC9maXggbGlua3MgdG86XG4gICAgICogICAtIGRvY3MgZXhwbGFpbmluZyB6b25lcyBhbmQgdGhlIHVzZSBvZiB6b25lcyBpbiBBbmd1bGFyIGFuZCBjaGFuZ2UtZGV0ZWN0aW9uXG4gICAgICogICAtIGxpbmsgdG8gcnVuT3V0c2lkZUFuZ3VsYXIvcnVuICh0aHJvdWdob3V0IHRoaXMgZmlsZSEpXG4gICAgICogICAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHtDb21wb25lbnQsIE5nWm9uZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHtOZ0lmfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICAgICAqXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ25nLXpvbmUtZGVtbycuXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICA8aDI+RGVtbzogTmdab25lPC9oMj5cbiAgICAgKlxuICAgICAqICAgICA8cD5Qcm9ncmVzczoge3twcm9ncmVzc319JTwvcD5cbiAgICAgKiAgICAgPHAgKm5nSWY9XCJwcm9ncmVzcyA+PSAxMDBcIj5Eb25lIHByb2Nlc3Npbmcge3tsYWJlbH19IG9mIEFuZ3VsYXIgem9uZSE8L3A+XG4gICAgICpcbiAgICAgKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc1dpdGhpbkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIHdpdGhpbiBBbmd1bGFyIHpvbmU8L2J1dHRvbj5cbiAgICAgKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc091dHNpZGVPZkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIG91dHNpZGUgb2YgQW5ndWxhciB6b25lPC9idXR0b24+XG4gICAgICogICBgLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIE5nWm9uZURlbW8ge1xuICAgICAqICAgcHJvZ3Jlc3M6IG51bWJlciA9IDA7XG4gICAgICogICBsYWJlbDogc3RyaW5nO1xuICAgICAqXG4gICAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkge31cbiAgICAgKlxuICAgICAqICAgLy8gTG9vcCBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZVxuICAgICAqICAgLy8gc28gdGhlIFVJIERPRVMgcmVmcmVzaCBhZnRlciBlYWNoIHNldFRpbWVvdXQgY3ljbGVcbiAgICAgKiAgIHByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpIHtcbiAgICAgKiAgICAgdGhpcy5sYWJlbCA9ICdpbnNpZGUnO1xuICAgICAqICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgKiAgICAgdGhpcy5faW5jcmVhc2VQcm9ncmVzcygoKSA9PiBjb25zb2xlLmxvZygnSW5zaWRlIERvbmUhJykpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICAvLyBMb29wIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZVxuICAgICAqICAgLy8gc28gdGhlIFVJIERPRVMgTk9UIHJlZnJlc2ggYWZ0ZXIgZWFjaCBzZXRUaW1lb3V0IGN5Y2xlXG4gICAgICogICBwcm9jZXNzT3V0c2lkZU9mQW5ndWxhclpvbmUoKSB7XG4gICAgICogICAgIHRoaXMubGFiZWwgPSAnb3V0c2lkZSc7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgICAqICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAqICAgICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4ge1xuICAgICAqICAgICAgIC8vIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZGlzcGxheSBkb25lXG4gICAgICogICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7Y29uc29sZS5sb2coJ091dHNpZGUgRG9uZSEnKSB9KTtcbiAgICAgKiAgICAgfX0pKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgX2luY3JlYXNlUHJvZ3Jlc3MoZG9uZUNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3MgKz0gMTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgcHJvZ3Jlc3M6ICR7dGhpcy5wcm9ncmVzc30lYCk7XG4gICAgICpcbiAgICAgKiAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgPCAxMDApIHtcbiAgICAgKiAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjaykpLCAxMClcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICBkb25lQ2FsbGJhY2soKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nWm9uZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nWm9uZShfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EuZW5hYmxlTG9uZ1N0YWNrVHJhY2UsIGVuYWJsZUxvbmdTdGFja1RyYWNlID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgICAgICB0aGlzLl9oYXNQZW5kaW5nTWljcm90YXNrcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ01hY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX25lc3RpbmcgPSAwO1xuICAgICAgICAgICAgdGhpcy5fb25VbnN0YWJsZSA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fb25NaWNyb3Rhc2tFbXB0eSA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFibGUgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3JFdmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgWm9uZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW5ndWxhciByZXF1aXJlcyBab25lLmpzIHByb2x5ZmlsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFpvbmUuYXNzZXJ0Wm9uZVBhdGNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZXIgPSB0aGlzLmlubmVyID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKFpvbmVbJ3d0ZlpvbmVTcGVjJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gdGhpcy5pbm5lci5mb3JrKFpvbmVbJ3d0ZlpvbmVTcGVjJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuYWJsZUxvbmdTdGFja1RyYWNlICYmIFpvbmVbJ2xvbmdTdGFja1RyYWNlWm9uZVNwZWMnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSB0aGlzLmlubmVyLmZvcmsoWm9uZVsnbG9uZ1N0YWNrVHJhY2Vab25lU3BlYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ya0lubmVyWm9uZVdpdGhBbmd1bGFyQmVoYXZpb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBOZ1pvbmUuaXNJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gWm9uZS5jdXJyZW50LmdldCgnaXNBbmd1bGFyWm9uZScpID09PSB0cnVlOyB9O1xuICAgICAgICBOZ1pvbmUuYXNzZXJ0SW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyBub3QhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKE5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gbm90IGJlIGluIEFuZ3VsYXIgWm9uZSwgYnV0IGl0IGlzIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24gc3luY2hyb25vdXNseSB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZSBhbmQgcmV0dXJucyB2YWx1ZSByZXR1cm5lZCBieVxuICAgICAgICAgKiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFJ1bm5pbmcgZnVuY3Rpb25zIHZpYSBgcnVuYCBhbGxvd3MgeW91IHRvIHJlZW50ZXIgQW5ndWxhciB6b25lIGZyb20gYSB0YXNrIHRoYXQgd2FzIGV4ZWN1dGVkXG4gICAgICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZSAodHlwaWNhbGx5IHN0YXJ0ZWQgdmlhIHtAbGluayBydW5PdXRzaWRlQW5ndWxhcn0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAgICAgKiB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBzeW5jaHJvbm91cyBlcnJvciBoYXBwZW5zIGl0IHdpbGwgYmUgcmV0aHJvd24gYW5kIG5vdCByZXBvcnRlZCB2aWEgYG9uRXJyb3JgLlxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuaW5uZXIucnVuKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMgYHJ1bmAsIGV4Y2VwdCB0aGF0IHN5bmNocm9ub3VzIGVycm9ycyBhcmUgY2F1Z2h0IGFuZCBmb3J3YXJkZWQgdmlhIGBvbkVycm9yYCBhbmQgbm90XG4gICAgICAgICAqIHJldGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5ydW5HdWFyZGVkID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLmlubmVyLnJ1bkd1YXJkZWQoZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24gc3luY2hyb25vdXNseSBpbiBBbmd1bGFyJ3MgcGFyZW50IHpvbmUgYW5kIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bk91dHNpZGVBbmd1bGFyYCBhbGxvd3MgeW91IHRvIGVzY2FwZSBBbmd1bGFyJ3Mgem9uZSBhbmQgZG8gd29yayB0aGF0XG4gICAgICAgICAqIGRvZXNuJ3QgdHJpZ2dlciBBbmd1bGFyIGNoYW5nZS1kZXRlY3Rpb24gb3IgaXMgc3ViamVjdCB0byBBbmd1bGFyJ3MgZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBmdXR1cmUgdGFza3Mgb3IgbWljcm90YXNrcyBzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIGV4ZWN1dGluZyBmcm9tXG4gICAgICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHtAbGluayBydW59IHRvIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZG8gd29yayB0aGF0IHVwZGF0ZXMgdGhlIGFwcGxpY2F0aW9uIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5ydW5PdXRzaWRlQW5ndWxhciA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5vdXRlci5ydW4oZm4pOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvblVuc3RhYmxlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZpZXMgd2hlbiBjb2RlIGVudGVycyBBbmd1bGFyIFpvbmUuIFRoaXMgZ2V0cyBmaXJlZCBmaXJzdCBvbiBWTSBUdXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uVW5zdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvbk1pY3JvdGFza0VtcHR5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZpZXMgd2hlbiB0aGVyZSBpcyBubyBtb3JlIG1pY3JvdGFza3MgZW5xdWV1ZSBpbiB0aGUgY3VycmVudCBWTSBUdXJuLlxuICAgICAgICAgICAgICogVGhpcyBpcyBhIGhpbnQgZm9yIEFuZ3VsYXIgdG8gZG8gY2hhbmdlIGRldGVjdGlvbiwgd2hpY2ggbWF5IGVucXVldWUgbW9yZSBtaWNyb3Rhc2tzLlxuICAgICAgICAgICAgICogRm9yIHRoaXMgcmVhc29uIHRoaXMgZXZlbnQgY2FuIGZpcmUgbXVsdGlwbGUgdGltZXMgcGVyIFZNIFR1cm4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25NaWNyb3Rhc2tFbXB0eTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcIm9uU3RhYmxlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZpZXMgd2hlbiB0aGUgbGFzdCBgb25NaWNyb3Rhc2tFbXB0eWAgaGFzIHJ1biBhbmQgdGhlcmUgYXJlIG5vIG1vcmUgbWljcm90YXNrcywgd2hpY2hcbiAgICAgICAgICAgICAqIGltcGxpZXMgd2UgYXJlIGFib3V0IHRvIHJlbGlucXVpc2ggVk0gdHVybi5cbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgZ2V0cyBjYWxsZWQganVzdCBvbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uU3RhYmxlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwib25FcnJvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdGlmeSB0aGF0IGFuIGVycm9yIGhhcyBiZWVuIGRlbGl2ZXJlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vbkVycm9yRXZlbnRzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaXNTdGFibGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyBtaWNyb3Rhc2tzIG9yIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faXNTdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJoYXNQZW5kaW5nTWljcm90YXNrc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaGFzUGVuZGluZ01hY3JvdGFza3NcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oYXNQZW5kaW5nTWFjcm90YXNrczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUuY2hlY2tTdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lc3RpbmcgPT0gMCAmJiAhdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgJiYgIXRoaXMuX2lzU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVzdGluZysrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbk1pY3JvdGFza0VtcHR5LmVtaXQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXN0aW5nLS07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25TdGFibGUuZW1pdChudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUuZm9ya0lubmVyWm9uZVdpdGhBbmd1bGFyQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2FuZ3VsYXInLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgJ2lzQW5ndWxhclpvbmUnOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgb25JbnZva2VUYXNrOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5pbnZva2VUYXNrKHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkludm9rZTogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuaW52b2tlKHRhcmdldCwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkhhc1Rhc2s6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCBoYXNUYXNrU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuaGFzVGFzayh0YXJnZXQsIGhhc1Rhc2tTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gaGFzVGFzayBldmVudHMgd2hpY2ggb3JpZ2luYXRlIGZyb20gb3VyIHpvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChBIGNoaWxkIGhhc1Rhc2sgZXZlbnQgaXMgbm90IGludGVyZXN0aW5nIHRvIHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Rhc2tTdGF0ZS5jaGFuZ2UgPT0gJ21pY3JvVGFzaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRIYXNNaWNyb3Rhc2soaGFzVGFza1N0YXRlLm1pY3JvVGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNUYXNrU3RhdGUuY2hhbmdlID09ICdtYWNyb1Rhc2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGFzTWFjcm90YXNrKGhhc1Rhc2tTdGF0ZS5tYWNyb1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkhhbmRsZUVycm9yOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuaGFuZGxlRXJyb3IodGFyZ2V0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5vbkVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVzdGluZysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblVuc3RhYmxlLmVtaXQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUub25MZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lc3RpbmctLTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTdGFibGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5zZXRIYXNNaWNyb3Rhc2sgPSBmdW5jdGlvbiAoaGFzTWljcm90YXNrcykge1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgPSBoYXNNaWNyb3Rhc2tzO1xuICAgICAgICAgICAgdGhpcy5jaGVja1N0YWJsZSgpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLnNldEhhc01hY3JvdGFzayA9IGZ1bmN0aW9uIChoYXNNYWNyb3Rhc2tzKSB7IHRoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzID0gaGFzTWFjcm90YXNrczsgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS50cmlnZ2VyRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgdGhpcy5fb25FcnJvckV2ZW50cy5lbWl0KGVycm9yKTsgfTtcbiAgICAgICAgcmV0dXJuIE5nWm9uZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFRlc3RhYmlsaXR5IHNlcnZpY2UgcHJvdmlkZXMgdGVzdGluZyBob29rcyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBmcm9tXG4gICAgICogdGhlIGJyb3dzZXIgYW5kIGJ5IHNlcnZpY2VzIHN1Y2ggYXMgUHJvdHJhY3Rvci4gRWFjaCBib290c3RyYXBwZWQgQW5ndWxhclxuICAgICAqIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiBUZXN0YWJpbGl0eS5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVzdGFiaWxpdHkoX25nWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pc1pvbmVTdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIGFueSB3b3JrIHdhcyBkb25lIHNpbmNlIHRoZSBsYXN0ICd3aGVuU3RhYmxlJyBjYWxsYmFjay4gVGhpcyBpc1xuICAgICAgICAgICAgICogdXNlZnVsIHRvIGRldGVjdCBpZiB0aGlzIGNvdWxkIGhhdmUgcG90ZW50aWFsbHkgZGVzdGFiaWxpemVkIGFub3RoZXJcbiAgICAgICAgICAgICAqIGNvbXBvbmVudCB3aGlsZSBpdCBpcyBzdGFiaWxpemluZy5cbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9kaWRXb3JrID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dhdGNoQW5ndWxhckV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLl93YXRjaEFuZ3VsYXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLm9uVW5zdGFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaWRXb3JrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzWm9uZVN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmdab25lLm9uU3RhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzWm9uZVN0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmluY3JlYXNlUGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCArPSAxO1xuICAgICAgICAgICAgdGhpcy5fZGlkV29yayA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZGVjcmVhc2VQZW5kaW5nUmVxdWVzdENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGVuZGluZyBhc3luYyByZXF1ZXN0cyBiZWxvdyB6ZXJvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuaXNTdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNab25lU3RhYmxlICYmIHRoaXMuX3BlbmRpbmdDb3VudCA9PSAwICYmICF0aGlzLl9uZ1pvbmUuaGFzUGVuZGluZ01hY3JvdGFza3M7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLl9ydW5DYWxsYmFja3NJZlJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZXMgdGhlIGNhbGwgYmFja3MgaW4gYSBuZXcgZnJhbWUgc28gdGhhdCBpdCBpcyBhbHdheXMgYXN5bmMuXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoX3RoaXMuX2NhbGxiYWNrcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfdGhpcy5fY2FsbGJhY2tzLnBvcCgpKShfdGhpcy5fZGlkV29yayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RpZFdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBSZWFkeVxuICAgICAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUud2hlblN0YWJsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZ2V0UGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDsgfTtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIHVzZSBmaW5kUHJvdmlkZXJzICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kQmluZGluZ3MgPSBmdW5jdGlvbiAodXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGp1bGllbXIpOiBpbXBsZW1lbnQuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kUHJvdmlkZXJzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gVGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIGdsb2JhbCByZWdpc3RyeSBvZiB7QGxpbmsgVGVzdGFiaWxpdHl9IGluc3RhbmNlcyBmb3Igc3BlY2lmaWMgZWxlbWVudHMuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBUZXN0YWJpbGl0eVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVzdGFiaWxpdHlSZWdpc3RyeSgpIHtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIF90ZXN0YWJpbGl0eUdldHRlci5hZGRUb1dpbmRvdyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlckFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKHRva2VuLCB0ZXN0YWJpbGl0eSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zLnNldCh0b2tlbiwgdGVzdGFiaWxpdHkpO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRUZXN0YWJpbGl0eSA9IGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0aGlzLl9hcHBsaWNhdGlvbnMuZ2V0KGVsZW0pOyB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBbGxUZXN0YWJpbGl0aWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9hcHBsaWNhdGlvbnMudmFsdWVzKCkpOyB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBbGxSb290RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2FwcGxpY2F0aW9ucy5rZXlzKCkpOyB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5maW5kVGVzdGFiaWxpdHlJblRyZWUgPSBmdW5jdGlvbiAoZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZmluZEluQW5jZXN0b3JzID09PSB2b2lkIDApIHsgZmluZEluQW5jZXN0b3JzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgcmV0dXJuIF90ZXN0YWJpbGl0eUdldHRlci5maW5kVGVzdGFiaWxpdHlJblRyZWUodGhpcywgZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9Ob29wR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTm9vcEdldFRlc3RhYmlsaXR5KCkge1xuICAgICAgICB9XG4gICAgICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZFRvV2luZG93ID0gZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7IH07XG4gICAgICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9Ob29wR2V0VGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBHZXRUZXN0YWJpbGl0eX0gaW1wbGVtZW50YXRpb24gdXNlZCBieSB0aGUgQW5ndWxhciB0ZXN0aW5nIGZyYW1ld29yay5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0VGVzdGFiaWxpdHlHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgIF90ZXN0YWJpbGl0eUdldHRlciA9IGdldHRlcjtcbiAgICB9XG4gICAgdmFyIF90ZXN0YWJpbGl0eUdldHRlciA9IG5ldyBfTm9vcEdldFRlc3RhYmlsaXR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIF9kZXZNb2RlID0gdHJ1ZTtcbiAgICB2YXIgX3J1bk1vZGVMb2NrZWQgPSBmYWxzZTtcbiAgICB2YXIgX3BsYXRmb3JtO1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgQW5ndWxhcidzIGRldmVsb3BtZW50IG1vZGUsIHdoaWNoIHR1cm5zIG9mZiBhc3NlcnRpb25zIGFuZCBvdGhlclxuICAgICAqIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIE9uZSBpbXBvcnRhbnQgYXNzZXJ0aW9uIHRoaXMgZGlzYWJsZXMgdmVyaWZpZXMgdGhhdCBhIGNoYW5nZSBkZXRlY3Rpb24gcGFzc1xuICAgICAqIGRvZXMgbm90IHJlc3VsdCBpbiBhZGRpdGlvbmFsIGNoYW5nZXMgdG8gYW55IGJpbmRpbmdzIChhbHNvIGtub3duIGFzXG4gICAgICogdW5pZGlyZWN0aW9uYWwgZGF0YSBmbG93KS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmFibGVQcm9kTW9kZSgpIHtcbiAgICAgICAgaWYgKF9ydW5Nb2RlTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmFibGUgcHJvZCBtb2RlIGFmdGVyIHBsYXRmb3JtIHNldHVwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9kZXZNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBBbmd1bGFyIGlzIGluIGRldmVsb3BtZW50IG1vZGUuIEFmdGVyIGNhbGxlZCBvbmNlLFxuICAgICAqIHRoZSB2YWx1ZSBpcyBsb2NrZWQgYW5kIHdvbid0IGNoYW5nZSBhbnkgbW9yZS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdHJ1ZSwgdW5sZXNzIGEgdXNlciBjYWxscyBgZW5hYmxlUHJvZE1vZGVgIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEZXZNb2RlKCkge1xuICAgICAgICBfcnVuTW9kZUxvY2tlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBfZGV2TW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYXRmb3JtLlxuICAgICAqIFBsYXRmb3JtcyBoYXZlIHRvIGJlIGVhZ2VybHkgY3JlYXRlZCB2aWEgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybShpbmplY3Rvcikge1xuICAgICAgICBpZiAoX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGNhbiBiZSBvbmx5IG9uZSBwbGF0Zm9ybS4gRGVzdHJveSB0aGUgcHJldmlvdXMgb25lIHRvIGNyZWF0ZSBhIG5ldyBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3BsYXRmb3JtID0gaW5qZWN0b3IuZ2V0KFBsYXRmb3JtUmVmKTtcbiAgICAgICAgdmFyIGluaXRzID0gaW5qZWN0b3IuZ2V0KFBMQVRGT1JNX0lOSVRJQUxJWkVSLCBudWxsKTtcbiAgICAgICAgaWYgKGluaXRzKVxuICAgICAgICAgICAgaW5pdHMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdCkgeyByZXR1cm4gaW5pdCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIF9wbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZm9yIGEgcGxhdGZvcm1cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkocGFyZW50UGxhZm9ybUZhY3RvcnksIG5hbWUsIHByb3ZpZGVycykge1xuICAgICAgICBpZiAocHJvdmlkZXJzID09PSB2b2lkIDApIHsgcHJvdmlkZXJzID0gW107IH1cbiAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBPcGFxdWVUb2tlbihcIlBsYXRmb3JtOiBcIiArIG5hbWUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFQcm92aWRlcnMgPT09IHZvaWQgMCkgeyBleHRyYVByb3ZpZGVycyA9IFtdOyB9XG4gICAgICAgICAgICBpZiAoIWdldFBsYXRmb3JtKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxhZm9ybUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UGxhZm9ybUZhY3RvcnkocHJvdmlkZXJzLmNvbmNhdChleHRyYVByb3ZpZGVycykuY29uY2F0KHsgcHJvdmlkZTogbWFya2VyLCB1c2VWYWx1ZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVQbGF0Zm9ybShSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShwcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKS5jb25jYXQoeyBwcm92aWRlOiBtYXJrZXIsIHVzZVZhbHVlOiB0cnVlIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzc2VydFBsYXRmb3JtKG1hcmtlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHRoZXJlIGN1cnJlbnRseSBpcyBhIHBsYXRmb3JtXG4gICAgICogd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIHRva2VuIGFzIGEgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0UGxhdGZvcm0ocmVxdWlyZWRUb2tlbikge1xuICAgICAgICB2YXIgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICAgICAgICBpZiAoIXBsYXRmb3JtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBsYXRmb3JtIGV4aXN0cyEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsYXRmb3JtLmluamVjdG9yLmdldChyZXF1aXJlZFRva2VuLCBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHBsYXRmb3JtIHdpdGggYSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBjcmVhdGVkLiBQbGVhc2UgZGVzdHJveSBpdCBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhdGZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGV4aXN0aW5nIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlc3Ryb3lQbGF0Zm9ybSgpIHtcbiAgICAgICAgaWYgKF9wbGF0Zm9ybSAmJiAhX3BsYXRmb3JtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgX3BsYXRmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkID8gX3BsYXRmb3JtIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIEFuZ3VsYXIgcGxhdGZvcm0gaXMgdGhlIGVudHJ5IHBvaW50IGZvciBBbmd1bGFyIG9uIGEgd2ViIHBhZ2UuIEVhY2ggcGFnZVxuICAgICAqIGhhcyBleGFjdGx5IG9uZSBwbGF0Zm9ybSwgYW5kIHNlcnZpY2VzIChzdWNoIGFzIHJlZmxlY3Rpb24pIHdoaWNoIGFyZSBjb21tb25cbiAgICAgKiB0byBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gdGhlIHBhZ2UgYXJlIGJvdW5kIGluIGl0cyBzY29wZS5cbiAgICAgKlxuICAgICAqIEEgcGFnZSdzIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkIGltcGxpY2l0bHkgd2hlbiB7QGxpbmsgYm9vdHN0cmFwfSgpIGlzIGNhbGxlZCwgb3JcbiAgICAgKiBleHBsaWNpdGx5IGJ5IGNhbGxpbmcge0BsaW5rIGNyZWF0ZVBsYXRmb3JtfSgpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQbGF0Zm9ybVJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIGBATmdNb2R1bGVgIGZvciB0aGUgZ2l2ZW4gcGxhdGZvcm1cbiAgICAgICAgICogZm9yIG9mZmxpbmUgY29tcGlsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogbXlfbW9kdWxlLnRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiBATmdNb2R1bGUoe1xuICAgICAgICAgKiAgIGltcG9ydHM6IFtCcm93c2VyTW9kdWxlXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiBtYWluLnRzOlxuICAgICAgICAgKiBpbXBvcnQge015TW9kdWxlTmdGYWN0b3J5fSBmcm9tICcuL215X21vZHVsZS5uZ2ZhY3RvcnknO1xuICAgICAgICAgKiBpbXBvcnQge3BsYXRmb3JtQnJvd3Nlcn0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gICAgICAgICAqXG4gICAgICAgICAqIGxldCBtb2R1bGVSZWYgPSBwbGF0Zm9ybUJyb3dzZXIoKS5ib290c3RyYXBNb2R1bGVGYWN0b3J5KE15TW9kdWxlTmdGYWN0b3J5KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGVGYWN0b3J5ID0gZnVuY3Rpb24gKG1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IHVuaW1wbGVtZW50ZWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gYEBOZ01vZHVsZWAgZm9yIGEgZ2l2ZW4gcGxhdGZvcm0gdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUgY29tcGlsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQE5nTW9kdWxlKHtcbiAgICAgICAgICogICBpbXBvcnRzOiBbQnJvd3Nlck1vZHVsZV1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgTXlNb2R1bGUge31cbiAgICAgICAgICpcbiAgICAgICAgICogbGV0IG1vZHVsZVJlZiA9IHBsYXRmb3JtQnJvd3NlcigpLmJvb3RzdHJhcE1vZHVsZShNeU1vZHVsZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAc3RhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZi5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGNvbXBpbGVyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB0aHJvdyB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgcGxhdGZvcm0ge0BsaW5rIEluamVjdG9yfSwgd2hpY2ggaXMgdGhlIHBhcmVudCBpbmplY3RvciBmb3JcbiAgICAgICAgICAgICAqIGV2ZXJ5IEFuZ3VsYXIgYXBwbGljYXRpb24gb24gdGhlIHBhZ2UgYW5kIHByb3ZpZGVzIHNpbmdsZXRvbiBwcm92aWRlcnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZi5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGxhdGZvcm1SZWY7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY2FsbEFuZFJlcG9ydFRvRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgYXMgdGhlIGV4Y2VwdGlvbiBoYW5kbGVyIG1pZ2h0IG5vdCBkbyBpdFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgLy8gcmV0aHJvdyBhcyB0aGUgZXhjZXB0aW9uIGhhbmRsZXIgbWlnaHQgbm90IGRvIGl0XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBQbGF0Zm9ybVJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhQbGF0Zm9ybVJlZl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmXyhfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWZfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmXy5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBsYXRmb3JtIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlRmFjdG9yeSA9IGZ1bmN0aW9uIChtb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9vdHN0cmFwTW9kdWxlRmFjdG9yeVdpdGhab25lKG1vZHVsZUZhY3RvcnksIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9ib290c3RyYXBNb2R1bGVGYWN0b3J5V2l0aFpvbmUgPSBmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSwgbmdab25lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjcmVhdGUgdGhlIE5nWm9uZSBfYmVmb3JlXyB3ZSBpbnN0YW50aWF0ZSB0aGUgbW9kdWxlLFxuICAgICAgICAgICAgLy8gYXMgaW5zdGFudGlhdGluZyB0aGUgbW9kdWxlIGNyZWF0ZXMgc29tZSBwcm92aWRlcnMgZWFnZXJseS5cbiAgICAgICAgICAgIC8vIFNvIHdlIGNyZWF0ZSBhIG1pbmkgcGFyZW50IGluamVjdG9yIHRoYXQganVzdCBjb250YWlucyB0aGUgbmV3IE5nWm9uZSBhbmRcbiAgICAgICAgICAgIC8vIHBhc3MgdGhhdCBhcyBwYXJlbnQgdG8gdGhlIE5nTW9kdWxlRmFjdG9yeS5cbiAgICAgICAgICAgIGlmICghbmdab25lKVxuICAgICAgICAgICAgICAgIG5nWm9uZSA9IG5ldyBOZ1pvbmUoeyBlbmFibGVMb25nU3RhY2tUcmFjZTogaXNEZXZNb2RlKCkgfSk7XG4gICAgICAgICAgICAvLyBBdHRlbnRpb246IERvbid0IHVzZSBBcHBsaWNhdGlvblJlZi5ydW4gaGVyZSxcbiAgICAgICAgICAgIC8vIGFzIHdlIHdhbnQgdG8gYmUgc3VyZSB0aGF0IGFsbCBwb3NzaWJsZSBjb25zdHJ1Y3RvciBjYWxscyBhcmUgaW5zaWRlIGBuZ1pvbmUucnVuYCFcbiAgICAgICAgICAgIHJldHVybiBuZ1pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmdab25lSW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbeyBwcm92aWRlOiBOZ1pvbmUsIHVzZVZhbHVlOiBuZ1pvbmUgfV0sIF90aGlzLmluamVjdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlUmVmID0gbW9kdWxlRmFjdG9yeS5jcmVhdGUobmdab25lSW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgIHZhciBleGNlcHRpb25IYW5kbGVyID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChFcnJvckhhbmRsZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICghZXhjZXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEVycm9ySGFuZGxlci4gSXMgcGxhdGZvcm0gbW9kdWxlIChCcm93c2VyTW9kdWxlKSBpbmNsdWRlZD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kdWxlUmVmLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBMaXN0V3JhcHBlci5yZW1vdmUoX3RoaXMuX21vZHVsZXMsIG1vZHVsZVJlZik7IH0pO1xuICAgICAgICAgICAgICAgIG5nWm9uZS5vbkVycm9yLnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uIChlcnJvcikgeyBleGNlcHRpb25IYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yKTsgfSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGxBbmRSZXBvcnRUb0Vycm9ySGFuZGxlcihleGNlcHRpb25IYW5kbGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0U3RhdHVzID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvbkluaXRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFN0YXR1cy5kb25lUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tb2R1bGVEb0Jvb3RzdHJhcChtb2R1bGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXJPcHRpb25zID09PSB2b2lkIDApIHsgY29tcGlsZXJPcHRpb25zID0gW107IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib290c3RyYXBNb2R1bGVXaXRoWm9uZShtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMsIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9ib290c3RyYXBNb2R1bGVXaXRoWm9uZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMsIG5nWm9uZSwgY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB2YXIgY29tcGlsZXJGYWN0b3J5ID0gdGhpcy5pbmplY3Rvci5nZXQoQ29tcGlsZXJGYWN0b3J5KTtcbiAgICAgICAgICAgIHZhciBjb21waWxlciA9IGNvbXBpbGVyRmFjdG9yeS5jcmVhdGVDb21waWxlcihBcnJheS5pc0FycmF5KGNvbXBpbGVyT3B0aW9ucykgPyBjb21waWxlck9wdGlvbnMgOiBbY29tcGlsZXJPcHRpb25zXSk7XG4gICAgICAgICAgICAvLyB1Z2x5IGludGVybmFsIGFwaSBoYWNrOiBnZW5lcmF0ZSBob3N0IGNvbXBvbmVudCBmYWN0b3JpZXMgZm9yIGFsbCBkZWNsYXJlZCBjb21wb25lbnRzIGFuZFxuICAgICAgICAgICAgLy8gcGFzcyB0aGUgZmFjdG9yaWVzIGludG8gdGhlIGNhbGxiYWNrIC0gdGhpcyBpcyB1c2VkIGJ5IFVwZGF0ZUFkYXB0ZXIgdG8gZ2V0IGhvbGQgb2YgYWxsXG4gICAgICAgICAgICAvLyBmYWN0b3JpZXMuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMobW9kdWxlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSBfYS5uZ01vZHVsZUZhY3RvcnksIGNvbXBvbmVudEZhY3RvcmllcyA9IF9hLmNvbXBvbmVudEZhY3RvcmllcztcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYm9vdHN0cmFwTW9kdWxlRmFjdG9yeVdpdGhab25lKG5nTW9kdWxlRmFjdG9yeSwgbmdab25lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21waWxlci5jb21waWxlTW9kdWxlQXN5bmMobW9kdWxlVHlwZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSkgeyByZXR1cm4gX3RoaXMuX2Jvb3RzdHJhcE1vZHVsZUZhY3RvcnlXaXRoWm9uZShtb2R1bGVGYWN0b3J5LCBuZ1pvbmUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5fbW9kdWxlRG9Cb290c3RyYXAgPSBmdW5jdGlvbiAobW9kdWxlUmVmKSB7XG4gICAgICAgICAgICB2YXIgYXBwUmVmID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvblJlZik7XG4gICAgICAgICAgICBpZiAobW9kdWxlUmVmLmJvb3RzdHJhcEZhY3Rvcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlUmVmLmJvb3RzdHJhcEZhY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wRmFjdG9yeSkgeyByZXR1cm4gYXBwUmVmLmJvb3RzdHJhcChjb21wRmFjdG9yeSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kdWxlUmVmLmluc3RhbmNlLm5nRG9Cb290c3RyYXApIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVSZWYuaW5zdGFuY2UubmdEb0Jvb3RzdHJhcChhcHBSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlRoZSBtb2R1bGUgXCIgKyBzdHJpbmdpZnkobW9kdWxlUmVmLmluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIHdhcyBib290c3RyYXBwZWQsIGJ1dCBpdCBkb2VzIG5vdCBkZWNsYXJlIFxcXCJATmdNb2R1bGUuYm9vdHN0cmFwXFxcIiBjb21wb25lbnRzIG5vciBhIFxcXCJuZ0RvQm9vdHN0cmFwXFxcIiBtZXRob2QuIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIGRlZmluZSBvbmUgb2YgdGhlc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGxhdGZvcm1SZWZfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtUmVmXztcbiAgICB9KFBsYXRmb3JtUmVmKSk7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gYW4gQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIGEgcGFnZS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGFib3V0IEFuZ3VsYXIgYXBwbGljYXRpb25zLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHtAbGluayBib290c3RyYXB9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBcHBsaWNhdGlvblJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSBsaXN0IG9mIGNvbXBvbmVudCB0eXBlcyByZWdpc3RlcmVkIHRvIHRoaXMgYXBwbGljYXRpb24uXG4gICAgICAgICAgICAgKiBUaGlzIGxpc3QgaXMgcG9wdWxhdGVkIGV2ZW4gYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIGxpc3Qgb2YgY29tcG9uZW50cyByZWdpc3RlcmVkIHRvIHRoaXMgYXBwbGljYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25SZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgQXBwbGljYXRpb25SZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoQXBwbGljYXRpb25SZWZfLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBcHBsaWNhdGlvblJlZl8oX3pvbmUsIF9jb25zb2xlLCBfaW5qZWN0b3IsIF9leGNlcHRpb25IYW5kbGVyLCBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfaW5pdFN0YXR1cywgX3Rlc3RhYmlsaXR5UmVnaXN0cnksIF90ZXN0YWJpbGl0eSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl9leGNlcHRpb25IYW5kbGVyID0gX2V4Y2VwdGlvbkhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICAgICAgdGhpcy5faW5pdFN0YXR1cyA9IF9pbml0U3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5fdGVzdGFiaWxpdHlSZWdpc3RyeSA9IF90ZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgICAgICAgICAgdGhpcy5fdGVzdGFiaWxpdHkgPSBfdGVzdGFiaWxpdHk7XG4gICAgICAgICAgICB0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50VHlwZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBpc0Rldk1vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUub25NaWNyb3Rhc2tFbXB0eS5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAoKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IF90aGlzLnRpY2soKTsgfSk7IH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5yZWdpc3RlckNoYW5nZURldGVjdG9yID0gZnVuY3Rpb24gKGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMucHVzaChjaGFuZ2VEZXRlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUudW5yZWdpc3RlckNoYW5nZURldGVjdG9yID0gZnVuY3Rpb24gKGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWZzLCBjaGFuZ2VEZXRlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdFN0YXR1cy5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYm9vdHN0cmFwIGFzIHRoZXJlIGFyZSBzdGlsbCBhc3luY2hyb25vdXMgaW5pdGlhbGl6ZXJzIHJ1bm5pbmcuIEJvb3RzdHJhcCBjb21wb25lbnRzIGluIHRoZSBgbmdEb0Jvb3RzdHJhcGAgbWV0aG9kIG9mIHRoZSByb290IG1vZHVsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9yRmFjdG9yeSBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5ID0gY29tcG9uZW50T3JGYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnRPckZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50RmFjdG9yeS5jb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHZhciBjb21wUmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUodGhpcy5faW5qZWN0b3IsIFtdLCBjb21wb25lbnRGYWN0b3J5LnNlbGVjdG9yKTtcbiAgICAgICAgICAgIGNvbXBSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgX3RoaXMuX3VubG9hZENvbXBvbmVudChjb21wUmVmKTsgfSk7XG4gICAgICAgICAgICB2YXIgdGVzdGFiaWxpdHkgPSBjb21wUmVmLmluamVjdG9yLmdldChUZXN0YWJpbGl0eSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAodGVzdGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBjb21wUmVmLmluamVjdG9yLmdldChUZXN0YWJpbGl0eVJlZ2lzdHJ5KVxuICAgICAgICAgICAgICAgICAgICAucmVnaXN0ZXJBcHBsaWNhdGlvbihjb21wUmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIHRlc3RhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvYWRDb21wb25lbnQoY29tcFJlZik7XG4gICAgICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmxvZyhcIkFuZ3VsYXIgMiBpcyBydW5uaW5nIGluIHRoZSBkZXZlbG9wbWVudCBtb2RlLiBDYWxsIGVuYWJsZVByb2RNb2RlKCkgdG8gZW5hYmxlIHRoZSBwcm9kdWN0aW9uIG1vZGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBSZWY7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5fbG9hZENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5wdXNoKGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzLnB1c2goY29tcG9uZW50UmVmKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGlzdGVuZXJzIGxhemlseSB0byBwcmV2ZW50IERJIGN5Y2xlcy5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9pbmplY3Rvci5nZXQoQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgW10pXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihjb21wb25lbnRSZWYpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLl91bmxvYWRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm9vdENvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnRSZWYpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyQ2hhbmdlRGV0ZWN0b3IoY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmKTtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9yb290Q29tcG9uZW50cywgY29tcG9uZW50UmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmdUaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcHBsaWNhdGlvblJlZi50aWNrIGlzIGNhbGxlZCByZWN1cnNpdmVseScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb3BlID0gQXBwbGljYXRpb25SZWZfLl90aWNrU2NvcGUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXRlY3RvcikgeyByZXR1cm4gZGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGV0ZWN0b3IpIHsgcmV0dXJuIGRldGVjdG9yLmNoZWNrTm9DaGFuZ2VzKCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd3RmTGVhdmUoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBEaXNwb3NlIG9mIHRoZSBOZ1pvbmUuXG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkgeyByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50c1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3RDb21wb25lbnRzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8uX3RpY2tTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdBcHBsaWNhdGlvblJlZiN0aWNrKCknKTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBDb25zb2xlLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogRXJyb3JIYW5kbGVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFwcGxpY2F0aW9uSW5pdFN0YXR1cywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogVGVzdGFiaWxpdHlSZWdpc3RyeSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFRlc3RhYmlsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uUmVmXztcbiAgICB9KEFwcGxpY2F0aW9uUmVmKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhbiBOZ01vZHVsZSBjcmVhdGVkIHZpYSBhIHtAbGluayBOZ01vZHVsZUZhY3Rvcnl9LlxuICAgICAqXG4gICAgICogYE5nTW9kdWxlUmVmYCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIE5nTW9kdWxlIEluc3RhbmNlIGFzIHdlbGwgb3RoZXIgb2JqZWN0cyByZWxhdGVkIHRvIHRoaXNcbiAgICAgKiBOZ01vZHVsZSBJbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluamVjdG9yIHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZSBwcm92aWRlcnMgb2YgdGhlIE5nTW9kdWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZVJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB0byBnZXQgaG9sZCBvZiB0aGUgQ29tcG9uZW50RmFjdG9yaWVzXG4gICAgICAgICAgICAgKiBkZWNsYXJlZCBpbiB0aGUgYGVudHJ5Q29tcG9uZW50c2AgcHJvcGVydHkgb2YgdGhlIG1vZHVsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIE5nTW9kdWxlIGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOZ01vZHVsZVJlZjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2R1bGVGYWN0b3J5KF9pbmplY3RvckNsYXNzLCBfbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3JDbGFzcyA9IF9pbmplY3RvckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5fbW9kdWxlVHlwZSA9IF9tb2R1bGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZUZhY3RvcnkucHJvdG90eXBlLCBcIm1vZHVsZVR5cGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tb2R1bGVUeXBlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdNb2R1bGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmplY3RvciA9IEluamVjdG9yLk5VTEw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdGhpcy5faW5qZWN0b3JDbGFzcyhwYXJlbnRJbmplY3Rvcik7XG4gICAgICAgICAgICBpbnN0YW5jZS5jcmVhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kdWxlRmFjdG9yeTtcbiAgICB9KCkpO1xuICAgIHZhciBfVU5ERUZJTkVEID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBOZ01vZHVsZUluamVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoTmdNb2R1bGVJbmplY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2R1bGVJbmplY3RvcihwYXJlbnQsIGZhY3RvcmllcywgYm9vdHN0cmFwRmFjdG9yaWVzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWN0b3JpZXMsIHBhcmVudC5nZXQoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuTlVMTCkpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJvb3RzdHJhcEZhY3RvcmllcyA9IGJvb3RzdHJhcEZhY3RvcmllcztcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbnN0YW5jZSA9IHRoaXMuY3JlYXRlSW50ZXJuYWwoKTsgfTtcbiAgICAgICAgTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBUSFJPV19JRl9OT1RfRk9VTkQ7IH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gSW5qZWN0b3IgfHwgdG9rZW4gPT09IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0SW50ZXJuYWwodG9rZW4sIF9VTkRFRklORUQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gX1VOREVGSU5FRCA/IHRoaXMucGFyZW50LmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5nIG1vZHVsZSBcIiArIHN0cmluZ2lmeSh0aGlzLmluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgICAgICByZXR1cm4gTmdNb2R1bGVJbmplY3RvcjtcbiAgICB9KENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGxvYWQgbmcgbW9kdWxlIGZhY3Rvcmllcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nTW9kdWxlRmFjdG9yeUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlRmFjdG9yeUxvYWRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTmdNb2R1bGVGYWN0b3J5TG9hZGVyO1xuICAgIH0oKSk7XG4gICAgdmFyIG1vZHVsZUZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsb2FkZWQgbW9kdWxlLiBTaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSBnZW5lcmF0ZWQgTmdNb2R1bGVGYWN0b3J5IGNvZGUuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlRmFjdG9yeShpZCwgZmFjdG9yeSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBtb2R1bGVGYWN0b3JpZXMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgbW9kdWxlIHJlZ2lzdGVyZWQgZm9yIFwiICsgaWQgKyBcIiAtIFwiICsgZXhpc3RpbmcubW9kdWxlVHlwZS5uYW1lICsgXCIgdnMgXCIgKyBmYWN0b3J5Lm1vZHVsZVR5cGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlRmFjdG9yaWVzLnNldChpZCwgZmFjdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5nTW9kdWxlRmFjdG9yeSB3aXRoIHRoZSBnaXZlbiBpZCwgaWYgaXQgZXhpc3RzIGFuZCBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICogRmFjdG9yaWVzIGZvciBtb2R1bGVzIHRoYXQgZG8gbm90IHNwZWNpZnkgYW4gYGlkYCBjYW5ub3QgYmUgcmV0cmlldmVkLiBUaHJvd3MgaWYgdGhlIG1vZHVsZVxuICAgICAqIGNhbm5vdCBiZSBmb3VuZC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TW9kdWxlRmFjdG9yeShpZCkge1xuICAgICAgICB2YXIgZmFjdG9yeSA9IG1vZHVsZUZhY3Rvcmllcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIWZhY3RvcnkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2R1bGUgd2l0aCBJRCBcIiArIGlkICsgXCIgbG9hZGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiB1bm1vZGlmaWFibGUgbGlzdCBvZiBpdGVtcyB0aGF0IEFuZ3VsYXIga2VlcHMgdXAgdG8gZGF0ZSB3aGVuIHRoZSBzdGF0ZVxuICAgICAqIG9mIHRoZSBhcHBsaWNhdGlvbiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVGhlIHR5cGUgb2Ygb2JqZWN0IHRoYXQge0BsaW5rIFF1ZXJ5fSBhbmQge0BsaW5rIFZpZXdRdWVyeU1ldGFkYXRhfSBwcm92aWRlLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50cyBhbiBpdGVyYWJsZSBpbnRlcmZhY2UsIHRoZXJlZm9yZSBpdCBjYW4gYmUgdXNlZCBpbiBib3RoIEVTNlxuICAgICAqIGphdmFzY3JpcHQgYGZvciAodmFyIGkgb2YgaXRlbXMpYCBsb29wcyBhcyB3ZWxsIGFzIGluIEFuZ3VsYXIgdGVtcGxhdGVzIHdpdGhcbiAgICAgKiBgKm5nRm9yPVwibGV0IGkgb2YgbXlMaXN0XCJgLlxuICAgICAqXG4gICAgICogQ2hhbmdlcyBjYW4gYmUgb2JzZXJ2ZWQgYnkgc3Vic2NyaWJpbmcgdG8gdGhlIGNoYW5nZXMgYE9ic2VydmFibGVgLlxuICAgICAqXG4gICAgICogTk9URTogSW4gdGhlIGZ1dHVyZSB0aGlzIGNsYXNzIHdpbGwgaW1wbGVtZW50IGFuIGBPYnNlcnZhYmxlYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvUlg4c0puUVlsOUZXdVNDV21lNXo/cD1wcmV2aWV3KSlcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7Li4ufSlcbiAgICAgKiBjbGFzcyBDb250YWluZXIge1xuICAgICAqICAgQFZpZXdDaGlsZHJlbihJdGVtKSBpdGVtczpRdWVyeUxpc3Q8SXRlbT47XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUXVlcnlMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUXVlcnlMaXN0KCkge1xuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJjaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZW1pdHRlcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwibGFzdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHNbdGhpcy5sZW5ndGggLSAxXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWVcbiAgICAgICAgICogW0FycmF5Lm1hcF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubWFwKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZmlsdGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMuZmlsdGVyKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZClcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5maW5kKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkucmVkdWNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UpXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMucmVkdWNlKGZuLCBpbml0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZm9yRWFjaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaClcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9yZXN1bHRzLmZvckVhY2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5zb21lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lKVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5zb21lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5zbGljZSgpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlW2dldFN5bWJvbEl0ZXJhdG9yKCldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0c1tnZXRTeW1ib2xJdGVyYXRvcigpXSgpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy50b1N0cmluZygpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IExpc3RXcmFwcGVyLmZsYXR0ZW4ocmVzKTtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9lbWl0dGVyLmVtaXQodGhpcyk7IH07XG4gICAgICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXJ0eTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBRdWVyeUxpc3Q7XG4gICAgfSgpKTtcblxuICAgIHZhciBfU0VQQVJBVE9SID0gJyMnO1xuICAgIHZhciBGQUNUT1JZX0NMQVNTX1NVRkZJWCA9ICdOZ0ZhY3RvcnknO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuXG4gICAgICogdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnO1xuICAgIH0oKSk7XG4gICAgdmFyIERFRkFVTFRfQ09ORklHID0ge1xuICAgICAgICBmYWN0b3J5UGF0aFByZWZpeDogJycsXG4gICAgICAgIGZhY3RvcnlQYXRoU3VmZml4OiAnLm5nZmFjdG9yeScsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOZ01vZHVsZUZhY3RvcnlMb2FkZXIgdGhhdCB1c2VzIFN5c3RlbUpTIHRvIGxvYWQgTmdNb2R1bGVGYWN0b3J5XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3lzdGVtSnNOZ01vZHVsZUxvYWRlcihfY29tcGlsZXIsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZXIgPSBfY29tcGlsZXI7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWcgfHwgREVGQVVMVF9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgb2ZmbGluZU1vZGUgPSB0aGlzLl9jb21waWxlciBpbnN0YW5jZW9mIENvbXBpbGVyO1xuICAgICAgICAgICAgcmV0dXJuIG9mZmxpbmVNb2RlID8gdGhpcy5sb2FkRmFjdG9yeShwYXRoKSA6IHRoaXMubG9hZEFuZENvbXBpbGUocGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIucHJvdG90eXBlLmxvYWRBbmRDb21waWxlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXRoLnNwbGl0KF9TRVBBUkFUT1IpLCBtb2R1bGUgPSBfYVswXSwgZXhwb3J0TmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLmltcG9ydChtb2R1bGUpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWVdOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBjaGVja05vdEVtcHR5KHR5cGUsIG1vZHVsZSwgZXhwb3J0TmFtZSk7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlci5jb21waWxlTW9kdWxlQXN5bmModHlwZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkRmFjdG9yeSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXRoLnNwbGl0KF9TRVBBUkFUT1IpLCBtb2R1bGUgPSBfYVswXSwgZXhwb3J0TmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIGZhY3RvcnlDbGFzc1N1ZmZpeCA9IEZBQ1RPUllfQ0xBU1NfU1VGRklYO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgZmFjdG9yeUNsYXNzU3VmZml4ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLmltcG9ydCh0aGlzLl9jb25maWcuZmFjdG9yeVBhdGhQcmVmaXggKyBtb2R1bGUgKyB0aGlzLl9jb25maWcuZmFjdG9yeVBhdGhTdWZmaXgpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWUgKyBmYWN0b3J5Q2xhc3NTdWZmaXhdOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBjaGVja05vdEVtcHR5KGZhY3RvcnksIG1vZHVsZSwgZXhwb3J0TmFtZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbXBpbGVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBjaGVja05vdEVtcHR5KHZhbHVlLCBtb2R1bGVQYXRoLCBleHBvcnROYW1lKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kICdcIiArIGV4cG9ydE5hbWUgKyBcIicgaW4gJ1wiICsgbW9kdWxlUGF0aCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIEVtYmVkZGVkIFRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFjY2VzcyBhIGBUZW1wbGF0ZVJlZmAsIGluIHR3byB3YXlzLiBWaWEgYSBkaXJlY3RpdmUgcGxhY2VkIG9uIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgKG9yXG4gICAgICogZGlyZWN0aXZlIHByZWZpeGVkIHdpdGggYCpgKSBhbmQgaGF2ZSB0aGUgYFRlbXBsYXRlUmVmYCBmb3IgdGhpcyBFbWJlZGRlZCBWaWV3IGluamVjdGVkIGludG8gdGhlXG4gICAgICogY29uc3RydWN0b3Igb2YgdGhlIGRpcmVjdGl2ZSB1c2luZyB0aGUgYFRlbXBsYXRlUmVmYCBUb2tlbi4gQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHF1ZXJ5IGZvciB0aGVcbiAgICAgKiBgVGVtcGxhdGVSZWZgIGZyb20gYSBDb21wb25lbnQgb3IgYSBEaXJlY3RpdmUgdmlhIHtAbGluayBRdWVyeX0uXG4gICAgICpcbiAgICAgKiBUbyBpbnN0YW50aWF0ZSBFbWJlZGRlZCBWaWV3cyBiYXNlZCBvbiBhIFRlbXBsYXRlLCB1c2VcbiAgICAgKiB7QGxpbmsgVmlld0NvbnRhaW5lclJlZiNjcmVhdGVFbWJlZGRlZFZpZXd9LCB3aGljaCB3aWxsIGNyZWF0ZSB0aGUgVmlldyBhbmQgYXR0YWNoIGl0IHRvIHRoZVxuICAgICAqIFZpZXcgQ29udGFpbmVyLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVGVtcGxhdGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVSZWYucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbG9jYXRpb24gaW4gdGhlIFZpZXcgd2hlcmUgdGhlIEVtYmVkZGVkIFZpZXcgbG9naWNhbGx5IGJlbG9uZ3MgdG8uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlIGRhdGEtYmluZGluZyBhbmQgaW5qZWN0aW9uIGNvbnRleHRzIG9mIEVtYmVkZGVkIFZpZXdzIGNyZWF0ZWQgZnJvbSB0aGlzIGBUZW1wbGF0ZVJlZmBcbiAgICAgICAgICAgICAqIGluaGVyaXQgZnJvbSB0aGUgY29udGV4dHMgb2YgdGhpcyBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUeXBpY2FsbHkgbmV3IEVtYmVkZGVkIFZpZXdzIGFyZSBhdHRhY2hlZCB0byB0aGUgVmlldyBDb250YWluZXIgb2YgdGhpcyBsb2NhdGlvbiwgYnV0IGluXG4gICAgICAgICAgICAgKiBhZHZhbmNlZCB1c2UtY2FzZXMsIHRoZSBWaWV3IGNhbiBiZSBhdHRhY2hlZCB0byBhIGRpZmZlcmVudCBjb250YWluZXIgd2hpbGUga2VlcGluZyB0aGVcbiAgICAgICAgICAgICAqIGRhdGEtYmluZGluZyBhbmQgaW5qZWN0aW9uIGNvbnRleHQgZnJvbSB0aGUgb3JpZ2luYWwgbG9jYXRpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUT0RPKGkpOiByZW5hbWUgdG8gYW5jaG9yIG9yIGxvY2F0aW9uXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVGVtcGxhdGVSZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgVGVtcGxhdGVSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEwKFRlbXBsYXRlUmVmXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVSZWZfKF9wYXJlbnRWaWV3LCBfbm9kZUluZGV4LCBfbmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRWaWV3ID0gX3BhcmVudFZpZXc7XG4gICAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSBfbm9kZUluZGV4O1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRWxlbWVudCA9IF9uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIFRlbXBsYXRlUmVmXy5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fcGFyZW50Vmlldy5jcmVhdGVFbWJlZGRlZFZpZXdJbnRlcm5hbCh0aGlzLl9ub2RlSW5kZXgpO1xuICAgICAgICAgICAgdmlldy5jcmVhdGUoY29udGV4dCB8fCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5yZWY7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW1wbGF0ZVJlZl8ucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRWxlbWVudFJlZih0aGlzLl9uYXRpdmVFbGVtZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZVJlZl87XG4gICAgfShUZW1wbGF0ZVJlZikpO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aGVyZSBvbmUgb3IgbW9yZSBWaWV3cyBjYW4gYmUgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiBUaGUgY29udGFpbmVyIGNhbiBjb250YWluIHR3byBraW5kcyBvZiBWaWV3cy4gSG9zdCBWaWV3cywgY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGFcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50fSB2aWEge0BsaW5rICNjcmVhdGVDb21wb25lbnR9LCBhbmQgRW1iZWRkZWQgVmlld3MsIGNyZWF0ZWQgYnkgaW5zdGFudGlhdGluZyBhblxuICAgICAqIHtAbGluayBUZW1wbGF0ZVJlZiBFbWJlZGRlZCBUZW1wbGF0ZX0gdmlhIHtAbGluayAjY3JlYXRlRW1iZWRkZWRWaWV3fS5cbiAgICAgKlxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgVmlldyBDb250YWluZXIgd2l0aGluIHRoZSBjb250YWluaW5nIFZpZXcgaXMgc3BlY2lmaWVkIGJ5IHRoZSBBbmNob3JcbiAgICAgKiBgZWxlbWVudGAuIEVhY2ggVmlldyBDb250YWluZXIgY2FuIGhhdmUgb25seSBvbmUgQW5jaG9yIEVsZW1lbnQgYW5kIGVhY2ggQW5jaG9yIEVsZW1lbnQgY2FuIG9ubHlcbiAgICAgKiBoYXZlIGEgc2luZ2xlIFZpZXcgQ29udGFpbmVyLlxuICAgICAqXG4gICAgICogUm9vdCBlbGVtZW50cyBvZiBWaWV3cyBhdHRhY2hlZCB0byB0aGlzIGNvbnRhaW5lciBiZWNvbWUgc2libGluZ3Mgb2YgdGhlIEFuY2hvciBFbGVtZW50IGluXG4gICAgICogdGhlIFJlbmRlcmVkIFZpZXcuXG4gICAgICpcbiAgICAgKiBUbyBhY2Nlc3MgYSBgVmlld0NvbnRhaW5lclJlZmAgb2YgYW4gRWxlbWVudCwgeW91IGNhbiBlaXRoZXIgcGxhY2UgYSB7QGxpbmsgRGlyZWN0aXZlfSBpbmplY3RlZFxuICAgICAqIHdpdGggYFZpZXdDb250YWluZXJSZWZgIG9uIHRoZSBFbGVtZW50LCBvciB5b3Ugb2J0YWluIGl0IHZpYSBhIHtAbGluayBWaWV3Q2hpbGR9IHF1ZXJ5LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld0NvbnRhaW5lclJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbmNob3IgZWxlbWVudCB0aGF0IHNwZWNpZmllcyB0aGUgbG9jYXRpb24gb2YgdGhpcyBjb250YWluZXIgaW4gdGhlIGNvbnRhaW5pbmcgVmlldy5cbiAgICAgICAgICAgICAqIDwhLS0gVE9ETzogcmVuYW1lIHRvIGFuY2hvckVsZW1lbnQgLS0+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBWaWV3cyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gVmlld0NvbnRhaW5lclJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBWaWV3Q29udGFpbmVyUmVmXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWZfKF9lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnRJbkNvbnRhaW5lclNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjY3JlYXRlQ29tcG9uZW50KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2luc2VydFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjaW5zZXJ0KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjcmVtb3ZlKCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2RldGFjaFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjZGV0YWNoKCknKTtcbiAgICAgICAgfVxuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzW2luZGV4XS5yZWY7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX2VsZW1lbnQubmVzdGVkVmlld3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2aWV3cykgPyB2aWV3cy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiZWxlbWVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50LmluamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPKHJhZG8pOiBwcm9maWxlIGFuZCBkZWNpZGUgd2hldGhlciBib3VuZHMgY2hlY2tzIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAvLyB0byB0aGUgbWV0aG9kcyBiZWxvdy5cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciB2aWV3UmVmID0gdGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQodmlld1JlZiwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdSZWY7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSwgaW5kZXgsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgICAgICBpZiAoaW5qZWN0b3IgPT09IHZvaWQgMCkgeyBpbmplY3RvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlQ29tcG9uZW50SW5Db250YWluZXJTY29wZSgpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHRJbmplY3RvciA9IGluamVjdG9yIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUoY29udGV4dEluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGNvbXBvbmVudFJlZi5ob3N0VmlldywgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIGNvbXBvbmVudFJlZik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmlld1JlZiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5faW5zZXJ0U2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHZpZXdSZWZfID0gdmlld1JlZjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYXR0YWNoVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCB2aWV3UmVmXyk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHZpZXdSZWYsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9pbnNlcnRTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmlld1JlZl8gPSB2aWV3UmVmO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5tb3ZlVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgdmlld1JlZl8pO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5uZXN0ZWRWaWV3cy5pbmRleE9mKHZpZXdSZWYuaW50ZXJuYWxWaWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyhpKTogcmVuYW1lIHRvIGRlc3Ryb3lcbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9yZW1vdmVTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9lbGVtZW50LmRldGFjaFZpZXcoaW5kZXgpO1xuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyB2aWV3IGlzIGludGVudGlvbmFsbHkgbm90IHJldHVybmVkIHRvIHRoZSBjbGllbnQuXG4gICAgICAgICAgICB3dGZMZWF2ZShzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyhpKTogcmVmYWN0b3IgaW5zZXJ0K3JlbW92ZSBpbnRvIG1vdmVcbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9kZXRhY2hTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9lbGVtZW50LmRldGFjaFZpZXcoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIHZpZXcucmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWZfO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9xdWV1ZWRBbmltYXRpb25zID0gW107XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIHF1ZXVlQW5pbWF0aW9uR2xvYmFsbHkocGxheWVyKSB7XG4gICAgICAgIF9xdWV1ZWRBbmltYXRpb25zLnB1c2gocGxheWVyKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJRdWV1ZWRBbmltYXRpb25zKCkge1xuICAgICAgICAvLyB0aGlzIGNvZGUgaXMgd3JhcHBlZCBpbnRvIGEgc2luZ2xlIHByb21pc2Ugc3VjaCB0aGF0IHRoZVxuICAgICAgICAvLyBvblN0YXJ0IGFuZCBvbkRvbmUgcGxheWVyIGNhbGxiYWNrcyBhcmUgdHJpZ2dlcmVkIG91dHNpZGVcbiAgICAgICAgLy8gb2YgdGhlIGRpZ2VzdCBjeWNsZSBvZiBhbmltYXRpb25zXG4gICAgICAgIGlmIChfcXVldWVkQW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKF90cmlnZ2VyQW5pbWF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3RyaWdnZXJBbmltYXRpb25zKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9xdWV1ZWRBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGxheWVyID0gX3F1ZXVlZEFuaW1hdGlvbnNbaV07XG4gICAgICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIF9xdWV1ZWRBbmltYXRpb25zID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3UmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVmlld1JlZjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBWaWV3LlxuICAgICAqXG4gICAgICogPCEtLSBUT0RPOiBtb3ZlIHRoZSBuZXh0IHR3byBwYXJhZ3JhcGhzIHRvIHRoZSBkZXYgZ3VpZGUgLS0+XG4gICAgICogQSBWaWV3IGlzIGEgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIGFwcGxpY2F0aW9uIFVJLiBJdCBpcyB0aGUgc21hbGxlc3QgZ3JvdXBpbmcgb2ZcbiAgICAgKiBFbGVtZW50cyB3aGljaCBhcmUgY3JlYXRlZCBhbmQgZGVzdHJveWVkIHRvZ2V0aGVyLlxuICAgICAqXG4gICAgICogUHJvcGVydGllcyBvZiBlbGVtZW50cyBpbiBhIFZpZXcgY2FuIGNoYW5nZSwgYnV0IHRoZSBzdHJ1Y3R1cmUgKG51bWJlciBhbmQgb3JkZXIpIG9mIGVsZW1lbnRzIGluXG4gICAgICogYSBWaWV3IGNhbm5vdC4gQ2hhbmdpbmcgdGhlIHN0cnVjdHVyZSBvZiBFbGVtZW50cyBjYW4gb25seSBiZSBkb25lIGJ5IGluc2VydGluZywgbW92aW5nIG9yXG4gICAgICogcmVtb3ZpbmcgbmVzdGVkIFZpZXdzIHZpYSBhIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfS4gRWFjaCBWaWV3IGNhbiBjb250YWluIG1hbnkgVmlldyBDb250YWluZXJzLlxuICAgICAqIDwhLS0gL1RPRE8gLS0+XG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogR2l2ZW4gdGhpcyB0ZW1wbGF0ZS4uLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cbiAgICAgKiA8dWw+XG4gICAgICogICA8bGkgKm5nRm9yPVwibGV0ICBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX08L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXZSBoYXZlIHR3byB7QGxpbmsgVGVtcGxhdGVSZWZ9czpcbiAgICAgKlxuICAgICAqIE91dGVyIHtAbGluayBUZW1wbGF0ZVJlZn06XG4gICAgICogYGBgXG4gICAgICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cbiAgICAgKiA8dWw+XG4gICAgICogICA8dGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gW25nRm9yT2ZdPVwiaXRlbXNcIj48L3RlbXBsYXRlPlxuICAgICAqIDwvdWw+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbm5lciB7QGxpbmsgVGVtcGxhdGVSZWZ9OlxuICAgICAqIGBgYFxuICAgICAqICAgPGxpPnt7aXRlbX19PC9saT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGljZSB0aGF0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBpcyBicm9rZW4gZG93biBpbnRvIHR3byBzZXBhcmF0ZSB7QGxpbmsgVGVtcGxhdGVSZWZ9cy5cbiAgICAgKlxuICAgICAqIFRoZSBvdXRlci9pbm5lciB7QGxpbmsgVGVtcGxhdGVSZWZ9cyBhcmUgdGhlbiBhc3NlbWJsZWQgaW50byB2aWV3cyBsaWtlIHNvOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPCEtLSBWaWV3UmVmOiBvdXRlci0wIC0tPlxuICAgICAqIENvdW50OiAyXG4gICAgICogPHVsPlxuICAgICAqICAgPHRlbXBsYXRlIHZpZXctY29udGFpbmVyLXJlZj48L3RlbXBsYXRlPlxuICAgICAqICAgPCEtLSBWaWV3UmVmOiBpbm5lci0xIC0tPjxsaT5maXJzdDwvbGk+PCEtLSAvVmlld1JlZjogaW5uZXItMSAtLT5cbiAgICAgKiAgIDwhLS0gVmlld1JlZjogaW5uZXItMiAtLT48bGk+c2Vjb25kPC9saT48IS0tIC9WaWV3UmVmOiBpbm5lci0yIC0tPlxuICAgICAqIDwvdWw+XG4gICAgICogPCEtLSAvVmlld1JlZjogb3V0ZXItMCAtLT5cbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEVtYmVkZGVkVmlld1JlZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMShFbWJlZGRlZFZpZXdSZWYsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVtYmVkZGVkVmlld1JlZigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWJlZGRlZFZpZXdSZWYucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1iZWRkZWRWaWV3UmVmLnByb3RvdHlwZSwgXCJyb290Tm9kZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIHJldHVybiBFbWJlZGRlZFZpZXdSZWY7XG4gICAgfShWaWV3UmVmKSk7XG4gICAgdmFyIFZpZXdSZWZfID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld1JlZl8oX3ZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTW9kZSA9IHRoaXMuX3ZpZXcuY2RNb2RlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwiaW50ZXJuYWxWaWV3XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldzsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwicm9vdE5vZGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5mbGF0Um9vdE5vZGVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5jb250ZXh0OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmRlc3Ryb3llZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5tYXJrRm9yQ2hlY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSgpOyB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkOyB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcuZGV0ZWN0Q2hhbmdlcyhmYWxzZSk7XG4gICAgICAgICAgICB0cmlnZ2VyUXVldWVkQW5pbWF0aW9ucygpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuY2hlY2tOb0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcuZGV0ZWN0Q2hhbmdlcyh0cnVlKTsgfTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLnJlYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmlldy5jZE1vZGUgPSB0aGlzLl9vcmlnaW5hbE1vZGU7XG4gICAgICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZpZXcuZGlzcG9zYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3LmRpc3Bvc2FibGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92aWV3LmRpc3Bvc2FibGVzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5kZXRhY2hBbmREZXN0cm95KCk7IH07XG4gICAgICAgIHJldHVybiBWaWV3UmVmXztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgRXZlbnRMaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gRXZlbnRMaXN0ZW5lcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQWxsIGRlYnVnZ2luZyBhcGlzIGFyZSBjdXJyZW50bHkgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBEZWJ1Z05vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z05vZGUobmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1Z0luZm8gPSBfZGVidWdJbmZvO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVOb2RlID0gbmF0aXZlTm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50IGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFkZENoaWxkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5pbmplY3RvciA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJjb21wb25lbnRJbnN0YW5jZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5jb21wb25lbnQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5jb250ZXh0IDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5yZWZlcmVuY2VzIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJwcm92aWRlclRva2Vuc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5wcm92aWRlclRva2VucyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWJ1Z0luZm8gPyB0aGlzLl9kZWJ1Z0luZm8uc291cmNlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEZWJ1Z05vZGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFsbCBkZWJ1Z2dpbmcgYXBpcyBhcmUgY3VycmVudGx5IGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgRGVidWdFbGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEyKERlYnVnRWxlbWVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdFbGVtZW50KG5hdGl2ZU5vZGUsIHBhcmVudCwgX2RlYnVnSW5mbykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEluZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLmluc2VydENoaWxkcmVuQWZ0ZXIgPSBmdW5jdGlvbiAoY2hpbGQsIG5ld0NoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgc2libGluZ0luZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKHNpYmxpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNDaGlsZHJlbiA9IHRoaXMuY2hpbGROb2Rlcy5zbGljZSgwLCBzaWJsaW5nSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKHNpYmxpbmdJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IHByZXZpb3VzQ2hpbGRyZW4uY29uY2F0KG5ld0NoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMucXVlcnlBbGwocHJlZGljYXRlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdIHx8IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnlBbGwgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgX3F1ZXJ5RWxlbWVudENoaWxkcmVuKHRoaXMsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeUFsbE5vZGVzID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIF9xdWVyeU5vZGVDaGlsZHJlbih0aGlzLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50OyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnRyaWdnZXJFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudE9iaikge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soZXZlbnRPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVidWdFbGVtZW50O1xuICAgIH0oRGVidWdOb2RlKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzTmF0aXZlRWxlbWVudHMoZGVidWdFbHMpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRWxzLm1hcChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLm5hdGl2ZUVsZW1lbnQ7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcXVlcnlFbGVtZW50Q2hpbGRyZW4oZWxlbWVudCwgcHJlZGljYXRlLCBtYXRjaGVzKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcXVlcnlFbGVtZW50Q2hpbGRyZW4obm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9xdWVyeU5vZGVDaGlsZHJlbihwYXJlbnROb2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9xdWVyeU5vZGVDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5lZWQgdG8ga2VlcCB0aGUgbm9kZXMgaW4gYSBnbG9iYWwgTWFwIHNvIHRoYXQgbXVsdGlwbGUgYW5ndWxhciBhcHBzIGFyZSBzdXBwb3J0ZWQuXG4gICAgdmFyIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldERlYnVnTm9kZShuYXRpdmVOb2RlKSB7XG4gICAgICAgIHJldHVybiBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLmdldChuYXRpdmVOb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZXhEZWJ1Z05vZGUobm9kZSkge1xuICAgICAgICBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLnNldChub2RlLm5hdGl2ZU5vZGUsIG5vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVEZWJ1Z05vZGVGcm9tSW5kZXgobm9kZSkge1xuICAgICAgICBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLmRlbGV0ZShub2RlLm5hdGl2ZU5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWZsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiByZWZsZWN0b3I7XG4gICAgfVxuICAgIHZhciBfQ09SRV9QTEFURk9STV9QUk9WSURFUlMgPSBbXG4gICAgICAgIFBsYXRmb3JtUmVmXyxcbiAgICAgICAgeyBwcm92aWRlOiBQbGF0Zm9ybVJlZiwgdXNlRXhpc3Rpbmc6IFBsYXRmb3JtUmVmXyB9LFxuICAgICAgICB7IHByb3ZpZGU6IFJlZmxlY3RvciwgdXNlRmFjdG9yeTogX3JlZmxlY3RvciwgZGVwczogW10gfSxcbiAgICAgICAgeyBwcm92aWRlOiBSZWZsZWN0b3JSZWFkZXIsIHVzZUV4aXN0aW5nOiBSZWZsZWN0b3IgfSxcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeSxcbiAgICAgICAgQ29uc29sZSxcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIFRoaXMgcGxhdGZvcm0gaGFzIHRvIGJlIGluY2x1ZGVkIGluIGFueSBvdGhlciBwbGF0Zm9ybVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBwbGF0Zm9ybUNvcmUgPSBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkobnVsbCwgJ2NvcmUnLCBfQ09SRV9QTEFURk9STV9QUk9WSURFUlMpO1xuXG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBpMThuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBMT0NBTEVfSUQgPSBuZXcgT3BhcXVlVG9rZW4oJ0xvY2FsZUlkJyk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBpMThuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBUUkFOU0xBVElPTlMgPSBuZXcgT3BhcXVlVG9rZW4oJ1RyYW5zbGF0aW9ucycpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgaTE4biBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgVFJBTlNMQVRJT05TX0ZPUk1BVCA9IG5ldyBPcGFxdWVUb2tlbignVHJhbnNsYXRpb25zRm9ybWF0Jyk7XG5cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVEaWZmZXJzRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRJdGVyYWJsZURpZmZlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9rZXlWYWx1ZURpZmZlcnNGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEtleVZhbHVlRGlmZmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2R1bGUgaW5jbHVkZXMgdGhlIHByb3ZpZGVycyBvZiBAYW5ndWxhci9jb3JlIHRoYXQgYXJlIG5lZWRlZFxuICAgICAqIHRvIGJvb3RzdHJhcCBjb21wb25lbnRzIHZpYSBgQXBwbGljYXRpb25SZWZgLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBcHBsaWNhdGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEFwcGxpY2F0aW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwbGljYXRpb25SZWZfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogQXBwbGljYXRpb25SZWYsIHVzZUV4aXN0aW5nOiBBcHBsaWNhdGlvblJlZl8gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tcGlsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBQX0lEX1JBTkRPTV9QUk9WSURFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3VXRpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBJdGVyYWJsZURpZmZlcnMsIHVzZUZhY3Rvcnk6IF9pdGVyYWJsZURpZmZlcnNGYWN0b3J5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBLZXlWYWx1ZURpZmZlcnMsIHVzZUZhY3Rvcnk6IF9rZXlWYWx1ZURpZmZlcnNGYWN0b3J5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBMT0NBTEVfSUQsIHVzZVZhbHVlOiAnZW4tVVMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQXBwbGljYXRpb25Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIEZJTExfU1RZTEVfRkxBRyA9ICd0cnVlJzsgLy8gVE9ETyAobWF0c2tvKTogY2hhbmdlIHRvIGJvb2xlYW5cbiAgICB2YXIgQU5ZX1NUQVRFID0gJyonO1xuICAgIHZhciBERUZBVUxUX1NUQVRFID0gJyonO1xuICAgIHZhciBFTVBUWV9TVEFURSA9ICd2b2lkJztcblxuICAgIHZhciBBbmltYXRpb25Hcm91cFBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkdyb3VwUGxheWVyKF9wbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IF9wbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5fcGxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG90YWwgPT0gMCkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbkZpbmlzaCgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5wYXJlbnRQbGF5ZXIgPSBfdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA+PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5pbml0KCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFyZW50UGxheWVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucGxheSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnBhdXNlKCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXN0YXJ0KCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZmluaXNoKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXNldCgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHAgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHBsYXllci5zZXRQb3NpdGlvbihwKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBsYXllci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHAsIG1pbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cFBsYXllcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25LZXlmcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbktleWZyYW1lKG9mZnNldCwgc3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25LZXlmcmFtZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBsYXllcigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJwYXJlbnRQbGF5ZXJcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEOiBCYXNlIENsYXNzJyk7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwbGF5ZXIpIHsgdGhyb3cgbmV3IEVycm9yKCdOT1QgSU1QTEVNRU5URUQ6IEJhc2UgQ2xhc3MnKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25QbGF5ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTm9PcEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5vT3BBbmltYXRpb25QbGF5ZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX29uRmluaXNoKCk7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwIC8qKiBUT0RPICM5MTAwICovKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcbiAgICAgICAgcmV0dXJuIE5vT3BBbmltYXRpb25QbGF5ZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBBbmltYXRpb25TZXF1ZW5jZVBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyKF9wbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IF9wbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcGxheWVyLnBhcmVudFBsYXllciA9IF90aGlzOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uTmV4dChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLl9vbk5leHQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5fZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXllcnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQbGF5ZXIgPSBuZXcgTm9PcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbkZpbmlzaCgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA+PSB0aGlzLl9wbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBsYXllciA9IG5ldyBOb09wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLl9wbGF5ZXJzW3RoaXMuX2N1cnJlbnRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbk5leHQodHJ1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBsYXllciA9IHBsYXllcjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmluaXQoKTsgfSk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYXJlbnRQbGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9hY3RpdmVQbGF5ZXIucGF1c2UoKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWVyc1swXS5yZXN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucmVzZXQoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBsYXllciA9IG5ldyBOb09wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwIC8qKiBUT0RPICM5MTAwICovKSB7IHRoaXMuX3BsYXllcnNbMF0uc2V0UG9zaXRpb24ocCk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYXllcnNbMF0uZ2V0UG9zaXRpb24oKTsgfTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBVVRPX1NUWUxFID0gJyonO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayB0cmlnZ2VyIHRyaWdnZXJcbiAgICAgKiBhbmltYXRpb24gZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBkZWZpbml0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25TdGF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBzdGF0ZSBzdGF0ZSBhbmltYXRpb25cbiAgICAgKiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZU5hbWVFeHByID0gc3RhdGVOYW1lRXhwcjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGVcbiAgICAgKiB7QGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YShzdGF0ZUNoYW5nZUV4cHIsIHN0ZXBzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFeHByID0gc3RhdGVDaGFuZ2VFeHByO1xuICAgICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25NZXRhZGF0YSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uTWV0YWRhdGE7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7QGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc1xuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBzdHlsZSBzdHlsZSBhbmltYXRpb25cbiAgICAgKiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0eWxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3R5bGVNZXRhZGF0YShzdHlsZXMsIG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIGFuaW1hdGUgYW5pbWF0ZVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25BbmltYXRlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25BbmltYXRlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEucHJvdG90eXBlLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05PVCBJTVBMRU1FTlRFRDogQmFzZSBDbGFzcycpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7QGxpbmsgc2VxdWVuY2Ugc2VxdWVuY2VcbiAgICAgKiBhbmltYXRpb24gZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoX3N0ZXBzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXBzID0gX3N0ZXBzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJzdGVwc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0ZXBzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBncm91cCBncm91cCBhbmltYXRpb25cbiAgICAgKiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShfc3RlcHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc3RlcHMgPSBfc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEucHJvdG90eXBlLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RlcHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogYGFuaW1hdGVgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBhbmltYXRlYCBzcGVjaWZpZXMgYW4gYW5pbWF0aW9uIHN0ZXAgdGhhdCB3aWxsIGFwcGx5IHRoZSBwcm92aWRlZCBgc3R5bGVzYCBkYXRhIGZvciBhIGdpdmVuXG4gICAgICogYW1vdW50IG9mXG4gICAgICogdGltZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYHRpbWluZ2AgZXhwcmVzc2lvbiB2YWx1ZS4gQ2FsbHMgdG8gYGFuaW1hdGVgIGFyZSBleHBlY3RlZCB0byBiZVxuICAgICAqIHVzZWQgd2l0aGluIHtAbGluayBzZXF1ZW5jZSBhbiBhbmltYXRpb24gc2VxdWVuY2V9LCB7QGxpbmsgZ3JvdXAgZ3JvdXB9LCBvciB7QGxpbmsgdHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb259LlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYGFuaW1hdGVgIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGlucHV0IHBhcmFtZXRlcnM6IGB0aW1pbmdgIGFuZCBgc3R5bGVzYDpcbiAgICAgKlxuICAgICAqIC0gYHRpbWluZ2AgaXMgYSBzdHJpbmcgYmFzZWQgdmFsdWUgdGhhdCBjYW4gYmUgYSBjb21iaW5hdGlvbiBvZiBhIGR1cmF0aW9uIHdpdGggb3B0aW9uYWxcbiAgICAgKiBkZWxheSBhbmQgZWFzaW5nIHZhbHVlcy4gVGhlIGZvcm1hdCBmb3IgdGhlIGV4cHJlc3Npb24gYnJlYWtzIGRvd24gdG8gYGR1cmF0aW9uIGRlbGF5IGVhc2luZ2BcbiAgICAgKiAodGhlcmVmb3JlIGEgdmFsdWUgc3VjaCBhcyBgMXMgMTAwbXMgZWFzZS1vdXRgIHdpbGwgYmUgcGFyc2UgaXRzZWxmIGludG8gYGR1cmF0aW9uPTEwMDAsXG4gICAgICogZGVsYXk9MTAwLCBlYXNpbmc9ZWFzZS1vdXRgLlxuICAgICAqIElmIGEgbnVtZXJpYyB2YWx1ZSBpcyBwcm92aWRlZCB0aGVuIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBgZHVyYXRpb25gIHZhbHVlIGluIG1pbGxpc2Vjb25kXG4gICAgICogZm9ybS5cbiAgICAgKiAtIGBzdHlsZXNgIGlzIHRoZSBzdHlsZSBpbnB1dCBkYXRhIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBjYWxsIHRvIHtAbGluayBzdHlsZSBzdHlsZX0gb3Ige0BsaW5rXG4gICAgICoga2V5ZnJhbWVzIGtleWZyYW1lc30uXG4gICAgICogSWYgbGVmdCBlbXB0eSB0aGVuIHRoZSBzdHlsZXMgZnJvbSB0aGUgZGVzdGluYXRpb24gc3RhdGUgd2lsbCBiZSBjb2xsZWN0ZWQgYW5kIHVzZWQgKHRoaXMgaXNcbiAgICAgKiB1c2VmdWwgd2hlblxuICAgICAqIGRlc2NyaWJpbmcgYW4gYW5pbWF0aW9uIHN0ZXAgdGhhdCB3aWxsIGNvbXBsZXRlIGFuIGFuaW1hdGlvbiBieSB7QGxpbmtcbiAgICAgKiB0cmFuc2l0aW9uI3RoZS1maW5hbC1hbmltYXRlLWNhbGwgYW5pbWF0aW5nIHRvIHRoZSBmaW5hbCBzdGF0ZX0pLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHZhcmlvdXMgZnVuY3Rpb25zIGZvciBzcGVjaWZ5aW5nIHRpbWluZyBkYXRhXG4gICAgICogYW5pbWF0ZSg1MDAsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjFzXCIsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjEwMG1zIDAuNXNcIiwgc3R5bGUoLi4uKSlcbiAgICAgKiBhbmltYXRlKFwiNXMgZWFzZVwiLCBzdHlsZSguLi4pKVxuICAgICAqIGFuaW1hdGUoXCI1cyAxMG1zIGN1YmljLWJlemllciguMTcsLjY3LC44OCwuMSlcIiwgc3R5bGUoLi4uKSlcbiAgICAgKlxuICAgICAqIC8vIGVpdGhlciBzdHlsZSgpIG9mIGtleWZyYW1lcygpIGNhbiBiZSB1c2VkXG4gICAgICogYW5pbWF0ZSg1MDAsIHN0eWxlKHsgYmFja2dyb3VuZDogXCJyZWRcIiB9KSlcbiAgICAgKiBhbmltYXRlKDUwMCwga2V5ZnJhbWVzKFtcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZDogXCJibHVlXCIgfSkpLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiIH0pKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1pbmcsIHN0eWxlcykge1xuICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgc3R5bGVzRW50cnkgPSBzdHlsZXM7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHN0eWxlc0VudHJ5KSkge1xuICAgICAgICAgICAgdmFyIEVNUFRZX1NUWUxFID0ge307XG4gICAgICAgICAgICBzdHlsZXNFbnRyeSA9IG5ldyBBbmltYXRpb25TdHlsZU1ldGFkYXRhKFtFTVBUWV9TVFlMRV0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHRpbWluZywgc3R5bGVzRW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ3JvdXBgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBncm91cGAgc3BlY2lmaWVzIGEgbGlzdCBvZiBhbmltYXRpb24gc3RlcHMgdGhhdCBhcmUgYWxsIHJ1biBpbiBwYXJhbGxlbC4gR3JvdXBlZCBhbmltYXRpb25zXG4gICAgICogYXJlIHVzZWZ1bCB3aGVuIGEgc2VyaWVzIG9mIHN0eWxlcyBtdXN0IGJlIGFuaW1hdGVkL2Nsb3NlZCBvZmZcbiAgICAgKiBhdCBkaWZmZXJlbnQgc3RhdHJ0aW5nL2VuZGluZyB0aW1lcy5cbiAgICAgKlxuICAgICAqIFRoZSBgZ3JvdXBgIGZ1bmN0aW9uIGNhbiBlaXRoZXIgYmUgdXNlZCB3aXRoaW4gYSB7QGxpbmsgc2VxdWVuY2Ugc2VxdWVuY2V9IG9yIGEge0BsaW5rIHRyYW5zaXRpb25cbiAgICAgKiB0cmFuc2l0aW9ufVxuICAgICAqIGFuZCBpdCB3aWxsIG9ubHkgY29udGludWUgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gb25jZSBhbGwgb2YgdGhlIGlubmVyIGFuaW1hdGlvbiBzdGVwc1xuICAgICAqIGhhdmUgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYHN0ZXBzYCBkYXRhIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlIGBncm91cGAgYW5pbWF0aW9uIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY29uc2lzdFxuICAgICAqIG9mIHtAbGluayBzdHlsZSBzdHlsZX0gb3Ige0BsaW5rIGFuaW1hdGUgYW5pbWF0ZX0gZnVuY3Rpb24gY2FsbHMuIEVhY2ggY2FsbCB0byBgc3R5bGUoKWAgb3JcbiAgICAgKiBgYW5pbWF0ZSgpYFxuICAgICAqIHdpdGhpbiBhIGdyb3VwIHdpbGwgYmUgZXhlY3V0ZWQgaW5zdGFudGx5ICh1c2Uge0BsaW5rIGtleWZyYW1lcyBrZXlmcmFtZXN9IG9yIGFcbiAgICAgKiB7QGxpbmsgYW5pbWF0ZSN1c2FnZSBhbmltYXRlKCkgd2l0aCBhIGRlbGF5IHZhbHVlfSB0byBvZmZzZXQgc3R5bGVzIHRvIGJlIGFwcGxpZWQgYXQgYSBsYXRlclxuICAgICAqIHRpbWUpLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGdyb3VwKFtcbiAgICAgKiAgIGFuaW1hdGUoXCIxc1wiLCB7IGJhY2tncm91bmQ6IFwiYmxhY2tcIiB9KSlcbiAgICAgKiAgIGFuaW1hdGUoXCIyc1wiLCB7IGNvbG9yOiBcIndoaXRlXCIgfSkpXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cChzdGVwcykge1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoc3RlcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2VxdWVuY2VgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBzZXF1ZW5jZWAgU3BlY2lmaWVzIGEgbGlzdCBvZiBhbmltYXRpb24gc3RlcHMgdGhhdCBhcmUgcnVuIG9uZSBieSBvbmUuIChgc2VxdWVuY2VgIGlzIHVzZWRcbiAgICAgKiBieSBkZWZhdWx0IHdoZW4gYW4gYXJyYXkgaXMgcGFzc2VkIGFzIGFuaW1hdGlvbiBkYXRhIGludG8ge0BsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn0uKVxuICAgICAqXG4gICAgICogVGhlIGBzZXF1ZW5jZWAgZnVuY3Rpb24gY2FuIGVpdGhlciBiZSB1c2VkIHdpdGhpbiBhIHtAbGluayBncm91cCBncm91cH0gb3IgYSB7QGxpbmsgdHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb259XG4gICAgICogYW5kIGl0IHdpbGwgb25seSBjb250aW51ZSB0byB0aGUgbmV4dCBpbnN0cnVjdGlvbiBvbmNlIGVhY2ggb2YgdGhlIGlubmVyIGFuaW1hdGlvbiBzdGVwc1xuICAgICAqIGhhdmUgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogVG8gcGVyZm9ybSBhbmltYXRpb24gc3R5bGluZyBpbiBwYXJhbGxlbCB3aXRoIG90aGVyIGFuaW1hdGlvbiBzdGVwcyB0aGVuXG4gICAgICogaGF2ZSBhIGxvb2sgYXQgdGhlIHtAbGluayBncm91cCBncm91cH0gYW5pbWF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYHN0ZXBzYCBkYXRhIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlIGBzZXF1ZW5jZWAgYW5pbWF0aW9uIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY29uc2lzdFxuICAgICAqIG9mIHtAbGluayBzdHlsZSBzdHlsZX0gb3Ige0BsaW5rIGFuaW1hdGUgYW5pbWF0ZX0gZnVuY3Rpb24gY2FsbHMuIEEgY2FsbCB0byBgc3R5bGUoKWAgd2lsbCBhcHBseVxuICAgICAqIHRoZVxuICAgICAqIHByb3ZpZGVkIHN0eWxpbmcgZGF0YSBpbW1lZGlhdGVseSB3aGlsZSBhIGNhbGwgdG8gYGFuaW1hdGUoKWAgd2lsbCBhcHBseSBpdHMgc3R5bGluZ1xuICAgICAqIGRhdGEgb3ZlciBhIGdpdmVuIHRpbWUgZGVwZW5kaW5nIG9uIGl0cyB0aW1pbmcgZGF0YS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBzZXF1ZW5jZShbXG4gICAgICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpLFxuICAgICAqICAgYW5pbWF0ZShcIjFzXCIsIHsgb3BhY2l0eTogMSB9KSlcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcXVlbmNlKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzdHlsZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHN0eWxlYCBkZWNsYXJlcyBhIGtleS92YWx1ZSBvYmplY3QgY29udGFpbmluZyBDU1MgcHJvcGVydGllcy9zdHlsZXMgdGhhdCBjYW4gdGhlblxuICAgICAqIGJlIHVzZWQgZm9yIHtAbGluayBzdGF0ZSBhbmltYXRpb24gc3RhdGVzfSwgd2l0aGluIGFuIHtAbGluayBzZXF1ZW5jZSBhbmltYXRpb24gc2VxdWVuY2V9LCBvciBhc1xuICAgICAqIHN0eWxpbmcgZGF0YSBmb3IgYm90aCB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBhbmQge0BsaW5rIGtleWZyYW1lcyBrZXlmcmFtZXN9LlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBgc3R5bGVgIHRha2VzIGluIGEga2V5L3ZhbHVlIHN0cmluZyBtYXAgYXMgZGF0YSBhbmQgZXhwZWN0cyBvbmUgb3IgbW9yZSBDU1MgcHJvcGVydHkvdmFsdWVcbiAgICAgKiBwYWlycyB0byBiZSBkZWZpbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHN0cmluZyB2YWx1ZXMgYXJlIHVzZWQgZm9yIGNzcyBwcm9wZXJ0aWVzXG4gICAgICogc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiLCBjb2xvcjogXCJibHVlXCIgfSlcbiAgICAgKlxuICAgICAqIC8vIG51bWVyaWNhbCAocGl4ZWwpIHZhbHVlcyBhcmUgYWxzbyBzdXBwb3J0ZWRcbiAgICAgKiBzdHlsZSh7IHdpZHRoOiAxMDAsIGhlaWdodDogMCB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIyBBdXRvLXN0eWxlcyAodXNpbmcgYCpgKVxuICAgICAqXG4gICAgICogV2hlbiBhbiBhc3Rlcml4IChgKmApIGNoYXJhY3RlciBpcyB1c2VkIGFzIGEgdmFsdWUgdGhlbiBpdCB3aWxsIGJlIGRldGVjdGVkIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBiZWluZyBhbmltYXRlZFxuICAgICAqIGFuZCBhcHBsaWVkIGFzIGFuaW1hdGlvbiBkYXRhIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZlYXR1cmUgcHJvdmVzIHVzZWZ1bCBmb3IgYSBzdGF0ZSBkZXBlbmRpbmcgb24gbGF5b3V0IGFuZC9vciBlbnZpcm9ubWVudCBmYWN0b3JzOyBpbiBzdWNoXG4gICAgICogY2FzZXNcbiAgICAgKiB0aGUgc3R5bGVzIGFyZSBjYWxjdWxhdGVkIGp1c3QgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHRoZSBzdGVwcyBiZWxvdyB3aWxsIGFuaW1hdGUgZnJvbSAwIHRvIHRoZVxuICAgICAqIC8vIGFjdHVhbCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBzdHlsZSh7IGhlaWdodDogMCB9KSxcbiAgICAgKiBhbmltYXRlKFwiMXNcIiwgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0eWxlKHRva2Vucykge1xuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gW3Rva2Vuc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IFt0b2tlbnNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnlPZmZzZXQgPSBlbnRyeVsnb2Zmc2V0J107XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChlbnRyeU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID09IG51bGwgPyBwYXJzZUZsb2F0KGVudHJ5T2Zmc2V0KSA6IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblN0eWxlTWV0YWRhdGEoaW5wdXQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzdGF0ZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHN0YXRlYCBkZWNsYXJlcyBhbiBhbmltYXRpb24gc3RhdGUgd2l0aGluIHRoZSBnaXZlbiB0cmlnZ2VyLiBXaGVuIGEgc3RhdGUgaXNcbiAgICAgKiBhY3RpdmUgd2l0aGluIGEgY29tcG9uZW50IHRoZW4gaXRzIGFzc29jaWF0ZWQgc3R5bGVzIHdpbGwgcGVyc2lzdCBvblxuICAgICAqIHRoZSBlbGVtZW50IHRoYXQgdGhlIHRyaWdnZXIgaXMgYXR0YWNoZWQgdG8gKGV2ZW4gd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMpLlxuICAgICAqXG4gICAgICogVG8gYW5pbWF0ZSBiZXR3ZWVuIHN0YXRlcywgaGF2ZSBhIGxvb2sgYXQgdGhlIGFuaW1hdGlvbiB7QGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9ufVxuICAgICAqIERTTCBmdW5jdGlvbi4gVG8gcmVnaXN0ZXIgc3RhdGVzIHRvIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHBsZWFzZSBoYXZlIGEgbG9va1xuICAgICAqIGF0IHRoZSB7QGxpbmsgdHJpZ2dlciB0cmlnZ2VyfSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgVGhlIGB2b2lkYCBzdGF0ZVxuICAgICAqXG4gICAgICogVGhlIGB2b2lkYCBzdGF0ZSB2YWx1ZSBpcyBhIHJlc2VydmVkIHdvcmQgdGhhdCBhbmd1bGFyIHVzZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90XG4gICAgICogYXBhcnRcbiAgICAgKiBvZiB0aGUgYXBwbGljYXRpb24gYW55bW9yZSAoZS5nLiB3aGVuIGFuIGBuZ0lmYCBldmFsdWF0ZXMgdG8gZmFsc2UgdGhlbiB0aGUgc3RhdGUgb2YgdGhlXG4gICAgICogYXNzb2NpYXRlZCBlbGVtZW50XG4gICAgICogaXMgdm9pZCkuXG4gICAgICpcbiAgICAgKiAjIyMjIFRoZSBgKmAgKGRlZmF1bHQpIHN0YXRlXG4gICAgICpcbiAgICAgKiBUaGUgYCpgIHN0YXRlICh3aGVuIHN0eWxlZCkgaXMgYSBmYWxsYmFjayBzdGF0ZSB0aGF0IHdpbGwgYmUgdXNlZCBpZlxuICAgICAqIHRoZSBzdGF0ZSB0aGF0IGlzIGJlaW5nIGFuaW1hdGVkIGlzIG5vdCBkZWNsYXJlZCB3aXRoaW4gdGhlIHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIGBzdGF0ZWAgd2lsbCBkZWNsYXJlIGFuIGFuaW1hdGlvbiBzdGF0ZSB3aXRoIGl0cyBhc3NvY2lhdGVkIHN0eWxlc1xuICAgICAqIHdpdGhpbiB0aGUgZ2l2ZW4gdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIC0gYHN0YXRlTmFtZUV4cHJgIGNhbiBiZSBvbmUgb3IgbW9yZSBzdGF0ZSBuYW1lcyBzZXBhcmF0ZWQgYnkgY29tbWFzLlxuICAgICAqIC0gYHN0eWxlc2AgcmVmZXJzIHRvIHRoZSB7QGxpbmsgc3R5bGUgc3R5bGluZyBkYXRhfSB0aGF0IHdpbGwgYmUgcGVyc2lzdGVkIG9uIHRoZSBlbGVtZW50IG9uY2VcbiAgICAgKiB0aGUgc3RhdGVcbiAgICAgKiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIFwidm9pZFwiIGlzIGEgcmVzZXJ2ZWQgbmFtZSBmb3IgYSBzdGF0ZSBhbmQgaXMgdXNlZCB0byByZXByZXNlbnRcbiAgICAgKiAvLyB0aGUgc3RhdGUgaW4gd2hpY2ggYW4gZWxlbWVudCBpcyBkZXRhY2hlZCBmcm9tIGZyb20gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIHN0YXRlKFwidm9pZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgKlxuICAgICAqIC8vIHVzZXItZGVmaW5lZCBzdGF0ZXNcbiAgICAgKiBzdGF0ZShcImNsb3NlZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgKiBzdGF0ZShcIm9wZW4sIHZpc2libGVcIiwgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXRlKHN0YXRlTmFtZUV4cHIsIHN0eWxlcykge1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBga2V5ZnJhbWVzYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyMidzXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGFcbiAgICAgKiBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhcjIgYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBga2V5ZnJhbWVzYCBzcGVjaWZpZXMgYSBjb2xsZWN0aW9uIG9mIHtAbGluayBzdHlsZSBzdHlsZX0gZW50cmllcyBlYWNoIG9wdGlvbmFsbHkgY2hhcmFjdGVyaXplZFxuICAgICAqIGJ5IGFuIGBvZmZzZXRgIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYGtleWZyYW1lc2AgYW5pbWF0aW9uIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYWxvbmdzaWRlIHRoZSB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbi4gSW5zdGVhZCBvZiBhcHBseWluZyBhbmltYXRpb25zIGZyb20gd2hlcmUgdGhleSBhcmVcbiAgICAgKiBjdXJyZW50bHkgdG8gdGhlaXIgZGVzdGluYXRpb24sIGtleWZyYW1lcyBjYW4gZGVzY3JpYmUgaG93IGVhY2ggc3R5bGUgZW50cnkgaXMgYXBwbGllZFxuICAgICAqIGFuZCBhdCB3aGF0IHBvaW50IHdpdGhpbiB0aGUgYW5pbWF0aW9uIGFyYyAobXVjaCBsaWtlIENTUyBLZXlmcmFtZSBBbmltYXRpb25zIGRvKS5cbiAgICAgKlxuICAgICAqIEZvciBlYWNoIGBzdHlsZSgpYCBlbnRyeSBhbiBgb2Zmc2V0YCB2YWx1ZSBjYW4gYmUgc2V0LiBEb2luZyBzbyBhbGxvd3MgdG8gc3BlY2lmaXkgYXRcbiAgICAgKiB3aGF0IHBlcmNlbnRhZ2Ugb2YgdGhlIGFuaW1hdGUgdGltZSB0aGUgc3R5bGVzIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyB0aGUgcHJvdmlkZWQgb2Zmc2V0IHZhbHVlcyBkZXNjcmliZSB3aGVuIGVhY2ggYmFja2dyb3VuZENvbG9yIHZhbHVlIGlzIGFwcGxpZWQuXG4gICAgICogYW5pbWF0ZShcIjVzXCIsIGtleWZyYW1lcyhbXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJyZWRcIiwgb2Zmc2V0OiAwIH0pLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiLCBvZmZzZXQ6IDAuMiB9KSxcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcIm9yYW5nZVwiLCBvZmZzZXQ6IDAuMyB9KSxcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsYWNrXCIsIG9mZnNldDogMSB9KVxuICAgICAqIF0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQWx0ZXJuYXRpdmVseSwgaWYgdGhlcmUgYXJlIG5vIGBvZmZzZXRgIHZhbHVlcyB1c2VkIHdpdGhpbiB0aGUgc3R5bGUgZW50cmllcyB0aGVuIHRoZSBvZmZzZXRzXG4gICAgICogd2lsbFxuICAgICAqIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBhbmltYXRlKFwiNXNcIiwga2V5ZnJhbWVzKFtcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcInJlZFwiIH0pIC8vIG9mZnNldCA9IDBcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsdWVcIiB9KSAvLyBvZmZzZXQgPSAwLjMzXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJvcmFuZ2VcIiB9KSAvLyBvZmZzZXQgPSAwLjY2XG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibGFja1wiIH0pIC8vIG9mZnNldCA9IDFcbiAgICAgKiBdKSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlmcmFtZXMoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyYW5zaXRpb25gIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGB0cmFuc2l0aW9uYCBkZWNsYXJlcyB0aGUge0BsaW5rIHNlcXVlbmNlIHNlcXVlbmNlIG9mIGFuaW1hdGlvbiBzdGVwc30gdGhhdCB3aWxsIGJlIHJ1biB3aGVuIHRoZVxuICAgICAqIHByb3ZpZGVkXG4gICAgICogYHN0YXRlQ2hhbmdlRXhwcmAgdmFsdWUgaXMgc2F0aXNmaWVkLiBUaGUgYHN0YXRlQ2hhbmdlRXhwcmAgY29uc2lzdHMgb2YgYSBgc3RhdGUxID0+IHN0YXRlMmBcbiAgICAgKiB3aGljaCBjb25zaXN0c1xuICAgICAqIG9mIHR3byBrbm93biBzdGF0ZXMgKHVzZSBhbiBhc3Rlcml4IChgKmApIHRvIHJlZmVyIHRvIGEgZHluYW1pYyBzdGFydGluZyBhbmQvb3IgZW5kaW5nIHN0YXRlKS5cbiAgICAgKlxuICAgICAqIEFuaW1hdGlvbiB0cmFuc2l0aW9ucyBhcmUgcGxhY2VkIHdpdGhpbiBhbiB7QGxpbmsgdHJpZ2dlciBhbmltYXRpb24gdHJpZ2dlcn0uIEZvciBhbiB0cmFuc2l0aW9uXG4gICAgICogdG8gYW5pbWF0ZSB0b1xuICAgICAqIGEgc3RhdGUgdmFsdWUgYW5kIHBlcnNpc3QgaXRzIHN0eWxlcyB0aGVuIG9uZSBvciBtb3JlIHtAbGluayBzdGF0ZSBhbmltYXRpb24gc3RhdGVzfSBpcyBleHBlY3RlZFxuICAgICAqIHRvIGJlIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIEFuIGFuaW1hdGlvbiB0cmFuc2l0aW9uIGlzIGtpY2tlZCBvZmYgdGhlIGBzdGF0ZUNoYW5nZUV4cHJgIHByZWRpY2F0ZSBldmFsdWF0ZXMgdG8gdHJ1ZSBiYXNlZCBvblxuICAgICAqIHdoYXQgdGhlXG4gICAgICogcHJldmlvdXMgc3RhdGUgaXMgYW5kIHdoYXQgdGhlIGN1cnJlbnQgc3RhdGUgaGFzIGJlY29tZS4gSW4gb3RoZXIgd29yZHMsIGlmIGEgdHJhbnNpdGlvbiBpc1xuICAgICAqIGRlZmluZWQgdGhhdFxuICAgICAqIG1hdGNoZXMgdGhlIG9sZC9jdXJyZW50IHN0YXRlIGNyaXRlcmlhIHRoZW4gdGhlIGFzc29jaWF0ZWQgYW5pbWF0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGFsbCB0cmFuc2l0aW9uL3N0YXRlIGNoYW5nZXMgYXJlIGRlZmluZWQgd2l0aGluIGFuIGFuaW1hdGlvbiB0cmlnZ2VyXG4gICAgICogdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gICAgICogICAvLyBpZiBhIHN0YXRlIGlzIGRlZmluZWQgdGhlbiBpdHMgc3R5bGVzIHdpbGwgYmUgcGVyc2lzdGVkIHdoZW4gdGhlXG4gICAgICogICAvLyBhbmltYXRpb24gaGFzIGZ1bGx5IGNvbXBsZXRlZCBpdHNlbGZcbiAgICAgKiAgIHN0YXRlKFwib25cIiwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImdyZWVuXCIgfSkpLFxuICAgICAqICAgc3RhdGUoXCJvZmZcIiwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImdyZXlcIiB9KSksXG4gICAgICpcbiAgICAgKiAgIC8vIGEgdHJhbnNpdGlvbiBhbmltYXRpb24gdGhhdCB3aWxsIGJlIGtpY2tlZCBvZmYgd2hlbiB0aGUgc3RhdGUgdmFsdWVcbiAgICAgKiAgIC8vIGJvdW5kIHRvIFwibXlBbmltYXRpb25UcmlnZ2VyXCIgY2hhbmdlcyBmcm9tIFwib25cIiB0byBcIm9mZlwiXG4gICAgICogICB0cmFuc2l0aW9uKFwib24gPT4gb2ZmXCIsIGFuaW1hdGUoNTAwKSksXG4gICAgICpcbiAgICAgKiAgIC8vIGl0IGlzIGFsc28gcG9zc2libGUgdG8gZG8gcnVuIHRoZSBzYW1lIGFuaW1hdGlvbiBmb3IgYm90aCBkaXJlY3Rpb25zXG4gICAgICogICB0cmFuc2l0aW9uKFwib24gPD0+IG9mZlwiLCBhbmltYXRlKDUwMCkpLFxuICAgICAqXG4gICAgICogICAvLyBvciB0byBkZWZpbmUgbXVsdGlwbGUgc3RhdGVzIHBhaXJzIHNlcGFyYXRlZCBieSBjb21tYXNcbiAgICAgKiAgIHRyYW5zaXRpb24oXCJvbiA9PiBvZmYsIG9mZiA9PiB2b2lkXCIsIGFuaW1hdGUoNTAwKSksXG4gICAgICpcbiAgICAgKiAgIC8vIHRoaXMgaXMgYSBjYXRjaC1hbGwgc3RhdGUgY2hhbmdlIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50b1xuICAgICAqICAgLy8gdGhlIHBhZ2UgYW5kIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZSBpcyB1bmtub3duXG4gICAgICogICB0cmFuc2l0aW9uKFwidm9pZCA9PiAqXCIsIFtcbiAgICAgKiAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAqICAgICBhbmltYXRlKDUwMClcbiAgICAgKiAgIF0pLFxuICAgICAqXG4gICAgICogICAvLyB0aGlzIHdpbGwgY2FwdHVyZSBhIHN0YXRlIGNoYW5nZSBiZXR3ZWVuIGFueSBzdGF0ZXNcbiAgICAgKiAgIHRyYW5zaXRpb24oXCIqID0+ICpcIiwgYW5pbWF0ZShcIjFzIDBzXCIpKSxcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIHRlbXBsYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbXBvbmVudCB3aWxsIG1ha2UgdXNlIG9mIHRoZSBgbXlBbmltYXRpb25UcmlnZ2VyYFxuICAgICAqIGFuaW1hdGlvbiB0cmlnZ2VyIGJ5IGJpbmRpbmcgdG8gYW4gZWxlbWVudCB3aXRoaW4gaXRzIHRlbXBsYXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLSBzb21ld2hlcmUgaW5zaWRlIG9mIG15LWNvbXBvbmVudC10cGwuaHRtbCAtLT5cbiAgICAgKiA8ZGl2IFtAbXlBbmltYXRpb25UcmlnZ2VyXT1cIm15U3RhdHVzRXhwXCI+Li4uPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIFRoZSBmaW5hbCBgYW5pbWF0ZWAgY2FsbFxuICAgICAqXG4gICAgICogSWYgdGhlIGZpbmFsIHN0ZXAgd2l0aGluIHRoZSB0cmFuc2l0aW9uIHN0ZXBzIGlzIGEgY2FsbCB0byBgYW5pbWF0ZSgpYCB0aGF0ICoqb25seSoqXG4gICAgICogdXNlcyBhIHRpbWluZyB2YWx1ZSB3aXRoICoqbm8gc3R5bGUgZGF0YSoqIHRoZW4gaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYXMgdGhlIGZpbmFsXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogYXJjIGZvciB0aGUgZWxlbWVudCB0byBhbmltYXRlIGl0c2VsZiB0byB0aGUgZmluYWwgc3RhdGUuIFRoaXMgaW52b2x2ZXMgYW4gYXV0b21hdGljIG1peCBvZlxuICAgICAqIGFkZGluZy9yZW1vdmluZyBDU1Mgc3R5bGVzIHNvIHRoYXQgdGhlIGVsZW1lbnQgd2lsbCBiZSBpbiB0aGUgZXhhY3Qgc3RhdGUgaXQgc2hvdWxkIGJlIGZvciB0aGVcbiAgICAgKiBhcHBsaWVkIHN0YXRlIHRvIGJlIHByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBzdGFydCBvZmYgYnkgaGlkaW5nIHRoZSBlbGVtZW50LCBidXQgbWFrZSBzdXJlIHRoYXQgaXQgYW5pbWF0ZXMgcHJvcGVybHkgdG8gd2hhdGV2ZXIgc3RhdGVcbiAgICAgKiAvLyBpcyBjdXJyZW50bHkgYWN0aXZlIGZvciBcIm15QW5pbWF0aW9uVHJpZ2dlclwiXG4gICAgICogdHJhbnNpdGlvbihcInZvaWQgPT4gKlwiLCBbXG4gICAgICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICogICBhbmltYXRlKDUwMClcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIFRyYW5zaXRpb24gQWxpYXNlcyAoYDplbnRlcmAgYW5kIGA6bGVhdmVgKVxuICAgICAqXG4gICAgICogR2l2ZW4gdGhhdCBlbnRlciAoaW5zZXJ0aW9uKSBhbmQgbGVhdmUgKHJlbW92YWwpIGFuaW1hdGlvbnMgYXJlIHNvIGNvbW1vbixcbiAgICAgKiB0aGUgYHRyYW5zaXRpb25gIGZ1bmN0aW9uIGFjY2VwdHMgYm90aCBgOmVudGVyYCBhbmQgYDpsZWF2ZWAgdmFsdWVzIHdoaWNoXG4gICAgICogYXJlIGFsaWFzZXMgZm9yIHRoZSBgdm9pZCA9PiAqYCBhbmQgYCogPT4gdm9pZGAgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHRyYW5zaXRpb24oXCI6ZW50ZXJcIiwgW1xuICAgICAqICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAqICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSlcbiAgICAgKiBdKVxuICAgICAqIHRyYW5zaXRpb24oXCI6bGVhdmVcIiwgW1xuICAgICAqICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb24oc3RhdGVDaGFuZ2VFeHByLCBzdGVwcykge1xuICAgICAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IEFycmF5LmlzQXJyYXkoc3RlcHMpID8gbmV3IEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpIDogc3RlcHM7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEoc3RhdGVDaGFuZ2VFeHByLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyaWdnZXJgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGB0cmlnZ2VyYCBDcmVhdGVzIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHdoaWNoIHdpbGwgYSBsaXN0IG9mIHtAbGluayBzdGF0ZSBzdGF0ZX0gYW5kIHtAbGlua1xuICAgICAqIHRyYW5zaXRpb24gdHJhbnNpdGlvbn1cbiAgICAgKiBlbnRyaWVzIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiBib3VuZCB0byB0aGUgdHJpZ2dlciBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgYXJlIHJlZ2lzdGVyZWQgd2l0aGluIHRoZSBjb21wb25lbnQgYW5ub3RhdGlvbiBkYXRhIHVuZGVyIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgYW5pbWF0aW9ucyBzZWN0aW9ufS4gQW4gYW5pbWF0aW9uIHRyaWdnZXIgY2FuXG4gICAgICogYmUgcGxhY2VkIG9uIGFuIGVsZW1lbnQgd2l0aGluIGEgdGVtcGxhdGUgYnkgcmVmZXJlbmNpbmcgdGhlIG5hbWUgb2YgdGhlXG4gICAgICogdHJpZ2dlciBmb2xsb3dlZCBieSB0aGUgZXhwcmVzc2lvbiB2YWx1ZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGJvdW5kIHRvXG4gICAgICogKGluIHRoZSBmb3JtIG9mIGBbQHRyaWdnZXJOYW1lXT1cImV4cHJlc3Npb25cImAuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIGB0cmlnZ2VyYCB3aWxsIGNyZWF0ZSBhbiBhbmltYXRpb24gdHJpZ2dlciByZWZlcmVuY2UgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGBuYW1lYCB2YWx1ZS5cbiAgICAgKiBUaGUgcHJvdmlkZWQgYGFuaW1hdGlvbmAgdmFsdWUgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXkgY29uc2lzdGluZyBvZiB7QGxpbmsgc3RhdGUgc3RhdGV9IGFuZFxuICAgICAqIHtAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb259XG4gICAgICogZGVjbGFyYXRpb25zLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICdteS1jb21wb25lbnQnLFxuICAgICAqICAgdGVtcGxhdGVVcmw6ICdteS1jb21wb25lbnQtdHBsLmh0bWwnLFxuICAgICAqICAgYW5pbWF0aW9uczogW1xuICAgICAqICAgICB0cmlnZ2VyKFwibXlBbmltYXRpb25UcmlnZ2VyXCIsIFtcbiAgICAgKiAgICAgICBzdGF0ZSguLi4pLFxuICAgICAqICAgICAgIHN0YXRlKC4uLiksXG4gICAgICogICAgICAgdHJhbnNpdGlvbiguLi4pLFxuICAgICAqICAgICAgIHRyYW5zaXRpb24oLi4uKVxuICAgICAqICAgICBdKVxuICAgICAqICAgXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgbXlTdGF0dXNFeHAgPSBcInNvbWV0aGluZ1wiO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21wb25lbnQgd2lsbCBtYWtlIHVzZSBvZiB0aGUgYG15QW5pbWF0aW9uVHJpZ2dlcmBcbiAgICAgKiBhbmltYXRpb24gdHJpZ2dlciBieSBiaW5kaW5nIHRvIGFuIGVsZW1lbnQgd2l0aGluIGl0cyB0ZW1wbGF0ZSBjb2RlLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS0gc29tZXdoZXJlIGluc2lkZSBvZiBteS1jb21wb25lbnQtdHBsLmh0bWwgLS0+XG4gICAgICogPGRpdiBbQG15QW5pbWF0aW9uVHJpZ2dlcl09XCJteVN0YXR1c0V4cFwiPi4uLjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXIobmFtZSwgYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBhbmltYXRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcyhwcmV2aW91c1N0eWxlcywgbmV3U3R5bGVzLCBudWxsVmFsdWUpIHtcbiAgICAgICAgaWYgKG51bGxWYWx1ZSA9PT0gdm9pZCAwKSB7IG51bGxWYWx1ZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIGZpbmFsU3R5bGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG5ld1N0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3U3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgZmluYWxTdHlsZXNbcHJvcF0gPSB2YWx1ZSA9PSBBVVRPX1NUWUxFID8gbnVsbFZhbHVlIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHByZXZpb3VzU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmaW5hbFN0eWxlc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbFN0eWxlc1twcm9wXSA9IG51bGxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbFN0eWxlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyhjb2xsZWN0ZWRTdHlsZXMsIGZpbmFsU3RhdGVTdHlsZXMsIGtleWZyYW1lcykge1xuICAgICAgICB2YXIgbGltaXQgPSBrZXlmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGZpcnN0S2V5ZnJhbWUgPSBrZXlmcmFtZXNbMF07XG4gICAgICAgIC8vIHBoYXNlIDE6IGNvcHkgYWxsIHRoZSBzdHlsZXMgZnJvbSB0aGUgZmlyc3Qga2V5ZnJhbWUgaW50byB0aGUgbG9va3VwIG1hcFxuICAgICAgICB2YXIgZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzID0gZmxhdHRlblN0eWxlcyhmaXJzdEtleWZyYW1lLnN0eWxlcy5zdHlsZXMpO1xuICAgICAgICB2YXIgZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzID0ge307XG4gICAgICAgIHZhciBoYXNFeHRyYUZpcnN0U3R5bGVzID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbGxlY3RlZFN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGVkU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHN0eWxlIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgZmlyc3Qga2V5ZnJhbWUgdGhlblxuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHJlcGxhY2UgaXQuXG4gICAgICAgICAgICBpZiAoIWZsYXRlbmVkRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSkge1xuICAgICAgICAgICAgICAgIGZsYXRlbmVkRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGV4dHJhRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGhhc0V4dHJhRmlyc3RTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtleWZyYW1lQ29sbGVjdGVkU3R5bGVzID0gU3RyaW5nTWFwV3JhcHBlci5tZXJnZSh7fSwgZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzKTtcbiAgICAgICAgLy8gcGhhc2UgMjogbm9ybWFsaXplIHRoZSBmaW5hbCBrZXlmcmFtZVxuICAgICAgICB2YXIgZmluYWxLZXlmcmFtZSA9IGtleWZyYW1lc1tsaW1pdF07XG4gICAgICAgIGZpbmFsS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcy51bnNoaWZ0KGZpbmFsU3RhdGVTdHlsZXMpO1xuICAgICAgICB2YXIgZmxhdGVuZWRGaW5hbEtleWZyYW1lU3R5bGVzID0gZmxhdHRlblN0eWxlcyhmaW5hbEtleWZyYW1lLnN0eWxlcy5zdHlsZXMpO1xuICAgICAgICB2YXIgZXh0cmFGaW5hbEtleWZyYW1lU3R5bGVzID0ge307XG4gICAgICAgIHZhciBoYXNFeHRyYUZpbmFsU3R5bGVzID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5rZXlzKGtleWZyYW1lQ29sbGVjdGVkU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmbGF0ZW5lZEZpbmFsS2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFGaW5hbEtleWZyYW1lU3R5bGVzW3Byb3BdID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICBoYXNFeHRyYUZpbmFsU3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNFeHRyYUZpbmFsU3R5bGVzKSB7XG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lLnN0eWxlcy5zdHlsZXMucHVzaChleHRyYUZpbmFsS2V5ZnJhbWVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGZsYXRlbmVkRmluYWxLZXlmcmFtZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGV4dHJhRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IEFVVE9fU1RZTEU7XG4gICAgICAgICAgICAgICAgaGFzRXh0cmFGaXJzdFN0eWxlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzRXh0cmFGaXJzdFN0eWxlcykge1xuICAgICAgICAgICAgZmlyc3RLZXlmcmFtZS5zdHlsZXMuc3R5bGVzLnB1c2goZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhclN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgdmFyIGZpbmFsU3R5bGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZpbmFsU3R5bGVzW2tleV0gPSBudWxsOyB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcyhjb2xsZWN0aW9uLCBzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzT2JqID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5W3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBGSUxMX1NUWUxFX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xsZWN0aW9uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc3R5bGVzT2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXNPYmo7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJTdHlsZXMoZWxlbWVudCwgcmVuZGVyZXIsIHN0eWxlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIHByb3AsIHN0eWxlc1twcm9wXSk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbGF0dGVuU3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBmaW5hbFN0eWxlc1twcm9wXSA9IGVudHJ5W3Byb3BdOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbFN0eWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdHlsZXM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIHJldHVybmVkIGFzIGFuIGV2ZW50IHBhcmFtZXRlciB3aGVuIGFuIGFuaW1hdGlvblxuICAgICAqIGNhbGxiYWNrIGlzIGNhcHR1cmVkIGZvciBhbiBhbmltYXRpb24gZWl0aGVyIGR1cmluZyB0aGUgc3RhcnQgb3IgZG9uZSBwaGFzZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIGhvc3Q6IHtcbiAgICAgKiAgICAgJ1tAbXlBbmltYXRpb25UcmlnZ2VyXSc6ICdzb21lRXhwcmVzc2lvbicsXG4gICAgICogICAgICcoQG15QW5pbWF0aW9uVHJpZ2dlci5zdGFydCknOiAnY2FwdHVyZVN0YXJ0RXZlbnQoJGV2ZW50KScsXG4gICAgICogICAgICcoQG15QW5pbWF0aW9uVHJpZ2dlci5kb25lKSc6ICdjYXB0dXJlRG9uZUV2ZW50KCRldmVudCknLFxuICAgICAqICAgfSxcbiAgICAgKiAgIGFuaW1hdGlvbnM6IFtcbiAgICAgKiAgICAgdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICBdKVxuICAgICAqICAgXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgc29tZUV4cHJlc3Npb246IGFueSA9IGZhbHNlO1xuICAgICAqICAgY2FwdHVyZVN0YXJ0RXZlbnQoZXZlbnQ6IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCkge1xuICAgICAqICAgICAvLyB0aGUgdG9TdGF0ZSwgZnJvbVN0YXRlIGFuZCB0b3RhbFRpbWUgZGF0YSBpcyBhY2Nlc3NpYmxlIGZyb20gdGhlIGV2ZW50IHZhcmlhYmxlXG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIGNhcHR1cmVEb25lRXZlbnQoZXZlbnQ6IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCkge1xuICAgICAqICAgICAvLyB0aGUgdG9TdGF0ZSwgZnJvbVN0YXRlIGFuZCB0b3RhbFRpbWUgZGF0YSBpcyBhY2Nlc3NpYmxlIGZyb20gdGhlIGV2ZW50IHZhcmlhYmxlXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25FdmVudChfYSkge1xuICAgICAgICAgICAgdmFyIGZyb21TdGF0ZSA9IF9hLmZyb21TdGF0ZSwgdG9TdGF0ZSA9IF9hLnRvU3RhdGUsIHRvdGFsVGltZSA9IF9hLnRvdGFsVGltZSwgcGhhc2VOYW1lID0gX2EucGhhc2VOYW1lO1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RhdGUgPSBmcm9tU3RhdGU7XG4gICAgICAgICAgICB0aGlzLnRvU3RhdGUgPSB0b1N0YXRlO1xuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgICAgICB0aGlzLnBoYXNlTmFtZSA9IHBoYXNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQW5pbWF0aW9uVHJhbnNpdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb24oX3BsYXllciwgX2Zyb21TdGF0ZSwgX3RvU3RhdGUsIF90b3RhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllciA9IF9wbGF5ZXI7XG4gICAgICAgICAgICB0aGlzLl9mcm9tU3RhdGUgPSBfZnJvbVN0YXRlO1xuICAgICAgICAgICAgdGhpcy5fdG9TdGF0ZSA9IF90b1N0YXRlO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gX3RvdGFsVGltZTtcbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb25UcmFuc2l0aW9uLnByb3RvdHlwZS5fY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiAocGhhc2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCh7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXRlOiB0aGlzLl9mcm9tU3RhdGUsXG4gICAgICAgICAgICAgICAgdG9TdGF0ZTogdGhpcy5fdG9TdGF0ZSxcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWU6IHRoaXMuX3RvdGFsVGltZSxcbiAgICAgICAgICAgICAgICBwaGFzZU5hbWU6IHBoYXNlTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdzdGFydCcpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgnZG9uZScpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIERlYnVnRG9tUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdEb21Sb290UmVuZGVyZXIoX2RlbGVnYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IF9kZWxlZ2F0ZTtcbiAgICAgICAgfVxuICAgICAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlYnVnRG9tUmVuZGVyZXIodGhpcy5fZGVsZWdhdGUucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFByb3RvKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIHZhciBEZWJ1Z0RvbVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdEb21SZW5kZXJlcihfZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICB9XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNlbGVjdFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVFbCA9IHRoaXMuX2RlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBuZXcgRGVidWdFbGVtZW50KG5hdGl2ZUVsLCBudWxsLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlRWw7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbmFtZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlRWwgPSB0aGlzLl9kZWxlZ2F0ZS5jcmVhdGVFbGVtZW50KHBhcmVudEVsZW1lbnQsIG5hbWUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z0VsZW1lbnQobmF0aXZlRWwsIGdldERlYnVnTm9kZShwYXJlbnRFbGVtZW50KSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGRlYnVnRWwubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVFbDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVmlld1Jvb3QgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQpIHsgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVZpZXdSb290KGhvc3RFbGVtZW50KTsgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z05vZGUoY29tbWVudCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRleHQocGFyZW50RWxlbWVudCwgdmFsdWUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z05vZGUodGV4dCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdQYXJlbnQgPSBnZXREZWJ1Z05vZGUocGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnUGFyZW50KSAmJiBkZWJ1Z1BhcmVudCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z0VsZW1lbnRfMSA9IGRlYnVnUGFyZW50O1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgZGVidWdFbGVtZW50XzEuYWRkQ2hpbGQoZ2V0RGVidWdOb2RlKG5vZGUpKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5wcm9qZWN0Tm9kZXMocGFyZW50RWxlbWVudCwgbm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hWaWV3QWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdmlld1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgdmFyIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z1BhcmVudCA9IGRlYnVnTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdSb290Tm9kZXMubGVuZ3RoID4gMCAmJiBpc1ByZXNlbnQoZGVidWdQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWJ1Z1ZpZXdSb290Tm9kZXNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2aWV3Um9vdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJvb3ROb2RlKSB7IHJldHVybiBkZWJ1Z1ZpZXdSb290Tm9kZXNfMS5wdXNoKGdldERlYnVnTm9kZShyb290Tm9kZSkpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdQYXJlbnQuaW5zZXJ0Q2hpbGRyZW5BZnRlcihkZWJ1Z05vZGUsIGRlYnVnVmlld1Jvb3ROb2Rlc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5hdHRhY2hWaWV3QWZ0ZXIobm9kZSwgdmlld1Jvb3ROb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFZpZXcgPSBmdW5jdGlvbiAodmlld1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnTm9kZSkgJiYgaXNQcmVzZW50KGRlYnVnTm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQoZGVidWdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRldGFjaFZpZXcodmlld1Jvb3ROb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3lWaWV3ID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpIHtcbiAgICAgICAgICAgIHZpZXdBbGxOb2RlcyA9IHZpZXdBbGxOb2RlcyB8fCBbXTtcbiAgICAgICAgICAgIHZpZXdBbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJlbW92ZURlYnVnTm9kZUZyb21JbmRleChnZXREZWJ1Z05vZGUobm9kZSkpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lWaWV3KGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHJlbmRlckVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z0VsKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwubGlzdGVuZXJzLnB1c2gobmV3IEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5saXN0ZW4ocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW5HbG9iYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmxpc3Rlbkdsb2JhbCh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRFbGVtZW50UHJvcGVydHkocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEVsZW1lbnRBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRCaW5kaW5nRGVidWdJbmZvID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0QmluZGluZ0RlYnVnSW5mbyhyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLmNsYXNzZXNbY2xhc3NOYW1lXSA9IGlzQWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudENsYXNzKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSwgaXNBZGQpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwuc3R5bGVzW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudFN0eWxlKHJlbmRlckVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuaW52b2tlRWxlbWVudE1ldGhvZChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChyZW5kZXJOb2RlLCB0ZXh0KSB7IHRoaXMuX2RlbGVnYXRlLnNldFRleHQocmVuZGVyTm9kZSwgdGV4dCk7IH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5hbmltYXRlKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlYnVnRG9tUmVuZGVyZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgVmlld1R5cGU7XG4gICAgKGZ1bmN0aW9uIChWaWV3VHlwZSkge1xuICAgICAgICAvLyBBIHZpZXcgdGhhdCBjb250YWlucyB0aGUgaG9zdCBlbGVtZW50IHdpdGggYm91bmQgY29tcG9uZW50IGRpcmVjdGl2ZS5cbiAgICAgICAgLy8gQ29udGFpbnMgYSBDT01QT05FTlQgdmlld1xuICAgICAgICBWaWV3VHlwZVtWaWV3VHlwZVtcIkhPU1RcIl0gPSAwXSA9IFwiSE9TVFwiO1xuICAgICAgICAvLyBUaGUgdmlldyBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIENhbiBjb250YWluIDAgdG8gbiBFTUJFRERFRCB2aWV3c1xuICAgICAgICBWaWV3VHlwZVtWaWV3VHlwZVtcIkNPTVBPTkVOVFwiXSA9IDFdID0gXCJDT01QT05FTlRcIjtcbiAgICAgICAgLy8gQSB2aWV3IHRoYXQgaXMgZW1iZWRkZWQgaW50byBhbm90aGVyIFZpZXcgdmlhIGEgPHRlbXBsYXRlPiBlbGVtZW50XG4gICAgICAgIC8vIGluc2lkZSBvZiBhIENPTVBPTkVOVCB2aWV3XG4gICAgICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiRU1CRURERURcIl0gPSAyXSA9IFwiRU1CRURERURcIjtcbiAgICB9KShWaWV3VHlwZSB8fCAoVmlld1R5cGUgPSB7fSkpO1xuXG4gICAgdmFyIFN0YXRpY05vZGVEZWJ1Z0luZm8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTdGF0aWNOb2RlRGVidWdJbmZvKHByb3ZpZGVyVG9rZW5zLCBjb21wb25lbnRUb2tlbiwgcmVmVG9rZW5zKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyVG9rZW5zID0gcHJvdmlkZXJUb2tlbnM7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFRva2VuID0gY29tcG9uZW50VG9rZW47XG4gICAgICAgICAgICB0aGlzLnJlZlRva2VucyA9IHJlZlRva2VucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RhdGljTm9kZURlYnVnSW5mbztcbiAgICB9KCkpO1xuICAgIHZhciBEZWJ1Z0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0NvbnRleHQoX3ZpZXcsIF9ub2RlSW5kZXgsIF90cGxSb3csIF90cGxDb2wpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX25vZGVJbmRleCA9IF9ub2RlSW5kZXg7XG4gICAgICAgICAgICB0aGlzLl90cGxSb3cgPSBfdHBsUm93O1xuICAgICAgICAgICAgdGhpcy5fdHBsQ29sID0gX3RwbENvbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJfc3RhdGljTm9kZUluZm9cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9ub2RlSW5kZXgpID8gdGhpcy5fdmlldy5zdGF0aWNOb2RlRGVidWdJbmZvc1t0aGlzLl9ub2RlSW5kZXhdIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5jb250ZXh0OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pICYmIGlzUHJlc2VudChzdGF0aWNOb2RlSW5mby5jb21wb25lbnRUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuZ2V0KHN0YXRpY05vZGVJbmZvLmNvbXBvbmVudFRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiY29tcG9uZW50UmVuZGVyRWxlbWVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IHRoaXMuX3ZpZXc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjb21wb25lbnRWaWV3LnBhcmVudFZpZXcpICYmIGNvbXBvbmVudFZpZXcudHlwZSAhPT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcgPSBjb21wb25lbnRWaWV3LnBhcmVudFZpZXc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRWaWV3LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmluamVjdG9yKHRoaXMuX25vZGVJbmRleCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJyZW5kZXJOb2RlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fbm9kZUluZGV4KSAmJiB0aGlzLl92aWV3LmFsbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmFsbE5vZGVzW3RoaXMuX25vZGVJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykgPyBzdGF0aWNOb2RlSW5mby5wcm92aWRlclRva2VucyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwic291cmNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmNvbXBvbmVudFR5cGUudGVtcGxhdGVVcmwgKyBcIjpcIiArIHRoaXMuX3RwbFJvdyArIFwiOlwiICsgdGhpcy5fdHBsQ29sO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgdmFyVmFsdWVzID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnNfMSA9IHN0YXRpY05vZGVJbmZvLnJlZlRva2VucztcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVmc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWZOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmVG9rZW4gPSByZWZzXzFbcmVmTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbGFuayhyZWZUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZSA9IF90aGlzLl92aWV3LmFsbE5vZGVzID8gX3RoaXMuX3ZpZXcuYWxsTm9kZXNbX3RoaXMuX25vZGVJbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5fdmlldy5pbmplY3RvckdldChyZWZUb2tlbiwgX3RoaXMuX25vZGVJbmRleCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZXNbcmVmTmFtZV0gPSB2YXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJWYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERlYnVnQ29udGV4dDtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFZpZXdBbmltYXRpb25NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3QW5pbWF0aW9uTWFwKCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWxsUGxheWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgICAgdmFyIHBsYXllcnNCeUFuaW1hdGlvbiA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBsYXllcnNCeUFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5maW5kQWxsUGxheWVyc0J5RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsID8gT2JqZWN0LmtleXMoZWwpLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gZWxba107IH0pIDogW107XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lLCBwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBwbGF5ZXJzQnlBbmltYXRpb24gPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQocGxheWVyc0J5QW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHBsYXllcnNCeUFuaW1hdGlvbiA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nRW50cnkgPSBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV07XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4aXN0aW5nRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV0gPSBwbGF5ZXI7XG4gICAgICAgICAgICB0aGlzLl9hbGxQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoZWxlbWVudCwgcGxheWVyc0J5QW5pbWF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUuZ2V0QWxsUGxheWVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FsbFBsYXllcnM7IH07XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGxheWVyc0J5QW5pbWF0aW9uID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzQnlBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fYWxsUGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwbGF5ZXJzQnlBbmltYXRpb24pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdBbmltYXRpb25NYXA7XG4gICAgfSgpKTtcblxuICAgIHZhciBBbmltYXRpb25WaWV3Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblZpZXdDb250ZXh0KCkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IG5ldyBWaWV3QW5pbWF0aW9uTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgQW5pbWF0aW9uVmlld0NvbnRleHQucHJvdG90eXBlLm9uQWxsQWN0aXZlQW5pbWF0aW9uc0RvbmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmVBbmltYXRpb25QbGF5ZXJzID0gdGhpcy5fcGxheWVycy5nZXRBbGxQbGF5ZXJzKCk7XG4gICAgICAgICAgICAvLyB3ZSBjaGVjayBmb3IgdGhlIGxlbmd0aCB0byBhdm9pZCBoYXZpbmcgR3JvdXBBbmltYXRpb25QbGF5ZXJcbiAgICAgICAgICAgIC8vIGlzc3VlIGFuIHVubmVjZXNzYXJ5IG1pY3JvdGFzayB3aGVuIHplcm8gcGxheWVycyBhcmUgcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAoYWN0aXZlQW5pbWF0aW9uUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXcgQW5pbWF0aW9uR3JvdXBQbGF5ZXIoYWN0aXZlQW5pbWF0aW9uUGxheWVycykub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uVmlld0NvbnRleHQucHJvdG90eXBlLnF1ZXVlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUsIHBsYXllcikge1xuICAgICAgICAgICAgcXVldWVBbmltYXRpb25HbG9iYWxseShwbGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5zZXQoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSwgcGxheWVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uVmlld0NvbnRleHQucHJvdG90eXBlLmNhbmNlbEFjdGl2ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lLCByZW1vdmVBbGxBbmltYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlQWxsQW5pbWF0aW9ucyA9PT0gdm9pZCAwKSB7IHJlbW92ZUFsbEFuaW1hdGlvbnMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHJlbW92ZUFsbEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZpbmRBbGxQbGF5ZXJzQnlFbGVtZW50KGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gdGhpcy5fcGxheWVycy5maW5kKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb25WaWV3Q29udGV4dDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgRWxlbWVudEluamVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDE1KEVsZW1lbnRJbmplY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRWxlbWVudEluamVjdG9yKF92aWV3LCBfbm9kZUluZGV4KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX25vZGVJbmRleCA9IF9ub2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IFRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuaW5qZWN0b3JHZXQodG9rZW4sIHRoaXMuX25vZGVJbmRleCwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFbGVtZW50SW5qZWN0b3I7XG4gICAgfShJbmplY3RvcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgX3Njb3BlX2NoZWNrID0gd3RmQ3JlYXRlU2NvcGUoXCJBcHBWaWV3I2NoZWNrKGFzY2lpIGlkKVwiKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEVNUFRZX0NPTlRFWFQkMSA9IG5ldyBPYmplY3QoKTtcbiAgICB2YXIgVU5ERUZJTkVEJDEgPSBuZXcgT2JqZWN0KCk7XG4gICAgLyoqXG4gICAgICogQ29zdCBvZiBtYWtpbmcgb2JqZWN0czogaHR0cDovL2pzcGVyZi5jb20vaW5zdGFudGlhdGUtc2l6ZS1vZi1vYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBBcHBWaWV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwVmlldyhjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRWaWV3LCBwYXJlbnRJbmRleCwgcGFyZW50RWxlbWVudCwgY2RNb2RlLCBkZWNsYXJlZFZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChkZWNsYXJlZFZpZXdDb250YWluZXIgPT09IHZvaWQgMCkgeyBkZWNsYXJlZFZpZXdDb250YWluZXIgPSBudWxsOyB9XG4gICAgICAgICAgICB0aGlzLmNsYXp6ID0gY2xheno7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRoaXMudmlld1V0aWxzID0gdmlld1V0aWxzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRWaWV3ID0gcGFyZW50VmlldztcbiAgICAgICAgICAgIHRoaXMucGFyZW50SW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmNkTW9kZSA9IGNkTW9kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZWRWaWV3Q29udGFpbmVyID0gZGVjbGFyZWRWaWV3Q29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDaGVja3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBuZXcgVmlld1JlZl8odGhpcyk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UIHx8IHR5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gdmlld1V0aWxzLnJlbmRlckNvbXBvbmVudChjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBwYXJlbnRWaWV3LnJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0UmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLmRpcmVjdFJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJhbmltYXRpb25Db250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25Db250ZXh0ID0gbmV3IEFuaW1hdGlvblZpZXdDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25Db250ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcm5hbChudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlSG9zdFZpZXcgPSBmdW5jdGlvbiAocm9vdFNlbGVjdG9yT3JOb2RlLCBob3N0SW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IEVNUFRZX0NPTlRFWFQkMTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0V4dGVybmFsSG9zdEVsZW1lbnQgPSBpc1ByZXNlbnQocm9vdFNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RJbmplY3RvciA9IGhvc3RJbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RQcm9qZWN0YWJsZU5vZGVzID0gcHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVybmFsKHJvb3RTZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICAgICAqIFJldHVybnMgdGhlIENvbXBvbmVudFJlZiBmb3IgdGhlIGhvc3QgZWxlbWVudCBmb3IgVmlld1R5cGUuSE9TVC5cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmNyZWF0ZUludGVybmFsID0gZnVuY3Rpb24gKHJvb3RTZWxlY3Rvck9yTm9kZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlld0ludGVybmFsID0gZnVuY3Rpb24gKHRlbXBsYXRlTm9kZUluZGV4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGxhc3RSb290Tm9kZSwgYWxsTm9kZXMsIGRpc3Bvc2FibGVzKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSb290Tm9kZSA9IGxhc3RSb290Tm9kZTtcbiAgICAgICAgICAgIHRoaXMuYWxsTm9kZXMgPSBhbGxOb2RlcztcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBkaXNwb3NhYmxlcztcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3JHZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gVU5ERUZJTkVEJDE7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0ID09PSBVTkRFRklORUQkMSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobm9kZUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2aWV3LmluamVjdG9yR2V0SW50ZXJuYWwodG9rZW4sIG5vZGVJbmRleCwgVU5ERUZJTkVEJDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBVTkRFRklORUQkMSAmJiB2aWV3LnR5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdmlldy5faG9zdEluamVjdG9yLmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IHZpZXcucGFyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgdmlldyA9IHZpZXcucGFyZW50VmlldztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0SW50ZXJuYWwgPSBmdW5jdGlvbiAodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RGb3VuZFJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3IgPSBmdW5jdGlvbiAobm9kZUluZGV4KSB7IHJldHVybiBuZXcgRWxlbWVudEluamVjdG9yKHRoaXMsIG5vZGVJbmRleCk7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGFjaEFuZERlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzRXh0ZXJuYWxIb3N0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy52aWV3Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5kZXRhY2hWaWV3KHRoaXMudmlld0NvbnRhaW5lci5uZXN0ZWRWaWV3cy5pbmRleE9mKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhvc3RFbGVtZW50ID0gdGhpcy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgPyB0aGlzLnBhcmVudEVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zYWJsZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlzcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlc1tpXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUludGVybmFsKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbnRleHQub25BbGxBY3RpdmVBbmltYXRpb25zRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgX3RoaXMuYWxsTm9kZXMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveVZpZXcoaG9zdEVsZW1lbnQsIHRoaXMuYWxsTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZE1vZGUgPSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRlc3Ryb3lJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRldGFjaEludGVybmFsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbnRleHQub25BbGxBY3RpdmVBbmltYXRpb25zRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcmVuZGVyRGV0YWNoKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyRGV0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIgJiYgdGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIgIT09IHRoaXMudmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRWaWV3cyA9IHRoaXMuZGVjbGFyZWRWaWV3Q29udGFpbmVyLnByb2plY3RlZFZpZXdzO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHByb2plY3RlZFZpZXdzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gcGVyZjogcG9wIGlzIGZhc3RlciB0aGFuIHNwbGljZSFcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gcHJvamVjdGVkVmlld3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0ZWRWaWV3cy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RlZFZpZXdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuX3JlbmRlckRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXJlY3RSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRSb290Tm9kZXNJbnRlcm5hbCh0aGlzLl9kaXJlY3RSZW5kZXJlci5yZW1vdmUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kZXRhY2hWaWV3KHRoaXMuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmF0dGFjaEFmdGVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXIsIHByZXZWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJBdHRhY2godmlld0NvbnRhaW5lciwgcHJldlZpZXcpO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlY2xhcmVkVmlld0NvbnRhaW5lciAmJiB0aGlzLmRlY2xhcmVkVmlld0NvbnRhaW5lciAhPT0gdmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIucHJvamVjdGVkVmlld3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIucHJvamVjdGVkVmlld3MgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIucHJvamVjdGVkVmlld3MucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUubW92ZUFmdGVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXIsIHByZXZWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJBdHRhY2godmlld0NvbnRhaW5lciwgcHJldlZpZXcpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5fcmVuZGVyQXR0YWNoID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXIsIHByZXZWaWV3KSB7XG4gICAgICAgICAgICB2YXIgcHJldk5vZGUgPSBwcmV2VmlldyA/IHByZXZWaWV3Lmxhc3RSb290Tm9kZSA6IHZpZXdDb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXJlY3RSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IHRoaXMuX2RpcmVjdFJlbmRlcmVyLm5leHRTaWJsaW5nKHByZXZOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFJvb3ROb2Rlc0ludGVybmFsKHRoaXMuX2RpcmVjdFJlbmRlcmVyLmluc2VydEJlZm9yZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFJvb3ROb2Rlc0ludGVybmFsKHRoaXMuX2RpcmVjdFJlbmRlcmVyLmFwcGVuZENoaWxkLCB0aGlzLl9kaXJlY3RSZW5kZXJlci5wYXJlbnRFbGVtZW50KHByZXZOb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hdHRhY2hWaWV3QWZ0ZXIocHJldk5vZGUsIHRoaXMuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJjaGFuZ2VEZXRlY3RvclJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcImZsYXRSb290Tm9kZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdFJvb3ROb2Rlc0ludGVybmFsKGFkZFRvQXJyYXksIG5vZGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5nQ29udGVudEluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UHJvamVjdGVkTm9kZXMobmdDb250ZW50SW5kZXgsIHRoaXMuX2RpcmVjdFJlbmRlcmVyLmFwcGVuZENoaWxkLCBwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRQcm9qZWN0ZWROb2RlcyhuZ0NvbnRlbnRJbmRleCwgYWRkVG9BcnJheSwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucHJvamVjdE5vZGVzKHBhcmVudEVsZW1lbnQsIG5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUudmlzaXRQcm9qZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChuZ0NvbnRlbnRJbmRleCwgY2IsIGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5FTUJFRERFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRWaWV3LnZpc2l0UHJvamVjdGVkTm9kZXMobmdDb250ZW50SW5kZXgsIGNiLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5DT01QT05FTlQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudFZpZXcudHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5wYXJlbnRWaWV3Ll9ob3N0UHJvamVjdGFibGVOb2Rlc1tuZ0NvbnRlbnRJbmRleF0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Iobm9kZXNbaV0sIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRWaWV3LnZpc2l0UHJvamVjdGFibGVOb2Rlc0ludGVybmFsKHRoaXMucGFyZW50SW5kZXgsIG5nQ29udGVudEluZGV4LCBjYiwgYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLnZpc2l0Um9vdE5vZGVzSW50ZXJuYWwgPSBmdW5jdGlvbiAoY2IsIGMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUudmlzaXRQcm9qZWN0YWJsZU5vZGVzSW50ZXJuYWwgPSBmdW5jdGlvbiAobm9kZUluZGV4LCBuZ0NvbnRlbnRJbmRleCwgY2IsIGMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBfc2NvcGVfY2hlY2sodGhpcy5jbGF6eik7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRXJyb3JlZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXRhY2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGhyb3dEZXN0cm95ZWRFcnJvcignZGV0ZWN0Q2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzSW50ZXJuYWwodGhyb3dPbkNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZSlcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ2hlY2tzKys7XG4gICAgICAgICAgICB3dGZMZWF2ZShzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0ludGVybmFsID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUubWFya0FzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZTsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChpc1ByZXNlbnQoYykgJiYgYy5jZE1vZGUgIT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5DaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuY2RNb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tPbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGMucGFyZW50VmlldztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjLnZpZXdDb250YWluZXIgPyBjLnZpZXdDb250YWluZXIucGFyZW50VmlldyA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5ldmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiBjYjtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUudGhyb3dEZXN0cm95ZWRFcnJvciA9IGZ1bmN0aW9uIChkZXRhaWxzKSB7IHRocm93IG5ldyBWaWV3RGVzdHJveWVkRXJyb3IoZGV0YWlscyk7IH07XG4gICAgICAgIHJldHVybiBBcHBWaWV3O1xuICAgIH0oKSk7XG4gICAgdmFyIERlYnVnQXBwVmlldyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxNChEZWJ1Z0FwcFZpZXcsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERlYnVnQXBwVmlldyhjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRWaWV3LCBwYXJlbnRJbmRleCwgcGFyZW50Tm9kZSwgY2RNb2RlLCBzdGF0aWNOb2RlRGVidWdJbmZvcywgZGVjbGFyZWRWaWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoZGVjbGFyZWRWaWV3Q29udGFpbmVyID09PSB2b2lkIDApIHsgZGVjbGFyZWRWaWV3Q29udGFpbmVyID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgY2xhenosIGNvbXBvbmVudFR5cGUsIHR5cGUsIHZpZXdVdGlscywgcGFyZW50VmlldywgcGFyZW50SW5kZXgsIHBhcmVudE5vZGUsIGNkTW9kZSwgZGVjbGFyZWRWaWV3Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGljTm9kZURlYnVnSW5mb3MgPSBzdGF0aWNOb2RlRGVidWdJbmZvcztcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnREZWJ1Z0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmNyZWF0ZUhvc3RWaWV3ID0gZnVuY3Rpb24gKHJvb3RTZWxlY3Rvck9yTm9kZSwgaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlSG9zdFZpZXcuY2FsbCh0aGlzLCByb290U2VsZWN0b3JPck5vZGUsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3JHZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaW5qZWN0b3JHZXQuY2FsbCh0aGlzLCB0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGVjdENoYW5nZXMuY2FsbCh0aGlzLCB0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuX3Jlc2V0RGVidWcgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2N1cnJlbnREZWJ1Z0NvbnRleHQgPSBudWxsOyB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgcm93TnVtLCBjb2xOdW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0ID0gbmV3IERlYnVnQ29udGV4dCh0aGlzLCBub2RlSW5kZXgsIHJvd051bSwgY29sTnVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5fcmV0aHJvd1dpdGhDb250ZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBWaWV3V3JhcHBlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkVycm9yZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fY3VycmVudERlYnVnQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZpZXdXcmFwcGVkRXJyb3IoZSwgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdXBlckhhbmRsZXIgPSBfc3VwZXIucHJvdG90eXBlLmV2ZW50SGFuZGxlci5jYWxsKHRoaXMsIGNiKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVySGFuZGxlci5jYWxsKF90aGlzLCBldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVidWdBcHBWaWV3O1xuICAgIH0oQXBwVmlldykpO1xuXG4gICAgLyoqXG4gICAgICogQSBWaWV3Q29udGFpbmVyIGlzIGNyZWF0ZWQgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIFZpZXdDb250YWluZXJSZWZcbiAgICAgKiB0byBrZWVwIHRyYWNrIG9mIHRoZSBuZXN0ZWQgdmlld3MuXG4gICAgICovXG4gICAgdmFyIFZpZXdDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3Q29udGFpbmVyKGluZGV4LCBwYXJlbnRJbmRleCwgcGFyZW50VmlldywgbmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRJbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRWaWV3ID0gcGFyZW50VmlldztcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXIucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRWxlbWVudFJlZih0aGlzLm5hdGl2ZUVsZW1lbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXIucHJvdG90eXBlLCBcInZjUmVmXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFZpZXdDb250YWluZXJSZWZfKHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXIucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnRWaWV3LmluamVjdG9yKHRoaXMucGFyZW50SW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXIucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnRWaWV3LmluamVjdG9yKHRoaXMuaW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0luTmVzdGVkVmlld3MgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmVzdGVkVmlld3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmVzdGVkVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3c1tpXS5kZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveU5lc3RlZFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmVzdGVkVmlld3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmVzdGVkVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3c1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS52aXNpdE5lc3RlZFZpZXdSb290Tm9kZXMgPSBmdW5jdGlvbiAoY2IsIGMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lc3RlZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5lc3RlZFZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3NbaV0udmlzaXRSb290Tm9kZXNJbnRlcm5hbChjYiwgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5tYXBOZXN0ZWRWaWV3cyA9IGZ1bmN0aW9uIChuZXN0ZWRWaWV3Q2xhc3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5uZXN0ZWRWaWV3cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXN0ZWRWaWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkVmlldyA9IHRoaXMubmVzdGVkVmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRWaWV3LmNsYXp6ID09PSBuZXN0ZWRWaWV3Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKG5lc3RlZFZpZXcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3RlZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb2plY3RlZFZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRWaWV3ID0gdGhpcy5wcm9qZWN0ZWRWaWV3c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3RlZFZpZXcuY2xhenogPT09IG5lc3RlZFZpZXdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2socHJvamVjdGVkVmlldykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUubW92ZVZpZXcgPSBmdW5jdGlvbiAodmlldywgY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IHRoaXMubmVzdGVkVmlld3MuaW5kZXhPZih2aWV3KTtcbiAgICAgICAgICAgIGlmICh2aWV3LnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCB2aWV3cyBjYW4ndCBiZSBtb3ZlZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmVzdGVkVmlld3MgPSB0aGlzLm5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXdzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRWaWV3cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MgPSBuZXN0ZWRWaWV3cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lc3RlZFZpZXdzLnNwbGljZShwcmV2aW91c0luZGV4LCAxKTtcbiAgICAgICAgICAgIG5lc3RlZFZpZXdzLnNwbGljZShjdXJyZW50SW5kZXgsIDAsIHZpZXcpO1xuICAgICAgICAgICAgdmFyIHByZXZWaWV3ID0gY3VycmVudEluZGV4ID4gMCA/IG5lc3RlZFZpZXdzW2N1cnJlbnRJbmRleCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgIHZpZXcubW92ZUFmdGVyKHRoaXMsIHByZXZWaWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUuYXR0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3LCB2aWV3SW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh2aWV3LnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCB2aWV3cyBjYW4ndCBiZSBtb3ZlZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmVzdGVkVmlld3MgPSB0aGlzLm5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXdzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRWaWV3cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MgPSBuZXN0ZWRWaWV3cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBlcmY6IGFycmF5LnB1c2ggaXMgZmFzdGVyIHRoYW4gYXJyYXkuc3BsaWNlIVxuICAgICAgICAgICAgaWYgKHZpZXdJbmRleCA+PSBuZXN0ZWRWaWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVzdGVkVmlld3Muc3BsaWNlKHZpZXdJbmRleCwgMCwgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldlZpZXcgPSB2aWV3SW5kZXggPiAwID8gbmVzdGVkVmlld3Nbdmlld0luZGV4IC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgdmlldy5hdHRhY2hBZnRlcih0aGlzLCBwcmV2Vmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmRldGFjaFZpZXcgPSBmdW5jdGlvbiAodmlld0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMubmVzdGVkVmlld3Nbdmlld0luZGV4XTtcbiAgICAgICAgICAgIC8vIHBlcmY6IGFycmF5LnBvcCBpcyBmYXN0ZXIgdGhhbiBhcnJheS5zcGxpY2UhXG4gICAgICAgICAgICBpZiAodmlld0luZGV4ID49IHRoaXMubmVzdGVkVmlld3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdzLnNwbGljZSh2aWV3SW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcuZGV0YWNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdDb250YWluZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBfX2NvcmVfcHJpdmF0ZV9fID0ge1xuICAgICAgICBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTogaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzOiBDaGFuZ2VEZXRlY3RvclN0YXR1cyxcbiAgICAgICAgY29uc3RydWN0RGVwZW5kZW5jaWVzOiBjb25zdHJ1Y3REZXBlbmRlbmNpZXMsXG4gICAgICAgIExpZmVjeWNsZUhvb2tzOiBMaWZlY3ljbGVIb29rcyxcbiAgICAgICAgTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUzogTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUyxcbiAgICAgICAgUmVmbGVjdG9yUmVhZGVyOiBSZWZsZWN0b3JSZWFkZXIsXG4gICAgICAgIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIENvbXBvbmVudFJlZl86IENvbXBvbmVudFJlZl8sXG4gICAgICAgIFZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXIsXG4gICAgICAgIEFwcFZpZXc6IEFwcFZpZXcsXG4gICAgICAgIERlYnVnQXBwVmlldzogRGVidWdBcHBWaWV3LFxuICAgICAgICBOZ01vZHVsZUluamVjdG9yOiBOZ01vZHVsZUluamVjdG9yLFxuICAgICAgICByZWdpc3Rlck1vZHVsZUZhY3Rvcnk6IHJlZ2lzdGVyTW9kdWxlRmFjdG9yeSxcbiAgICAgICAgVmlld1R5cGU6IFZpZXdUeXBlLFxuICAgICAgICB2aWV3X3V0aWxzOiB2aWV3X3V0aWxzLFxuICAgICAgICBWaWV3TWV0YWRhdGE6IFZpZXdNZXRhZGF0YSxcbiAgICAgICAgRGVidWdDb250ZXh0OiBEZWJ1Z0NvbnRleHQsXG4gICAgICAgIFN0YXRpY05vZGVEZWJ1Z0luZm86IFN0YXRpY05vZGVEZWJ1Z0luZm8sXG4gICAgICAgIGRldk1vZGVFcXVhbDogZGV2TW9kZUVxdWFsLFxuICAgICAgICBVTklOSVRJQUxJWkVEOiBVTklOSVRJQUxJWkVELFxuICAgICAgICBWYWx1ZVVud3JhcHBlcjogVmFsdWVVbndyYXBwZXIsXG4gICAgICAgIFJlbmRlckRlYnVnSW5mbzogUmVuZGVyRGVidWdJbmZvLFxuICAgICAgICBUZW1wbGF0ZVJlZl86IFRlbXBsYXRlUmVmXyxcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllczogUmVmbGVjdGlvbkNhcGFiaWxpdGllcyxcbiAgICAgICAgbWFrZURlY29yYXRvcjogbWFrZURlY29yYXRvcixcbiAgICAgICAgRGVidWdEb21Sb290UmVuZGVyZXI6IERlYnVnRG9tUm9vdFJlbmRlcmVyLFxuICAgICAgICBDb25zb2xlOiBDb25zb2xlLFxuICAgICAgICByZWZsZWN0b3I6IHJlZmxlY3RvcixcbiAgICAgICAgUmVmbGVjdG9yOiBSZWZsZWN0b3IsXG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXI6IE5vT3BBbmltYXRpb25QbGF5ZXIsXG4gICAgICAgIEFuaW1hdGlvblBsYXllcjogQW5pbWF0aW9uUGxheWVyLFxuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllcjogQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIsXG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyOiBBbmltYXRpb25Hcm91cFBsYXllcixcbiAgICAgICAgQW5pbWF0aW9uS2V5ZnJhbWU6IEFuaW1hdGlvbktleWZyYW1lLFxuICAgICAgICBwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXM6IHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcyxcbiAgICAgICAgYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lczogYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyxcbiAgICAgICAgZmxhdHRlblN0eWxlczogZmxhdHRlblN0eWxlcyxcbiAgICAgICAgY2xlYXJTdHlsZXM6IGNsZWFyU3R5bGVzLFxuICAgICAgICByZW5kZXJTdHlsZXM6IHJlbmRlclN0eWxlcyxcbiAgICAgICAgY29sbGVjdEFuZFJlc29sdmVTdHlsZXM6IGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzLFxuICAgICAgICBBUFBfSURfUkFORE9NX1BST1ZJREVSOiBBUFBfSURfUkFORE9NX1BST1ZJREVSLFxuICAgICAgICBBbmltYXRpb25TdHlsZXM6IEFuaW1hdGlvblN0eWxlcyxcbiAgICAgICAgQU5ZX1NUQVRFOiBBTllfU1RBVEUsXG4gICAgICAgIERFRkFVTFRfU1RBVEU6IERFRkFVTFRfU1RBVEUsXG4gICAgICAgIEVNUFRZX1NUQVRFOiBFTVBUWV9TVEFURSxcbiAgICAgICAgRklMTF9TVFlMRV9GTEFHOiBGSUxMX1NUWUxFX0ZMQUcsXG4gICAgICAgIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yOiBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcixcbiAgICAgICAgaXNQcm9taXNlOiBpc1Byb21pc2UsXG4gICAgICAgIEFuaW1hdGlvblRyYW5zaXRpb246IEFuaW1hdGlvblRyYW5zaXRpb25cbiAgICB9O1xuXG4gICAgZXhwb3J0cy5jcmVhdGVQbGF0Zm9ybSA9IGNyZWF0ZVBsYXRmb3JtO1xuICAgIGV4cG9ydHMuYXNzZXJ0UGxhdGZvcm0gPSBhc3NlcnRQbGF0Zm9ybTtcbiAgICBleHBvcnRzLmRlc3Ryb3lQbGF0Zm9ybSA9IGRlc3Ryb3lQbGF0Zm9ybTtcbiAgICBleHBvcnRzLmdldFBsYXRmb3JtID0gZ2V0UGxhdGZvcm07XG4gICAgZXhwb3J0cy5QbGF0Zm9ybVJlZiA9IFBsYXRmb3JtUmVmO1xuICAgIGV4cG9ydHMuQXBwbGljYXRpb25SZWYgPSBBcHBsaWNhdGlvblJlZjtcbiAgICBleHBvcnRzLmVuYWJsZVByb2RNb2RlID0gZW5hYmxlUHJvZE1vZGU7XG4gICAgZXhwb3J0cy5pc0Rldk1vZGUgPSBpc0Rldk1vZGU7XG4gICAgZXhwb3J0cy5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkgPSBjcmVhdGVQbGF0Zm9ybUZhY3Rvcnk7XG4gICAgZXhwb3J0cy5BUFBfSUQgPSBBUFBfSUQ7XG4gICAgZXhwb3J0cy5QQUNLQUdFX1JPT1RfVVJMID0gUEFDS0FHRV9ST09UX1VSTDtcbiAgICBleHBvcnRzLlBMQVRGT1JNX0lOSVRJQUxJWkVSID0gUExBVEZPUk1fSU5JVElBTElaRVI7XG4gICAgZXhwb3J0cy5BUFBfQk9PVFNUUkFQX0xJU1RFTkVSID0gQVBQX0JPT1RTVFJBUF9MSVNURU5FUjtcbiAgICBleHBvcnRzLkFQUF9JTklUSUFMSVpFUiA9IEFQUF9JTklUSUFMSVpFUjtcbiAgICBleHBvcnRzLkFwcGxpY2F0aW9uSW5pdFN0YXR1cyA9IEFwcGxpY2F0aW9uSW5pdFN0YXR1cztcbiAgICBleHBvcnRzLkRlYnVnRWxlbWVudCA9IERlYnVnRWxlbWVudDtcbiAgICBleHBvcnRzLkRlYnVnTm9kZSA9IERlYnVnTm9kZTtcbiAgICBleHBvcnRzLmFzTmF0aXZlRWxlbWVudHMgPSBhc05hdGl2ZUVsZW1lbnRzO1xuICAgIGV4cG9ydHMuZ2V0RGVidWdOb2RlID0gZ2V0RGVidWdOb2RlO1xuICAgIGV4cG9ydHMuVGVzdGFiaWxpdHkgPSBUZXN0YWJpbGl0eTtcbiAgICBleHBvcnRzLlRlc3RhYmlsaXR5UmVnaXN0cnkgPSBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgIGV4cG9ydHMuc2V0VGVzdGFiaWxpdHlHZXR0ZXIgPSBzZXRUZXN0YWJpbGl0eUdldHRlcjtcbiAgICBleHBvcnRzLlRSQU5TTEFUSU9OUyA9IFRSQU5TTEFUSU9OUztcbiAgICBleHBvcnRzLlRSQU5TTEFUSU9OU19GT1JNQVQgPSBUUkFOU0xBVElPTlNfRk9STUFUO1xuICAgIGV4cG9ydHMuTE9DQUxFX0lEID0gTE9DQUxFX0lEO1xuICAgIGV4cG9ydHMuQXBwbGljYXRpb25Nb2R1bGUgPSBBcHBsaWNhdGlvbk1vZHVsZTtcbiAgICBleHBvcnRzLnd0ZkNyZWF0ZVNjb3BlID0gd3RmQ3JlYXRlU2NvcGU7XG4gICAgZXhwb3J0cy53dGZMZWF2ZSA9IHd0ZkxlYXZlO1xuICAgIGV4cG9ydHMud3RmU3RhcnRUaW1lUmFuZ2UgPSB3dGZTdGFydFRpbWVSYW5nZTtcbiAgICBleHBvcnRzLnd0ZkVuZFRpbWVSYW5nZSA9IHd0ZkVuZFRpbWVSYW5nZTtcbiAgICBleHBvcnRzLlR5cGUgPSBUeXBlO1xuICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuICAgIGV4cG9ydHMuRXJyb3JIYW5kbGVyID0gRXJyb3JIYW5kbGVyO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50ID0gQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50O1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uUGxheWVyID0gQW5pbWF0aW9uUGxheWVyO1xuICAgIGV4cG9ydHMuU2FuaXRpemVyID0gU2FuaXRpemVyO1xuICAgIGV4cG9ydHMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyA9IEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFM7XG4gICAgZXhwb3J0cy5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5Db250ZW50Q2hpbGQgPSBDb250ZW50Q2hpbGQ7XG4gICAgZXhwb3J0cy5Db250ZW50Q2hpbGRyZW4gPSBDb250ZW50Q2hpbGRyZW47XG4gICAgZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xuICAgIGV4cG9ydHMuVmlld0NoaWxkID0gVmlld0NoaWxkO1xuICAgIGV4cG9ydHMuVmlld0NoaWxkcmVuID0gVmlld0NoaWxkcmVuO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuSG9zdEJpbmRpbmcgPSBIb3N0QmluZGluZztcbiAgICBleHBvcnRzLkhvc3RMaXN0ZW5lciA9IEhvc3RMaXN0ZW5lcjtcbiAgICBleHBvcnRzLklucHV0ID0gSW5wdXQ7XG4gICAgZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG4gICAgZXhwb3J0cy5QaXBlID0gUGlwZTtcbiAgICBleHBvcnRzLkFmdGVyQ29udGVudENoZWNrZWQgPSBBZnRlckNvbnRlbnRDaGVja2VkO1xuICAgIGV4cG9ydHMuQWZ0ZXJDb250ZW50SW5pdCA9IEFmdGVyQ29udGVudEluaXQ7XG4gICAgZXhwb3J0cy5BZnRlclZpZXdDaGVja2VkID0gQWZ0ZXJWaWV3Q2hlY2tlZDtcbiAgICBleHBvcnRzLkFmdGVyVmlld0luaXQgPSBBZnRlclZpZXdJbml0O1xuICAgIGV4cG9ydHMuRG9DaGVjayA9IERvQ2hlY2s7XG4gICAgZXhwb3J0cy5PbkNoYW5nZXMgPSBPbkNoYW5nZXM7XG4gICAgZXhwb3J0cy5PbkRlc3Ryb3kgPSBPbkRlc3Ryb3k7XG4gICAgZXhwb3J0cy5PbkluaXQgPSBPbkluaXQ7XG4gICAgZXhwb3J0cy5DVVNUT01fRUxFTUVOVFNfU0NIRU1BID0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQTtcbiAgICBleHBvcnRzLk5PX0VSUk9SU19TQ0hFTUEgPSBOT19FUlJPUlNfU0NIRU1BO1xuICAgIGV4cG9ydHMuTmdNb2R1bGUgPSBOZ01vZHVsZTtcbiAgICBleHBvcnRzLkNsYXNzID0gQ2xhc3M7XG4gICAgZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbiAgICBleHBvcnRzLnJlc29sdmVGb3J3YXJkUmVmID0gcmVzb2x2ZUZvcndhcmRSZWY7XG4gICAgZXhwb3J0cy5JbmplY3RvciA9IEluamVjdG9yO1xuICAgIGV4cG9ydHMuUmVmbGVjdGl2ZUluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yO1xuICAgIGV4cG9ydHMuUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3Rvcnk7XG4gICAgZXhwb3J0cy5SZWZsZWN0aXZlS2V5ID0gUmVmbGVjdGl2ZUtleTtcbiAgICBleHBvcnRzLk9wYXF1ZVRva2VuID0gT3BhcXVlVG9rZW47XG4gICAgZXhwb3J0cy5JbmplY3QgPSBJbmplY3Q7XG4gICAgZXhwb3J0cy5PcHRpb25hbCA9IE9wdGlvbmFsO1xuICAgIGV4cG9ydHMuSW5qZWN0YWJsZSA9IEluamVjdGFibGU7XG4gICAgZXhwb3J0cy5TZWxmID0gU2VsZjtcbiAgICBleHBvcnRzLlNraXBTZWxmID0gU2tpcFNlbGY7XG4gICAgZXhwb3J0cy5Ib3N0ID0gSG9zdDtcbiAgICBleHBvcnRzLk5nWm9uZSA9IE5nWm9uZTtcbiAgICBleHBvcnRzLlJlbmRlckNvbXBvbmVudFR5cGUgPSBSZW5kZXJDb21wb25lbnRUeXBlO1xuICAgIGV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgICBleHBvcnRzLlJvb3RSZW5kZXJlciA9IFJvb3RSZW5kZXJlcjtcbiAgICBleHBvcnRzLkNPTVBJTEVSX09QVElPTlMgPSBDT01QSUxFUl9PUFRJT05TO1xuICAgIGV4cG9ydHMuQ29tcGlsZXIgPSBDb21waWxlcjtcbiAgICBleHBvcnRzLkNvbXBpbGVyRmFjdG9yeSA9IENvbXBpbGVyRmFjdG9yeTtcbiAgICBleHBvcnRzLk1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMgPSBNb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50RmFjdG9yeSA9IENvbXBvbmVudEZhY3Rvcnk7XG4gICAgZXhwb3J0cy5Db21wb25lbnRSZWYgPSBDb21wb25lbnRSZWY7XG4gICAgZXhwb3J0cy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgZXhwb3J0cy5FbGVtZW50UmVmID0gRWxlbWVudFJlZjtcbiAgICBleHBvcnRzLk5nTW9kdWxlRmFjdG9yeSA9IE5nTW9kdWxlRmFjdG9yeTtcbiAgICBleHBvcnRzLk5nTW9kdWxlUmVmID0gTmdNb2R1bGVSZWY7XG4gICAgZXhwb3J0cy5OZ01vZHVsZUZhY3RvcnlMb2FkZXIgPSBOZ01vZHVsZUZhY3RvcnlMb2FkZXI7XG4gICAgZXhwb3J0cy5nZXRNb2R1bGVGYWN0b3J5ID0gZ2V0TW9kdWxlRmFjdG9yeTtcbiAgICBleHBvcnRzLlF1ZXJ5TGlzdCA9IFF1ZXJ5TGlzdDtcbiAgICBleHBvcnRzLlN5c3RlbUpzTmdNb2R1bGVMb2FkZXIgPSBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyO1xuICAgIGV4cG9ydHMuU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZyA9IFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWc7XG4gICAgZXhwb3J0cy5UZW1wbGF0ZVJlZiA9IFRlbXBsYXRlUmVmO1xuICAgIGV4cG9ydHMuVmlld0NvbnRhaW5lclJlZiA9IFZpZXdDb250YWluZXJSZWY7XG4gICAgZXhwb3J0cy5FbWJlZGRlZFZpZXdSZWYgPSBFbWJlZGRlZFZpZXdSZWY7XG4gICAgZXhwb3J0cy5WaWV3UmVmID0gVmlld1JlZjtcbiAgICBleHBvcnRzLkNoYW5nZURldGVjdG9yUmVmID0gQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgZXhwb3J0cy5Db2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gQ29sbGVjdGlvbkNoYW5nZVJlY29yZDtcbiAgICBleHBvcnRzLkRlZmF1bHRJdGVyYWJsZURpZmZlciA9IERlZmF1bHRJdGVyYWJsZURpZmZlcjtcbiAgICBleHBvcnRzLkl0ZXJhYmxlRGlmZmVycyA9IEl0ZXJhYmxlRGlmZmVycztcbiAgICBleHBvcnRzLktleVZhbHVlQ2hhbmdlUmVjb3JkID0gS2V5VmFsdWVDaGFuZ2VSZWNvcmQ7XG4gICAgZXhwb3J0cy5LZXlWYWx1ZURpZmZlcnMgPSBLZXlWYWx1ZURpZmZlcnM7XG4gICAgZXhwb3J0cy5TaW1wbGVDaGFuZ2UgPSBTaW1wbGVDaGFuZ2U7XG4gICAgZXhwb3J0cy5XcmFwcGVkVmFsdWUgPSBXcmFwcGVkVmFsdWU7XG4gICAgZXhwb3J0cy5wbGF0Zm9ybUNvcmUgPSBwbGF0Zm9ybUNvcmU7XG4gICAgZXhwb3J0cy5fX2NvcmVfcHJpdmF0ZV9fID0gX19jb3JlX3ByaXZhdGVfXztcbiAgICBleHBvcnRzLkFVVE9fU1RZTEUgPSBBVVRPX1NUWUxFO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uRW50cnlNZXRhZGF0YSA9IEFuaW1hdGlvbkVudHJ5TWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdGF0ZU1ldGFkYXRhID0gQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25NZXRhZGF0YSA9IEFuaW1hdGlvbk1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdHlsZU1ldGFkYXRhID0gQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhID0gQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhID0gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSBBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICAgIGV4cG9ydHMuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgZXhwb3J0cy5ncm91cCA9IGdyb3VwO1xuICAgIGV4cG9ydHMuc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICBleHBvcnRzLnN0eWxlID0gc3R5bGU7XG4gICAgZXhwb3J0cy5zdGF0ZSA9IHN0YXRlO1xuICAgIGV4cG9ydHMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgIGV4cG9ydHMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgZXhwb3J0cy50cmlnZ2VyID0gdHJpZ2dlcjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(4);\nvar Subscriber_1 = __webpack_require__(7);\nvar Subscription_1 = __webpack_require__(9);\nvar ObjectUnsubscribedError_1 = __webpack_require__(18);\nvar SubjectSubscription_1 = __webpack_require__(19);\nvar rxSubscriber_1 = __webpack_require__(16);\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvU3ViamVjdC5qcz9jMWM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJqZWN0U3Vic2NyaXB0aW9uJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbi8qKlxuICogQGNsYXNzIFN1YmplY3RTdWJzY3JpYmVyPFQ+XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpYmVyID0gU3ViamVjdFN1YnNjcmliZXI7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0PFQ+XG4gKi9cbnZhciBTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uXzEuU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3Q7XG4vKipcbiAqIEBjbGFzcyBBbm9ueW1vdXNTdWJqZWN0PFQ+XG4gKi9cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5vbnltb3VzU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbm9ueW1vdXNTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnRzLkFub255bW91c1N1YmplY3QgPSBBbm9ueW1vdXNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9TdWJqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(5);\nvar toSubscriber_1 = __webpack_require__(6);\nvar observable_1 = __webpack_require__(17);\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvT2JzZXJ2YWJsZS5qcz80ZTA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxtQkFBbUI7QUFDbEMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3V0aWwvcm9vdCcpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi91dGlsL3RvU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL29ic2VydmFibGUnKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbnkgc2V0IG9mIHZhbHVlcyBvdmVyIGFueSBhbW91bnQgb2YgdGltZS4gVGhpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9ja1xuICogb2YgUnhKUy5cbiAqXG4gKiBAY2xhc3MgT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzICBjYWxsZWQgd2hlbiB0aGUgT2JzZXJ2YWJsZSBpc1xuICAgICAqIGluaXRpYWxseSBzdWJzY3JpYmVkIHRvLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIGEgU3Vic2NyaWJlciwgdG8gd2hpY2ggbmV3IHZhbHVlc1xuICAgICAqIGNhbiBiZSBgbmV4dGBlZCwgb3IgYW4gYGVycm9yYCBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByYWlzZSBhbiBlcnJvciwgb3JcbiAgICAgKiBgY29tcGxldGVgIGNhbiBiZSBjYWxsZWQgdG8gbm90aWZ5IG9mIGEgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9ic2VydmFibGUsIHdpdGggdGhpcyBPYnNlcnZhYmxlIGFzIHRoZSBzb3VyY2UsIGFuZCB0aGUgcGFzc2VkXG4gICAgICogb3BlcmF0b3IgZGVmaW5lZCBhcyB0aGUgbmV3IG9ic2VydmFibGUncyBvcGVyYXRvci5cbiAgICAgKiBAbWV0aG9kIGxpZnRcbiAgICAgKiBAcGFyYW0ge09wZXJhdG9yfSBvcGVyYXRvciB0aGUgb3BlcmF0b3IgZGVmaW5pbmcgdGhlIG9wZXJhdGlvbiB0byB0YWtlIG9uIHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgb2JzZXJ2YWJsZSB3aXRoIHRoZSBPcGVyYXRvciBhcHBsaWVkXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgaGFuZGxpbmcgZW1pdHRlZCB2YWx1ZXMsIGVycm9yIGFuZCBjb21wbGV0aW9ucyBmcm9tIHRoZSBvYnNlcnZhYmxlLCBhbmRcbiAgICAgKiAgZXhlY3V0ZXMgdGhlIG9ic2VydmFibGUncyBzdWJzY3JpYmVyIGZ1bmN0aW9uLCB3aGljaCB3aWxsIHRha2UgYWN0aW9uIHRvIHNldCB1cCB0aGUgdW5kZXJseWluZyBkYXRhIHN0cmVhbVxuICAgICAqIEBtZXRob2Qgc3Vic2NyaWJlXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsT2JzZXJ2ZXJ8RnVuY3Rpb259IG9ic2VydmVyT3JOZXh0IChvcHRpb25hbCkgZWl0aGVyIGFuIG9ic2VydmVyIGRlZmluaW5nIGFsbCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkLFxuICAgICAqICBvciB0aGUgZmlyc3Qgb2YgdGhyZWUgcG9zc2libGUgaGFuZGxlcnMsIHdoaWNoIGlzIHRoZSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAob3B0aW9uYWwpIGEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBhbiBlcnJvci4gSWYgbm8gZXJyb3IgaGFuZGxlciBpcyBwcm92aWRlZCxcbiAgICAgKiAgdGhlIGVycm9yIHdpbGwgYmUgdGhyb3duIGFzIHVuaGFuZGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBsZXRlIChvcHRpb25hbCkgYSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJuIHtJU3Vic2NyaXB0aW9ufSBhIHN1YnNjcmlwdGlvbiByZWZlcmVuY2UgdG8gdGhlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luay5hZGQodGhpcy5fc3Vic2NyaWJlKHNpbmspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCBhIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZUNvbnN0cnVjdG9yfSBbUHJvbWlzZUN0b3JdIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgUHJvbWlzZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlcyBvbiBvYnNlcnZhYmxlIGNvbXBsZXRpb24gb3JcbiAgICAgKiAgcmVqZWN0cyB3aXRoIHRoZSBoYW5kbGVkIGVycm9yXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBQcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuUnggJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSBjYW4gc3VybWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBoYW5kbGluZyBpcyBhc3luY2hyb25vdXMuIEFueSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgcmVqZWN0ZWQgZXhwbGljaXRseSBhbmQgdW5zdWJzY3JpYmUgbXVzdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIE5PIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSdyZSBnZXR0aW5nIGEgbmV4dGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHN5bmNocm9ub3VzbHkgZHVyaW5nIHN1YnNjcmlwdGlvbi4gV2UgY2FuIGp1c3QgY2FsbCBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCBPYnNlcnZhYmxlJ3MgYHN1YnNjcmliZWAgd2lsbCBlbnN1cmUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc3Vic2NyaXB0aW9uIGxvZ2ljIGlzIGNhbGxlZCwgdGhlbiBzeW5jaHJvbm91c2x5IHJldGhyb3cgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciB0aGF0LCBQcm9taXNlIHdpbGwgdHJhcCB0aGUgZXJyb3IgYW5kIHNlbmQgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0aGUgcmVqZWN0aW9uIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm9wIHBvaW50IGRlZmluZWQgYnkgdGhlIGVzNy1vYnNlcnZhYmxlIHNwZWMgaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgU3ltYm9sLm9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSB0aGlzIGluc3RhbmNlIG9mIHRoZSBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgICAvLyBmaWdodCBhZ2FpbnN0IFR5cGVTY3JpcHQgaGVyZSBzbyBTdWJqZWN0IGNhbiBoYXZlIGEgZGlmZmVyZW50IHN0YXRpYyBjcmVhdGUgc2lnbmF0dXJlXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xkIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmU/IHRoZSBzdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IGNvbGQgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL09ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\nvar objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9yb290LmpzPzkzYzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2Vcbn07XG5leHBvcnRzLnJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpIHx8IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xudmFyIGZyZWVHbG9iYWwgPSBvYmplY3RUeXBlc1t0eXBlb2YgZ2xvYmFsXSAmJiBnbG9iYWw7XG5pZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgZXhwb3J0cy5yb290ID0gZnJlZUdsb2JhbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9yb290LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar Subscriber_1 = __webpack_require__(7);\nvar rxSubscriber_1 = __webpack_require__(16);\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber();\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC90b1N1YnNjcmliZXIuanM/ZjhmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXh0T3JPYnNlcnZlciAmJiAhZXJyb3IgJiYgIWNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvdG9TdWJzY3JpYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = __webpack_require__(8);\nvar Subscription_1 = __webpack_require__(9);\nvar Observer_1 = __webpack_require__(15);\nvar rxSubscriber_1 = __webpack_require__(16);\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parent = _parent;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parent = this._parent;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parent = this._parent;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvU3Vic2NyaWJlci5qcz8yMTVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxJQUFJLG1CQUFtQixtQkFBbUIsZUFBZTtBQUN6RCwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EsZUFBZSxJQUFJO0FBQ25CLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlIGFuZCBleHRlbmRzIHRoZVxuICoge0BsaW5rIFN1YnNjcmlwdGlvbn0gY2xhc3MuIFdoaWxlIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGlzIHRoZSBwdWJsaWMgQVBJIGZvclxuICogY29uc3VtaW5nIHRoZSB2YWx1ZXMgb2YgYW4ge0BsaW5rIE9ic2VydmFibGV9LCBhbGwgT2JzZXJ2ZXJzIGdldCBjb252ZXJ0ZWQgdG9cbiAqIGEgU3Vic2NyaWJlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBTdWJzY3JpcHRpb24tbGlrZSBjYXBhYmlsaXRpZXMgc3VjaCBhc1xuICogYHVuc3Vic2NyaWJlYC4gU3Vic2NyaWJlciBpcyBhIGNvbW1vbiB0eXBlIGluIFJ4SlMsIGFuZCBjcnVjaWFsIGZvclxuICogaW1wbGVtZW50aW5nIG9wZXJhdG9ycywgYnV0IGl0IGlzIHJhcmVseSB1c2VkIGFzIGEgcHVibGljIEFQSS5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IFtkZXN0aW5hdGlvbk9yTmV4dF0gQSBwYXJ0aWFsbHlcbiAgICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgZmFjdG9yeSBmb3IgYSBTdWJzY3JpYmVyLCBnaXZlbiBhIChwb3RlbnRpYWxseSBwYXJ0aWFsKSBkZWZpbml0aW9uXG4gICAgICogb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4OiA/VCk6IHZvaWR9IFtuZXh0XSBUaGUgYG5leHRgIGNhbGxiYWNrIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpYmVyPFQ+fSBBIFN1YnNjcmliZXIgd3JhcHBpbmcgdGhlIChwYXJ0aWFsbHkgZGVmaW5lZClcbiAgICAgKiBPYnNlcnZlciByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAqL1xuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYG5leHRgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhIHZhbHVlLiBUaGUgT2JzZXJ2YWJsZSBtYXkgY2FsbCB0aGlzIG1ldGhvZCAwIG9yIG1vcmVcbiAgICAgKiB0aW1lcy5cbiAgICAgKiBAcGFyYW0ge1R9IFt2YWx1ZV0gVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBlcnJvcmAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBFcnJvcn0uIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0XG4gICAgICogdGhlIE9ic2VydmFibGUgaGFzIGV4cGVyaWVuY2VkIGFuIGVycm9yIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXhjZXB0aW9uLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgYSB2YWx1ZWxlc3Mgbm90aWZpY2F0aW9uIG9mIHR5cGVcbiAgICAgKiBgY29tcGxldGVgIGZyb20gdGhlIE9ic2VydmFibGUuIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0IHRoZSBPYnNlcnZhYmxlXG4gICAgICogaGFzIGZpbmlzaGVkIHNlbmRpbmcgcHVzaC1iYXNlZCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudCwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFfcGFyZW50LnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICBfcGFyZW50LnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvU3Vic2NyaWJlci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc0Z1bmN0aW9uLmpzPzUxYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0Z1bmN0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvaXNGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar isArray_1 = __webpack_require__(10);\nvar isObject_1 = __webpack_require__(11);\nvar isFunction_1 = __webpack_require__(8);\nvar tryCatch_1 = __webpack_require__(12);\nvar errorObject_1 = __webpack_require__(13);\nvar UnsubscriptionError_1 = __webpack_require__(14);\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject_1.errorObject.e);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.closed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvU3Vic2NyaXB0aW9uLmpzPzVjNTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2lzT2JqZWN0Jyk7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBkaXNwb3NhYmxlIHJlc291cmNlLCBzdWNoIGFzIHRoZSBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZS4gQVxuICogU3Vic2NyaXB0aW9uIGhhcyBvbmUgaW1wb3J0YW50IG1ldGhvZCwgYHVuc3Vic2NyaWJlYCwgdGhhdCB0YWtlcyBubyBhcmd1bWVudFxuICogYW5kIGp1c3QgZGlzcG9zZXMgdGhlIHJlc291cmNlIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHN1YnNjcmlwdGlvbnMgbWF5IGJlIGdyb3VwZWQgdG9nZXRoZXIgdGhyb3VnaCB0aGUgYGFkZCgpYFxuICogbWV0aG9kLCB3aGljaCB3aWxsIGF0dGFjaCBhIGNoaWxkIFN1YnNjcmlwdGlvbiB0byB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24uXG4gKiBXaGVuIGEgU3Vic2NyaXB0aW9uIGlzIHVuc3Vic2NyaWJlZCwgYWxsIGl0cyBjaGlsZHJlbiAoYW5kIGl0cyBncmFuZGNoaWxkcmVuKVxuICogd2lsbCBiZSB1bnN1YnNjcmliZWQgYXMgd2VsbC5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaXB0aW9uXG4gKi9cbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW3Vuc3Vic2NyaWJlXSBBIGZ1bmN0aW9uIGRlc2NyaWJpbmcgaG93IHRvXG4gICAgICogcGVyZm9ybSB0aGUgZGlzcG9zYWwgb2YgcmVzb3VyY2VzIHdoZW4gdGhlIGB1bnN1YnNjcmliZWAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgU3Vic2NyaXB0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdW5zdWJzY3JpYmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSwgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgKGVycm9ycyA9IGVycm9ycyB8fCBbXSkucHVzaChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3RfMS5pc09iamVjdChzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc3ViLnVuc3Vic2NyaWJlKS5jYWxsKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGVyci5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRlYXIgZG93biB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSgpIG9mIHRoaXNcbiAgICAgKiBTdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGVhciBkb3duIGJlaW5nIGFkZGVkIGlzIGEgc3Vic2NyaXB0aW9uIHRoYXQgaXMgYWxyZWFkeVxuICAgICAqIHVuc3Vic2NyaWJlZCwgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGBhZGRgIGlzIGJlaW5nIGNhbGxlZCBvbiwgb3IgaXNcbiAgICAgKiBgU3Vic2NyaXB0aW9uLkVNUFRZYCwgaXQgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHN1YnNjcmlwdGlvbiBpcyBhbHJlYWR5IGluIGFuIGBjbG9zZWRgIHN0YXRlLCB0aGUgcGFzc2VkXG4gICAgICogdGVhciBkb3duIGxvZ2ljIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RlYXJkb3duTG9naWN9IHRlYXJkb3duIFRoZSBhZGRpdGlvbmFsIGxvZ2ljIHRvIGV4ZWN1dGUgb25cbiAgICAgKiB0ZWFyZG93bi5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259IFJldHVybnMgdGhlIFN1YnNjcmlwdGlvbiB1c2VkIG9yIGNyZWF0ZWQgdG8gYmVcbiAgICAgKiBhZGRlZCB0byB0aGUgaW5uZXIgc3Vic2NyaXB0aW9ucyBsaXN0LiBUaGlzIFN1YnNjcmlwdGlvbiBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICogYHJlbW92ZSgpYCB0byByZW1vdmUgdGhlIHBhc3NlZCB0ZWFyZG93biBsb2dpYyBmcm9tIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAgICogbGlzdC5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICBpZiAoIXRlYXJkb3duIHx8ICh0ZWFyZG93biA9PT0gU3Vic2NyaXB0aW9uLkVNUFRZKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVhcmRvd24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWIgPSB0ZWFyZG93bjtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdGVhcmRvd24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5jbG9zZWQgfHwgdHlwZW9mIHN1Yi51bnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5fc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdKSkucHVzaChzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBTdWJzY3JpcHRpb24gZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHRoYXQgd2lsbFxuICAgICAqIHVuc3Vic2NyaWJlIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUgcHJvY2VzcyBvZiB0aGlzIFN1YnNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBzdWJzY3JpcHRpb24gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIEhBQ0s6IFRoaXMgbWlnaHQgYmUgcmVkdW5kYW50IGJlY2F1c2Ugb2YgdGhlIGxvZ2ljIGluIGBhZGQoKWBcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PSBudWxsIHx8IChzdWJzY3JpcHRpb24gPT09IHRoaXMpIHx8IChzdWJzY3JpcHRpb24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9TdWJzY3JpcHRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc0FycmF5LmpzP2IwZWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrREFBa0QsMENBQTBDLEVBQUU7QUFDOUYiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL2lzQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9pc09iamVjdC5qcz9hYTJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9pc09iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar errorObject_1 = __webpack_require__(13);\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC90cnlDYXRjaC5qcz83Njk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vZXJyb3JPYmplY3QnKTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cbmV4cG9ydHMudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyeUNhdGNoLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3V0aWwvdHJ5Q2F0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9lcnJvck9iamVjdC5qcz9mNDliIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gdHlwZW9mIGFueSBzbyB0aGF0IGl0IHdlIGRvbid0IGhhdmUgdG8gY2FzdCB3aGVuIGNvbXBhcmluZyBhIHJlc3VsdCB0byB0aGUgZXJyb3Igb2JqZWN0XG5leHBvcnRzLmVycm9yT2JqZWN0ID0geyBlOiB7fSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JPYmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9lcnJvck9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzP2JjOWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsMENBQTBDLEVBQUU7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBlcnJvcnMgP1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuICBcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gKChpICsgMSkgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKSk7IH0pLmpvaW4oJ1xcbiAgJykgOiAnJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("\"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvT2JzZXJ2ZXIuanM/ZjA5OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRTtBQUM5QiwyQkFBMkIsV0FBVyxFQUFFO0FBQ3hDLDJCQUEyQjtBQUMzQjtBQUNBIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL09ic2VydmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(5);\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvc3ltYm9sL3J4U3Vic2NyaWJlci5qcz8xMTJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcnhqcy9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar root_1 = __webpack_require__(5);\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.$$observable = getSymbolObservable(root_1.root);\n//# sourceMappingURL=observable.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvc3ltYm9sL29ic2VydmFibGUuanM/MWYyNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuZnVuY3Rpb24gZ2V0U3ltYm9sT2JzZXJ2YWJsZShjb250ZXh0KSB7XG4gICAgdmFyICQkb2JzZXJ2YWJsZTtcbiAgICB2YXIgU3ltYm9sID0gY29udGV4dC5TeW1ib2w7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2wub2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuICAgICAgICAgICAgU3ltYm9sLm9ic2VydmFibGUgPSAkJG9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICQkb2JzZXJ2YWJsZSA9ICdAQG9ic2VydmFibGUnO1xuICAgIH1cbiAgICByZXR1cm4gJCRvYnNlcnZhYmxlO1xufVxuZXhwb3J0cy5nZXRTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZTtcbmV4cG9ydHMuJCRvYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZShyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yeGpzL3N5bWJvbC9vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcz9lNTU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFVuc3Vic2NyaWJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(9);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcz9kMzUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaXB0aW9uID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RTdWJzY3JpcHRpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.2.0\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(21), __webpack_require__(2), __webpack_require__(22)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/compiler', '@angular/core', '@angular/platform-browser'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.platformBrowserDynamic = global.ng.platformBrowserDynamic || {}),global.ng.compiler,global.ng.core,global.ng.platformBrowser));\n}(this, function (exports,_angular_compiler,_angular_core,_angular_platformBrowser) { 'use strict';\n\n    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = _angular_platformBrowser.__platform_browser_private__.INTERNAL_BROWSER_PLATFORM_PROVIDERS;\n\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var ResourceLoaderImpl = (function (_super) {\n        __extends(ResourceLoaderImpl, _super);\n        function ResourceLoaderImpl() {\n            _super.apply(this, arguments);\n        }\n        ResourceLoaderImpl.prototype.get = function (url) {\n            var resolve;\n            var reject;\n            var promise = new Promise(function (res, rej) {\n                resolve = res;\n                reject = rej;\n            });\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, true);\n            xhr.responseType = 'text';\n            xhr.onload = function () {\n                // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n                // response/responseType properties were introduced in ResourceLoader Level2 spec (supported\n                // by IE10)\n                var response = xhr.response || xhr.responseText;\n                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                var status = xhr.status === 1223 ? 204 : xhr.status;\n                // fix status code when it is 0 (0 status is undocumented).\n                // Occurs when accessing file resources or on Android 4.1 stock browser\n                // while retrieving files from application cache.\n                if (status === 0) {\n                    status = response ? 200 : 0;\n                }\n                if (200 <= status && status <= 300) {\n                    resolve(response);\n                }\n                else {\n                    reject(\"Failed to load \" + url);\n                }\n            };\n            xhr.onerror = function () { reject(\"Failed to load \" + url); };\n            xhr.send();\n            return promise;\n        };\n        ResourceLoaderImpl.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        ResourceLoaderImpl.ctorParameters = [];\n        return ResourceLoaderImpl;\n    }(_angular_compiler.ResourceLoader));\n\n    var INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [\n        INTERNAL_BROWSER_PLATFORM_PROVIDERS,\n        {\n            provide: _angular_core.COMPILER_OPTIONS,\n            useValue: { providers: [{ provide: _angular_compiler.ResourceLoader, useClass: ResourceLoaderImpl }] },\n            multi: true\n        },\n    ];\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var _global = globalScope;\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    _global.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * An implementation of ResourceLoader that uses a template cache to avoid doing an actual\n     * ResourceLoader.\n     *\n     * The template cache needs to be built and loaded into window.$templateCache\n     * via a separate mechanism.\n     */\n    var CachedResourceLoader = (function (_super) {\n        __extends$1(CachedResourceLoader, _super);\n        function CachedResourceLoader() {\n            _super.call(this);\n            this._cache = _global.$templateCache;\n            if (this._cache == null) {\n                throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');\n            }\n        }\n        CachedResourceLoader.prototype.get = function (url) {\n            if (this._cache.hasOwnProperty(url)) {\n                return Promise.resolve(this._cache[url]);\n            }\n            else {\n                return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);\n            }\n        };\n        return CachedResourceLoader;\n    }(_angular_compiler.ResourceLoader));\n\n    var __platform_browser_dynamic_private__ = {\n        INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS,\n        ResourceLoaderImpl: ResourceLoaderImpl\n    };\n\n    /**\n     * @experimental\n     */\n    var RESOURCE_CACHE_PROVIDER = [{ provide: _angular_compiler.ResourceLoader, useClass: CachedResourceLoader }];\n    /**\n     * @stable\n     */\n    var platformBrowserDynamic = _angular_core.createPlatformFactory(_angular_compiler.platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);\n\n    exports.RESOURCE_CACHE_PROVIDER = RESOURCE_CACHE_PROVIDER;\n    exports.platformBrowserDynamic = platformBrowserDynamic;\n    exports.__platform_browser_dynamic_private__ = __platform_browser_dynamic_private__;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy51bWQuanM/MDRlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJFQUEyRTtBQUNwSCxDQUFDLG9GQUFvRjs7QUFFckY7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQ0FBaUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlDQUFpQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYywwRUFBMEUsR0FBRztBQUNsSDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEVBQTRFO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEciLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMi4wXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbXBpbGVyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb21waWxlcicsICdAYW5ndWxhci9jb3JlJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljID0gZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfHwge30pLGdsb2JhbC5uZy5jb21waWxlcixnbG9iYWwubmcuY29yZSxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvbXBpbGVyLF9hbmd1bGFyX2NvcmUsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5fX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fLklOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTO1xuXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBSZXNvdXJjZUxvYWRlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVzb3VyY2VMb2FkZXJJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlckltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICAgICAgdmFyIHJlamVjdDtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gUmVzb3VyY2VMb2FkZXIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IElFMTApXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSB3aGVuIGl0IGlzIDAgKDAgc3RhdHVzIGlzIHVuZG9jdW1lbnRlZCkuXG4gICAgICAgICAgICAgICAgLy8gT2NjdXJzIHdoZW4gYWNjZXNzaW5nIGZpbGUgcmVzb3VyY2VzIG9yIG9uIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSByZXNwb25zZSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7IH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIFJlc291cmNlTG9hZGVySW1wbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJlc291cmNlTG9hZGVySW1wbC5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXJJbXBsO1xuICAgIH0oX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIpKTtcblxuICAgIHZhciBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5DT01QSUxFUl9PUFRJT05TLFxuICAgICAgICAgICAgdXNlVmFsdWU6IHsgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBfYW5ndWxhcl9jb21waWxlci5SZXNvdXJjZUxvYWRlciwgdXNlQ2xhc3M6IFJlc291cmNlTG9hZGVySW1wbCB9XSB9LFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIF9nbG9iYWwgPSBnbG9iYWxTY29wZTtcbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIF9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgUmVzb3VyY2VMb2FkZXIgdGhhdCB1c2VzIGEgdGVtcGxhdGUgY2FjaGUgdG8gYXZvaWQgZG9pbmcgYW4gYWN0dWFsXG4gICAgICogUmVzb3VyY2VMb2FkZXIuXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgY2FjaGUgbmVlZHMgdG8gYmUgYnVpbHQgYW5kIGxvYWRlZCBpbnRvIHdpbmRvdy4kdGVtcGxhdGVDYWNoZVxuICAgICAqIHZpYSBhIHNlcGFyYXRlIG1lY2hhbmlzbS5cbiAgICAgKi9cbiAgICB2YXIgQ2FjaGVkUmVzb3VyY2VMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShDYWNoZWRSZXNvdXJjZUxvYWRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2FjaGVkUmVzb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gX2dsb2JhbC4kdGVtcGxhdGVDYWNoZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogVGVtcGxhdGUgY2FjaGUgd2FzIG5vdCBmb3VuZCBpbiAkdGVtcGxhdGVDYWNoZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDYWNoZWRSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhc093blByb3BlcnR5KHVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlW3VybF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogRGlkIG5vdCBmaW5kIGNhY2hlZCB0ZW1wbGF0ZSBmb3IgJyArIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYWNoZWRSZXNvdXJjZUxvYWRlcjtcbiAgICB9KF9hbmd1bGFyX2NvbXBpbGVyLlJlc291cmNlTG9hZGVyKSk7XG5cbiAgICB2YXIgX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fID0ge1xuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTOiBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTLFxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGw6IFJlc291cmNlTG9hZGVySW1wbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSID0gW3sgcHJvdmlkZTogX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBDYWNoZWRSZXNvdXJjZUxvYWRlciB9XTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgPSBfYW5ndWxhcl9jb3JlLmNyZWF0ZVBsYXRmb3JtRmFjdG9yeShfYW5ndWxhcl9jb21waWxlci5wbGF0Zm9ybUNvcmVEeW5hbWljLCAnYnJvd3NlckR5bmFtaWMnLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTKTtcblxuICAgIGV4cG9ydHMuUkVTT1VSQ0VfQ0FDSEVfUFJPVklERVIgPSBSRVNPVVJDRV9DQUNIRV9QUk9WSURFUjtcbiAgICBleHBvcnRzLnBsYXRmb3JtQnJvd3NlckR5bmFtaWMgPSBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljO1xuICAgIGV4cG9ydHMuX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fID0gX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9idW5kbGVzL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * @license Angular v2.2.0\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(2)) :\n  typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :\n  (factory((global.ng = global.ng || {}, global.ng.compiler = global.ng.compiler || {}),global.ng.core));\n}(this, function (exports,_angular_core) { 'use strict';\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   * A segment of text within the template.\n   */\n  var TextAst = (function () {\n      function TextAst(value, ngContentIndex, sourceSpan) {\n          this.value = value;\n          this.ngContentIndex = ngContentIndex;\n          this.sourceSpan = sourceSpan;\n      }\n      TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n      return TextAst;\n  }());\n  /**\n   * A bound expression within the text of a template.\n   */\n  var BoundTextAst = (function () {\n      function BoundTextAst(value, ngContentIndex, sourceSpan) {\n          this.value = value;\n          this.ngContentIndex = ngContentIndex;\n          this.sourceSpan = sourceSpan;\n      }\n      BoundTextAst.prototype.visit = function (visitor, context) {\n          return visitor.visitBoundText(this, context);\n      };\n      return BoundTextAst;\n  }());\n  /**\n   * A plain attribute on an element.\n   */\n  var AttrAst = (function () {\n      function AttrAst(name, value, sourceSpan) {\n          this.name = name;\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\n      return AttrAst;\n  }());\n  /**\n   * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n   * `[@trigger]=\"stateExp\"`)\n   */\n  var BoundElementPropertyAst = (function () {\n      function BoundElementPropertyAst(name, type, securityContext, needsRuntimeSecurityContext, value, unit, sourceSpan) {\n          this.name = name;\n          this.type = type;\n          this.securityContext = securityContext;\n          this.needsRuntimeSecurityContext = needsRuntimeSecurityContext;\n          this.value = value;\n          this.unit = unit;\n          this.sourceSpan = sourceSpan;\n      }\n      BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n          return visitor.visitElementProperty(this, context);\n      };\n      Object.defineProperty(BoundElementPropertyAst.prototype, \"isAnimation\", {\n          get: function () { return this.type === exports.PropertyBindingType.Animation; },\n          enumerable: true,\n          configurable: true\n      });\n      return BoundElementPropertyAst;\n  }());\n  /**\n   * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n   * `(@trigger.phase)=\"callback($event)\"`).\n   */\n  var BoundEventAst = (function () {\n      function BoundEventAst(name, target, phase, handler, sourceSpan) {\n          this.name = name;\n          this.target = target;\n          this.phase = phase;\n          this.handler = handler;\n          this.sourceSpan = sourceSpan;\n      }\n      BoundEventAst.calcFullName = function (name, target, phase) {\n          if (target) {\n              return target + \":\" + name;\n          }\n          else if (phase) {\n              return \"@\" + name + \".\" + phase;\n          }\n          else {\n              return name;\n          }\n      };\n      BoundEventAst.prototype.visit = function (visitor, context) {\n          return visitor.visitEvent(this, context);\n      };\n      Object.defineProperty(BoundEventAst.prototype, \"fullName\", {\n          get: function () { return BoundEventAst.calcFullName(this.name, this.target, this.phase); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(BoundEventAst.prototype, \"isAnimation\", {\n          get: function () { return !!this.phase; },\n          enumerable: true,\n          configurable: true\n      });\n      return BoundEventAst;\n  }());\n  /**\n   * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n   */\n  var ReferenceAst = (function () {\n      function ReferenceAst(name, value, sourceSpan) {\n          this.name = name;\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      ReferenceAst.prototype.visit = function (visitor, context) {\n          return visitor.visitReference(this, context);\n      };\n      return ReferenceAst;\n  }());\n  /**\n   * A variable declaration on a <template> (e.g. `var-someName=\"someLocalName\"`).\n   */\n  var VariableAst = (function () {\n      function VariableAst(name, value, sourceSpan) {\n          this.name = name;\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      VariableAst.prototype.visit = function (visitor, context) {\n          return visitor.visitVariable(this, context);\n      };\n      return VariableAst;\n  }());\n  /**\n   * An element declaration in a template.\n   */\n  var ElementAst = (function () {\n      function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan, endSourceSpan) {\n          this.name = name;\n          this.attrs = attrs;\n          this.inputs = inputs;\n          this.outputs = outputs;\n          this.references = references;\n          this.directives = directives;\n          this.providers = providers;\n          this.hasViewContainer = hasViewContainer;\n          this.children = children;\n          this.ngContentIndex = ngContentIndex;\n          this.sourceSpan = sourceSpan;\n          this.endSourceSpan = endSourceSpan;\n      }\n      ElementAst.prototype.visit = function (visitor, context) {\n          return visitor.visitElement(this, context);\n      };\n      return ElementAst;\n  }());\n  /**\n   * A `<template>` element included in an Angular template.\n   */\n  var EmbeddedTemplateAst = (function () {\n      function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {\n          this.attrs = attrs;\n          this.outputs = outputs;\n          this.references = references;\n          this.variables = variables;\n          this.directives = directives;\n          this.providers = providers;\n          this.hasViewContainer = hasViewContainer;\n          this.children = children;\n          this.ngContentIndex = ngContentIndex;\n          this.sourceSpan = sourceSpan;\n      }\n      EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n          return visitor.visitEmbeddedTemplate(this, context);\n      };\n      return EmbeddedTemplateAst;\n  }());\n  /**\n   * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n   */\n  var BoundDirectivePropertyAst = (function () {\n      function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n          this.directiveName = directiveName;\n          this.templateName = templateName;\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n          return visitor.visitDirectiveProperty(this, context);\n      };\n      return BoundDirectivePropertyAst;\n  }());\n  /**\n   * A directive declared on an element.\n   */\n  var DirectiveAst = (function () {\n      function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {\n          this.directive = directive;\n          this.inputs = inputs;\n          this.hostProperties = hostProperties;\n          this.hostEvents = hostEvents;\n          this.sourceSpan = sourceSpan;\n      }\n      DirectiveAst.prototype.visit = function (visitor, context) {\n          return visitor.visitDirective(this, context);\n      };\n      return DirectiveAst;\n  }());\n  /**\n   * A provider declared on an element\n   */\n  var ProviderAst = (function () {\n      function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {\n          this.token = token;\n          this.multiProvider = multiProvider;\n          this.eager = eager;\n          this.providers = providers;\n          this.providerType = providerType;\n          this.lifecycleHooks = lifecycleHooks;\n          this.sourceSpan = sourceSpan;\n      }\n      ProviderAst.prototype.visit = function (visitor, context) {\n          // No visit method in the visitor for now...\n          return null;\n      };\n      return ProviderAst;\n  }());\n  exports.ProviderAstType;\n  (function (ProviderAstType) {\n      ProviderAstType[ProviderAstType[\"PublicService\"] = 0] = \"PublicService\";\n      ProviderAstType[ProviderAstType[\"PrivateService\"] = 1] = \"PrivateService\";\n      ProviderAstType[ProviderAstType[\"Component\"] = 2] = \"Component\";\n      ProviderAstType[ProviderAstType[\"Directive\"] = 3] = \"Directive\";\n      ProviderAstType[ProviderAstType[\"Builtin\"] = 4] = \"Builtin\";\n  })(exports.ProviderAstType || (exports.ProviderAstType = {}));\n  /**\n   * Position where content is to be projected (instance of `<ng-content>` in a template).\n   */\n  var NgContentAst = (function () {\n      function NgContentAst(index, ngContentIndex, sourceSpan) {\n          this.index = index;\n          this.ngContentIndex = ngContentIndex;\n          this.sourceSpan = sourceSpan;\n      }\n      NgContentAst.prototype.visit = function (visitor, context) {\n          return visitor.visitNgContent(this, context);\n      };\n      return NgContentAst;\n  }());\n  /**\n   * Enumeration of types of property bindings.\n   */\n  exports.PropertyBindingType;\n  (function (PropertyBindingType) {\n      /**\n       * A normal binding to a property (e.g. `[property]=\"expression\"`).\n       */\n      PropertyBindingType[PropertyBindingType[\"Property\"] = 0] = \"Property\";\n      /**\n       * A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n       */\n      PropertyBindingType[PropertyBindingType[\"Attribute\"] = 1] = \"Attribute\";\n      /**\n       * A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n       */\n      PropertyBindingType[PropertyBindingType[\"Class\"] = 2] = \"Class\";\n      /**\n       * A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n       */\n      PropertyBindingType[PropertyBindingType[\"Style\"] = 3] = \"Style\";\n      /**\n       * A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n       */\n      PropertyBindingType[PropertyBindingType[\"Animation\"] = 4] = \"Animation\";\n  })(exports.PropertyBindingType || (exports.PropertyBindingType = {}));\n  /**\n   * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n   */\n  function templateVisitAll(visitor, asts, context) {\n      if (context === void 0) { context = null; }\n      var result = [];\n      var visit = visitor.visit ?\n          function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n          function (ast) { return ast.visit(visitor, context); };\n      asts.forEach(function (ast) {\n          var astResult = visit(ast);\n          if (astResult) {\n              result.push(astResult);\n          }\n      });\n      return result;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var $EOF = 0;\n  var $TAB = 9;\n  var $LF = 10;\n  var $VTAB = 11;\n  var $FF = 12;\n  var $CR = 13;\n  var $SPACE = 32;\n  var $BANG = 33;\n  var $DQ = 34;\n  var $HASH = 35;\n  var $$ = 36;\n  var $PERCENT = 37;\n  var $AMPERSAND = 38;\n  var $SQ = 39;\n  var $LPAREN = 40;\n  var $RPAREN = 41;\n  var $STAR = 42;\n  var $PLUS = 43;\n  var $COMMA = 44;\n  var $MINUS = 45;\n  var $PERIOD = 46;\n  var $SLASH = 47;\n  var $COLON = 58;\n  var $SEMICOLON = 59;\n  var $LT = 60;\n  var $EQ = 61;\n  var $GT = 62;\n  var $QUESTION = 63;\n  var $0 = 48;\n  var $9 = 57;\n  var $A = 65;\n  var $E = 69;\n  var $F = 70;\n  var $X = 88;\n  var $Z = 90;\n  var $LBRACKET = 91;\n  var $BACKSLASH = 92;\n  var $RBRACKET = 93;\n  var $CARET = 94;\n  var $_ = 95;\n  var $a = 97;\n  var $e = 101;\n  var $f = 102;\n  var $n = 110;\n  var $r = 114;\n  var $t = 116;\n  var $u = 117;\n  var $v = 118;\n  var $x = 120;\n  var $z = 122;\n  var $LBRACE = 123;\n  var $BAR = 124;\n  var $RBRACE = 125;\n  var $NBSP = 160;\n  var $BT = 96;\n  function isWhitespace(code) {\n      return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n  }\n  function isDigit(code) {\n      return $0 <= code && code <= $9;\n  }\n  function isAsciiLetter(code) {\n      return code >= $a && code <= $z || code >= $A && code <= $Z;\n  }\n  function isAsciiHexDigit(code) {\n      return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n  }\n\n  function isPresent(obj) {\n      return obj != null;\n  }\n  function isBlank(obj) {\n      return obj == null;\n  }\n  var STRING_MAP_PROTO = Object.getPrototypeOf({});\n  function isStrictStringMap(obj) {\n      return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n  }\n  function stringify(token) {\n      if (typeof token === 'string') {\n          return token;\n      }\n      if (token == null) {\n          return '' + token;\n      }\n      if (token.overriddenName) {\n          return token.overriddenName;\n      }\n      if (token.name) {\n          return token.name;\n      }\n      var res = token.toString();\n      var newLineIndex = res.indexOf('\\n');\n      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n  }\n  var NumberWrapper = (function () {\n      function NumberWrapper() {\n      }\n      NumberWrapper.parseIntAutoRadix = function (text) {\n          var result = parseInt(text);\n          if (isNaN(result)) {\n              throw new Error('Invalid integer literal when parsing ' + text);\n          }\n          return result;\n      };\n      NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n      return NumberWrapper;\n  }());\n  function isJsObject(o) {\n      return o !== null && (typeof o === 'function' || typeof o === 'object');\n  }\n  function isPrimitive(obj) {\n      return !isJsObject(obj);\n  }\n  function escapeRegExp(s) {\n      return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  }\n\n  function assertArrayOfStrings(identifier, value) {\n      if (!_angular_core.isDevMode() || isBlank(value)) {\n          return;\n      }\n      if (!Array.isArray(value)) {\n          throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n      }\n      for (var i = 0; i < value.length; i += 1) {\n          if (typeof value[i] !== 'string') {\n              throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n          }\n      }\n  }\n  var INTERPOLATION_BLACKLIST_REGEXPS = [\n      /^\\s*$/,\n      /[<>]/,\n      /^[{}]$/,\n      /&(#|[a-z])/i,\n      /^\\/\\//,\n  ];\n  function assertInterpolationSymbols(identifier, value) {\n      if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {\n          throw new Error(\"Expected '\" + identifier + \"' to be an array, [start, end].\");\n      }\n      else if (_angular_core.isDevMode() && !isBlank(value)) {\n          var start_1 = value[0];\n          var end_1 = value[1];\n          // black list checking\n          INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {\n              if (regexp.test(start_1) || regexp.test(end_1)) {\n                  throw new Error(\"['\" + start_1 + \"', '\" + end_1 + \"'] contains unusable interpolation symbol.\");\n              }\n          });\n      }\n  }\n\n  var InterpolationConfig = (function () {\n      function InterpolationConfig(start, end) {\n          this.start = start;\n          this.end = end;\n      }\n      InterpolationConfig.fromArray = function (markers) {\n          if (!markers) {\n              return DEFAULT_INTERPOLATION_CONFIG;\n          }\n          assertInterpolationSymbols('interpolation', markers);\n          return new InterpolationConfig(markers[0], markers[1]);\n      };\n      ;\n      return InterpolationConfig;\n  }());\n  var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$1 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var ParserError = (function () {\n      function ParserError(message, input, errLocation, ctxLocation) {\n          this.input = input;\n          this.errLocation = errLocation;\n          this.ctxLocation = ctxLocation;\n          this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n      }\n      return ParserError;\n  }());\n  var ParseSpan = (function () {\n      function ParseSpan(start, end) {\n          this.start = start;\n          this.end = end;\n      }\n      return ParseSpan;\n  }());\n  var AST = (function () {\n      function AST(span) {\n          this.span = span;\n      }\n      AST.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return null;\n      };\n      AST.prototype.toString = function () { return 'AST'; };\n      return AST;\n  }());\n  /**\n   * Represents a quoted expression of the form:\n   *\n   * quote = prefix `:` uninterpretedExpression\n   * prefix = identifier\n   * uninterpretedExpression = arbitrary string\n   *\n   * A quoted expression is meant to be pre-processed by an AST transformer that\n   * converts it into another AST that no longer contains quoted expressions.\n   * It is meant to allow third-party developers to extend Angular template\n   * expression language. The `uninterpretedExpression` part of the quote is\n   * therefore not interpreted by the Angular's own expression parser.\n   */\n  var Quote = (function (_super) {\n      __extends$1(Quote, _super);\n      function Quote(span, prefix, uninterpretedExpression, location) {\n          _super.call(this, span);\n          this.prefix = prefix;\n          this.uninterpretedExpression = uninterpretedExpression;\n          this.location = location;\n      }\n      Quote.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitQuote(this, context);\n      };\n      Quote.prototype.toString = function () { return 'Quote'; };\n      return Quote;\n  }(AST));\n  var EmptyExpr = (function (_super) {\n      __extends$1(EmptyExpr, _super);\n      function EmptyExpr() {\n          _super.apply(this, arguments);\n      }\n      EmptyExpr.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          // do nothing\n      };\n      return EmptyExpr;\n  }(AST));\n  var ImplicitReceiver = (function (_super) {\n      __extends$1(ImplicitReceiver, _super);\n      function ImplicitReceiver() {\n          _super.apply(this, arguments);\n      }\n      ImplicitReceiver.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitImplicitReceiver(this, context);\n      };\n      return ImplicitReceiver;\n  }(AST));\n  /**\n   * Multiple expressions separated by a semicolon.\n   */\n  var Chain = (function (_super) {\n      __extends$1(Chain, _super);\n      function Chain(span, expressions) {\n          _super.call(this, span);\n          this.expressions = expressions;\n      }\n      Chain.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitChain(this, context);\n      };\n      return Chain;\n  }(AST));\n  var Conditional = (function (_super) {\n      __extends$1(Conditional, _super);\n      function Conditional(span, condition, trueExp, falseExp) {\n          _super.call(this, span);\n          this.condition = condition;\n          this.trueExp = trueExp;\n          this.falseExp = falseExp;\n      }\n      Conditional.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitConditional(this, context);\n      };\n      return Conditional;\n  }(AST));\n  var PropertyRead = (function (_super) {\n      __extends$1(PropertyRead, _super);\n      function PropertyRead(span, receiver, name) {\n          _super.call(this, span);\n          this.receiver = receiver;\n          this.name = name;\n      }\n      PropertyRead.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitPropertyRead(this, context);\n      };\n      return PropertyRead;\n  }(AST));\n  var PropertyWrite = (function (_super) {\n      __extends$1(PropertyWrite, _super);\n      function PropertyWrite(span, receiver, name, value) {\n          _super.call(this, span);\n          this.receiver = receiver;\n          this.name = name;\n          this.value = value;\n      }\n      PropertyWrite.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitPropertyWrite(this, context);\n      };\n      return PropertyWrite;\n  }(AST));\n  var SafePropertyRead = (function (_super) {\n      __extends$1(SafePropertyRead, _super);\n      function SafePropertyRead(span, receiver, name) {\n          _super.call(this, span);\n          this.receiver = receiver;\n          this.name = name;\n      }\n      SafePropertyRead.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitSafePropertyRead(this, context);\n      };\n      return SafePropertyRead;\n  }(AST));\n  var KeyedRead = (function (_super) {\n      __extends$1(KeyedRead, _super);\n      function KeyedRead(span, obj, key) {\n          _super.call(this, span);\n          this.obj = obj;\n          this.key = key;\n      }\n      KeyedRead.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitKeyedRead(this, context);\n      };\n      return KeyedRead;\n  }(AST));\n  var KeyedWrite = (function (_super) {\n      __extends$1(KeyedWrite, _super);\n      function KeyedWrite(span, obj, key, value) {\n          _super.call(this, span);\n          this.obj = obj;\n          this.key = key;\n          this.value = value;\n      }\n      KeyedWrite.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitKeyedWrite(this, context);\n      };\n      return KeyedWrite;\n  }(AST));\n  var BindingPipe = (function (_super) {\n      __extends$1(BindingPipe, _super);\n      function BindingPipe(span, exp, name, args) {\n          _super.call(this, span);\n          this.exp = exp;\n          this.name = name;\n          this.args = args;\n      }\n      BindingPipe.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitPipe(this, context);\n      };\n      return BindingPipe;\n  }(AST));\n  var LiteralPrimitive = (function (_super) {\n      __extends$1(LiteralPrimitive, _super);\n      function LiteralPrimitive(span, value) {\n          _super.call(this, span);\n          this.value = value;\n      }\n      LiteralPrimitive.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitLiteralPrimitive(this, context);\n      };\n      return LiteralPrimitive;\n  }(AST));\n  var LiteralArray = (function (_super) {\n      __extends$1(LiteralArray, _super);\n      function LiteralArray(span, expressions) {\n          _super.call(this, span);\n          this.expressions = expressions;\n      }\n      LiteralArray.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitLiteralArray(this, context);\n      };\n      return LiteralArray;\n  }(AST));\n  var LiteralMap = (function (_super) {\n      __extends$1(LiteralMap, _super);\n      function LiteralMap(span, keys, values) {\n          _super.call(this, span);\n          this.keys = keys;\n          this.values = values;\n      }\n      LiteralMap.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitLiteralMap(this, context);\n      };\n      return LiteralMap;\n  }(AST));\n  var Interpolation = (function (_super) {\n      __extends$1(Interpolation, _super);\n      function Interpolation(span, strings, expressions) {\n          _super.call(this, span);\n          this.strings = strings;\n          this.expressions = expressions;\n      }\n      Interpolation.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitInterpolation(this, context);\n      };\n      return Interpolation;\n  }(AST));\n  var Binary = (function (_super) {\n      __extends$1(Binary, _super);\n      function Binary(span, operation, left, right) {\n          _super.call(this, span);\n          this.operation = operation;\n          this.left = left;\n          this.right = right;\n      }\n      Binary.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitBinary(this, context);\n      };\n      return Binary;\n  }(AST));\n  var PrefixNot = (function (_super) {\n      __extends$1(PrefixNot, _super);\n      function PrefixNot(span, expression) {\n          _super.call(this, span);\n          this.expression = expression;\n      }\n      PrefixNot.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitPrefixNot(this, context);\n      };\n      return PrefixNot;\n  }(AST));\n  var MethodCall = (function (_super) {\n      __extends$1(MethodCall, _super);\n      function MethodCall(span, receiver, name, args) {\n          _super.call(this, span);\n          this.receiver = receiver;\n          this.name = name;\n          this.args = args;\n      }\n      MethodCall.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitMethodCall(this, context);\n      };\n      return MethodCall;\n  }(AST));\n  var SafeMethodCall = (function (_super) {\n      __extends$1(SafeMethodCall, _super);\n      function SafeMethodCall(span, receiver, name, args) {\n          _super.call(this, span);\n          this.receiver = receiver;\n          this.name = name;\n          this.args = args;\n      }\n      SafeMethodCall.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitSafeMethodCall(this, context);\n      };\n      return SafeMethodCall;\n  }(AST));\n  var FunctionCall = (function (_super) {\n      __extends$1(FunctionCall, _super);\n      function FunctionCall(span, target, args) {\n          _super.call(this, span);\n          this.target = target;\n          this.args = args;\n      }\n      FunctionCall.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return visitor.visitFunctionCall(this, context);\n      };\n      return FunctionCall;\n  }(AST));\n  var ASTWithSource = (function (_super) {\n      __extends$1(ASTWithSource, _super);\n      function ASTWithSource(ast, source, location, errors) {\n          _super.call(this, new ParseSpan(0, isBlank(source) ? 0 : source.length));\n          this.ast = ast;\n          this.source = source;\n          this.location = location;\n          this.errors = errors;\n      }\n      ASTWithSource.prototype.visit = function (visitor, context) {\n          if (context === void 0) { context = null; }\n          return this.ast.visit(visitor, context);\n      };\n      ASTWithSource.prototype.toString = function () { return this.source + \" in \" + this.location; };\n      return ASTWithSource;\n  }(AST));\n  var TemplateBinding = (function () {\n      function TemplateBinding(span, key, keyIsVar, name, expression) {\n          this.span = span;\n          this.key = key;\n          this.keyIsVar = keyIsVar;\n          this.name = name;\n          this.expression = expression;\n      }\n      return TemplateBinding;\n  }());\n  var RecursiveAstVisitor = (function () {\n      function RecursiveAstVisitor() {\n      }\n      RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n          ast.left.visit(this);\n          ast.right.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };\n      RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n          ast.condition.visit(this);\n          ast.trueExp.visit(this);\n          ast.falseExp.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n          ast.exp.visit(this);\n          this.visitAll(ast.args, context);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n          ast.target.visit(this);\n          this.visitAll(ast.args, context);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };\n      RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n          return this.visitAll(ast.expressions, context);\n      };\n      RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n          ast.obj.visit(this);\n          ast.key.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n          ast.obj.visit(this);\n          ast.key.visit(this);\n          ast.value.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n          return this.visitAll(ast.expressions, context);\n      };\n      RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };\n      RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };\n      RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n          ast.receiver.visit(this);\n          return this.visitAll(ast.args, context);\n      };\n      RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n          ast.expression.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n          ast.receiver.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n          ast.receiver.visit(this);\n          ast.value.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n          ast.receiver.visit(this);\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n          ast.receiver.visit(this);\n          return this.visitAll(ast.args, context);\n      };\n      RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n          var _this = this;\n          asts.forEach(function (ast) { return ast.visit(_this, context); });\n          return null;\n      };\n      RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };\n      return RecursiveAstVisitor;\n  }());\n\n  exports.TokenType;\n  (function (TokenType) {\n      TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n      TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n      TokenType[TokenType[\"Keyword\"] = 2] = \"Keyword\";\n      TokenType[TokenType[\"String\"] = 3] = \"String\";\n      TokenType[TokenType[\"Operator\"] = 4] = \"Operator\";\n      TokenType[TokenType[\"Number\"] = 5] = \"Number\";\n      TokenType[TokenType[\"Error\"] = 6] = \"Error\";\n  })(exports.TokenType || (exports.TokenType = {}));\n  var KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n  var Lexer = (function () {\n      function Lexer() {\n      }\n      Lexer.prototype.tokenize = function (text) {\n          var scanner = new _Scanner(text);\n          var tokens = [];\n          var token = scanner.scanToken();\n          while (token != null) {\n              tokens.push(token);\n              token = scanner.scanToken();\n          }\n          return tokens;\n      };\n      Lexer.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      Lexer.ctorParameters = [];\n      return Lexer;\n  }());\n  var Token = (function () {\n      function Token(index, type, numValue, strValue) {\n          this.index = index;\n          this.type = type;\n          this.numValue = numValue;\n          this.strValue = strValue;\n      }\n      Token.prototype.isCharacter = function (code) {\n          return this.type == exports.TokenType.Character && this.numValue == code;\n      };\n      Token.prototype.isNumber = function () { return this.type == exports.TokenType.Number; };\n      Token.prototype.isString = function () { return this.type == exports.TokenType.String; };\n      Token.prototype.isOperator = function (operater) {\n          return this.type == exports.TokenType.Operator && this.strValue == operater;\n      };\n      Token.prototype.isIdentifier = function () { return this.type == exports.TokenType.Identifier; };\n      Token.prototype.isKeyword = function () { return this.type == exports.TokenType.Keyword; };\n      Token.prototype.isKeywordLet = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'let'; };\n      Token.prototype.isKeywordNull = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'null'; };\n      Token.prototype.isKeywordUndefined = function () {\n          return this.type == exports.TokenType.Keyword && this.strValue == 'undefined';\n      };\n      Token.prototype.isKeywordTrue = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'true'; };\n      Token.prototype.isKeywordFalse = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'false'; };\n      Token.prototype.isKeywordThis = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'this'; };\n      Token.prototype.isError = function () { return this.type == exports.TokenType.Error; };\n      Token.prototype.toNumber = function () { return this.type == exports.TokenType.Number ? this.numValue : -1; };\n      Token.prototype.toString = function () {\n          switch (this.type) {\n              case exports.TokenType.Character:\n              case exports.TokenType.Identifier:\n              case exports.TokenType.Keyword:\n              case exports.TokenType.Operator:\n              case exports.TokenType.String:\n              case exports.TokenType.Error:\n                  return this.strValue;\n              case exports.TokenType.Number:\n                  return this.numValue.toString();\n              default:\n                  return null;\n          }\n      };\n      return Token;\n  }());\n  function newCharacterToken(index, code) {\n      return new Token(index, exports.TokenType.Character, code, String.fromCharCode(code));\n  }\n  function newIdentifierToken(index, text) {\n      return new Token(index, exports.TokenType.Identifier, 0, text);\n  }\n  function newKeywordToken(index, text) {\n      return new Token(index, exports.TokenType.Keyword, 0, text);\n  }\n  function newOperatorToken(index, text) {\n      return new Token(index, exports.TokenType.Operator, 0, text);\n  }\n  function newStringToken(index, text) {\n      return new Token(index, exports.TokenType.String, 0, text);\n  }\n  function newNumberToken(index, n) {\n      return new Token(index, exports.TokenType.Number, n, '');\n  }\n  function newErrorToken(index, message) {\n      return new Token(index, exports.TokenType.Error, 0, message);\n  }\n  var EOF = new Token(-1, exports.TokenType.Character, 0, '');\n  var _Scanner = (function () {\n      function _Scanner(input) {\n          this.input = input;\n          this.peek = 0;\n          this.index = -1;\n          this.length = input.length;\n          this.advance();\n      }\n      _Scanner.prototype.advance = function () {\n          this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n      };\n      _Scanner.prototype.scanToken = function () {\n          var input = this.input, length = this.length;\n          var peek = this.peek, index = this.index;\n          // Skip whitespace.\n          while (peek <= $SPACE) {\n              if (++index >= length) {\n                  peek = $EOF;\n                  break;\n              }\n              else {\n                  peek = input.charCodeAt(index);\n              }\n          }\n          this.peek = peek;\n          this.index = index;\n          if (index >= length) {\n              return null;\n          }\n          // Handle identifiers and numbers.\n          if (isIdentifierStart(peek))\n              return this.scanIdentifier();\n          if (isDigit(peek))\n              return this.scanNumber(index);\n          var start = index;\n          switch (peek) {\n              case $PERIOD:\n                  this.advance();\n                  return isDigit(this.peek) ? this.scanNumber(start) :\n                      newCharacterToken(start, $PERIOD);\n              case $LPAREN:\n              case $RPAREN:\n              case $LBRACE:\n              case $RBRACE:\n              case $LBRACKET:\n              case $RBRACKET:\n              case $COMMA:\n              case $COLON:\n              case $SEMICOLON:\n                  return this.scanCharacter(start, peek);\n              case $SQ:\n              case $DQ:\n                  return this.scanString();\n              case $HASH:\n              case $PLUS:\n              case $MINUS:\n              case $STAR:\n              case $SLASH:\n              case $PERCENT:\n              case $CARET:\n                  return this.scanOperator(start, String.fromCharCode(peek));\n              case $QUESTION:\n                  return this.scanComplexOperator(start, '?', $PERIOD, '.');\n              case $LT:\n              case $GT:\n                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n              case $BANG:\n              case $EQ:\n                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n              case $AMPERSAND:\n                  return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n              case $BAR:\n                  return this.scanComplexOperator(start, '|', $BAR, '|');\n              case $NBSP:\n                  while (isWhitespace(this.peek))\n                      this.advance();\n                  return this.scanToken();\n          }\n          this.advance();\n          return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n      };\n      _Scanner.prototype.scanCharacter = function (start, code) {\n          this.advance();\n          return newCharacterToken(start, code);\n      };\n      _Scanner.prototype.scanOperator = function (start, str) {\n          this.advance();\n          return newOperatorToken(start, str);\n      };\n      /**\n       * Tokenize a 2/3 char long operator\n       *\n       * @param start start index in the expression\n       * @param one first symbol (always part of the operator)\n       * @param twoCode code point for the second symbol\n       * @param two second symbol (part of the operator when the second code point matches)\n       * @param threeCode code point for the third symbol\n       * @param three third symbol (part of the operator when provided and matches source expression)\n       * @returns {Token}\n       */\n      _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n          this.advance();\n          var str = one;\n          if (this.peek == twoCode) {\n              this.advance();\n              str += two;\n          }\n          if (isPresent(threeCode) && this.peek == threeCode) {\n              this.advance();\n              str += three;\n          }\n          return newOperatorToken(start, str);\n      };\n      _Scanner.prototype.scanIdentifier = function () {\n          var start = this.index;\n          this.advance();\n          while (isIdentifierPart(this.peek))\n              this.advance();\n          var str = this.input.substring(start, this.index);\n          return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n              newIdentifierToken(start, str);\n      };\n      _Scanner.prototype.scanNumber = function (start) {\n          var simple = (this.index === start);\n          this.advance(); // Skip initial digit.\n          while (true) {\n              if (isDigit(this.peek)) {\n              }\n              else if (this.peek == $PERIOD) {\n                  simple = false;\n              }\n              else if (isExponentStart(this.peek)) {\n                  this.advance();\n                  if (isExponentSign(this.peek))\n                      this.advance();\n                  if (!isDigit(this.peek))\n                      return this.error('Invalid exponent', -1);\n                  simple = false;\n              }\n              else {\n                  break;\n              }\n              this.advance();\n          }\n          var str = this.input.substring(start, this.index);\n          var value = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n          return newNumberToken(start, value);\n      };\n      _Scanner.prototype.scanString = function () {\n          var start = this.index;\n          var quote = this.peek;\n          this.advance(); // Skip initial quote.\n          var buffer = '';\n          var marker = this.index;\n          var input = this.input;\n          while (this.peek != quote) {\n              if (this.peek == $BACKSLASH) {\n                  buffer += input.substring(marker, this.index);\n                  this.advance();\n                  var unescapedCode = void 0;\n                  if (this.peek == $u) {\n                      // 4 character hex code for unicode character.\n                      var hex = input.substring(this.index + 1, this.index + 5);\n                      if (/^[0-9a-f]+$/i.test(hex)) {\n                          unescapedCode = parseInt(hex, 16);\n                      }\n                      else {\n                          return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n                      }\n                      for (var i = 0; i < 5; i++) {\n                          this.advance();\n                      }\n                  }\n                  else {\n                      unescapedCode = unescape(this.peek);\n                      this.advance();\n                  }\n                  buffer += String.fromCharCode(unescapedCode);\n                  marker = this.index;\n              }\n              else if (this.peek == $EOF) {\n                  return this.error('Unterminated quote', 0);\n              }\n              else {\n                  this.advance();\n              }\n          }\n          var last = input.substring(marker, this.index);\n          this.advance(); // Skip terminating quote.\n          return newStringToken(start, buffer + last);\n      };\n      _Scanner.prototype.error = function (message, offset) {\n          var position = this.index + offset;\n          return newErrorToken(position, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n      };\n      return _Scanner;\n  }());\n  function isIdentifierStart(code) {\n      return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n          (code == $_) || (code == $$);\n  }\n  function isIdentifier(input) {\n      if (input.length == 0)\n          return false;\n      var scanner = new _Scanner(input);\n      if (!isIdentifierStart(scanner.peek))\n          return false;\n      scanner.advance();\n      while (scanner.peek !== $EOF) {\n          if (!isIdentifierPart(scanner.peek))\n              return false;\n          scanner.advance();\n      }\n      return true;\n  }\n  function isIdentifierPart(code) {\n      return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n          (code == $$);\n  }\n  function isExponentStart(code) {\n      return code == $e || code == $E;\n  }\n  function isExponentSign(code) {\n      return code == $MINUS || code == $PLUS;\n  }\n  function isQuote(code) {\n      return code === $SQ || code === $DQ || code === $BT;\n  }\n  function unescape(code) {\n      switch (code) {\n          case $n:\n              return $LF;\n          case $f:\n              return $FF;\n          case $r:\n              return $CR;\n          case $t:\n              return $TAB;\n          case $v:\n              return $VTAB;\n          default:\n              return code;\n      }\n  }\n\n  var SplitInterpolation = (function () {\n      function SplitInterpolation(strings, expressions, offsets) {\n          this.strings = strings;\n          this.expressions = expressions;\n          this.offsets = offsets;\n      }\n      return SplitInterpolation;\n  }());\n  var TemplateBindingParseResult = (function () {\n      function TemplateBindingParseResult(templateBindings, warnings, errors) {\n          this.templateBindings = templateBindings;\n          this.warnings = warnings;\n          this.errors = errors;\n      }\n      return TemplateBindingParseResult;\n  }());\n  function _createInterpolateRegExp(config) {\n      var pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n      return new RegExp(pattern, 'g');\n  }\n  var Parser = (function () {\n      function Parser(_lexer) {\n          this._lexer = _lexer;\n          this.errors = [];\n      }\n      Parser.prototype.parseAction = function (input, location, interpolationConfig) {\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          this._checkNoInterpolation(input, location, interpolationConfig);\n          var sourceToLex = this._stripComments(input);\n          var tokens = this._lexer.tokenize(this._stripComments(input));\n          var ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n              .parseChain();\n          return new ASTWithSource(ast, input, location, this.errors);\n      };\n      Parser.prototype.parseBinding = function (input, location, interpolationConfig) {\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          var ast = this._parseBindingAst(input, location, interpolationConfig);\n          return new ASTWithSource(ast, input, location, this.errors);\n      };\n      Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          var ast = this._parseBindingAst(input, location, interpolationConfig);\n          var errors = SimpleExpressionChecker.check(ast);\n          if (errors.length > 0) {\n              this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n          }\n          return new ASTWithSource(ast, input, location, this.errors);\n      };\n      Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n          this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n      };\n      Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {\n          // Quotes expressions use 3rd-party expression language. We don't want to use\n          // our lexer or parser for that, so we check for that ahead of time.\n          var quote = this._parseQuote(input, location);\n          if (isPresent(quote)) {\n              return quote;\n          }\n          this._checkNoInterpolation(input, location, interpolationConfig);\n          var sourceToLex = this._stripComments(input);\n          var tokens = this._lexer.tokenize(sourceToLex);\n          return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n              .parseChain();\n      };\n      Parser.prototype._parseQuote = function (input, location) {\n          if (isBlank(input))\n              return null;\n          var prefixSeparatorIndex = input.indexOf(':');\n          if (prefixSeparatorIndex == -1)\n              return null;\n          var prefix = input.substring(0, prefixSeparatorIndex).trim();\n          if (!isIdentifier(prefix))\n              return null;\n          var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n          return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n      };\n      Parser.prototype.parseTemplateBindings = function (prefixToken, input, location) {\n          var tokens = this._lexer.tokenize(input);\n          if (prefixToken) {\n              // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n              var prefixTokens = this._lexer.tokenize(prefixToken).map(function (t) {\n                  t.index = 0;\n                  return t;\n              });\n              tokens.unshift.apply(tokens, prefixTokens);\n          }\n          return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n              .parseTemplateBindings();\n      };\n      Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          var split = this.splitInterpolation(input, location, interpolationConfig);\n          if (split == null)\n              return null;\n          var expressions = [];\n          for (var i = 0; i < split.expressions.length; ++i) {\n              var expressionText = split.expressions[i];\n              var sourceToLex = this._stripComments(expressionText);\n              var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n              var ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                  .parseChain();\n              expressions.push(ast);\n          }\n          return new ASTWithSource(new Interpolation(new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions), input, location, this.errors);\n      };\n      Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          var regexp = _createInterpolateRegExp(interpolationConfig);\n          var parts = input.split(regexp);\n          if (parts.length <= 1) {\n              return null;\n          }\n          var strings = [];\n          var expressions = [];\n          var offsets = [];\n          var offset = 0;\n          for (var i = 0; i < parts.length; i++) {\n              var part = parts[i];\n              if (i % 2 === 0) {\n                  // fixed string\n                  strings.push(part);\n                  offset += part.length;\n              }\n              else if (part.trim().length > 0) {\n                  offset += interpolationConfig.start.length;\n                  expressions.push(part);\n                  offsets.push(offset);\n                  offset += part.length + interpolationConfig.end.length;\n              }\n              else {\n                  this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + \" in\", location);\n                  expressions.push('$implict');\n                  offsets.push(offset);\n              }\n          }\n          return new SplitInterpolation(strings, expressions, offsets);\n      };\n      Parser.prototype.wrapLiteralPrimitive = function (input, location) {\n          return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input, location, this.errors);\n      };\n      Parser.prototype._stripComments = function (input) {\n          var i = this._commentStart(input);\n          return isPresent(i) ? input.substring(0, i).trim() : input;\n      };\n      Parser.prototype._commentStart = function (input) {\n          var outerQuote = null;\n          for (var i = 0; i < input.length - 1; i++) {\n              var char = input.charCodeAt(i);\n              var nextChar = input.charCodeAt(i + 1);\n              if (char === $SLASH && nextChar == $SLASH && isBlank(outerQuote))\n                  return i;\n              if (outerQuote === char) {\n                  outerQuote = null;\n              }\n              else if (isBlank(outerQuote) && isQuote(char)) {\n                  outerQuote = char;\n              }\n          }\n          return null;\n      };\n      Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {\n          var regexp = _createInterpolateRegExp(interpolationConfig);\n          var parts = input.split(regexp);\n          if (parts.length > 1) {\n              this._reportError(\"Got interpolation (\" + interpolationConfig.start + interpolationConfig.end + \") where expression was expected\", input, \"at column \" + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + \" in\", location);\n          }\n      };\n      Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {\n          var errLocation = '';\n          for (var j = 0; j < partInErrIdx; j++) {\n              errLocation += j % 2 === 0 ?\n                  parts[j] :\n                  \"\" + interpolationConfig.start + parts[j] + interpolationConfig.end;\n          }\n          return errLocation.length;\n      };\n      Parser.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      Parser.ctorParameters = [\n          { type: Lexer, },\n      ];\n      return Parser;\n  }());\n  var _ParseAST = (function () {\n      function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {\n          this.input = input;\n          this.location = location;\n          this.tokens = tokens;\n          this.inputLength = inputLength;\n          this.parseAction = parseAction;\n          this.errors = errors;\n          this.offset = offset;\n          this.rparensExpected = 0;\n          this.rbracketsExpected = 0;\n          this.rbracesExpected = 0;\n          this.index = 0;\n      }\n      _ParseAST.prototype.peek = function (offset) {\n          var i = this.index + offset;\n          return i < this.tokens.length ? this.tokens[i] : EOF;\n      };\n      Object.defineProperty(_ParseAST.prototype, \"next\", {\n          get: function () { return this.peek(0); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n          get: function () {\n              return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                  this.inputLength + this.offset;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };\n      _ParseAST.prototype.advance = function () { this.index++; };\n      _ParseAST.prototype.optionalCharacter = function (code) {\n          if (this.next.isCharacter(code)) {\n              this.advance();\n              return true;\n          }\n          else {\n              return false;\n          }\n      };\n      _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };\n      _ParseAST.prototype.expectCharacter = function (code) {\n          if (this.optionalCharacter(code))\n              return;\n          this.error(\"Missing expected \" + String.fromCharCode(code));\n      };\n      _ParseAST.prototype.optionalOperator = function (op) {\n          if (this.next.isOperator(op)) {\n              this.advance();\n              return true;\n          }\n          else {\n              return false;\n          }\n      };\n      _ParseAST.prototype.expectOperator = function (operator) {\n          if (this.optionalOperator(operator))\n              return;\n          this.error(\"Missing expected operator \" + operator);\n      };\n      _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n          var n = this.next;\n          if (!n.isIdentifier() && !n.isKeyword()) {\n              this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\n              return '';\n          }\n          this.advance();\n          return n.toString();\n      };\n      _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n          var n = this.next;\n          if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n              this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\n              return '';\n          }\n          this.advance();\n          return n.toString();\n      };\n      _ParseAST.prototype.parseChain = function () {\n          var exprs = [];\n          var start = this.inputIndex;\n          while (this.index < this.tokens.length) {\n              var expr = this.parsePipe();\n              exprs.push(expr);\n              if (this.optionalCharacter($SEMICOLON)) {\n                  if (!this.parseAction) {\n                      this.error('Binding expression cannot contain chained expression');\n                  }\n                  while (this.optionalCharacter($SEMICOLON)) {\n                  } // read all semicolons\n              }\n              else if (this.index < this.tokens.length) {\n                  this.error(\"Unexpected token '\" + this.next + \"'\");\n              }\n          }\n          if (exprs.length == 0)\n              return new EmptyExpr(this.span(start));\n          if (exprs.length == 1)\n              return exprs[0];\n          return new Chain(this.span(start), exprs);\n      };\n      _ParseAST.prototype.parsePipe = function () {\n          var result = this.parseExpression();\n          if (this.optionalOperator('|')) {\n              if (this.parseAction) {\n                  this.error('Cannot have a pipe in an action expression');\n              }\n              do {\n                  var name_1 = this.expectIdentifierOrKeyword();\n                  var args = [];\n                  while (this.optionalCharacter($COLON)) {\n                      args.push(this.parseExpression());\n                  }\n                  result = new BindingPipe(this.span(result.span.start - this.offset), result, name_1, args);\n              } while (this.optionalOperator('|'));\n          }\n          return result;\n      };\n      _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };\n      _ParseAST.prototype.parseConditional = function () {\n          var start = this.inputIndex;\n          var result = this.parseLogicalOr();\n          if (this.optionalOperator('?')) {\n              var yes = this.parsePipe();\n              var no = void 0;\n              if (!this.optionalCharacter($COLON)) {\n                  var end = this.inputIndex;\n                  var expression = this.input.substring(start, end);\n                  this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n                  no = new EmptyExpr(this.span(start));\n              }\n              else {\n                  no = this.parsePipe();\n              }\n              return new Conditional(this.span(start), result, yes, no);\n          }\n          else {\n              return result;\n          }\n      };\n      _ParseAST.prototype.parseLogicalOr = function () {\n          // '||'\n          var result = this.parseLogicalAnd();\n          while (this.optionalOperator('||')) {\n              var right = this.parseLogicalAnd();\n              result = new Binary(this.span(result.span.start), '||', result, right);\n          }\n          return result;\n      };\n      _ParseAST.prototype.parseLogicalAnd = function () {\n          // '&&'\n          var result = this.parseEquality();\n          while (this.optionalOperator('&&')) {\n              var right = this.parseEquality();\n              result = new Binary(this.span(result.span.start), '&&', result, right);\n          }\n          return result;\n      };\n      _ParseAST.prototype.parseEquality = function () {\n          // '==','!=','===','!=='\n          var result = this.parseRelational();\n          while (this.next.type == exports.TokenType.Operator) {\n              var operator = this.next.strValue;\n              switch (operator) {\n                  case '==':\n                  case '===':\n                  case '!=':\n                  case '!==':\n                      this.advance();\n                      var right = this.parseRelational();\n                      result = new Binary(this.span(result.span.start), operator, result, right);\n                      continue;\n              }\n              break;\n          }\n          return result;\n      };\n      _ParseAST.prototype.parseRelational = function () {\n          // '<', '>', '<=', '>='\n          var result = this.parseAdditive();\n          while (this.next.type == exports.TokenType.Operator) {\n              var operator = this.next.strValue;\n              switch (operator) {\n                  case '<':\n                  case '>':\n                  case '<=':\n                  case '>=':\n                      this.advance();\n                      var right = this.parseAdditive();\n                      result = new Binary(this.span(result.span.start), operator, result, right);\n                      continue;\n              }\n              break;\n          }\n          return result;\n      };\n      _ParseAST.prototype.parseAdditive = function () {\n          // '+', '-'\n          var result = this.parseMultiplicative();\n          while (this.next.type == exports.TokenType.Operator) {\n              var operator = this.next.strValue;\n              switch (operator) {\n                  case '+':\n                  case '-':\n                      this.advance();\n                      var right = this.parseMultiplicative();\n                      result = new Binary(this.span(result.span.start), operator, result, right);\n                      continue;\n              }\n              break;\n          }\n          return result;\n      };\n      _ParseAST.prototype.parseMultiplicative = function () {\n          // '*', '%', '/'\n          var result = this.parsePrefix();\n          while (this.next.type == exports.TokenType.Operator) {\n              var operator = this.next.strValue;\n              switch (operator) {\n                  case '*':\n                  case '%':\n                  case '/':\n                      this.advance();\n                      var right = this.parsePrefix();\n                      result = new Binary(this.span(result.span.start), operator, result, right);\n                      continue;\n              }\n              break;\n          }\n          return result;\n      };\n      _ParseAST.prototype.parsePrefix = function () {\n          if (this.next.type == exports.TokenType.Operator) {\n              var start = this.inputIndex;\n              var operator = this.next.strValue;\n              var result = void 0;\n              switch (operator) {\n                  case '+':\n                      this.advance();\n                      return this.parsePrefix();\n                  case '-':\n                      this.advance();\n                      result = this.parsePrefix();\n                      return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n                  case '!':\n                      this.advance();\n                      result = this.parsePrefix();\n                      return new PrefixNot(this.span(start), result);\n              }\n          }\n          return this.parseCallChain();\n      };\n      _ParseAST.prototype.parseCallChain = function () {\n          var result = this.parsePrimary();\n          while (true) {\n              if (this.optionalCharacter($PERIOD)) {\n                  result = this.parseAccessMemberOrMethodCall(result, false);\n              }\n              else if (this.optionalOperator('?.')) {\n                  result = this.parseAccessMemberOrMethodCall(result, true);\n              }\n              else if (this.optionalCharacter($LBRACKET)) {\n                  this.rbracketsExpected++;\n                  var key = this.parsePipe();\n                  this.rbracketsExpected--;\n                  this.expectCharacter($RBRACKET);\n                  if (this.optionalOperator('=')) {\n                      var value = this.parseConditional();\n                      result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                  }\n                  else {\n                      result = new KeyedRead(this.span(result.span.start), result, key);\n                  }\n              }\n              else if (this.optionalCharacter($LPAREN)) {\n                  this.rparensExpected++;\n                  var args = this.parseCallArguments();\n                  this.rparensExpected--;\n                  this.expectCharacter($RPAREN);\n                  result = new FunctionCall(this.span(result.span.start), result, args);\n              }\n              else {\n                  return result;\n              }\n          }\n      };\n      _ParseAST.prototype.parsePrimary = function () {\n          var start = this.inputIndex;\n          if (this.optionalCharacter($LPAREN)) {\n              this.rparensExpected++;\n              var result = this.parsePipe();\n              this.rparensExpected--;\n              this.expectCharacter($RPAREN);\n              return result;\n          }\n          else if (this.next.isKeywordNull()) {\n              this.advance();\n              return new LiteralPrimitive(this.span(start), null);\n          }\n          else if (this.next.isKeywordUndefined()) {\n              this.advance();\n              return new LiteralPrimitive(this.span(start), void 0);\n          }\n          else if (this.next.isKeywordTrue()) {\n              this.advance();\n              return new LiteralPrimitive(this.span(start), true);\n          }\n          else if (this.next.isKeywordFalse()) {\n              this.advance();\n              return new LiteralPrimitive(this.span(start), false);\n          }\n          else if (this.next.isKeywordThis()) {\n              this.advance();\n              return new ImplicitReceiver(this.span(start));\n          }\n          else if (this.optionalCharacter($LBRACKET)) {\n              this.rbracketsExpected++;\n              var elements = this.parseExpressionList($RBRACKET);\n              this.rbracketsExpected--;\n              this.expectCharacter($RBRACKET);\n              return new LiteralArray(this.span(start), elements);\n          }\n          else if (this.next.isCharacter($LBRACE)) {\n              return this.parseLiteralMap();\n          }\n          else if (this.next.isIdentifier()) {\n              return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n          }\n          else if (this.next.isNumber()) {\n              var value = this.next.toNumber();\n              this.advance();\n              return new LiteralPrimitive(this.span(start), value);\n          }\n          else if (this.next.isString()) {\n              var literalValue = this.next.toString();\n              this.advance();\n              return new LiteralPrimitive(this.span(start), literalValue);\n          }\n          else if (this.index >= this.tokens.length) {\n              this.error(\"Unexpected end of expression: \" + this.input);\n              return new EmptyExpr(this.span(start));\n          }\n          else {\n              this.error(\"Unexpected token \" + this.next);\n              return new EmptyExpr(this.span(start));\n          }\n      };\n      _ParseAST.prototype.parseExpressionList = function (terminator) {\n          var result = [];\n          if (!this.next.isCharacter(terminator)) {\n              do {\n                  result.push(this.parsePipe());\n              } while (this.optionalCharacter($COMMA));\n          }\n          return result;\n      };\n      _ParseAST.prototype.parseLiteralMap = function () {\n          var keys = [];\n          var values = [];\n          var start = this.inputIndex;\n          this.expectCharacter($LBRACE);\n          if (!this.optionalCharacter($RBRACE)) {\n              this.rbracesExpected++;\n              do {\n                  var key = this.expectIdentifierOrKeywordOrString();\n                  keys.push(key);\n                  this.expectCharacter($COLON);\n                  values.push(this.parsePipe());\n              } while (this.optionalCharacter($COMMA));\n              this.rbracesExpected--;\n              this.expectCharacter($RBRACE);\n          }\n          return new LiteralMap(this.span(start), keys, values);\n      };\n      _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\n          if (isSafe === void 0) { isSafe = false; }\n          var start = receiver.span.start;\n          var id = this.expectIdentifierOrKeyword();\n          if (this.optionalCharacter($LPAREN)) {\n              this.rparensExpected++;\n              var args = this.parseCallArguments();\n              this.expectCharacter($RPAREN);\n              this.rparensExpected--;\n              var span = this.span(start);\n              return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                  new MethodCall(span, receiver, id, args);\n          }\n          else {\n              if (isSafe) {\n                  if (this.optionalOperator('=')) {\n                      this.error('The \\'?.\\' operator cannot be used in the assignment');\n                      return new EmptyExpr(this.span(start));\n                  }\n                  else {\n                      return new SafePropertyRead(this.span(start), receiver, id);\n                  }\n              }\n              else {\n                  if (this.optionalOperator('=')) {\n                      if (!this.parseAction) {\n                          this.error('Bindings cannot contain assignments');\n                          return new EmptyExpr(this.span(start));\n                      }\n                      var value = this.parseConditional();\n                      return new PropertyWrite(this.span(start), receiver, id, value);\n                  }\n                  else {\n                      return new PropertyRead(this.span(start), receiver, id);\n                  }\n              }\n          }\n      };\n      _ParseAST.prototype.parseCallArguments = function () {\n          if (this.next.isCharacter($RPAREN))\n              return [];\n          var positionals = [];\n          do {\n              positionals.push(this.parsePipe());\n          } while (this.optionalCharacter($COMMA));\n          return positionals;\n      };\n      /**\n       * An identifier, a keyword, a string with an optional `-` inbetween.\n       */\n      _ParseAST.prototype.expectTemplateBindingKey = function () {\n          var result = '';\n          var operatorFound = false;\n          do {\n              result += this.expectIdentifierOrKeywordOrString();\n              operatorFound = this.optionalOperator('-');\n              if (operatorFound) {\n                  result += '-';\n              }\n          } while (operatorFound);\n          return result.toString();\n      };\n      _ParseAST.prototype.parseTemplateBindings = function () {\n          var bindings = [];\n          var prefix = null;\n          var warnings = [];\n          while (this.index < this.tokens.length) {\n              var start = this.inputIndex;\n              var keyIsVar = this.peekKeywordLet();\n              if (keyIsVar) {\n                  this.advance();\n              }\n              var key = this.expectTemplateBindingKey();\n              if (!keyIsVar) {\n                  if (prefix == null) {\n                      prefix = key;\n                  }\n                  else {\n                      key = prefix + key[0].toUpperCase() + key.substring(1);\n                  }\n              }\n              this.optionalCharacter($COLON);\n              var name_2 = null;\n              var expression = null;\n              if (keyIsVar) {\n                  if (this.optionalOperator('=')) {\n                      name_2 = this.expectTemplateBindingKey();\n                  }\n                  else {\n                      name_2 = '\\$implicit';\n                  }\n              }\n              else if (this.next !== EOF && !this.peekKeywordLet()) {\n                  var start_1 = this.inputIndex;\n                  var ast = this.parsePipe();\n                  var source = this.input.substring(start_1 - this.offset, this.inputIndex - this.offset);\n                  expression = new ASTWithSource(ast, source, this.location, this.errors);\n              }\n              bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name_2, expression));\n              if (!this.optionalCharacter($SEMICOLON)) {\n                  this.optionalCharacter($COMMA);\n              }\n          }\n          return new TemplateBindingParseResult(bindings, warnings, this.errors);\n      };\n      _ParseAST.prototype.error = function (message, index) {\n          if (index === void 0) { index = null; }\n          this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n          this.skip();\n      };\n      _ParseAST.prototype.locationText = function (index) {\n          if (index === void 0) { index = null; }\n          if (isBlank(index))\n              index = this.index;\n          return (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\n              \"at the end of the expression\";\n      };\n      // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n      // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n      // '}' and ']' as conditional recovery points if one of calling productions is expecting\n      // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n      // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n      // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n      // must be conditional as they must be skipped if none of the calling productions are not\n      // expecting the closing token else we will never make progress in the case of an\n      // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n      // parseChain() is always the root production and it expects a ';'.\n      // If a production expects one of these token it increments the corresponding nesting count,\n      // and then decrements it just prior to checking if the token is in the input.\n      _ParseAST.prototype.skip = function () {\n          var n = this.next;\n          while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n              (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n              (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n              (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n              if (this.next.isError()) {\n                  this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n              }\n              this.advance();\n              n = this.next;\n          }\n      };\n      return _ParseAST;\n  }());\n  var SimpleExpressionChecker = (function () {\n      function SimpleExpressionChecker() {\n          this.errors = [];\n      }\n      SimpleExpressionChecker.check = function (ast) {\n          var s = new SimpleExpressionChecker();\n          ast.visit(s);\n          return s.errors;\n      };\n      SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };\n      SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };\n      SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };\n      SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitAll = function (asts) {\n          var _this = this;\n          return asts.map(function (node) { return node.visit(_this); });\n      };\n      SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };\n      SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };\n      return SimpleExpressionChecker;\n  }());\n\n  var ParseLocation = (function () {\n      function ParseLocation(file, offset, line, col) {\n          this.file = file;\n          this.offset = offset;\n          this.line = line;\n          this.col = col;\n      }\n      ParseLocation.prototype.toString = function () {\n          return isPresent(this.offset) ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n      };\n      return ParseLocation;\n  }());\n  var ParseSourceFile = (function () {\n      function ParseSourceFile(content, url) {\n          this.content = content;\n          this.url = url;\n      }\n      return ParseSourceFile;\n  }());\n  var ParseSourceSpan = (function () {\n      function ParseSourceSpan(start, end, details) {\n          if (details === void 0) { details = null; }\n          this.start = start;\n          this.end = end;\n          this.details = details;\n      }\n      ParseSourceSpan.prototype.toString = function () {\n          return this.start.file.content.substring(this.start.offset, this.end.offset);\n      };\n      return ParseSourceSpan;\n  }());\n  exports.ParseErrorLevel;\n  (function (ParseErrorLevel) {\n      ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n      ParseErrorLevel[ParseErrorLevel[\"FATAL\"] = 1] = \"FATAL\";\n  })(exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));\n  var ParseError = (function () {\n      function ParseError(span, msg, level) {\n          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }\n          this.span = span;\n          this.msg = msg;\n          this.level = level;\n      }\n      ParseError.prototype.toString = function () {\n          var source = this.span.start.file.content;\n          var ctxStart = this.span.start.offset;\n          var contextStr = '';\n          var details = '';\n          if (isPresent(ctxStart)) {\n              if (ctxStart > source.length - 1) {\n                  ctxStart = source.length - 1;\n              }\n              var ctxEnd = ctxStart;\n              var ctxLen = 0;\n              var ctxLines = 0;\n              while (ctxLen < 100 && ctxStart > 0) {\n                  ctxStart--;\n                  ctxLen++;\n                  if (source[ctxStart] == '\\n') {\n                      if (++ctxLines == 3) {\n                          break;\n                      }\n                  }\n              }\n              ctxLen = 0;\n              ctxLines = 0;\n              while (ctxLen < 100 && ctxEnd < source.length - 1) {\n                  ctxEnd++;\n                  ctxLen++;\n                  if (source[ctxEnd] == '\\n') {\n                      if (++ctxLines == 3) {\n                          break;\n                      }\n                  }\n              }\n              var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' +\n                  source.substring(this.span.start.offset, ctxEnd + 1);\n              contextStr = \" (\\\"\" + context + \"\\\")\";\n          }\n          if (this.span.details) {\n              details = \", \" + this.span.details;\n          }\n          return \"\" + this.msg + contextStr + \": \" + this.span.start + details;\n      };\n      return ParseError;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var Text = (function () {\n      function Text(value, sourceSpan) {\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n      return Text;\n  }());\n  var Expansion = (function () {\n      function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {\n          this.switchValue = switchValue;\n          this.type = type;\n          this.cases = cases;\n          this.sourceSpan = sourceSpan;\n          this.switchValueSourceSpan = switchValueSourceSpan;\n      }\n      Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };\n      return Expansion;\n  }());\n  var ExpansionCase = (function () {\n      function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n          this.value = value;\n          this.expression = expression;\n          this.sourceSpan = sourceSpan;\n          this.valueSourceSpan = valueSourceSpan;\n          this.expSourceSpan = expSourceSpan;\n      }\n      ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };\n      return ExpansionCase;\n  }());\n  var Attribute$1 = (function () {\n      function Attribute(name, value, sourceSpan, valueSpan) {\n          this.name = name;\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n          this.valueSpan = valueSpan;\n      }\n      Attribute.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };\n      return Attribute;\n  }());\n  var Element = (function () {\n      function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {\n          this.name = name;\n          this.attrs = attrs;\n          this.children = children;\n          this.sourceSpan = sourceSpan;\n          this.startSourceSpan = startSourceSpan;\n          this.endSourceSpan = endSourceSpan;\n      }\n      Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };\n      return Element;\n  }());\n  var Comment = (function () {\n      function Comment(value, sourceSpan) {\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };\n      return Comment;\n  }());\n  function visitAll(visitor, nodes, context) {\n      if (context === void 0) { context = null; }\n      var result = [];\n      var visit = visitor.visit ?\n          function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n          function (ast) { return ast.visit(visitor, context); };\n      nodes.forEach(function (ast) {\n          var astResult = visit(ast);\n          if (astResult) {\n              result.push(astResult);\n          }\n      });\n      return result;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var TagContentType;\n  (function (TagContentType) {\n      TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n      TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n      TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n  })(TagContentType || (TagContentType = {}));\n  function splitNsName(elementName) {\n      if (elementName[0] != ':') {\n          return [null, elementName];\n      }\n      var colonIndex = elementName.indexOf(':', 1);\n      if (colonIndex == -1) {\n          throw new Error(\"Unsupported format \\\"\" + elementName + \"\\\" expecting \\\":namespace:name\\\"\");\n      }\n      return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n  }\n  function getNsPrefix(fullName) {\n      return fullName === null ? null : splitNsName(fullName)[0];\n  }\n  function mergeNsAndName(prefix, localName) {\n      return prefix ? \":\" + prefix + \":\" + localName : localName;\n  }\n  // see http://www.w3.org/TR/html51/syntax.html#named-character-references\n  // see https://html.spec.whatwg.org/multipage/entities.json\n  // This list is not exhaustive to keep the compiler footprint low.\n  // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.\n  var NAMED_ENTITIES = {\n      'Aacute': '\\u00C1',\n      'aacute': '\\u00E1',\n      'Acirc': '\\u00C2',\n      'acirc': '\\u00E2',\n      'acute': '\\u00B4',\n      'AElig': '\\u00C6',\n      'aelig': '\\u00E6',\n      'Agrave': '\\u00C0',\n      'agrave': '\\u00E0',\n      'alefsym': '\\u2135',\n      'Alpha': '\\u0391',\n      'alpha': '\\u03B1',\n      'amp': '&',\n      'and': '\\u2227',\n      'ang': '\\u2220',\n      'apos': '\\u0027',\n      'Aring': '\\u00C5',\n      'aring': '\\u00E5',\n      'asymp': '\\u2248',\n      'Atilde': '\\u00C3',\n      'atilde': '\\u00E3',\n      'Auml': '\\u00C4',\n      'auml': '\\u00E4',\n      'bdquo': '\\u201E',\n      'Beta': '\\u0392',\n      'beta': '\\u03B2',\n      'brvbar': '\\u00A6',\n      'bull': '\\u2022',\n      'cap': '\\u2229',\n      'Ccedil': '\\u00C7',\n      'ccedil': '\\u00E7',\n      'cedil': '\\u00B8',\n      'cent': '\\u00A2',\n      'Chi': '\\u03A7',\n      'chi': '\\u03C7',\n      'circ': '\\u02C6',\n      'clubs': '\\u2663',\n      'cong': '\\u2245',\n      'copy': '\\u00A9',\n      'crarr': '\\u21B5',\n      'cup': '\\u222A',\n      'curren': '\\u00A4',\n      'dagger': '\\u2020',\n      'Dagger': '\\u2021',\n      'darr': '\\u2193',\n      'dArr': '\\u21D3',\n      'deg': '\\u00B0',\n      'Delta': '\\u0394',\n      'delta': '\\u03B4',\n      'diams': '\\u2666',\n      'divide': '\\u00F7',\n      'Eacute': '\\u00C9',\n      'eacute': '\\u00E9',\n      'Ecirc': '\\u00CA',\n      'ecirc': '\\u00EA',\n      'Egrave': '\\u00C8',\n      'egrave': '\\u00E8',\n      'empty': '\\u2205',\n      'emsp': '\\u2003',\n      'ensp': '\\u2002',\n      'Epsilon': '\\u0395',\n      'epsilon': '\\u03B5',\n      'equiv': '\\u2261',\n      'Eta': '\\u0397',\n      'eta': '\\u03B7',\n      'ETH': '\\u00D0',\n      'eth': '\\u00F0',\n      'Euml': '\\u00CB',\n      'euml': '\\u00EB',\n      'euro': '\\u20AC',\n      'exist': '\\u2203',\n      'fnof': '\\u0192',\n      'forall': '\\u2200',\n      'frac12': '\\u00BD',\n      'frac14': '\\u00BC',\n      'frac34': '\\u00BE',\n      'frasl': '\\u2044',\n      'Gamma': '\\u0393',\n      'gamma': '\\u03B3',\n      'ge': '\\u2265',\n      'gt': '>',\n      'harr': '\\u2194',\n      'hArr': '\\u21D4',\n      'hearts': '\\u2665',\n      'hellip': '\\u2026',\n      'Iacute': '\\u00CD',\n      'iacute': '\\u00ED',\n      'Icirc': '\\u00CE',\n      'icirc': '\\u00EE',\n      'iexcl': '\\u00A1',\n      'Igrave': '\\u00CC',\n      'igrave': '\\u00EC',\n      'image': '\\u2111',\n      'infin': '\\u221E',\n      'int': '\\u222B',\n      'Iota': '\\u0399',\n      'iota': '\\u03B9',\n      'iquest': '\\u00BF',\n      'isin': '\\u2208',\n      'Iuml': '\\u00CF',\n      'iuml': '\\u00EF',\n      'Kappa': '\\u039A',\n      'kappa': '\\u03BA',\n      'Lambda': '\\u039B',\n      'lambda': '\\u03BB',\n      'lang': '\\u27E8',\n      'laquo': '\\u00AB',\n      'larr': '\\u2190',\n      'lArr': '\\u21D0',\n      'lceil': '\\u2308',\n      'ldquo': '\\u201C',\n      'le': '\\u2264',\n      'lfloor': '\\u230A',\n      'lowast': '\\u2217',\n      'loz': '\\u25CA',\n      'lrm': '\\u200E',\n      'lsaquo': '\\u2039',\n      'lsquo': '\\u2018',\n      'lt': '<',\n      'macr': '\\u00AF',\n      'mdash': '\\u2014',\n      'micro': '\\u00B5',\n      'middot': '\\u00B7',\n      'minus': '\\u2212',\n      'Mu': '\\u039C',\n      'mu': '\\u03BC',\n      'nabla': '\\u2207',\n      'nbsp': '\\u00A0',\n      'ndash': '\\u2013',\n      'ne': '\\u2260',\n      'ni': '\\u220B',\n      'not': '\\u00AC',\n      'notin': '\\u2209',\n      'nsub': '\\u2284',\n      'Ntilde': '\\u00D1',\n      'ntilde': '\\u00F1',\n      'Nu': '\\u039D',\n      'nu': '\\u03BD',\n      'Oacute': '\\u00D3',\n      'oacute': '\\u00F3',\n      'Ocirc': '\\u00D4',\n      'ocirc': '\\u00F4',\n      'OElig': '\\u0152',\n      'oelig': '\\u0153',\n      'Ograve': '\\u00D2',\n      'ograve': '\\u00F2',\n      'oline': '\\u203E',\n      'Omega': '\\u03A9',\n      'omega': '\\u03C9',\n      'Omicron': '\\u039F',\n      'omicron': '\\u03BF',\n      'oplus': '\\u2295',\n      'or': '\\u2228',\n      'ordf': '\\u00AA',\n      'ordm': '\\u00BA',\n      'Oslash': '\\u00D8',\n      'oslash': '\\u00F8',\n      'Otilde': '\\u00D5',\n      'otilde': '\\u00F5',\n      'otimes': '\\u2297',\n      'Ouml': '\\u00D6',\n      'ouml': '\\u00F6',\n      'para': '\\u00B6',\n      'permil': '\\u2030',\n      'perp': '\\u22A5',\n      'Phi': '\\u03A6',\n      'phi': '\\u03C6',\n      'Pi': '\\u03A0',\n      'pi': '\\u03C0',\n      'piv': '\\u03D6',\n      'plusmn': '\\u00B1',\n      'pound': '\\u00A3',\n      'prime': '\\u2032',\n      'Prime': '\\u2033',\n      'prod': '\\u220F',\n      'prop': '\\u221D',\n      'Psi': '\\u03A8',\n      'psi': '\\u03C8',\n      'quot': '\\u0022',\n      'radic': '\\u221A',\n      'rang': '\\u27E9',\n      'raquo': '\\u00BB',\n      'rarr': '\\u2192',\n      'rArr': '\\u21D2',\n      'rceil': '\\u2309',\n      'rdquo': '\\u201D',\n      'real': '\\u211C',\n      'reg': '\\u00AE',\n      'rfloor': '\\u230B',\n      'Rho': '\\u03A1',\n      'rho': '\\u03C1',\n      'rlm': '\\u200F',\n      'rsaquo': '\\u203A',\n      'rsquo': '\\u2019',\n      'sbquo': '\\u201A',\n      'Scaron': '\\u0160',\n      'scaron': '\\u0161',\n      'sdot': '\\u22C5',\n      'sect': '\\u00A7',\n      'shy': '\\u00AD',\n      'Sigma': '\\u03A3',\n      'sigma': '\\u03C3',\n      'sigmaf': '\\u03C2',\n      'sim': '\\u223C',\n      'spades': '\\u2660',\n      'sub': '\\u2282',\n      'sube': '\\u2286',\n      'sum': '\\u2211',\n      'sup': '\\u2283',\n      'sup1': '\\u00B9',\n      'sup2': '\\u00B2',\n      'sup3': '\\u00B3',\n      'supe': '\\u2287',\n      'szlig': '\\u00DF',\n      'Tau': '\\u03A4',\n      'tau': '\\u03C4',\n      'there4': '\\u2234',\n      'Theta': '\\u0398',\n      'theta': '\\u03B8',\n      'thetasym': '\\u03D1',\n      'thinsp': '\\u2009',\n      'THORN': '\\u00DE',\n      'thorn': '\\u00FE',\n      'tilde': '\\u02DC',\n      'times': '\\u00D7',\n      'trade': '\\u2122',\n      'Uacute': '\\u00DA',\n      'uacute': '\\u00FA',\n      'uarr': '\\u2191',\n      'uArr': '\\u21D1',\n      'Ucirc': '\\u00DB',\n      'ucirc': '\\u00FB',\n      'Ugrave': '\\u00D9',\n      'ugrave': '\\u00F9',\n      'uml': '\\u00A8',\n      'upsih': '\\u03D2',\n      'Upsilon': '\\u03A5',\n      'upsilon': '\\u03C5',\n      'Uuml': '\\u00DC',\n      'uuml': '\\u00FC',\n      'weierp': '\\u2118',\n      'Xi': '\\u039E',\n      'xi': '\\u03BE',\n      'Yacute': '\\u00DD',\n      'yacute': '\\u00FD',\n      'yen': '\\u00A5',\n      'yuml': '\\u00FF',\n      'Yuml': '\\u0178',\n      'Zeta': '\\u0396',\n      'zeta': '\\u03B6',\n      'zwj': '\\u200D',\n      'zwnj': '\\u200C',\n  };\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$3 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var TokenType$1;\n  (function (TokenType) {\n      TokenType[TokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\n      TokenType[TokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\n      TokenType[TokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\n      TokenType[TokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\n      TokenType[TokenType[\"TEXT\"] = 4] = \"TEXT\";\n      TokenType[TokenType[\"ESCAPABLE_RAW_TEXT\"] = 5] = \"ESCAPABLE_RAW_TEXT\";\n      TokenType[TokenType[\"RAW_TEXT\"] = 6] = \"RAW_TEXT\";\n      TokenType[TokenType[\"COMMENT_START\"] = 7] = \"COMMENT_START\";\n      TokenType[TokenType[\"COMMENT_END\"] = 8] = \"COMMENT_END\";\n      TokenType[TokenType[\"CDATA_START\"] = 9] = \"CDATA_START\";\n      TokenType[TokenType[\"CDATA_END\"] = 10] = \"CDATA_END\";\n      TokenType[TokenType[\"ATTR_NAME\"] = 11] = \"ATTR_NAME\";\n      TokenType[TokenType[\"ATTR_VALUE\"] = 12] = \"ATTR_VALUE\";\n      TokenType[TokenType[\"DOC_TYPE\"] = 13] = \"DOC_TYPE\";\n      TokenType[TokenType[\"EXPANSION_FORM_START\"] = 14] = \"EXPANSION_FORM_START\";\n      TokenType[TokenType[\"EXPANSION_CASE_VALUE\"] = 15] = \"EXPANSION_CASE_VALUE\";\n      TokenType[TokenType[\"EXPANSION_CASE_EXP_START\"] = 16] = \"EXPANSION_CASE_EXP_START\";\n      TokenType[TokenType[\"EXPANSION_CASE_EXP_END\"] = 17] = \"EXPANSION_CASE_EXP_END\";\n      TokenType[TokenType[\"EXPANSION_FORM_END\"] = 18] = \"EXPANSION_FORM_END\";\n      TokenType[TokenType[\"EOF\"] = 19] = \"EOF\";\n  })(TokenType$1 || (TokenType$1 = {}));\n  var Token$1 = (function () {\n      function Token(type, parts, sourceSpan) {\n          this.type = type;\n          this.parts = parts;\n          this.sourceSpan = sourceSpan;\n      }\n      return Token;\n  }());\n  var TokenError = (function (_super) {\n      __extends$3(TokenError, _super);\n      function TokenError(errorMsg, tokenType, span) {\n          _super.call(this, span, errorMsg);\n          this.tokenType = tokenType;\n      }\n      return TokenError;\n  }(ParseError));\n  var TokenizeResult = (function () {\n      function TokenizeResult(tokens, errors) {\n          this.tokens = tokens;\n          this.errors = errors;\n      }\n      return TokenizeResult;\n  }());\n  function tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {\n      if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }\n      if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n      return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)\n          .tokenize();\n  }\n  var _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n  function _unexpectedCharacterErrorMsg(charCode) {\n      var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n      return \"Unexpected character \\\"\" + char + \"\\\"\";\n  }\n  function _unknownEntityErrorMsg(entitySrc) {\n      return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n  }\n  var _ControlFlowError = (function () {\n      function _ControlFlowError(error) {\n          this.error = error;\n      }\n      return _ControlFlowError;\n  }());\n  // See http://www.w3.org/TR/html51/syntax.html#writing\n  var _Tokenizer = (function () {\n      /**\n       * @param _file The html source\n       * @param _getTagDefinition\n       * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n       * @param _interpolationConfig\n       */\n      function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {\n          if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          this._file = _file;\n          this._getTagDefinition = _getTagDefinition;\n          this._tokenizeIcu = _tokenizeIcu;\n          this._interpolationConfig = _interpolationConfig;\n          // Note: this is always lowercase!\n          this._peek = -1;\n          this._nextPeek = -1;\n          this._index = -1;\n          this._line = 0;\n          this._column = -1;\n          this._expansionCaseStack = [];\n          this._inInterpolation = false;\n          this.tokens = [];\n          this.errors = [];\n          this._input = _file.content;\n          this._length = _file.content.length;\n          this._advance();\n      }\n      _Tokenizer.prototype._processCarriageReturns = function (content) {\n          // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n          // In order to keep the original position in the source, we can not\n          // pre-process it.\n          // Instead CRs are processed right before instantiating the tokens.\n          return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n      };\n      _Tokenizer.prototype.tokenize = function () {\n          while (this._peek !== $EOF) {\n              var start = this._getLocation();\n              try {\n                  if (this._attemptCharCode($LT)) {\n                      if (this._attemptCharCode($BANG)) {\n                          if (this._attemptCharCode($LBRACKET)) {\n                              this._consumeCdata(start);\n                          }\n                          else if (this._attemptCharCode($MINUS)) {\n                              this._consumeComment(start);\n                          }\n                          else {\n                              this._consumeDocType(start);\n                          }\n                      }\n                      else if (this._attemptCharCode($SLASH)) {\n                          this._consumeTagClose(start);\n                      }\n                      else {\n                          this._consumeTagOpen(start);\n                      }\n                  }\n                  else if (!this._tokenizeIcu || !this._tokenizeExpansionForm()) {\n                      this._consumeText();\n                  }\n              }\n              catch (e) {\n                  if (e instanceof _ControlFlowError) {\n                      this.errors.push(e.error);\n                  }\n                  else {\n                      throw e;\n                  }\n              }\n          }\n          this._beginToken(TokenType$1.EOF);\n          this._endToken([]);\n          return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n      };\n      /**\n       * @returns {boolean} whether an ICU token has been created\n       * @internal\n       */\n      _Tokenizer.prototype._tokenizeExpansionForm = function () {\n          if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n              this._consumeExpansionFormStart();\n              return true;\n          }\n          if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n              this._consumeExpansionCaseStart();\n              return true;\n          }\n          if (this._peek === $RBRACE) {\n              if (this._isInExpansionCase()) {\n                  this._consumeExpansionCaseEnd();\n                  return true;\n              }\n              if (this._isInExpansionForm()) {\n                  this._consumeExpansionFormEnd();\n                  return true;\n              }\n          }\n          return false;\n      };\n      _Tokenizer.prototype._getLocation = function () {\n          return new ParseLocation(this._file, this._index, this._line, this._column);\n      };\n      _Tokenizer.prototype._getSpan = function (start, end) {\n          if (start === void 0) { start = this._getLocation(); }\n          if (end === void 0) { end = this._getLocation(); }\n          return new ParseSourceSpan(start, end);\n      };\n      _Tokenizer.prototype._beginToken = function (type, start) {\n          if (start === void 0) { start = this._getLocation(); }\n          this._currentTokenStart = start;\n          this._currentTokenType = type;\n      };\n      _Tokenizer.prototype._endToken = function (parts, end) {\n          if (end === void 0) { end = this._getLocation(); }\n          var token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n          this.tokens.push(token);\n          this._currentTokenStart = null;\n          this._currentTokenType = null;\n          return token;\n      };\n      _Tokenizer.prototype._createError = function (msg, span) {\n          if (this._isInExpansionForm()) {\n              msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n          }\n          var error = new TokenError(msg, this._currentTokenType, span);\n          this._currentTokenStart = null;\n          this._currentTokenType = null;\n          return new _ControlFlowError(error);\n      };\n      _Tokenizer.prototype._advance = function () {\n          if (this._index >= this._length) {\n              throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());\n          }\n          if (this._peek === $LF) {\n              this._line++;\n              this._column = 0;\n          }\n          else if (this._peek !== $LF && this._peek !== $CR) {\n              this._column++;\n          }\n          this._index++;\n          this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);\n          this._nextPeek =\n              this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);\n      };\n      _Tokenizer.prototype._attemptCharCode = function (charCode) {\n          if (this._peek === charCode) {\n              this._advance();\n              return true;\n          }\n          return false;\n      };\n      _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n          if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n              this._advance();\n              return true;\n          }\n          return false;\n      };\n      _Tokenizer.prototype._requireCharCode = function (charCode) {\n          var location = this._getLocation();\n          if (!this._attemptCharCode(charCode)) {\n              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n          }\n      };\n      _Tokenizer.prototype._attemptStr = function (chars) {\n          var len = chars.length;\n          if (this._index + len > this._length) {\n              return false;\n          }\n          var initialPosition = this._savePosition();\n          for (var i = 0; i < len; i++) {\n              if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                  // If attempting to parse the string fails, we want to reset the parser\n                  // to where it was before the attempt\n                  this._restorePosition(initialPosition);\n                  return false;\n              }\n          }\n          return true;\n      };\n      _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n          for (var i = 0; i < chars.length; i++) {\n              if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                  return false;\n              }\n          }\n          return true;\n      };\n      _Tokenizer.prototype._requireStr = function (chars) {\n          var location = this._getLocation();\n          if (!this._attemptStr(chars)) {\n              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n          }\n      };\n      _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n          while (!predicate(this._peek)) {\n              this._advance();\n          }\n      };\n      _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n          var start = this._getLocation();\n          this._attemptCharCodeUntilFn(predicate);\n          if (this._index - start.offset < len) {\n              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n          }\n      };\n      _Tokenizer.prototype._attemptUntilChar = function (char) {\n          while (this._peek !== char) {\n              this._advance();\n          }\n      };\n      _Tokenizer.prototype._readChar = function (decodeEntities) {\n          if (decodeEntities && this._peek === $AMPERSAND) {\n              return this._decodeEntity();\n          }\n          else {\n              var index = this._index;\n              this._advance();\n              return this._input[index];\n          }\n      };\n      _Tokenizer.prototype._decodeEntity = function () {\n          var start = this._getLocation();\n          this._advance();\n          if (this._attemptCharCode($HASH)) {\n              var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n              var numberStart = this._getLocation().offset;\n              this._attemptCharCodeUntilFn(isDigitEntityEnd);\n              if (this._peek != $SEMICOLON) {\n                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n              }\n              this._advance();\n              var strNum = this._input.substring(numberStart, this._index - 1);\n              try {\n                  var charCode = parseInt(strNum, isHex ? 16 : 10);\n                  return String.fromCharCode(charCode);\n              }\n              catch (e) {\n                  var entity = this._input.substring(start.offset + 1, this._index - 1);\n                  throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n              }\n          }\n          else {\n              var startPosition = this._savePosition();\n              this._attemptCharCodeUntilFn(isNamedEntityEnd);\n              if (this._peek != $SEMICOLON) {\n                  this._restorePosition(startPosition);\n                  return '&';\n              }\n              this._advance();\n              var name_1 = this._input.substring(start.offset + 1, this._index - 1);\n              var char = NAMED_ENTITIES[name_1];\n              if (!char) {\n                  throw this._createError(_unknownEntityErrorMsg(name_1), this._getSpan(start));\n              }\n              return char;\n          }\n      };\n      _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {\n          var tagCloseStart;\n          var textStart = this._getLocation();\n          this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);\n          var parts = [];\n          while (true) {\n              tagCloseStart = this._getLocation();\n              if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n                  break;\n              }\n              if (this._index > tagCloseStart.offset) {\n                  // add the characters consumed by the previous if statement to the output\n                  parts.push(this._input.substring(tagCloseStart.offset, this._index));\n              }\n              while (this._peek !== firstCharOfEnd) {\n                  parts.push(this._readChar(decodeEntities));\n              }\n          }\n          return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n      };\n      _Tokenizer.prototype._consumeComment = function (start) {\n          var _this = this;\n          this._beginToken(TokenType$1.COMMENT_START, start);\n          this._requireCharCode($MINUS);\n          this._endToken([]);\n          var textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });\n          this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);\n          this._endToken([]);\n      };\n      _Tokenizer.prototype._consumeCdata = function (start) {\n          var _this = this;\n          this._beginToken(TokenType$1.CDATA_START, start);\n          this._requireStr('CDATA[');\n          this._endToken([]);\n          var textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });\n          this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);\n          this._endToken([]);\n      };\n      _Tokenizer.prototype._consumeDocType = function (start) {\n          this._beginToken(TokenType$1.DOC_TYPE, start);\n          this._attemptUntilChar($GT);\n          this._advance();\n          this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n      };\n      _Tokenizer.prototype._consumePrefixAndName = function () {\n          var nameOrPrefixStart = this._index;\n          var prefix = null;\n          while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {\n              this._advance();\n          }\n          var nameStart;\n          if (this._peek === $COLON) {\n              this._advance();\n              prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n              nameStart = this._index;\n          }\n          else {\n              nameStart = nameOrPrefixStart;\n          }\n          this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n          var name = this._input.substring(nameStart, this._index);\n          return [prefix, name];\n      };\n      _Tokenizer.prototype._consumeTagOpen = function (start) {\n          var savedPos = this._savePosition();\n          var tagName;\n          var lowercaseTagName;\n          try {\n              if (!isAsciiLetter(this._peek)) {\n                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n              }\n              var nameStart = this._index;\n              this._consumeTagOpenStart(start);\n              tagName = this._input.substring(nameStart, this._index);\n              lowercaseTagName = tagName.toLowerCase();\n              this._attemptCharCodeUntilFn(isNotWhitespace);\n              while (this._peek !== $SLASH && this._peek !== $GT) {\n                  this._consumeAttributeName();\n                  this._attemptCharCodeUntilFn(isNotWhitespace);\n                  if (this._attemptCharCode($EQ)) {\n                      this._attemptCharCodeUntilFn(isNotWhitespace);\n                      this._consumeAttributeValue();\n                  }\n                  this._attemptCharCodeUntilFn(isNotWhitespace);\n              }\n              this._consumeTagOpenEnd();\n          }\n          catch (e) {\n              if (e instanceof _ControlFlowError) {\n                  // When the start tag is invalid, assume we want a \"<\"\n                  this._restorePosition(savedPos);\n                  // Back to back text tokens are merged at the end\n                  this._beginToken(TokenType$1.TEXT, start);\n                  this._endToken(['<']);\n                  return;\n              }\n              throw e;\n          }\n          var contentTokenType = this._getTagDefinition(tagName).contentType;\n          if (contentTokenType === TagContentType.RAW_TEXT) {\n              this._consumeRawTextWithTagClose(lowercaseTagName, false);\n          }\n          else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n              this._consumeRawTextWithTagClose(lowercaseTagName, true);\n          }\n      };\n      _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {\n          var _this = this;\n          var textToken = this._consumeRawText(decodeEntities, $LT, function () {\n              if (!_this._attemptCharCode($SLASH))\n                  return false;\n              _this._attemptCharCodeUntilFn(isNotWhitespace);\n              if (!_this._attemptStrCaseInsensitive(lowercaseTagName))\n                  return false;\n              _this._attemptCharCodeUntilFn(isNotWhitespace);\n              return _this._attemptCharCode($GT);\n          });\n          this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);\n          this._endToken([null, lowercaseTagName]);\n      };\n      _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n          this._beginToken(TokenType$1.TAG_OPEN_START, start);\n          var parts = this._consumePrefixAndName();\n          this._endToken(parts);\n      };\n      _Tokenizer.prototype._consumeAttributeName = function () {\n          this._beginToken(TokenType$1.ATTR_NAME);\n          var prefixAndName = this._consumePrefixAndName();\n          this._endToken(prefixAndName);\n      };\n      _Tokenizer.prototype._consumeAttributeValue = function () {\n          this._beginToken(TokenType$1.ATTR_VALUE);\n          var value;\n          if (this._peek === $SQ || this._peek === $DQ) {\n              var quoteChar = this._peek;\n              this._advance();\n              var parts = [];\n              while (this._peek !== quoteChar) {\n                  parts.push(this._readChar(true));\n              }\n              value = parts.join('');\n              this._advance();\n          }\n          else {\n              var valueStart = this._index;\n              this._requireCharCodeUntilFn(isNameEnd, 1);\n              value = this._input.substring(valueStart, this._index);\n          }\n          this._endToken([this._processCarriageReturns(value)]);\n      };\n      _Tokenizer.prototype._consumeTagOpenEnd = function () {\n          var tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;\n          this._beginToken(tokenType);\n          this._requireCharCode($GT);\n          this._endToken([]);\n      };\n      _Tokenizer.prototype._consumeTagClose = function (start) {\n          this._beginToken(TokenType$1.TAG_CLOSE, start);\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          var prefixAndName = this._consumePrefixAndName();\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._requireCharCode($GT);\n          this._endToken(prefixAndName);\n      };\n      _Tokenizer.prototype._consumeExpansionFormStart = function () {\n          this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());\n          this._requireCharCode($LBRACE);\n          this._endToken([]);\n          this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);\n          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n          var condition = this._readUntil($COMMA);\n          this._endToken([condition], this._getLocation());\n          this._requireCharCode($COMMA);\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n          var type = this._readUntil($COMMA);\n          this._endToken([type], this._getLocation());\n          this._requireCharCode($COMMA);\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n      };\n      _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n          this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());\n          var value = this._readUntil($LBRACE).trim();\n          this._endToken([value], this._getLocation());\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());\n          this._requireCharCode($LBRACE);\n          this._endToken([], this._getLocation());\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);\n      };\n      _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());\n          this._requireCharCode($RBRACE);\n          this._endToken([], this._getLocation());\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._expansionCaseStack.pop();\n      };\n      _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n          this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());\n          this._requireCharCode($RBRACE);\n          this._endToken([]);\n          this._expansionCaseStack.pop();\n      };\n      _Tokenizer.prototype._consumeText = function () {\n          var start = this._getLocation();\n          this._beginToken(TokenType$1.TEXT, start);\n          var parts = [];\n          do {\n              if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                  parts.push(this._interpolationConfig.start);\n                  this._inInterpolation = true;\n              }\n              else if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.end) &&\n                  this._inInterpolation) {\n                  parts.push(this._interpolationConfig.end);\n                  this._inInterpolation = false;\n              }\n              else {\n                  parts.push(this._readChar(true));\n              }\n          } while (!this._isTextEnd());\n          this._endToken([this._processCarriageReturns(parts.join(''))]);\n      };\n      _Tokenizer.prototype._isTextEnd = function () {\n          if (this._peek === $LT || this._peek === $EOF) {\n              return true;\n          }\n          if (this._tokenizeIcu && !this._inInterpolation) {\n              if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n                  // start of an expansion form\n                  return true;\n              }\n              if (this._peek === $RBRACE && this._isInExpansionCase()) {\n                  // end of and expansion case\n                  return true;\n              }\n          }\n          return false;\n      };\n      _Tokenizer.prototype._savePosition = function () {\n          return [this._peek, this._index, this._column, this._line, this.tokens.length];\n      };\n      _Tokenizer.prototype._readUntil = function (char) {\n          var start = this._index;\n          this._attemptUntilChar(char);\n          return this._input.substring(start, this._index);\n      };\n      _Tokenizer.prototype._restorePosition = function (position) {\n          this._peek = position[0];\n          this._index = position[1];\n          this._column = position[2];\n          this._line = position[3];\n          var nbTokens = position[4];\n          if (nbTokens < this.tokens.length) {\n              // remove any extra tokens\n              this.tokens = this.tokens.slice(0, nbTokens);\n          }\n      };\n      _Tokenizer.prototype._isInExpansionCase = function () {\n          return this._expansionCaseStack.length > 0 &&\n              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                  TokenType$1.EXPANSION_CASE_EXP_START;\n      };\n      _Tokenizer.prototype._isInExpansionForm = function () {\n          return this._expansionCaseStack.length > 0 &&\n              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                  TokenType$1.EXPANSION_FORM_START;\n      };\n      return _Tokenizer;\n  }());\n  function isNotWhitespace(code) {\n      return !isWhitespace(code) || code === $EOF;\n  }\n  function isNameEnd(code) {\n      return isWhitespace(code) || code === $GT || code === $SLASH ||\n          code === $SQ || code === $DQ || code === $EQ;\n  }\n  function isPrefixEnd(code) {\n      return (code < $a || $z < code) && (code < $A || $Z < code) &&\n          (code < $0 || code > $9);\n  }\n  function isDigitEntityEnd(code) {\n      return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n  }\n  function isNamedEntityEnd(code) {\n      return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n  }\n  function isExpansionFormStart(input, offset, interpolationConfig) {\n      var isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n      return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;\n  }\n  function isExpansionCaseStart(peek) {\n      return peek === $EQ || isAsciiLetter(peek);\n  }\n  function compareCharCodeCaseInsensitive(code1, code2) {\n      return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n  }\n  function toUpperCaseCharCode(code) {\n      return code >= $a && code <= $z ? code - $a + $A : code;\n  }\n  function mergeTextTokens(srcTokens) {\n      var dstTokens = [];\n      var lastDstToken;\n      for (var i = 0; i < srcTokens.length; i++) {\n          var token = srcTokens[i];\n          if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {\n              lastDstToken.parts[0] += token.parts[0];\n              lastDstToken.sourceSpan.end = token.sourceSpan.end;\n          }\n          else {\n              lastDstToken = token;\n              dstTokens.push(lastDstToken);\n          }\n      }\n      return dstTokens;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$2 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var TreeError = (function (_super) {\n      __extends$2(TreeError, _super);\n      function TreeError(elementName, span, msg) {\n          _super.call(this, span, msg);\n          this.elementName = elementName;\n      }\n      TreeError.create = function (elementName, span, msg) {\n          return new TreeError(elementName, span, msg);\n      };\n      return TreeError;\n  }(ParseError));\n  var ParseTreeResult = (function () {\n      function ParseTreeResult(rootNodes, errors) {\n          this.rootNodes = rootNodes;\n          this.errors = errors;\n      }\n      return ParseTreeResult;\n  }());\n  var Parser$1 = (function () {\n      function Parser(getTagDefinition) {\n          this.getTagDefinition = getTagDefinition;\n      }\n      Parser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n          if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          var tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n          var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n          return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));\n      };\n      return Parser;\n  }());\n  var _TreeBuilder = (function () {\n      function _TreeBuilder(tokens, getTagDefinition) {\n          this.tokens = tokens;\n          this.getTagDefinition = getTagDefinition;\n          this._index = -1;\n          this._rootNodes = [];\n          this._errors = [];\n          this._elementStack = [];\n          this._advance();\n      }\n      _TreeBuilder.prototype.build = function () {\n          while (this._peek.type !== TokenType$1.EOF) {\n              if (this._peek.type === TokenType$1.TAG_OPEN_START) {\n                  this._consumeStartTag(this._advance());\n              }\n              else if (this._peek.type === TokenType$1.TAG_CLOSE) {\n                  this._consumeEndTag(this._advance());\n              }\n              else if (this._peek.type === TokenType$1.CDATA_START) {\n                  this._closeVoidElement();\n                  this._consumeCdata(this._advance());\n              }\n              else if (this._peek.type === TokenType$1.COMMENT_START) {\n                  this._closeVoidElement();\n                  this._consumeComment(this._advance());\n              }\n              else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||\n                  this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {\n                  this._closeVoidElement();\n                  this._consumeText(this._advance());\n              }\n              else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {\n                  this._consumeExpansion(this._advance());\n              }\n              else {\n                  // Skip all other tokens...\n                  this._advance();\n              }\n          }\n          return new ParseTreeResult(this._rootNodes, this._errors);\n      };\n      _TreeBuilder.prototype._advance = function () {\n          var prev = this._peek;\n          if (this._index < this.tokens.length - 1) {\n              // Note: there is always an EOF token at the end\n              this._index++;\n          }\n          this._peek = this.tokens[this._index];\n          return prev;\n      };\n      _TreeBuilder.prototype._advanceIf = function (type) {\n          if (this._peek.type === type) {\n              return this._advance();\n          }\n          return null;\n      };\n      _TreeBuilder.prototype._consumeCdata = function (startToken) {\n          this._consumeText(this._advance());\n          this._advanceIf(TokenType$1.CDATA_END);\n      };\n      _TreeBuilder.prototype._consumeComment = function (token) {\n          var text = this._advanceIf(TokenType$1.RAW_TEXT);\n          this._advanceIf(TokenType$1.COMMENT_END);\n          var value = isPresent(text) ? text.parts[0].trim() : null;\n          this._addToParent(new Comment(value, token.sourceSpan));\n      };\n      _TreeBuilder.prototype._consumeExpansion = function (token) {\n          var switchValue = this._advance();\n          var type = this._advance();\n          var cases = [];\n          // read =\n          while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {\n              var expCase = this._parseExpansionCase();\n              if (!expCase)\n                  return; // error\n              cases.push(expCase);\n          }\n          // read the final }\n          if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {\n              this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n              return;\n          }\n          var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n          this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n          this._advance();\n      };\n      _TreeBuilder.prototype._parseExpansionCase = function () {\n          var value = this._advance();\n          // read {\n          if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {\n              this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n              return null;\n          }\n          // read until }\n          var start = this._advance();\n          var exp = this._collectExpansionExpTokens(start);\n          if (!exp)\n              return null;\n          var end = this._advance();\n          exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));\n          // parse everything in between { and }\n          var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n          if (parsedExp.errors.length > 0) {\n              this._errors = this._errors.concat(parsedExp.errors);\n              return null;\n          }\n          var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n          var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n          return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n      };\n      _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {\n          var exp = [];\n          var expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];\n          while (true) {\n              if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||\n                  this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {\n                  expansionFormStack.push(this._peek.type);\n              }\n              if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {\n                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {\n                      expansionFormStack.pop();\n                      if (expansionFormStack.length == 0)\n                          return exp;\n                  }\n                  else {\n                      this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                      return null;\n                  }\n              }\n              if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {\n                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {\n                      expansionFormStack.pop();\n                  }\n                  else {\n                      this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                      return null;\n                  }\n              }\n              if (this._peek.type === TokenType$1.EOF) {\n                  this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                  return null;\n              }\n              exp.push(this._advance());\n          }\n      };\n      _TreeBuilder.prototype._consumeText = function (token) {\n          var text = token.parts[0];\n          if (text.length > 0 && text[0] == '\\n') {\n              var parent_1 = this._getParentElement();\n              if (isPresent(parent_1) && parent_1.children.length == 0 &&\n                  this.getTagDefinition(parent_1.name).ignoreFirstLf) {\n                  text = text.substring(1);\n              }\n          }\n          if (text.length > 0) {\n              this._addToParent(new Text(text, token.sourceSpan));\n          }\n      };\n      _TreeBuilder.prototype._closeVoidElement = function () {\n          if (this._elementStack.length > 0) {\n              var el = this._elementStack[this._elementStack.length - 1];\n              if (this.getTagDefinition(el.name).isVoid) {\n                  this._elementStack.pop();\n              }\n          }\n      };\n      _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\n          var prefix = startTagToken.parts[0];\n          var name = startTagToken.parts[1];\n          var attrs = [];\n          while (this._peek.type === TokenType$1.ATTR_NAME) {\n              attrs.push(this._consumeAttr(this._advance()));\n          }\n          var fullName = this._getElementFullName(prefix, name, this._getParentElement());\n          var selfClosing = false;\n          // Note: There could have been a tokenizer error\n          // so that we don't get a token for the end tag...\n          if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {\n              this._advance();\n              selfClosing = true;\n              var tagDef = this.getTagDefinition(fullName);\n              if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                  this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\n              }\n          }\n          else if (this._peek.type === TokenType$1.TAG_OPEN_END) {\n              this._advance();\n              selfClosing = false;\n          }\n          var end = this._peek.sourceSpan.start;\n          var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n          var el = new Element(fullName, attrs, [], span, span, null);\n          this._pushElement(el);\n          if (selfClosing) {\n              this._popElement(fullName);\n              el.endSourceSpan = span;\n          }\n      };\n      _TreeBuilder.prototype._pushElement = function (el) {\n          if (this._elementStack.length > 0) {\n              var parentEl = this._elementStack[this._elementStack.length - 1];\n              if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n                  this._elementStack.pop();\n              }\n          }\n          var tagDef = this.getTagDefinition(el.name);\n          var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;\n          if (isPresent(parent) && tagDef.requireExtraParent(parent.name)) {\n              var newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n              this._insertBeforeContainer(parent, container, newParent);\n          }\n          this._addToParent(el);\n          this._elementStack.push(el);\n      };\n      _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\n          var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n          if (this._getParentElement()) {\n              this._getParentElement().endSourceSpan = endTagToken.sourceSpan;\n          }\n          if (this.getTagDefinition(fullName).isVoid) {\n              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n          }\n          else if (!this._popElement(fullName)) {\n              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Unexpected closing tag \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n          }\n      };\n      _TreeBuilder.prototype._popElement = function (fullName) {\n          for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n              var el = this._elementStack[stackIndex];\n              if (el.name == fullName) {\n                  this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                  return true;\n              }\n              if (!this.getTagDefinition(el.name).closedByParent) {\n                  return false;\n              }\n          }\n          return false;\n      };\n      _TreeBuilder.prototype._consumeAttr = function (attrName) {\n          var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n          var end = attrName.sourceSpan.end;\n          var value = '';\n          var valueSpan;\n          if (this._peek.type === TokenType$1.ATTR_VALUE) {\n              var valueToken = this._advance();\n              value = valueToken.parts[0];\n              end = valueToken.sourceSpan.end;\n              valueSpan = valueToken.sourceSpan;\n          }\n          return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n      };\n      _TreeBuilder.prototype._getParentElement = function () {\n          return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n      };\n      /**\n       * Returns the parent in the DOM and the container.\n       *\n       * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n       */\n      _TreeBuilder.prototype._getParentElementSkippingContainers = function () {\n          var container = null;\n          for (var i = this._elementStack.length - 1; i >= 0; i--) {\n              if (this._elementStack[i].name !== 'ng-container') {\n                  return { parent: this._elementStack[i], container: container };\n              }\n              container = this._elementStack[i];\n          }\n          return { parent: this._elementStack[this._elementStack.length - 1], container: container };\n      };\n      _TreeBuilder.prototype._addToParent = function (node) {\n          var parent = this._getParentElement();\n          if (isPresent(parent)) {\n              parent.children.push(node);\n          }\n          else {\n              this._rootNodes.push(node);\n          }\n      };\n      /**\n       * Insert a node between the parent and the container.\n       * When no container is given, the node is appended as a child of the parent.\n       * Also updates the element stack accordingly.\n       *\n       * @internal\n       */\n      _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {\n          if (!container) {\n              this._addToParent(node);\n              this._elementStack.push(node);\n          }\n          else {\n              if (parent) {\n                  // replace the container with the new node in the children\n                  var index = parent.children.indexOf(container);\n                  parent.children[index] = node;\n              }\n              else {\n                  this._rootNodes.push(node);\n              }\n              node.children.push(container);\n              this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n          }\n      };\n      _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {\n          if (isBlank(prefix)) {\n              prefix = this.getTagDefinition(localName).implicitNamespacePrefix;\n              if (isBlank(prefix) && isPresent(parentElement)) {\n                  prefix = getNsPrefix(parentElement.name);\n              }\n          }\n          return mergeNsAndName(prefix, localName);\n      };\n      return _TreeBuilder;\n  }());\n  function lastOnStack(stack, element) {\n      return stack.length > 0 && stack[stack.length - 1] === element;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  function digestMessage(message) {\n      return sha1(serializeNodes(message.nodes).join('') + (\"[\" + message.meaning + \"]\"));\n  }\n  /**\n   * Serialize the i18n ast to something xml-like in order to generate an UID.\n   *\n   * The visitor is also used in the i18n parser tests\n   *\n   * @internal\n   */\n  var _SerializerVisitor = (function () {\n      function _SerializerVisitor() {\n      }\n      _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };\n      _SerializerVisitor.prototype.visitContainer = function (container, context) {\n          var _this = this;\n          return \"[\" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + \"]\";\n      };\n      _SerializerVisitor.prototype.visitIcu = function (icu, context) {\n          var _this = this;\n          var strCases = Object.keys(icu.cases).map(function (k) { return (k + \" {\" + icu.cases[k].visit(_this) + \"}\"); });\n          return \"{\" + icu.expression + \", \" + icu.type + \", \" + strCases.join(', ') + \"}\";\n      };\n      _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n          var _this = this;\n          return ph.isVoid ?\n              \"<ph tag name=\\\"\" + ph.startName + \"\\\"/>\" :\n              \"<ph tag name=\\\"\" + ph.startName + \"\\\">\" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + \"</ph name=\\\"\" + ph.closeName + \"\\\">\";\n      };\n      _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n          return \"<ph name=\\\"\" + ph.name + \"\\\">\" + ph.value + \"</ph>\";\n      };\n      _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n          return \"<ph icu name=\\\"\" + ph.name + \"\\\">\" + ph.value.visit(this) + \"</ph>\";\n      };\n      return _SerializerVisitor;\n  }());\n  var serializerVisitor = new _SerializerVisitor();\n  function serializeNodes(nodes) {\n      return nodes.map(function (a) { return a.visit(serializerVisitor, null); });\n  }\n  /**\n   * Compute the SHA1 of the given string\n   *\n   * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n   *\n   * WARNING: this function has not been designed not tested with security in mind.\n   *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n   */\n  function sha1(str) {\n      var utf8 = utf8Encode(str);\n      var words32 = stringToWords32(utf8);\n      var len = utf8.length * 8;\n      var w = new Array(80);\n      var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];\n      words32[len >> 5] |= 0x80 << (24 - len % 32);\n      words32[((len + 64 >> 9) << 4) + 15] = len;\n      for (var i = 0; i < words32.length; i += 16) {\n          var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];\n          for (var j = 0; j < 80; j++) {\n              if (j < 16) {\n                  w[j] = words32[i + j];\n              }\n              else {\n                  w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n              }\n              var _c = fk(j, b, c, d), f = _c[0], k = _c[1];\n              var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n              _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];\n          }\n          _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];\n      }\n      var sha1 = words32ToString([a, b, c, d, e]);\n      var hex = '';\n      for (var i = 0; i < sha1.length; i++) {\n          var b_1 = sha1.charCodeAt(i);\n          hex += (b_1 >>> 4 & 0x0f).toString(16) + (b_1 & 0x0f).toString(16);\n      }\n      return hex.toLowerCase();\n      var _d, _e;\n  }\n  function utf8Encode(str) {\n      var encoded = '';\n      for (var index = 0; index < str.length; index++) {\n          var codePoint = decodeSurrogatePairs(str, index);\n          if (codePoint <= 0x7f) {\n              encoded += String.fromCharCode(codePoint);\n          }\n          else if (codePoint <= 0x7ff) {\n              encoded += String.fromCharCode(0xc0 | codePoint >>> 6, 0x80 | codePoint & 0x3f);\n          }\n          else if (codePoint <= 0xffff) {\n              encoded += String.fromCharCode(0xe0 | codePoint >>> 12, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);\n          }\n          else if (codePoint <= 0x1fffff) {\n              encoded += String.fromCharCode(0xf0 | codePoint >>> 18, 0x80 | codePoint >>> 12 & 0x3f, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);\n          }\n      }\n      return encoded;\n  }\n  // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n  function decodeSurrogatePairs(str, index) {\n      if (index < 0 || index >= str.length) {\n          throw new Error(\"index=\" + index + \" is out of range in \\\"\" + str + \"\\\"\");\n      }\n      var high = str.charCodeAt(index);\n      var low;\n      if (high >= 0xd800 && high <= 0xdfff && str.length > index + 1) {\n          low = str.charCodeAt(index + 1);\n          if (low >= 0xdc00 && low <= 0xdfff) {\n              return (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;\n          }\n      }\n      return high;\n  }\n  function stringToWords32(str) {\n      var words32 = Array(str.length >>> 2);\n      for (var i = 0; i < words32.length; i++) {\n          words32[i] = 0;\n      }\n      for (var i = 0; i < str.length; i++) {\n          words32[i >>> 2] |= (str.charCodeAt(i) & 0xff) << 8 * (3 - i & 0x3);\n      }\n      return words32;\n  }\n  function words32ToString(words32) {\n      var str = '';\n      for (var i = 0; i < words32.length * 4; i++) {\n          str += String.fromCharCode((words32[i >>> 2] >>> 8 * (3 - i & 0x3)) & 0xff);\n      }\n      return str;\n  }\n  function fk(index, b, c, d) {\n      if (index < 20) {\n          return [(b & c) | (~b & d), 0x5a827999];\n      }\n      if (index < 40) {\n          return [b ^ c ^ d, 0x6ed9eba1];\n      }\n      if (index < 60) {\n          return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n      }\n      return [b ^ c ^ d, 0xca62c1d6];\n  }\n  function add32(a, b) {\n      var low = (a & 0xffff) + (b & 0xffff);\n      var high = (a >> 16) + (b >> 16) + (low >> 16);\n      return (high << 16) | (low & 0xffff);\n  }\n  function rol32(a, count) {\n      return (a << count) | (a >>> (32 - count));\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var Message = (function () {\n      /**\n       * @param nodes message AST\n       * @param placeholders maps placeholder names to static content\n       * @param placeholderToMsgIds maps placeholder names to translatable message IDs (used for ICU\n       *                            messages)\n       * @param meaning\n       * @param description\n       */\n      function Message(nodes, placeholders, placeholderToMsgIds, meaning, description) {\n          this.nodes = nodes;\n          this.placeholders = placeholders;\n          this.placeholderToMsgIds = placeholderToMsgIds;\n          this.meaning = meaning;\n          this.description = description;\n      }\n      return Message;\n  }());\n  var Text$1 = (function () {\n      function Text(value, sourceSpan) {\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n      return Text;\n  }());\n  var Container = (function () {\n      function Container(children, sourceSpan) {\n          this.children = children;\n          this.sourceSpan = sourceSpan;\n      }\n      Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };\n      return Container;\n  }());\n  var Icu = (function () {\n      function Icu(expression, type, cases, sourceSpan) {\n          this.expression = expression;\n          this.type = type;\n          this.cases = cases;\n          this.sourceSpan = sourceSpan;\n      }\n      Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };\n      return Icu;\n  }());\n  var TagPlaceholder = (function () {\n      function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n          this.tag = tag;\n          this.attrs = attrs;\n          this.startName = startName;\n          this.closeName = closeName;\n          this.children = children;\n          this.isVoid = isVoid;\n          this.sourceSpan = sourceSpan;\n      }\n      TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };\n      return TagPlaceholder;\n  }());\n  var Placeholder = (function () {\n      function Placeholder(value, name, sourceSpan) {\n          if (name === void 0) { name = ''; }\n          this.value = value;\n          this.name = name;\n          this.sourceSpan = sourceSpan;\n      }\n      Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };\n      return Placeholder;\n  }());\n  var IcuPlaceholder = (function () {\n      function IcuPlaceholder(value, name, sourceSpan) {\n          if (name === void 0) { name = ''; }\n          this.value = value;\n          this.name = name;\n          this.sourceSpan = sourceSpan;\n      }\n      IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };\n      return IcuPlaceholder;\n  }());\n\n  var HtmlTagDefinition = (function () {\n      function HtmlTagDefinition(_a) {\n          var _this = this;\n          var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;\n          this.closedByChildren = {};\n          this.closedByParent = false;\n          this.canSelfClose = false;\n          if (closedByChildren && closedByChildren.length > 0) {\n              closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\n          }\n          this.isVoid = isVoid;\n          this.closedByParent = closedByParent || isVoid;\n          if (requiredParents && requiredParents.length > 0) {\n              this.requiredParents = {};\n              // The first parent is the list is automatically when none of the listed parents are present\n              this.parentToAdd = requiredParents[0];\n              requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });\n          }\n          this.implicitNamespacePrefix = implicitNamespacePrefix;\n          this.contentType = contentType;\n          this.ignoreFirstLf = ignoreFirstLf;\n      }\n      HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {\n          if (!this.requiredParents) {\n              return false;\n          }\n          if (!currentParent) {\n              return true;\n          }\n          var lcParent = currentParent.toLowerCase();\n          return this.requiredParents[lcParent] != true && lcParent != 'template';\n      };\n      HtmlTagDefinition.prototype.isClosedByChild = function (name) {\n          return this.isVoid || name.toLowerCase() in this.closedByChildren;\n      };\n      return HtmlTagDefinition;\n  }());\n  // see http://www.w3.org/TR/html51/syntax.html#optional-tags\n  // This implementation does not fully conform to the HTML5 spec.\n  var TAG_DEFINITIONS = {\n      'base': new HtmlTagDefinition({ isVoid: true }),\n      'meta': new HtmlTagDefinition({ isVoid: true }),\n      'area': new HtmlTagDefinition({ isVoid: true }),\n      'embed': new HtmlTagDefinition({ isVoid: true }),\n      'link': new HtmlTagDefinition({ isVoid: true }),\n      'img': new HtmlTagDefinition({ isVoid: true }),\n      'input': new HtmlTagDefinition({ isVoid: true }),\n      'param': new HtmlTagDefinition({ isVoid: true }),\n      'hr': new HtmlTagDefinition({ isVoid: true }),\n      'br': new HtmlTagDefinition({ isVoid: true }),\n      'source': new HtmlTagDefinition({ isVoid: true }),\n      'track': new HtmlTagDefinition({ isVoid: true }),\n      'wbr': new HtmlTagDefinition({ isVoid: true }),\n      'p': new HtmlTagDefinition({\n          closedByChildren: [\n              'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',\n              'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',\n              'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'\n          ],\n          closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n      'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n      'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n      'tr': new HtmlTagDefinition({\n          closedByChildren: ['tr'],\n          requiredParents: ['tbody', 'tfoot', 'thead'],\n          closedByParent: true\n      }),\n      'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n      'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n      'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),\n      'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n      'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n      'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n      'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n      'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n      'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n      'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n      'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n      'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n      'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n      'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n      'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n      'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n      'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n      'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n      'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n      'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n  };\n  var _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n  function getHtmlTagDefinition(tagName) {\n      return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var TAG_TO_PLACEHOLDER_NAMES = {\n      'A': 'LINK',\n      'B': 'BOLD_TEXT',\n      'BR': 'LINE_BREAK',\n      'EM': 'EMPHASISED_TEXT',\n      'H1': 'HEADING_LEVEL1',\n      'H2': 'HEADING_LEVEL2',\n      'H3': 'HEADING_LEVEL3',\n      'H4': 'HEADING_LEVEL4',\n      'H5': 'HEADING_LEVEL5',\n      'H6': 'HEADING_LEVEL6',\n      'HR': 'HORIZONTAL_RULE',\n      'I': 'ITALIC_TEXT',\n      'LI': 'LIST_ITEM',\n      'LINK': 'MEDIA_LINK',\n      'OL': 'ORDERED_LIST',\n      'P': 'PARAGRAPH',\n      'Q': 'QUOTATION',\n      'S': 'STRIKETHROUGH_TEXT',\n      'SMALL': 'SMALL_TEXT',\n      'SUB': 'SUBSTRIPT',\n      'SUP': 'SUPERSCRIPT',\n      'TBODY': 'TABLE_BODY',\n      'TD': 'TABLE_CELL',\n      'TFOOT': 'TABLE_FOOTER',\n      'TH': 'TABLE_HEADER_CELL',\n      'THEAD': 'TABLE_HEADER',\n      'TR': 'TABLE_ROW',\n      'TT': 'MONOSPACED_TEXT',\n      'U': 'UNDERLINED_TEXT',\n      'UL': 'UNORDERED_LIST',\n  };\n  /**\n   * Creates unique names for placeholder with different content\n   *\n   * @internal\n   */\n  var PlaceholderRegistry = (function () {\n      function PlaceholderRegistry() {\n          // Count the occurrence of the base name top generate a unique name\n          this._placeHolderNameCounts = {};\n          // Maps signature to placeholder names\n          this._signatureToName = {};\n      }\n      PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {\n          var signature = this._hashTag(tag, attrs, isVoid);\n          if (this._signatureToName[signature]) {\n              return this._signatureToName[signature];\n          }\n          var upperTag = tag.toUpperCase();\n          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n          var name = this._generateUniqueName(isVoid ? baseName : \"START_\" + baseName);\n          this._signatureToName[signature] = name;\n          return name;\n      };\n      PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {\n          var signature = this._hashClosingTag(tag);\n          if (this._signatureToName[signature]) {\n              return this._signatureToName[signature];\n          }\n          var upperTag = tag.toUpperCase();\n          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n          var name = this._generateUniqueName(\"CLOSE_\" + baseName);\n          this._signatureToName[signature] = name;\n          return name;\n      };\n      PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {\n          var upperName = name.toUpperCase();\n          var signature = \"PH: \" + upperName + \"=\" + content;\n          if (this._signatureToName[signature]) {\n              return this._signatureToName[signature];\n          }\n          var uniqueName = this._generateUniqueName(upperName);\n          this._signatureToName[signature] = uniqueName;\n          return uniqueName;\n      };\n      // Generate a hash for a tag - does not take attribute order into account\n      PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {\n          var start = \"<\" + tag;\n          var strAttrs = Object.keys(attrs).sort().map(function (name) { return (\" \" + name + \"=\" + attrs[name]); }).join('');\n          var end = isVoid ? '/>' : \"></\" + tag + \">\";\n          return start + strAttrs + end;\n      };\n      PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag(\"/\" + tag, {}, false); };\n      PlaceholderRegistry.prototype._generateUniqueName = function (base) {\n          var name = base;\n          var next = this._placeHolderNameCounts[name];\n          if (!next) {\n              next = 1;\n          }\n          else {\n              name += \"_\" + next;\n              next++;\n          }\n          this._placeHolderNameCounts[base] = next;\n          return name;\n      };\n      return PlaceholderRegistry;\n  }());\n\n  var _expParser = new Parser(new Lexer());\n  /**\n   * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n   */\n  function createI18nMessageFactory(interpolationConfig) {\n      var visitor = new _I18nVisitor(_expParser, interpolationConfig);\n      return function (nodes, meaning, description) {\n          return visitor.toI18nMessage(nodes, meaning, description);\n      };\n  }\n  var _I18nVisitor = (function () {\n      function _I18nVisitor(_expressionParser, _interpolationConfig) {\n          this._expressionParser = _expressionParser;\n          this._interpolationConfig = _interpolationConfig;\n      }\n      _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description) {\n          this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;\n          this._icuDepth = 0;\n          this._placeholderRegistry = new PlaceholderRegistry();\n          this._placeholderToContent = {};\n          this._placeholderToIds = {};\n          var i18nodes = visitAll(this, nodes, {});\n          return new Message(i18nodes, this._placeholderToContent, this._placeholderToIds, meaning, description);\n      };\n      _I18nVisitor.prototype.visitElement = function (el, context) {\n          var children = visitAll(this, el.children);\n          var attrs = {};\n          el.attrs.forEach(function (attr) {\n              // Do not visit the attributes, translatable ones are top-level ASTs\n              attrs[attr.name] = attr.value;\n          });\n          var isVoid = getHtmlTagDefinition(el.name).isVoid;\n          var startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n          this._placeholderToContent[startPhName] = el.sourceSpan.toString();\n          var closePhName = '';\n          if (!isVoid) {\n              closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n              this._placeholderToContent[closePhName] = \"</\" + el.name + \">\";\n          }\n          return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);\n      };\n      _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n          return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n      };\n      _I18nVisitor.prototype.visitText = function (text, context) {\n          return this._visitTextWithInterpolation(text.value, text.sourceSpan);\n      };\n      _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };\n      _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n          var _this = this;\n          this._icuDepth++;\n          var i18nIcuCases = {};\n          var i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n          icu.cases.forEach(function (caze) {\n              i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);\n          });\n          this._icuDepth--;\n          if (this._isIcu || this._icuDepth > 0) {\n              // If the message (vs a part of the message) is an ICU message returns it\n              return i18nIcu;\n          }\n          // Else returns a placeholder\n          // ICU placeholders should not be replaced with their original content but with the their\n          // translations. We need to create a new visitor (they are not re-entrant) to compute the\n          // message id.\n          // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n          var phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n          var visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n          this._placeholderToIds[phName] = digestMessage(visitor.toI18nMessage([icu], '', ''));\n          return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n      };\n      _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {\n          throw new Error('Unreachable code');\n      };\n      _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {\n          var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n          if (!splitInterpolation) {\n              // No expression, return a single text\n              return new Text$1(text, sourceSpan);\n          }\n          // Return a group of text + expressions\n          var nodes = [];\n          var container = new Container(nodes, sourceSpan);\n          var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;\n          for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {\n              var expression = splitInterpolation.expressions[i];\n              var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n              var phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n              if (splitInterpolation.strings[i].length) {\n                  // No need to add empty strings\n                  nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n              }\n              nodes.push(new Placeholder(expression, phName, sourceSpan));\n              this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n          }\n          // The last index contains no expression\n          var lastStringIdx = splitInterpolation.strings.length - 1;\n          if (splitInterpolation.strings[lastStringIdx].length) {\n              nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n          }\n          return container;\n      };\n      return _I18nVisitor;\n  }());\n  var _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*\"([\\s\\S]*?)\"[\\s\\S]*\\)/g;\n  function _extractPlaceholderName(input) {\n      return input.split(_CUSTOM_PH_EXP)[1];\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$4 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  /**\n   * An i18n error.\n   */\n  var I18nError = (function (_super) {\n      __extends$4(I18nError, _super);\n      function I18nError(span, msg) {\n          _super.call(this, span, msg);\n      }\n      return I18nError;\n  }(ParseError));\n\n  var _I18N_ATTR = 'i18n';\n  var _I18N_ATTR_PREFIX = 'i18n-';\n  var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\n  /**\n   * Extract translatable messages from an html AST\n   */\n  function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n      var visitor = new _Visitor(implicitTags, implicitAttrs);\n      return visitor.extract(nodes, interpolationConfig);\n  }\n  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n      var visitor = new _Visitor(implicitTags, implicitAttrs);\n      return visitor.merge(nodes, translations, interpolationConfig);\n  }\n  var ExtractionResult = (function () {\n      function ExtractionResult(messages, errors) {\n          this.messages = messages;\n          this.errors = errors;\n      }\n      return ExtractionResult;\n  }());\n  var _VisitorMode;\n  (function (_VisitorMode) {\n      _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n      _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n  })(_VisitorMode || (_VisitorMode = {}));\n  /**\n   * This Visitor is used:\n   * 1. to extract all the translatable strings from an html AST (see `extract()`),\n   * 2. to replace the translatable strings with the actual translations (see `merge()`)\n   *\n   * @internal\n   */\n  var _Visitor = (function () {\n      function _Visitor(_implicitTags, _implicitAttrs) {\n          this._implicitTags = _implicitTags;\n          this._implicitAttrs = _implicitAttrs;\n      }\n      /**\n       * Extracts the messages from the tree\n       */\n      _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n          var _this = this;\n          this._init(_VisitorMode.Extract, interpolationConfig);\n          nodes.forEach(function (node) { return node.visit(_this, null); });\n          if (this._inI18nBlock) {\n              this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n          }\n          return new ExtractionResult(this._messages, this._errors);\n      };\n      /**\n       * Returns a tree where all translatable nodes are translated\n       */\n      _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n          this._init(_VisitorMode.Merge, interpolationConfig);\n          this._translations = translations;\n          // Construct a single fake root element\n          var wrapper = new Element('wrapper', [], nodes, null, null, null);\n          var translatedNode = wrapper.visit(this, null);\n          if (this._inI18nBlock) {\n              this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n          }\n          return new ParseTreeResult(translatedNode.children, this._errors);\n      };\n      _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n          // Parse cases for translatable html attributes\n          var expression = visitAll(this, icuCase.expression, context);\n          if (this._mode === _VisitorMode.Merge) {\n              return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n          }\n      };\n      _Visitor.prototype.visitExpansion = function (icu, context) {\n          this._mayBeAddBlockChildren(icu);\n          var wasInIcu = this._inIcu;\n          if (!this._inIcu) {\n              // nested ICU messages should not be extracted but top-level translated as a whole\n              if (this._isInTranslatableSection) {\n                  this._addMessage([icu]);\n              }\n              this._inIcu = true;\n          }\n          var cases = visitAll(this, icu.cases, context);\n          if (this._mode === _VisitorMode.Merge) {\n              icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n          }\n          this._inIcu = wasInIcu;\n          return icu;\n      };\n      _Visitor.prototype.visitComment = function (comment, context) {\n          var isOpening = _isOpeningComment(comment);\n          if (isOpening && this._isInTranslatableSection) {\n              this._reportError(comment, 'Could not start a block inside a translatable section');\n              return;\n          }\n          var isClosing = _isClosingComment(comment);\n          if (isClosing && !this._inI18nBlock) {\n              this._reportError(comment, 'Trying to close an unopened block');\n              return;\n          }\n          if (!this._inI18nNode && !this._inIcu) {\n              if (!this._inI18nBlock) {\n                  if (isOpening) {\n                      this._inI18nBlock = true;\n                      this._blockStartDepth = this._depth;\n                      this._blockChildren = [];\n                      this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                      this._openTranslatableSection(comment);\n                  }\n              }\n              else {\n                  if (isClosing) {\n                      if (this._depth == this._blockStartDepth) {\n                          this._closeTranslatableSection(comment, this._blockChildren);\n                          this._inI18nBlock = false;\n                          var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                          // merge attributes in sections\n                          var nodes = this._translateMessage(comment, message);\n                          return visitAll(this, nodes);\n                      }\n                      else {\n                          this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                          return;\n                      }\n                  }\n              }\n          }\n      };\n      _Visitor.prototype.visitText = function (text, context) {\n          if (this._isInTranslatableSection) {\n              this._mayBeAddBlockChildren(text);\n          }\n          return text;\n      };\n      _Visitor.prototype.visitElement = function (el, context) {\n          var _this = this;\n          this._mayBeAddBlockChildren(el);\n          this._depth++;\n          var wasInI18nNode = this._inI18nNode;\n          var wasInImplicitNode = this._inImplicitNode;\n          var childNodes;\n          // Extract only top level nodes with the (implicit) \"i18n\" attribute if not in a block or an ICU\n          // message\n          var i18nAttr = _getI18nAttr(el);\n          var isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) &&\n              !this._inIcu && !this._isInTranslatableSection;\n          var isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n          this._inImplicitNode = this._inImplicitNode || isImplicit;\n          if (!this._isInTranslatableSection && !this._inIcu) {\n              if (i18nAttr) {\n                  // explicit translation\n                  this._inI18nNode = true;\n                  var message = this._addMessage(el.children, i18nAttr.value);\n                  childNodes = this._translateMessage(el, message);\n              }\n              else if (isTopLevelImplicit) {\n                  // implicit translation\n                  this._inI18nNode = true;\n                  var message = this._addMessage(el.children);\n                  childNodes = this._translateMessage(el, message);\n              }\n              if (this._mode == _VisitorMode.Extract) {\n                  var isTranslatable = i18nAttr || isTopLevelImplicit;\n                  if (isTranslatable) {\n                      this._openTranslatableSection(el);\n                  }\n                  visitAll(this, el.children);\n                  if (isTranslatable) {\n                      this._closeTranslatableSection(el, el.children);\n                  }\n              }\n              if (this._mode === _VisitorMode.Merge && !i18nAttr && !isTopLevelImplicit) {\n                  childNodes = [];\n                  el.children.forEach(function (child) {\n                      var visited = child.visit(_this, context);\n                      if (visited && !_this._isInTranslatableSection) {\n                          // Do not add the children from translatable sections (= i18n blocks here)\n                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)\n                          childNodes = childNodes.concat(visited);\n                      }\n                  });\n              }\n          }\n          else {\n              if (i18nAttr || isTopLevelImplicit) {\n                  this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n              }\n              if (this._mode == _VisitorMode.Extract) {\n                  // Descend into child nodes for extraction\n                  visitAll(this, el.children);\n              }\n              if (this._mode == _VisitorMode.Merge) {\n                  // Translate attributes in ICU messages\n                  childNodes = [];\n                  el.children.forEach(function (child) {\n                      var visited = child.visit(_this, context);\n                      if (visited && !_this._isInTranslatableSection) {\n                          // Do not add the children from translatable sections (= i18n blocks here)\n                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)\n                          childNodes = childNodes.concat(visited);\n                      }\n                  });\n              }\n          }\n          this._visitAttributesOf(el);\n          this._depth--;\n          this._inI18nNode = wasInI18nNode;\n          this._inImplicitNode = wasInImplicitNode;\n          if (this._mode === _VisitorMode.Merge) {\n              // There are no childNodes in translatable sections - those nodes will be replace anyway\n              var translatedAttrs = this._translateAttributes(el);\n              return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n          }\n      };\n      _Visitor.prototype.visitAttribute = function (attribute, context) {\n          throw new Error('unreachable code');\n      };\n      _Visitor.prototype._init = function (mode, interpolationConfig) {\n          this._mode = mode;\n          this._inI18nBlock = false;\n          this._inI18nNode = false;\n          this._depth = 0;\n          this._inIcu = false;\n          this._msgCountAtSectionStart = void 0;\n          this._errors = [];\n          this._messages = [];\n          this._inImplicitNode = false;\n          this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n      };\n      // looks for translatable attributes\n      _Visitor.prototype._visitAttributesOf = function (el) {\n          var _this = this;\n          var explicitAttrNameToValue = {};\n          var implicitAttrNames = this._implicitAttrs[el.name] || [];\n          el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })\n              .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n              attr.value; });\n          el.attrs.forEach(function (attr) {\n              if (attr.name in explicitAttrNameToValue) {\n                  _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n              }\n              else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {\n                  _this._addMessage([attr]);\n              }\n          });\n      };\n      // add a translatable message\n      _Visitor.prototype._addMessage = function (ast, meaningAndDesc) {\n          if (ast.length == 0 ||\n              ast.length == 1 && ast[0] instanceof Attribute$1 && !ast[0].value) {\n              // Do not create empty messages\n              return;\n          }\n          var _a = _splitMeaningAndDesc(meaningAndDesc), meaning = _a[0], description = _a[1];\n          var message = this._createI18nMessage(ast, meaning, description);\n          this._messages.push(message);\n          return message;\n      };\n      // Translates the given message given the `TranslationBundle`\n      // no-op when called in extraction mode (returns [])\n      _Visitor.prototype._translateMessage = function (el, message) {\n          if (message && this._mode === _VisitorMode.Merge) {\n              var id = digestMessage(message);\n              var nodes = this._translations.get(id);\n              if (nodes) {\n                  return nodes;\n              }\n              this._reportError(el, \"Translation unavailable for message id=\\\"\" + id + \"\\\"\");\n          }\n          return [];\n      };\n      // translate the attributes of an element and remove i18n specific attributes\n      _Visitor.prototype._translateAttributes = function (el) {\n          var _this = this;\n          var attributes = el.attrs;\n          var i18nAttributeMeanings = {};\n          attributes.forEach(function (attr) {\n              if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                  i18nAttributeMeanings[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                      _splitMeaningAndDesc(attr.value)[0];\n              }\n          });\n          var translatedAttributes = [];\n          attributes.forEach(function (attr) {\n              if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                  // strip i18n specific attributes\n                  return;\n              }\n              if (attr.value && attr.value != '' && i18nAttributeMeanings.hasOwnProperty(attr.name)) {\n                  var meaning = i18nAttributeMeanings[attr.name];\n                  var message = _this._createI18nMessage([attr], meaning, '');\n                  var id = digestMessage(message);\n                  var nodes = _this._translations.get(id);\n                  if (nodes) {\n                      if (nodes[0] instanceof Text) {\n                          var value = nodes[0].value;\n                          translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));\n                      }\n                      else {\n                          _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + id + \"\\\")\");\n                      }\n                  }\n                  else {\n                      _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + id + \"\\\")\");\n                  }\n              }\n              else {\n                  translatedAttributes.push(attr);\n              }\n          });\n          return translatedAttributes;\n      };\n      /**\n       * Add the node as a child of the block when:\n       * - we are in a block,\n       * - we are not inside a ICU message (those are handled separately),\n       * - the node is a \"direct child\" of the block\n       */\n      _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n          if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n              this._blockChildren.push(node);\n          }\n      };\n      /**\n       * Marks the start of a section, see `_endSection`\n       */\n      _Visitor.prototype._openTranslatableSection = function (node) {\n          if (this._isInTranslatableSection) {\n              this._reportError(node, 'Unexpected section start');\n          }\n          else {\n              this._msgCountAtSectionStart = this._messages.length;\n          }\n      };\n      Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n          /**\n           * A translatable section could be:\n           * - a translatable element,\n           * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n           */\n          get: function () {\n              return this._msgCountAtSectionStart !== void 0;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      /**\n       * Terminates a section.\n       *\n       * If a section has only one significant children (comments not significant) then we should not\n       * keep the message from this children:\n       *\n       * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n       * - one for the <p> content with meaning and description,\n       * - another one for the ICU message.\n       *\n       * In this case the last message is discarded as it contains less information (the AST is\n       * otherwise identical).\n       *\n       * Note that we should still keep messages extracted from attributes inside the section (ie in the\n       * ICU message here)\n       */\n      _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n          if (!this._isInTranslatableSection) {\n              this._reportError(node, 'Unexpected section end');\n              return;\n          }\n          var startIndex = this._msgCountAtSectionStart;\n          var significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);\n          if (significantChildren == 1) {\n              for (var i = this._messages.length - 1; i >= startIndex; i--) {\n                  var ast = this._messages[i].nodes;\n                  if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n                      this._messages.splice(i, 1);\n                      break;\n                  }\n              }\n          }\n          this._msgCountAtSectionStart = void 0;\n      };\n      _Visitor.prototype._reportError = function (node, msg) {\n          this._errors.push(new I18nError(node.sourceSpan, msg));\n      };\n      return _Visitor;\n  }());\n  function _isOpeningComment(n) {\n      return n instanceof Comment && n.value && n.value.startsWith('i18n');\n  }\n  function _isClosingComment(n) {\n      return n instanceof Comment && n.value && n.value === '/i18n';\n  }\n  function _getI18nAttr(p) {\n      return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;\n  }\n  function _splitMeaningAndDesc(i18n) {\n      if (!i18n)\n          return ['', ''];\n      var pipeIndex = i18n.indexOf('|');\n      return pipeIndex == -1 ? ['', i18n] : [i18n.slice(0, pipeIndex), i18n.slice(pipeIndex + 1)];\n  }\n\n  /**\n   * A container for message extracted from the templates.\n   */\n  var MessageBundle = (function () {\n      function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {\n          this._htmlParser = _htmlParser;\n          this._implicitTags = _implicitTags;\n          this._implicitAttrs = _implicitAttrs;\n          this._messageMap = {};\n      }\n      MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {\n          var _this = this;\n          var htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);\n          if (htmlParserResult.errors.length) {\n              return htmlParserResult.errors;\n          }\n          var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n          if (i18nParserResult.errors.length) {\n              return i18nParserResult.errors;\n          }\n          i18nParserResult.messages.forEach(function (message) { _this._messageMap[digestMessage(message)] = message; });\n      };\n      MessageBundle.prototype.getMessageMap = function () { return this._messageMap; };\n      MessageBundle.prototype.write = function (serializer) { return serializer.write(this._messageMap); };\n      return MessageBundle;\n  }());\n\n  /**\n   * Wraps Javascript Objects\n   */\n  var StringMapWrapper = (function () {\n      function StringMapWrapper() {\n      }\n      StringMapWrapper.merge = function (m1, m2) {\n          var m = {};\n          for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n              var k = _a[_i];\n              m[k] = m1[k];\n          }\n          for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n              var k = _c[_b];\n              m[k] = m2[k];\n          }\n          return m;\n      };\n      StringMapWrapper.equals = function (m1, m2) {\n          var k1 = Object.keys(m1);\n          var k2 = Object.keys(m2);\n          if (k1.length != k2.length) {\n              return false;\n          }\n          for (var i = 0; i < k1.length; i++) {\n              var key = k1[i];\n              if (m1[key] !== m2[key]) {\n                  return false;\n              }\n          }\n          return true;\n      };\n      return StringMapWrapper;\n  }());\n  var ListWrapper = (function () {\n      function ListWrapper() {\n      }\n      ListWrapper.removeAll = function (list, items) {\n          for (var i = 0; i < items.length; ++i) {\n              var index = list.indexOf(items[i]);\n              if (index > -1) {\n                  list.splice(index, 1);\n              }\n          }\n      };\n      ListWrapper.remove = function (list, el) {\n          var index = list.indexOf(el);\n          if (index > -1) {\n              list.splice(index, 1);\n              return true;\n          }\n          return false;\n      };\n      ListWrapper.equals = function (a, b) {\n          if (a.length != b.length)\n              return false;\n          for (var i = 0; i < a.length; ++i) {\n              if (a[i] !== b[i])\n                  return false;\n          }\n          return true;\n      };\n      ListWrapper.flatten = function (list) {\n          return list.reduce(function (flat, item) {\n              var flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;\n              return flat.concat(flatItem);\n          }, []);\n      };\n      return ListWrapper;\n  }());\n\n  var XmlTagDefinition = (function () {\n      function XmlTagDefinition() {\n          this.closedByParent = false;\n          this.contentType = TagContentType.PARSABLE_DATA;\n          this.isVoid = false;\n          this.ignoreFirstLf = false;\n          this.canSelfClose = true;\n      }\n      XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };\n      XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };\n      return XmlTagDefinition;\n  }());\n  var _TAG_DEFINITION = new XmlTagDefinition();\n  function getXmlTagDefinition(tagName) {\n      return _TAG_DEFINITION;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$5 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var XmlParser = (function (_super) {\n      __extends$5(XmlParser, _super);\n      function XmlParser() {\n          _super.call(this, getXmlTagDefinition);\n      }\n      XmlParser.prototype.parse = function (source, url, parseExpansionForms) {\n          if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n          return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);\n      };\n      return XmlParser;\n  }(Parser$1));\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  // Generate a map of placeholder to content indexed by message ids\n  function extractPlaceholders(messageBundle) {\n      var messageMap = messageBundle.getMessageMap();\n      var placeholders = {};\n      Object.keys(messageMap).forEach(function (msgId) {\n          placeholders[msgId] = messageMap[msgId].placeholders;\n      });\n      return placeholders;\n  }\n  // Generate a map of placeholder to message ids indexed by message ids\n  function extractPlaceholderToIds(messageBundle) {\n      var messageMap = messageBundle.getMessageMap();\n      var placeholderToIds = {};\n      Object.keys(messageMap).forEach(function (msgId) {\n          placeholderToIds[msgId] = messageMap[msgId].placeholderToMsgIds;\n      });\n      return placeholderToIds;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$6 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var _Visitor$1 = (function () {\n      function _Visitor() {\n      }\n      _Visitor.prototype.visitTag = function (tag) {\n          var _this = this;\n          var strAttrs = this._serializeAttributes(tag.attrs);\n          if (tag.children.length == 0) {\n              return \"<\" + tag.name + strAttrs + \"/>\";\n          }\n          var strChildren = tag.children.map(function (node) { return node.visit(_this); });\n          return \"<\" + tag.name + strAttrs + \">\" + strChildren.join('') + \"</\" + tag.name + \">\";\n      };\n      _Visitor.prototype.visitText = function (text) { return text.value; };\n      _Visitor.prototype.visitDeclaration = function (decl) {\n          return \"<?xml\" + this._serializeAttributes(decl.attrs) + \" ?>\";\n      };\n      _Visitor.prototype._serializeAttributes = function (attrs) {\n          var strAttrs = Object.keys(attrs).map(function (name) { return (name + \"=\\\"\" + attrs[name] + \"\\\"\"); }).join(' ');\n          return strAttrs.length > 0 ? ' ' + strAttrs : '';\n      };\n      _Visitor.prototype.visitDoctype = function (doctype) {\n          return \"<!DOCTYPE \" + doctype.rootTag + \" [\\n\" + doctype.dtd + \"\\n]>\";\n      };\n      return _Visitor;\n  }());\n  var _visitor = new _Visitor$1();\n  function serialize(nodes) {\n      return nodes.map(function (node) { return node.visit(_visitor); }).join('');\n  }\n  var Declaration = (function () {\n      function Declaration(unescapedAttrs) {\n          var _this = this;\n          this.attrs = {};\n          Object.keys(unescapedAttrs).forEach(function (k) {\n              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n          });\n      }\n      Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };\n      return Declaration;\n  }());\n  var Doctype = (function () {\n      function Doctype(rootTag, dtd) {\n          this.rootTag = rootTag;\n          this.dtd = dtd;\n      }\n      ;\n      Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };\n      return Doctype;\n  }());\n  var Tag = (function () {\n      function Tag(name, unescapedAttrs, children) {\n          var _this = this;\n          if (unescapedAttrs === void 0) { unescapedAttrs = {}; }\n          if (children === void 0) { children = []; }\n          this.name = name;\n          this.children = children;\n          this.attrs = {};\n          Object.keys(unescapedAttrs).forEach(function (k) {\n              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n          });\n      }\n      Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };\n      return Tag;\n  }());\n  var Text$2 = (function () {\n      function Text(unescapedValue) {\n          this.value = _escapeXml(unescapedValue);\n      }\n      ;\n      Text.prototype.visit = function (visitor) { return visitor.visitText(this); };\n      return Text;\n  }());\n  var CR = (function (_super) {\n      __extends$6(CR, _super);\n      function CR(ws) {\n          if (ws === void 0) { ws = 0; }\n          _super.call(this, \"\\n\" + new Array(ws + 1).join(' '));\n      }\n      return CR;\n  }(Text$2));\n  var _ESCAPED_CHARS = [\n      [/&/g, '&amp;'],\n      [/\"/g, '&quot;'],\n      [/'/g, '&apos;'],\n      [/</g, '&lt;'],\n      [/>/g, '&gt;'],\n  ];\n  function _escapeXml(text) {\n      return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);\n  }\n\n  var _VERSION = '1.2';\n  var _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n  // TODO(vicb): make this a param (s/_/-/)\n  var _SOURCE_LANG = 'en';\n  var _PLACEHOLDER_TAG = 'x';\n  var _SOURCE_TAG = 'source';\n  var _TARGET_TAG = 'target';\n  var _UNIT_TAG = 'trans-unit';\n  // http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n  // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\n  var Xliff = (function () {\n      function Xliff(_htmlParser, _interpolationConfig) {\n          this._htmlParser = _htmlParser;\n          this._interpolationConfig = _interpolationConfig;\n      }\n      Xliff.prototype.write = function (messageMap) {\n          var visitor = new _WriteVisitor();\n          var transUnits = [];\n          Object.keys(messageMap).forEach(function (id) {\n              var message = messageMap[id];\n              var transUnit = new Tag(_UNIT_TAG, { id: id, datatype: 'html' });\n              transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG));\n              if (message.description) {\n                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\n              }\n              if (message.meaning) {\n                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\n              }\n              transUnit.children.push(new CR(6));\n              transUnits.push(new CR(6), transUnit);\n          });\n          var body = new Tag('body', {}, transUnits.concat([new CR(4)]));\n          var file = new Tag('file', { 'source-language': _SOURCE_LANG, datatype: 'plaintext', original: 'ng2.template' }, [new CR(4), body, new CR(2)]);\n          var xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\n          return serialize([\n              new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n          ]);\n      };\n      Xliff.prototype.load = function (content, url, messageBundle) {\n          var _this = this;\n          // Parse the xtb file into xml nodes\n          var result = new XmlParser().parse(content, url);\n          if (result.errors.length) {\n              throw new Error(\"xtb parse errors:\\n\" + result.errors.join('\\n'));\n          }\n          // Replace the placeholders, messages are now string\n          var _a = new _LoadVisitor().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;\n          if (errors.length) {\n              throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n          }\n          // Convert the string messages to html ast\n          // TODO(vicb): map error message back to the original message in xtb\n          var messageMap = {};\n          var parseErrors = [];\n          Object.keys(messages).forEach(function (id) {\n              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);\n              parseErrors.push.apply(parseErrors, res.errors);\n              messageMap[id] = res.rootNodes;\n          });\n          if (parseErrors.length) {\n              throw new Error(\"xtb parse errors:\\n\" + parseErrors.join('\\n'));\n          }\n          return messageMap;\n      };\n      return Xliff;\n  }());\n  var _WriteVisitor = (function () {\n      function _WriteVisitor() {\n      }\n      _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n      _WriteVisitor.prototype.visitContainer = function (container, context) {\n          var _this = this;\n          var nodes = [];\n          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n          return nodes;\n      };\n      _WriteVisitor.prototype.visitIcu = function (icu, context) {\n          if (this._isInIcu) {\n              // nested ICU is not supported\n              throw new Error('xliff does not support nested ICU messages');\n          }\n          this._isInIcu = true;\n          // TODO(vicb): support ICU messages\n          // https://lists.oasis-open.org/archives/xliff/201201/msg00028.html\n          // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-po/xliff-profile-po-1.2-cd02.html\n          var nodes = [];\n          this._isInIcu = false;\n          return nodes;\n      };\n      _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n          var ctype = getCtypeForTag(ph.tag);\n          var startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });\n          if (ph.isVoid) {\n              // void tags have no children nor closing tags\n              return [startTagPh];\n          }\n          var closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });\n          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n      };\n      _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n      };\n      _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n      };\n      _WriteVisitor.prototype.serialize = function (nodes) {\n          var _this = this;\n          this._isInIcu = false;\n          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));\n      };\n      return _WriteVisitor;\n  }());\n  // TODO(vicb): add error management (structure)\n  // TODO(vicb): factorize (xtb) ?\n  var _LoadVisitor = (function () {\n      function _LoadVisitor() {\n      }\n      _LoadVisitor.prototype.parse = function (nodes, messageBundle) {\n          var _this = this;\n          this._messageNodes = [];\n          this._translatedMessages = {};\n          this._msgId = '';\n          this._target = [];\n          this._errors = [];\n          // Find all messages\n          visitAll(this, nodes, null);\n          var messageMap = messageBundle.getMessageMap();\n          var placeholders = extractPlaceholders(messageBundle);\n          var placeholderToIds = extractPlaceholderToIds(messageBundle);\n          this._messageNodes\n              .filter(function (message) {\n              // Remove any messages that is not present in the source message bundle.\n              return messageMap.hasOwnProperty(message[0]);\n          })\n              .sort(function (a, b) {\n              // Because there could be no ICU placeholders inside an ICU message,\n              // we do not need to take into account the `placeholderToMsgIds` of the referenced\n              // messages, those would always be empty\n              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()\n              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {\n                  return -1;\n              }\n              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {\n                  return 1;\n              }\n              return 0;\n          })\n              .forEach(function (message) {\n              var id = message[0];\n              _this._placeholders = placeholders[id] || {};\n              _this._placeholderToIds = placeholderToIds[id] || {};\n              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`\n              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');\n          });\n          return { messages: this._translatedMessages, errors: this._errors };\n      };\n      _LoadVisitor.prototype.visitElement = function (element, context) {\n          switch (element.name) {\n              case _UNIT_TAG:\n                  this._target = null;\n                  var msgId = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                  if (!msgId) {\n                      this._addError(element, \"<\" + _UNIT_TAG + \"> misses the \\\"id\\\" attribute\");\n                  }\n                  else {\n                      this._msgId = msgId.value;\n                  }\n                  visitAll(this, element.children, null);\n                  if (this._msgId !== null) {\n                      this._messageNodes.push([this._msgId, this._target]);\n                  }\n                  break;\n              case _SOURCE_TAG:\n                  // ignore source message\n                  break;\n              case _TARGET_TAG:\n                  this._target = element.children;\n                  break;\n              case _PLACEHOLDER_TAG:\n                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                  if (!idAttr) {\n                      this._addError(element, \"<\" + _PLACEHOLDER_TAG + \"> misses the \\\"id\\\" attribute\");\n                  }\n                  else {\n                      var id = idAttr.value;\n                      if (this._placeholders.hasOwnProperty(id)) {\n                          return this._placeholders[id];\n                      }\n                      if (this._placeholderToIds.hasOwnProperty(id) &&\n                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])) {\n                          return this._translatedMessages[this._placeholderToIds[id]];\n                      }\n                      // TODO(vicb): better error message for when\n                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])\n                      this._addError(element, \"The placeholder \\\"\" + id + \"\\\" does not exists in the source message\");\n                  }\n                  break;\n              default:\n                  visitAll(this, element.children, null);\n          }\n      };\n      _LoadVisitor.prototype.visitAttribute = function (attribute, context) {\n          throw new Error('unreachable code');\n      };\n      _LoadVisitor.prototype.visitText = function (text, context) { return text.value; };\n      _LoadVisitor.prototype.visitComment = function (comment, context) { return ''; };\n      _LoadVisitor.prototype.visitExpansion = function (expansion, context) {\n          throw new Error('unreachable code');\n      };\n      _LoadVisitor.prototype.visitExpansionCase = function (expansionCase, context) {\n          throw new Error('unreachable code');\n      };\n      _LoadVisitor.prototype._addError = function (node, message) {\n          this._errors.push(new I18nError(node.sourceSpan, message));\n      };\n      return _LoadVisitor;\n  }());\n  function getCtypeForTag(tag) {\n      switch (tag.toLowerCase()) {\n          case 'br':\n              return 'lb';\n          case 'img':\n              return 'image';\n          default:\n              return \"x-\" + tag;\n      }\n  }\n\n  var _MESSAGES_TAG = 'messagebundle';\n  var _MESSAGE_TAG = 'msg';\n  var _PLACEHOLDER_TAG$1 = 'ph';\n  var _EXEMPLE_TAG = 'ex';\n  var _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\n  var Xmb = (function () {\n      function Xmb() {\n      }\n      Xmb.prototype.write = function (messageMap) {\n          var visitor = new _Visitor$2();\n          var rootNode = new Tag(_MESSAGES_TAG);\n          Object.keys(messageMap).forEach(function (id) {\n              var message = messageMap[id];\n              var attrs = { id: id };\n              if (message.description) {\n                  attrs['desc'] = message.description;\n              }\n              if (message.meaning) {\n                  attrs['meaning'] = message.meaning;\n              }\n              rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes)));\n          });\n          rootNode.children.push(new CR());\n          return serialize([\n              new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n              new CR(),\n              new Doctype(_MESSAGES_TAG, _DOCTYPE),\n              new CR(),\n              rootNode,\n              new CR(),\n          ]);\n      };\n      Xmb.prototype.load = function (content, url, messageBundle) {\n          throw new Error('Unsupported');\n      };\n      return Xmb;\n  }());\n  var _Visitor$2 = (function () {\n      function _Visitor() {\n      }\n      _Visitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n      _Visitor.prototype.visitContainer = function (container, context) {\n          var _this = this;\n          var nodes = [];\n          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n          return nodes;\n      };\n      _Visitor.prototype.visitIcu = function (icu, context) {\n          var _this = this;\n          var nodes = [new Text$2(\"{\" + icu.expression + \", \" + icu.type + \", \")];\n          Object.keys(icu.cases).forEach(function (c) {\n              nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n          });\n          nodes.push(new Text$2(\"}\"));\n          return nodes;\n      };\n      _Visitor.prototype.visitTagPlaceholder = function (ph, context) {\n          var startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"<\" + ph.tag + \">\")]);\n          var startTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.startName }, [startEx]);\n          if (ph.isVoid) {\n              // void tags have no children nor closing tags\n              return [startTagPh];\n          }\n          var closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"</\" + ph.tag + \">\")]);\n          var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.closeName }, [closeEx]);\n          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n      };\n      _Visitor.prototype.visitPlaceholder = function (ph, context) {\n          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];\n      };\n      _Visitor.prototype.visitIcuPlaceholder = function (ph, context) {\n          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];\n      };\n      _Visitor.prototype.serialize = function (nodes) {\n          var _this = this;\n          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));\n      };\n      return _Visitor;\n  }());\n\n  var _TRANSLATIONS_TAG = 'translationbundle';\n  var _TRANSLATION_TAG = 'translation';\n  var _PLACEHOLDER_TAG$2 = 'ph';\n  var Xtb = (function () {\n      function Xtb(_htmlParser, _interpolationConfig) {\n          this._htmlParser = _htmlParser;\n          this._interpolationConfig = _interpolationConfig;\n      }\n      Xtb.prototype.write = function (messageMap) { throw new Error('Unsupported'); };\n      Xtb.prototype.load = function (content, url, messageBundle) {\n          var _this = this;\n          // Parse the xtb file into xml nodes\n          var result = new XmlParser().parse(content, url);\n          if (result.errors.length) {\n              throw new Error(\"xtb parse errors:\\n\" + result.errors.join('\\n'));\n          }\n          // Replace the placeholders, messages are now string\n          var _a = new _Visitor$3().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;\n          if (errors.length) {\n              throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n          }\n          // Convert the string messages to html ast\n          // TODO(vicb): map error message back to the original message in xtb\n          var messageMap = {};\n          var parseErrors = [];\n          Object.keys(messages).forEach(function (id) {\n              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);\n              parseErrors.push.apply(parseErrors, res.errors);\n              messageMap[id] = res.rootNodes;\n          });\n          if (parseErrors.length) {\n              throw new Error(\"xtb parse errors:\\n\" + parseErrors.join('\\n'));\n          }\n          return messageMap;\n      };\n      return Xtb;\n  }());\n  var _Visitor$3 = (function () {\n      function _Visitor() {\n      }\n      _Visitor.prototype.parse = function (nodes, messageBundle) {\n          var _this = this;\n          this._messageNodes = [];\n          this._translatedMessages = {};\n          this._bundleDepth = 0;\n          this._translationDepth = 0;\n          this._errors = [];\n          // Find all messages\n          visitAll(this, nodes, null);\n          var messageMap = messageBundle.getMessageMap();\n          var placeholders = extractPlaceholders(messageBundle);\n          var placeholderToIds = extractPlaceholderToIds(messageBundle);\n          this._messageNodes\n              .filter(function (message) {\n              // Remove any messages that is not present in the source message bundle.\n              return messageMap.hasOwnProperty(message[0]);\n          })\n              .sort(function (a, b) {\n              // Because there could be no ICU placeholders inside an ICU message,\n              // we do not need to take into account the `placeholderToMsgIds` of the referenced\n              // messages, those would always be empty\n              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()\n              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {\n                  return -1;\n              }\n              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {\n                  return 1;\n              }\n              return 0;\n          })\n              .forEach(function (message) {\n              var id = message[0];\n              _this._placeholders = placeholders[id] || {};\n              _this._placeholderToIds = placeholderToIds[id] || {};\n              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`\n              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');\n          });\n          return { messages: this._translatedMessages, errors: this._errors };\n      };\n      _Visitor.prototype.visitElement = function (element, context) {\n          switch (element.name) {\n              case _TRANSLATIONS_TAG:\n                  this._bundleDepth++;\n                  if (this._bundleDepth > 1) {\n                      this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n                  }\n                  visitAll(this, element.children, null);\n                  this._bundleDepth--;\n                  break;\n              case _TRANSLATION_TAG:\n                  this._translationDepth++;\n                  if (this._translationDepth > 1) {\n                      this._addError(element, \"<\" + _TRANSLATION_TAG + \"> elements can not be nested\");\n                  }\n                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                  if (!idAttr) {\n                      this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n                  }\n                  else {\n                      // ICU placeholders are reference to other messages.\n                      // The referenced message might not have been decoded yet.\n                      // We need to have all messages available to make sure deps are decoded first.\n                      // TODO(vicb): report an error on duplicate id\n                      this._messageNodes.push([idAttr.value, element.children]);\n                  }\n                  this._translationDepth--;\n                  break;\n              case _PLACEHOLDER_TAG$2:\n                  var nameAttr = element.attrs.find(function (attr) { return attr.name === 'name'; });\n                  if (!nameAttr) {\n                      this._addError(element, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"name\\\" attribute\");\n                  }\n                  else {\n                      var name_1 = nameAttr.value;\n                      if (this._placeholders.hasOwnProperty(name_1)) {\n                          return this._placeholders[name_1];\n                      }\n                      if (this._placeholderToIds.hasOwnProperty(name_1) &&\n                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[name_1])) {\n                          return this._translatedMessages[this._placeholderToIds[name_1]];\n                      }\n                      // TODO(vicb): better error message for when\n                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[name])\n                      this._addError(element, \"The placeholder \\\"\" + name_1 + \"\\\" does not exists in the source message\");\n                  }\n                  break;\n              default:\n                  this._addError(element, 'Unexpected tag');\n          }\n      };\n      _Visitor.prototype.visitAttribute = function (attribute, context) {\n          throw new Error('unreachable code');\n      };\n      _Visitor.prototype.visitText = function (text, context) { return text.value; };\n      _Visitor.prototype.visitComment = function (comment, context) { return ''; };\n      _Visitor.prototype.visitExpansion = function (expansion, context) {\n          var _this = this;\n          var strCases = expansion.cases.map(function (c) { return c.visit(_this, null); });\n          return \"{\" + expansion.switchValue + \", \" + expansion.type + \", strCases.join(' ')}\";\n      };\n      _Visitor.prototype.visitExpansionCase = function (expansionCase, context) {\n          return expansionCase.value + \" {\" + visitAll(this, expansionCase.expression, null) + \"}\";\n      };\n      _Visitor.prototype._addError = function (node, message) {\n          this._errors.push(new I18nError(node.sourceSpan, message));\n      };\n      return _Visitor;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   * A container for translated messages\n   */\n  var TranslationBundle = (function () {\n      function TranslationBundle(_messageMap) {\n          if (_messageMap === void 0) { _messageMap = {}; }\n          this._messageMap = _messageMap;\n      }\n      TranslationBundle.load = function (content, url, messageBundle, serializer) {\n          return new TranslationBundle(serializer.load(content, url, messageBundle));\n      };\n      TranslationBundle.prototype.get = function (id) { return this._messageMap[id]; };\n      TranslationBundle.prototype.has = function (id) { return id in this._messageMap; };\n      return TranslationBundle;\n  }());\n\n  var I18NHtmlParser = (function () {\n      // TODO(vicb): transB.load() should not need a msgB & add transB.resolve(msgB,\n      // interpolationConfig)\n      // TODO(vicb): remove the interpolationConfig from the Xtb serializer\n      function I18NHtmlParser(_htmlParser, _translations, _translationsFormat) {\n          this._htmlParser = _htmlParser;\n          this._translations = _translations;\n          this._translationsFormat = _translationsFormat;\n      }\n      I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n          if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          var parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);\n          if (!this._translations || this._translations === '') {\n              // Do not enable i18n when no translation bundle is provided\n              return parseResult;\n          }\n          // TODO(vicb): add support for implicit tags / attributes\n          var messageBundle = new MessageBundle(this._htmlParser, [], {});\n          var errors = messageBundle.updateFromTemplate(source, url, interpolationConfig);\n          if (errors && errors.length) {\n              return new ParseTreeResult(parseResult.rootNodes, parseResult.errors.concat(errors));\n          }\n          var serializer = this._createSerializer(interpolationConfig);\n          var translationBundle = TranslationBundle.load(this._translations, url, messageBundle, serializer);\n          return mergeTranslations(parseResult.rootNodes, translationBundle, interpolationConfig, [], {});\n      };\n      I18NHtmlParser.prototype._createSerializer = function (interpolationConfig) {\n          var format = (this._translationsFormat || 'xlf').toLowerCase();\n          switch (format) {\n              case 'xmb':\n                  return new Xmb();\n              case 'xtb':\n                  return new Xtb(this._htmlParser, interpolationConfig);\n              case 'xliff':\n              case 'xlf':\n              default:\n                  return new Xliff(this._htmlParser, interpolationConfig);\n          }\n      };\n      return I18NHtmlParser;\n  }());\n\n  var _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' +\n      '([-\\\\w]+)|' +\n      '(?:\\\\.([-\\\\w]+))|' +\n      '(?:\\\\[([-\\\\w*]+)(?:=([^\\\\]]*))?\\\\])|' +\n      '(\\\\))|' +\n      '(\\\\s*,\\\\s*)', // \",\"\n  'g');\n  /**\n   * A css selector contains an element name,\n   * css classes and attribute/value pairs with the purpose\n   * of selecting subsets out of them.\n   */\n  var CssSelector = (function () {\n      function CssSelector() {\n          this.element = null;\n          this.classNames = [];\n          this.attrs = [];\n          this.notSelectors = [];\n      }\n      CssSelector.parse = function (selector) {\n          var results = [];\n          var _addResult = function (res, cssSel) {\n              if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                  cssSel.attrs.length == 0) {\n                  cssSel.element = '*';\n              }\n              res.push(cssSel);\n          };\n          var cssSelector = new CssSelector();\n          var match;\n          var current = cssSelector;\n          var inNot = false;\n          _SELECTOR_REGEXP.lastIndex = 0;\n          while (match = _SELECTOR_REGEXP.exec(selector)) {\n              if (match[1]) {\n                  if (inNot) {\n                      throw new Error('Nesting :not is not allowed in a selector');\n                  }\n                  inNot = true;\n                  current = new CssSelector();\n                  cssSelector.notSelectors.push(current);\n              }\n              if (match[2]) {\n                  current.setElement(match[2]);\n              }\n              if (match[3]) {\n                  current.addClassName(match[3]);\n              }\n              if (match[4]) {\n                  current.addAttribute(match[4], match[5]);\n              }\n              if (match[6]) {\n                  inNot = false;\n                  current = cssSelector;\n              }\n              if (match[7]) {\n                  if (inNot) {\n                      throw new Error('Multiple selectors in :not are not supported');\n                  }\n                  _addResult(results, cssSelector);\n                  cssSelector = current = new CssSelector();\n              }\n          }\n          _addResult(results, cssSelector);\n          return results;\n      };\n      CssSelector.prototype.isElementSelector = function () {\n          return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n              this.notSelectors.length === 0;\n      };\n      CssSelector.prototype.hasElementSelector = function () { return !!this.element; };\n      CssSelector.prototype.setElement = function (element) {\n          if (element === void 0) { element = null; }\n          this.element = element;\n      };\n      /** Gets a template string for an element that matches the selector. */\n      CssSelector.prototype.getMatchingElementTemplate = function () {\n          var tagName = this.element || 'div';\n          var classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n          var attrs = '';\n          for (var i = 0; i < this.attrs.length; i += 2) {\n              var attrName = this.attrs[i];\n              var attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n              attrs += \" \" + attrName + attrValue;\n          }\n          return getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" :\n              \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n      };\n      CssSelector.prototype.addAttribute = function (name, value) {\n          if (value === void 0) { value = ''; }\n          this.attrs.push(name, value && value.toLowerCase() || '');\n      };\n      CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };\n      CssSelector.prototype.toString = function () {\n          var res = this.element || '';\n          if (this.classNames) {\n              this.classNames.forEach(function (klass) { return res += \".\" + klass; });\n          }\n          if (this.attrs) {\n              for (var i = 0; i < this.attrs.length; i += 2) {\n                  var name_1 = this.attrs[i];\n                  var value = this.attrs[i + 1];\n                  res += \"[\" + name_1 + (value ? '=' + value : '') + \"]\";\n              }\n          }\n          this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\n          return res;\n      };\n      return CssSelector;\n  }());\n  /**\n   * Reads a list of CssSelectors and allows to calculate which ones\n   * are contained in a given CssSelector.\n   */\n  var SelectorMatcher = (function () {\n      function SelectorMatcher() {\n          this._elementMap = new Map();\n          this._elementPartialMap = new Map();\n          this._classMap = new Map();\n          this._classPartialMap = new Map();\n          this._attrValueMap = new Map();\n          this._attrValuePartialMap = new Map();\n          this._listContexts = [];\n      }\n      SelectorMatcher.createNotMatcher = function (notSelectors) {\n          var notMatcher = new SelectorMatcher();\n          notMatcher.addSelectables(notSelectors, null);\n          return notMatcher;\n      };\n      SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n          var listContext = null;\n          if (cssSelectors.length > 1) {\n              listContext = new SelectorListContext(cssSelectors);\n              this._listContexts.push(listContext);\n          }\n          for (var i = 0; i < cssSelectors.length; i++) {\n              this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n          }\n      };\n      /**\n       * Add an object that can be found later on by calling `match`.\n       * @param cssSelector A css selector\n       * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n       */\n      SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n          var matcher = this;\n          var element = cssSelector.element;\n          var classNames = cssSelector.classNames;\n          var attrs = cssSelector.attrs;\n          var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n          if (element) {\n              var isTerminal = attrs.length === 0 && classNames.length === 0;\n              if (isTerminal) {\n                  this._addTerminal(matcher._elementMap, element, selectable);\n              }\n              else {\n                  matcher = this._addPartial(matcher._elementPartialMap, element);\n              }\n          }\n          if (classNames) {\n              for (var i = 0; i < classNames.length; i++) {\n                  var isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                  var className = classNames[i];\n                  if (isTerminal) {\n                      this._addTerminal(matcher._classMap, className, selectable);\n                  }\n                  else {\n                      matcher = this._addPartial(matcher._classPartialMap, className);\n                  }\n              }\n          }\n          if (attrs) {\n              for (var i = 0; i < attrs.length; i += 2) {\n                  var isTerminal = i === attrs.length - 2;\n                  var name_2 = attrs[i];\n                  var value = attrs[i + 1];\n                  if (isTerminal) {\n                      var terminalMap = matcher._attrValueMap;\n                      var terminalValuesMap = terminalMap.get(name_2);\n                      if (!terminalValuesMap) {\n                          terminalValuesMap = new Map();\n                          terminalMap.set(name_2, terminalValuesMap);\n                      }\n                      this._addTerminal(terminalValuesMap, value, selectable);\n                  }\n                  else {\n                      var partialMap = matcher._attrValuePartialMap;\n                      var partialValuesMap = partialMap.get(name_2);\n                      if (!partialValuesMap) {\n                          partialValuesMap = new Map();\n                          partialMap.set(name_2, partialValuesMap);\n                      }\n                      matcher = this._addPartial(partialValuesMap, value);\n                  }\n              }\n          }\n      };\n      SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n          var terminalList = map.get(name);\n          if (!terminalList) {\n              terminalList = [];\n              map.set(name, terminalList);\n          }\n          terminalList.push(selectable);\n      };\n      SelectorMatcher.prototype._addPartial = function (map, name) {\n          var matcher = map.get(name);\n          if (!matcher) {\n              matcher = new SelectorMatcher();\n              map.set(name, matcher);\n          }\n          return matcher;\n      };\n      /**\n       * Find the objects that have been added via `addSelectable`\n       * whose css selector is contained in the given css selector.\n       * @param cssSelector A css selector\n       * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n       * @return boolean true if a match was found\n      */\n      SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n          var result = false;\n          var element = cssSelector.element;\n          var classNames = cssSelector.classNames;\n          var attrs = cssSelector.attrs;\n          for (var i = 0; i < this._listContexts.length; i++) {\n              this._listContexts[i].alreadyMatched = false;\n          }\n          result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n          result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n              result;\n          if (classNames) {\n              for (var i = 0; i < classNames.length; i++) {\n                  var className = classNames[i];\n                  result =\n                      this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                  result =\n                      this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                          result;\n              }\n          }\n          if (attrs) {\n              for (var i = 0; i < attrs.length; i += 2) {\n                  var name_3 = attrs[i];\n                  var value = attrs[i + 1];\n                  var terminalValuesMap = this._attrValueMap.get(name_3);\n                  if (value) {\n                      result =\n                          this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                  }\n                  result =\n                      this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                  var partialValuesMap = this._attrValuePartialMap.get(name_3);\n                  if (value) {\n                      result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                  }\n                  result =\n                      this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n              }\n          }\n          return result;\n      };\n      /** @internal */\n      SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n          if (!map || typeof name !== 'string') {\n              return false;\n          }\n          var selectables = map.get(name);\n          var starSelectables = map.get('*');\n          if (starSelectables) {\n              selectables = selectables.concat(starSelectables);\n          }\n          if (!selectables) {\n              return false;\n          }\n          var selectable;\n          var result = false;\n          for (var i = 0; i < selectables.length; i++) {\n              selectable = selectables[i];\n              result = selectable.finalize(cssSelector, matchedCallback) || result;\n          }\n          return result;\n      };\n      /** @internal */\n      SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n          if (!map || typeof name !== 'string') {\n              return false;\n          }\n          var nestedSelector = map.get(name);\n          if (!nestedSelector) {\n              return false;\n          }\n          // TODO(perf): get rid of recursion and measure again\n          // TODO(perf): don't pass the whole selector into the recursion,\n          // but only the not processed parts\n          return nestedSelector.match(cssSelector, matchedCallback);\n      };\n      return SelectorMatcher;\n  }());\n  var SelectorListContext = (function () {\n      function SelectorListContext(selectors) {\n          this.selectors = selectors;\n          this.alreadyMatched = false;\n      }\n      return SelectorListContext;\n  }());\n  // Store context to pass back selector and context when a selector is matched\n  var SelectorContext = (function () {\n      function SelectorContext(selector, cbContext, listContext) {\n          this.selector = selector;\n          this.cbContext = cbContext;\n          this.listContext = listContext;\n          this.notSelectors = selector.notSelectors;\n      }\n      SelectorContext.prototype.finalize = function (cssSelector, callback) {\n          var result = true;\n          if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n              var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n              result = !notMatcher.match(cssSelector, null);\n          }\n          if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n              if (this.listContext) {\n                  this.listContext.alreadyMatched = true;\n              }\n              callback(this.selector, this.cbContext);\n          }\n          return result;\n      };\n      return SelectorContext;\n  }());\n\n  var MODULE_SUFFIX = '';\n  var DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n  function dashCaseToCamelCase(input) {\n      return input.replace(DASH_CASE_REGEXP, function () {\n          var m = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              m[_i - 0] = arguments[_i];\n          }\n          return m[1].toUpperCase();\n      });\n  }\n  function splitAtColon(input, defaultValues) {\n      return _splitAt(input, ':', defaultValues);\n  }\n  function splitAtPeriod(input, defaultValues) {\n      return _splitAt(input, '.', defaultValues);\n  }\n  function _splitAt(input, character, defaultValues) {\n      var characterIndex = input.indexOf(character);\n      if (characterIndex == -1)\n          return defaultValues;\n      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n  }\n  function sanitizeIdentifier(name) {\n      return name.replace(/\\W/g, '_');\n  }\n  function visitValue(value, visitor, context) {\n      if (Array.isArray(value)) {\n          return visitor.visitArray(value, context);\n      }\n      if (isStrictStringMap(value)) {\n          return visitor.visitStringMap(value, context);\n      }\n      if (isBlank(value) || isPrimitive(value)) {\n          return visitor.visitPrimitive(value, context);\n      }\n      return visitor.visitOther(value, context);\n  }\n  var ValueTransformer = (function () {\n      function ValueTransformer() {\n      }\n      ValueTransformer.prototype.visitArray = function (arr, context) {\n          var _this = this;\n          return arr.map(function (value) { return visitValue(value, _this, context); });\n      };\n      ValueTransformer.prototype.visitStringMap = function (map, context) {\n          var _this = this;\n          var result = {};\n          Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });\n          return result;\n      };\n      ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };\n      ValueTransformer.prototype.visitOther = function (value, context) { return value; };\n      return ValueTransformer;\n  }());\n  var SyncAsyncResult = (function () {\n      function SyncAsyncResult(syncResult, asyncResult) {\n          if (asyncResult === void 0) { asyncResult = null; }\n          this.syncResult = syncResult;\n          this.asyncResult = asyncResult;\n          if (!asyncResult) {\n              this.asyncResult = Promise.resolve(syncResult);\n          }\n      }\n      return SyncAsyncResult;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$7 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  function unimplemented() {\n      throw new Error('unimplemented');\n  }\n  // group 0: \"[prop] or (event) or @trigger\"\n  // group 1: \"prop\" from \"[prop]\"\n  // group 2: \"event\" from \"(event)\"\n  // group 3: \"@trigger\" from \"@trigger\"\n  var HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n  var CompileMetadataWithIdentifier = (function () {\n      function CompileMetadataWithIdentifier() {\n      }\n      Object.defineProperty(CompileMetadataWithIdentifier.prototype, \"identifier\", {\n          get: function () { return unimplemented(); },\n          enumerable: true,\n          configurable: true\n      });\n      return CompileMetadataWithIdentifier;\n  }());\n  var CompileAnimationEntryMetadata = (function () {\n      function CompileAnimationEntryMetadata(name, definitions) {\n          if (name === void 0) { name = null; }\n          if (definitions === void 0) { definitions = null; }\n          this.name = name;\n          this.definitions = definitions;\n      }\n      return CompileAnimationEntryMetadata;\n  }());\n  var CompileAnimationStateMetadata = (function () {\n      function CompileAnimationStateMetadata() {\n      }\n      return CompileAnimationStateMetadata;\n  }());\n  var CompileAnimationStateDeclarationMetadata = (function (_super) {\n      __extends$7(CompileAnimationStateDeclarationMetadata, _super);\n      function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {\n          _super.call(this);\n          this.stateNameExpr = stateNameExpr;\n          this.styles = styles;\n      }\n      return CompileAnimationStateDeclarationMetadata;\n  }(CompileAnimationStateMetadata));\n  var CompileAnimationStateTransitionMetadata = (function (_super) {\n      __extends$7(CompileAnimationStateTransitionMetadata, _super);\n      function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {\n          _super.call(this);\n          this.stateChangeExpr = stateChangeExpr;\n          this.steps = steps;\n      }\n      return CompileAnimationStateTransitionMetadata;\n  }(CompileAnimationStateMetadata));\n  var CompileAnimationMetadata = (function () {\n      function CompileAnimationMetadata() {\n      }\n      return CompileAnimationMetadata;\n  }());\n  var CompileAnimationKeyframesSequenceMetadata = (function (_super) {\n      __extends$7(CompileAnimationKeyframesSequenceMetadata, _super);\n      function CompileAnimationKeyframesSequenceMetadata(steps) {\n          if (steps === void 0) { steps = []; }\n          _super.call(this);\n          this.steps = steps;\n      }\n      return CompileAnimationKeyframesSequenceMetadata;\n  }(CompileAnimationMetadata));\n  var CompileAnimationStyleMetadata = (function (_super) {\n      __extends$7(CompileAnimationStyleMetadata, _super);\n      function CompileAnimationStyleMetadata(offset, styles) {\n          if (styles === void 0) { styles = null; }\n          _super.call(this);\n          this.offset = offset;\n          this.styles = styles;\n      }\n      return CompileAnimationStyleMetadata;\n  }(CompileAnimationMetadata));\n  var CompileAnimationAnimateMetadata = (function (_super) {\n      __extends$7(CompileAnimationAnimateMetadata, _super);\n      function CompileAnimationAnimateMetadata(timings, styles) {\n          if (timings === void 0) { timings = 0; }\n          if (styles === void 0) { styles = null; }\n          _super.call(this);\n          this.timings = timings;\n          this.styles = styles;\n      }\n      return CompileAnimationAnimateMetadata;\n  }(CompileAnimationMetadata));\n  var CompileAnimationWithStepsMetadata = (function (_super) {\n      __extends$7(CompileAnimationWithStepsMetadata, _super);\n      function CompileAnimationWithStepsMetadata(steps) {\n          if (steps === void 0) { steps = null; }\n          _super.call(this);\n          this.steps = steps;\n      }\n      return CompileAnimationWithStepsMetadata;\n  }(CompileAnimationMetadata));\n  var CompileAnimationSequenceMetadata = (function (_super) {\n      __extends$7(CompileAnimationSequenceMetadata, _super);\n      function CompileAnimationSequenceMetadata(steps) {\n          if (steps === void 0) { steps = null; }\n          _super.call(this, steps);\n      }\n      return CompileAnimationSequenceMetadata;\n  }(CompileAnimationWithStepsMetadata));\n  var CompileAnimationGroupMetadata = (function (_super) {\n      __extends$7(CompileAnimationGroupMetadata, _super);\n      function CompileAnimationGroupMetadata(steps) {\n          if (steps === void 0) { steps = null; }\n          _super.call(this, steps);\n      }\n      return CompileAnimationGroupMetadata;\n  }(CompileAnimationWithStepsMetadata));\n  var CompileIdentifierMetadata = (function () {\n      function CompileIdentifierMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, value = _b.value;\n          this.reference = reference;\n          this.name = name;\n          this.prefix = prefix;\n          this.moduleUrl = moduleUrl;\n          this.value = value;\n      }\n      Object.defineProperty(CompileIdentifierMetadata.prototype, \"identifier\", {\n          get: function () { return this; },\n          enumerable: true,\n          configurable: true\n      });\n      return CompileIdentifierMetadata;\n  }());\n  var CompileDiDependencyMetadata = (function () {\n      function CompileDiDependencyMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, isAttribute = _b.isAttribute, isSelf = _b.isSelf, isHost = _b.isHost, isSkipSelf = _b.isSkipSelf, isOptional = _b.isOptional, isValue = _b.isValue, token = _b.token, value = _b.value;\n          this.isAttribute = !!isAttribute;\n          this.isSelf = !!isSelf;\n          this.isHost = !!isHost;\n          this.isSkipSelf = !!isSkipSelf;\n          this.isOptional = !!isOptional;\n          this.isValue = !!isValue;\n          this.token = token;\n          this.value = value;\n      }\n      return CompileDiDependencyMetadata;\n  }());\n  var CompileProviderMetadata = (function () {\n      function CompileProviderMetadata(_a) {\n          var token = _a.token, useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n          this.token = token;\n          this.useClass = useClass;\n          this.useValue = useValue;\n          this.useExisting = useExisting;\n          this.useFactory = useFactory;\n          this.deps = deps || null;\n          this.multi = !!multi;\n      }\n      return CompileProviderMetadata;\n  }());\n  var CompileFactoryMetadata = (function (_super) {\n      __extends$7(CompileFactoryMetadata, _super);\n      function CompileFactoryMetadata(_a) {\n          var reference = _a.reference, name = _a.name, moduleUrl = _a.moduleUrl, prefix = _a.prefix, diDeps = _a.diDeps, value = _a.value;\n          _super.call(this, { reference: reference, name: name, prefix: prefix, moduleUrl: moduleUrl, value: value });\n          this.diDeps = _normalizeArray(diDeps);\n      }\n      return CompileFactoryMetadata;\n  }(CompileIdentifierMetadata));\n  var CompileTokenMetadata = (function () {\n      function CompileTokenMetadata(_a) {\n          var value = _a.value, identifier = _a.identifier, identifierIsInstance = _a.identifierIsInstance;\n          this.value = value;\n          this.identifier = identifier;\n          this.identifierIsInstance = !!identifierIsInstance;\n      }\n      Object.defineProperty(CompileTokenMetadata.prototype, \"reference\", {\n          get: function () {\n              if (isPresent(this.identifier)) {\n                  return this.identifier.reference;\n              }\n              else {\n                  return this.value;\n              }\n          },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(CompileTokenMetadata.prototype, \"name\", {\n          get: function () {\n              return isPresent(this.value) ? sanitizeIdentifier(this.value) : this.identifier.name;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      return CompileTokenMetadata;\n  }());\n  /**\n   * Metadata regarding compilation of a type.\n   */\n  var CompileTypeMetadata = (function (_super) {\n      __extends$7(CompileTypeMetadata, _super);\n      function CompileTypeMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, isHost = _b.isHost, value = _b.value, diDeps = _b.diDeps, lifecycleHooks = _b.lifecycleHooks;\n          _super.call(this, { reference: reference, name: name, moduleUrl: moduleUrl, prefix: prefix, value: value });\n          this.isHost = !!isHost;\n          this.diDeps = _normalizeArray(diDeps);\n          this.lifecycleHooks = _normalizeArray(lifecycleHooks);\n      }\n      return CompileTypeMetadata;\n  }(CompileIdentifierMetadata));\n  var CompileQueryMetadata = (function () {\n      function CompileQueryMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, selectors = _b.selectors, descendants = _b.descendants, first = _b.first, propertyName = _b.propertyName, read = _b.read;\n          this.selectors = selectors;\n          this.descendants = !!descendants;\n          this.first = !!first;\n          this.propertyName = propertyName;\n          this.read = read;\n      }\n      return CompileQueryMetadata;\n  }());\n  /**\n   * Metadata about a stylesheet\n   */\n  var CompileStylesheetMetadata = (function () {\n      function CompileStylesheetMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;\n          this.moduleUrl = moduleUrl;\n          this.styles = _normalizeArray(styles);\n          this.styleUrls = _normalizeArray(styleUrls);\n      }\n      return CompileStylesheetMetadata;\n  }());\n  /**\n   * Metadata regarding compilation of a template.\n   */\n  var CompileTemplateMetadata = (function () {\n      function CompileTemplateMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, externalStylesheets = _b.externalStylesheets, animations = _b.animations, ngContentSelectors = _b.ngContentSelectors, interpolation = _b.interpolation;\n          this.encapsulation = encapsulation;\n          this.template = template;\n          this.templateUrl = templateUrl;\n          this.styles = _normalizeArray(styles);\n          this.styleUrls = _normalizeArray(styleUrls);\n          this.externalStylesheets = _normalizeArray(externalStylesheets);\n          this.animations = animations ? ListWrapper.flatten(animations) : [];\n          this.ngContentSelectors = ngContentSelectors || [];\n          if (interpolation && interpolation.length != 2) {\n              throw new Error(\"'interpolation' should have a start and an end symbol.\");\n          }\n          this.interpolation = interpolation;\n      }\n      CompileTemplateMetadata.prototype.toSummary = function () {\n          return {\n              isSummary: true,\n              animations: this.animations.map(function (anim) { return anim.name; }),\n              ngContentSelectors: this.ngContentSelectors,\n              encapsulation: this.encapsulation\n          };\n      };\n      return CompileTemplateMetadata;\n  }());\n  /**\n   * Metadata regarding compilation of a directive.\n   */\n  var CompileDirectiveMetadata = (function () {\n      function CompileDirectiveMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;\n          this.type = type;\n          this.isComponent = isComponent;\n          this.selector = selector;\n          this.exportAs = exportAs;\n          this.changeDetection = changeDetection;\n          this.inputs = inputs;\n          this.outputs = outputs;\n          this.hostListeners = hostListeners;\n          this.hostProperties = hostProperties;\n          this.hostAttributes = hostAttributes;\n          this.providers = _normalizeArray(providers);\n          this.viewProviders = _normalizeArray(viewProviders);\n          this.queries = _normalizeArray(queries);\n          this.viewQueries = _normalizeArray(viewQueries);\n          this.entryComponents = _normalizeArray(entryComponents);\n          this.template = template;\n      }\n      CompileDirectiveMetadata.create = function (_a) {\n          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;\n          var hostListeners = {};\n          var hostProperties = {};\n          var hostAttributes = {};\n          if (isPresent(host)) {\n              Object.keys(host).forEach(function (key) {\n                  var value = host[key];\n                  var matches = key.match(HOST_REG_EXP);\n                  if (matches === null) {\n                      hostAttributes[key] = value;\n                  }\n                  else if (isPresent(matches[1])) {\n                      hostProperties[matches[1]] = value;\n                  }\n                  else if (isPresent(matches[2])) {\n                      hostListeners[matches[2]] = value;\n                  }\n              });\n          }\n          var inputsMap = {};\n          if (isPresent(inputs)) {\n              inputs.forEach(function (bindConfig) {\n                  // canonical syntax: `dirProp: elProp`\n                  // if there is no `:`, use dirProp = elProp\n                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                  inputsMap[parts[0]] = parts[1];\n              });\n          }\n          var outputsMap = {};\n          if (isPresent(outputs)) {\n              outputs.forEach(function (bindConfig) {\n                  // canonical syntax: `dirProp: elProp`\n                  // if there is no `:`, use dirProp = elProp\n                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                  outputsMap[parts[0]] = parts[1];\n              });\n          }\n          return new CompileDirectiveMetadata({\n              type: type,\n              isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,\n              inputs: inputsMap,\n              outputs: outputsMap,\n              hostListeners: hostListeners,\n              hostProperties: hostProperties,\n              hostAttributes: hostAttributes,\n              providers: providers,\n              viewProviders: viewProviders,\n              queries: queries,\n              viewQueries: viewQueries,\n              entryComponents: entryComponents,\n              template: template,\n          });\n      };\n      Object.defineProperty(CompileDirectiveMetadata.prototype, \"identifier\", {\n          get: function () { return this.type; },\n          enumerable: true,\n          configurable: true\n      });\n      CompileDirectiveMetadata.prototype.toSummary = function () {\n          return {\n              isSummary: true,\n              type: this.type,\n              isComponent: this.isComponent,\n              selector: this.selector,\n              exportAs: this.exportAs,\n              inputs: this.inputs,\n              outputs: this.outputs,\n              hostListeners: this.hostListeners,\n              hostProperties: this.hostProperties,\n              hostAttributes: this.hostAttributes,\n              providers: this.providers,\n              viewProviders: this.viewProviders,\n              queries: this.queries,\n              entryComponents: this.entryComponents,\n              changeDetection: this.changeDetection,\n              template: this.template && this.template.toSummary()\n          };\n      };\n      return CompileDirectiveMetadata;\n  }());\n  /**\n   * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.\n   */\n  function createHostComponentMeta(compMeta) {\n      var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\n      return CompileDirectiveMetadata.create({\n          type: new CompileTypeMetadata({\n              reference: Object,\n              name: compMeta.type.name + \"_Host\",\n              moduleUrl: compMeta.type.moduleUrl,\n              isHost: true\n          }),\n          template: new CompileTemplateMetadata({\n              encapsulation: _angular_core.ViewEncapsulation.None,\n              template: template,\n              templateUrl: '',\n              styles: [],\n              styleUrls: [],\n              ngContentSelectors: [],\n              animations: []\n          }),\n          changeDetection: _angular_core.ChangeDetectionStrategy.Default,\n          inputs: [],\n          outputs: [],\n          host: {},\n          isComponent: true,\n          selector: '*',\n          providers: [],\n          viewProviders: [],\n          queries: [],\n          viewQueries: []\n      });\n  }\n  var CompilePipeMetadata = (function () {\n      function CompilePipeMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;\n          this.type = type;\n          this.name = name;\n          this.pure = !!pure;\n      }\n      Object.defineProperty(CompilePipeMetadata.prototype, \"identifier\", {\n          get: function () { return this.type; },\n          enumerable: true,\n          configurable: true\n      });\n      CompilePipeMetadata.prototype.toSummary = function () {\n          return { isSummary: true, type: this.type, name: this.name, pure: this.pure };\n      };\n      return CompilePipeMetadata;\n  }());\n  /**\n   * Metadata regarding compilation of a module.\n   */\n  var CompileNgModuleMetadata = (function () {\n      function CompileNgModuleMetadata(_a) {\n          var _b = _a === void 0 ? {} : _a, type = _b.type, providers = _b.providers, declaredDirectives = _b.declaredDirectives, exportedDirectives = _b.exportedDirectives, declaredPipes = _b.declaredPipes, exportedPipes = _b.exportedPipes, entryComponents = _b.entryComponents, bootstrapComponents = _b.bootstrapComponents, importedModules = _b.importedModules, exportedModules = _b.exportedModules, schemas = _b.schemas, transitiveModule = _b.transitiveModule, id = _b.id;\n          this.type = type;\n          this.declaredDirectives = _normalizeArray(declaredDirectives);\n          this.exportedDirectives = _normalizeArray(exportedDirectives);\n          this.declaredPipes = _normalizeArray(declaredPipes);\n          this.exportedPipes = _normalizeArray(exportedPipes);\n          this.providers = _normalizeArray(providers);\n          this.entryComponents = _normalizeArray(entryComponents);\n          this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n          this.importedModules = _normalizeArray(importedModules);\n          this.exportedModules = _normalizeArray(exportedModules);\n          this.schemas = _normalizeArray(schemas);\n          this.id = id;\n          this.transitiveModule = transitiveModule;\n      }\n      Object.defineProperty(CompileNgModuleMetadata.prototype, \"identifier\", {\n          get: function () { return this.type; },\n          enumerable: true,\n          configurable: true\n      });\n      CompileNgModuleMetadata.prototype.toSummary = function () {\n          return {\n              isSummary: true,\n              type: this.type,\n              entryComponents: this.entryComponents,\n              providers: this.providers,\n              importedModules: this.importedModules,\n              exportedModules: this.exportedModules,\n              exportedDirectives: this.exportedDirectives,\n              exportedPipes: this.exportedPipes,\n              loadingPromises: this.transitiveModule.loadingPromises\n          };\n      };\n      CompileNgModuleMetadata.prototype.toInjectorSummary = function () {\n          return {\n              isSummary: true,\n              type: this.type,\n              entryComponents: this.entryComponents,\n              providers: this.providers,\n              importedModules: this.importedModules,\n              exportedModules: this.exportedModules\n          };\n      };\n      CompileNgModuleMetadata.prototype.toDirectiveSummary = function () {\n          return {\n              isSummary: true,\n              type: this.type,\n              exportedDirectives: this.exportedDirectives,\n              exportedPipes: this.exportedPipes,\n              exportedModules: this.exportedModules,\n              loadingPromises: this.transitiveModule.loadingPromises\n          };\n      };\n      return CompileNgModuleMetadata;\n  }());\n  var TransitiveCompileNgModuleMetadata = (function () {\n      function TransitiveCompileNgModuleMetadata(modules, providers, entryComponents, directives, pipes, loadingPromises) {\n          var _this = this;\n          this.modules = modules;\n          this.providers = providers;\n          this.entryComponents = entryComponents;\n          this.directives = directives;\n          this.pipes = pipes;\n          this.loadingPromises = loadingPromises;\n          this.directivesSet = new Set();\n          this.pipesSet = new Set();\n          directives.forEach(function (dir) { return _this.directivesSet.add(dir.reference); });\n          pipes.forEach(function (pipe) { return _this.pipesSet.add(pipe.reference); });\n      }\n      return TransitiveCompileNgModuleMetadata;\n  }());\n  function removeIdentifierDuplicates(items) {\n      var map = new Map();\n      items.forEach(function (item) {\n          if (!map.get(item.identifier.reference)) {\n              map.set(item.identifier.reference, item);\n          }\n      });\n      return Array.from(map.values());\n  }\n  function _normalizeArray(obj) {\n      return obj || [];\n  }\n  function isStaticSymbol(value) {\n      return typeof value === 'object' && value !== null && value['name'] && value['filePath'];\n  }\n  var ProviderMeta = (function () {\n      function ProviderMeta(token, _a) {\n          var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n          this.token = token;\n          this.useClass = useClass;\n          this.useValue = useValue;\n          this.useExisting = useExisting;\n          this.useFactory = useFactory;\n          this.dependencies = deps;\n          this.multi = !!multi;\n      }\n      return ProviderMeta;\n  }());\n\n  var isDefaultChangeDetectionStrategy = _angular_core.__core_private__.isDefaultChangeDetectionStrategy;\n  var ChangeDetectorStatus = _angular_core.__core_private__.ChangeDetectorStatus;\n  var LifecycleHooks = _angular_core.__core_private__.LifecycleHooks;\n  var LIFECYCLE_HOOKS_VALUES = _angular_core.__core_private__.LIFECYCLE_HOOKS_VALUES;\n  var ReflectorReader = _angular_core.__core_private__.ReflectorReader;\n  var ViewContainer = _angular_core.__core_private__.ViewContainer;\n  var CodegenComponentFactoryResolver = _angular_core.__core_private__.CodegenComponentFactoryResolver;\n  var ComponentRef_ = _angular_core.__core_private__.ComponentRef_;\n  var AppView = _angular_core.__core_private__.AppView;\n  var DebugAppView = _angular_core.__core_private__.DebugAppView;\n  var NgModuleInjector = _angular_core.__core_private__.NgModuleInjector;\n  var registerModuleFactory = _angular_core.__core_private__.registerModuleFactory;\n  var ViewType = _angular_core.__core_private__.ViewType;\n  var view_utils = _angular_core.__core_private__.view_utils;\n  var DebugContext = _angular_core.__core_private__.DebugContext;\n  var StaticNodeDebugInfo = _angular_core.__core_private__.StaticNodeDebugInfo;\n  var devModeEqual = _angular_core.__core_private__.devModeEqual;\n  var UNINITIALIZED = _angular_core.__core_private__.UNINITIALIZED;\n  var ValueUnwrapper = _angular_core.__core_private__.ValueUnwrapper;\n  var TemplateRef_ = _angular_core.__core_private__.TemplateRef_;\n  var Console = _angular_core.__core_private__.Console;\n  var reflector = _angular_core.__core_private__.reflector;\n  var Reflector = _angular_core.__core_private__.Reflector;\n  var ReflectionCapabilities = _angular_core.__core_private__.ReflectionCapabilities;\n  var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;\n  var AnimationSequencePlayer = _angular_core.__core_private__.AnimationSequencePlayer;\n  var AnimationGroupPlayer = _angular_core.__core_private__.AnimationGroupPlayer;\n  var AnimationKeyframe = _angular_core.__core_private__.AnimationKeyframe;\n  var AnimationStyles = _angular_core.__core_private__.AnimationStyles;\n  var ANY_STATE = _angular_core.__core_private__.ANY_STATE;\n  var DEFAULT_STATE = _angular_core.__core_private__.DEFAULT_STATE;\n  var EMPTY_ANIMATION_STATE = _angular_core.__core_private__.EMPTY_STATE;\n  var FILL_STYLE_FLAG = _angular_core.__core_private__.FILL_STYLE_FLAG;\n  var prepareFinalAnimationStyles = _angular_core.__core_private__.prepareFinalAnimationStyles;\n  var balanceAnimationKeyframes = _angular_core.__core_private__.balanceAnimationKeyframes;\n  var clearStyles = _angular_core.__core_private__.clearStyles;\n  var collectAndResolveStyles = _angular_core.__core_private__.collectAndResolveStyles;\n  var renderStyles = _angular_core.__core_private__.renderStyles;\n  var ComponentStillLoadingError = _angular_core.__core_private__.ComponentStillLoadingError;\n  var AnimationTransition = _angular_core.__core_private__.AnimationTransition;\n\n  var APP_VIEW_MODULE_URL = assetUrl('core', 'linker/view');\n  var VIEW_UTILS_MODULE_URL = assetUrl('core', 'linker/view_utils');\n  var CD_MODULE_URL = assetUrl('core', 'change_detection/change_detection');\n  var ANIMATION_STYLE_UTIL_ASSET_URL = assetUrl('core', 'animation/animation_style_util');\n  var Identifiers = (function () {\n      function Identifiers() {\n      }\n      Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n          name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n          moduleUrl: assetUrl('core', 'metadata/di'),\n          runtime: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS\n      };\n      Identifiers.ViewUtils = {\n          name: 'ViewUtils',\n          moduleUrl: assetUrl('core', 'linker/view_utils'),\n          runtime: view_utils.ViewUtils\n      };\n      Identifiers.AppView = { name: 'AppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: AppView };\n      Identifiers.DebugAppView = {\n          name: 'DebugAppView',\n          moduleUrl: APP_VIEW_MODULE_URL,\n          runtime: DebugAppView\n      };\n      Identifiers.ViewContainer = {\n          name: 'ViewContainer',\n          moduleUrl: assetUrl('core', 'linker/view_container'),\n          runtime: ViewContainer\n      };\n      Identifiers.ElementRef = {\n          name: 'ElementRef',\n          moduleUrl: assetUrl('core', 'linker/element_ref'),\n          runtime: _angular_core.ElementRef\n      };\n      Identifiers.ViewContainerRef = {\n          name: 'ViewContainerRef',\n          moduleUrl: assetUrl('core', 'linker/view_container_ref'),\n          runtime: _angular_core.ViewContainerRef\n      };\n      Identifiers.ChangeDetectorRef = {\n          name: 'ChangeDetectorRef',\n          moduleUrl: assetUrl('core', 'change_detection/change_detector_ref'),\n          runtime: _angular_core.ChangeDetectorRef\n      };\n      Identifiers.RenderComponentType = {\n          name: 'RenderComponentType',\n          moduleUrl: assetUrl('core', 'render/api'),\n          runtime: _angular_core.RenderComponentType\n      };\n      Identifiers.QueryList = {\n          name: 'QueryList',\n          moduleUrl: assetUrl('core', 'linker/query_list'),\n          runtime: _angular_core.QueryList\n      };\n      Identifiers.TemplateRef = {\n          name: 'TemplateRef',\n          moduleUrl: assetUrl('core', 'linker/template_ref'),\n          runtime: _angular_core.TemplateRef\n      };\n      Identifiers.TemplateRef_ = {\n          name: 'TemplateRef_',\n          moduleUrl: assetUrl('core', 'linker/template_ref'),\n          runtime: TemplateRef_\n      };\n      Identifiers.CodegenComponentFactoryResolver = {\n          name: 'CodegenComponentFactoryResolver',\n          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),\n          runtime: CodegenComponentFactoryResolver\n      };\n      Identifiers.ComponentFactoryResolver = {\n          name: 'ComponentFactoryResolver',\n          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),\n          runtime: _angular_core.ComponentFactoryResolver\n      };\n      Identifiers.ComponentFactory = {\n          name: 'ComponentFactory',\n          runtime: _angular_core.ComponentFactory,\n          moduleUrl: assetUrl('core', 'linker/component_factory')\n      };\n      Identifiers.ComponentRef_ = {\n          name: 'ComponentRef_',\n          runtime: ComponentRef_,\n          moduleUrl: assetUrl('core', 'linker/component_factory')\n      };\n      Identifiers.ComponentRef = {\n          name: 'ComponentRef',\n          runtime: _angular_core.ComponentRef,\n          moduleUrl: assetUrl('core', 'linker/component_factory')\n      };\n      Identifiers.NgModuleFactory = {\n          name: 'NgModuleFactory',\n          runtime: _angular_core.NgModuleFactory,\n          moduleUrl: assetUrl('core', 'linker/ng_module_factory')\n      };\n      Identifiers.NgModuleInjector = {\n          name: 'NgModuleInjector',\n          runtime: NgModuleInjector,\n          moduleUrl: assetUrl('core', 'linker/ng_module_factory')\n      };\n      Identifiers.RegisterModuleFactoryFn = {\n          name: 'registerModuleFactory',\n          runtime: registerModuleFactory,\n          moduleUrl: assetUrl('core', 'linker/ng_module_factory_loader')\n      };\n      Identifiers.ValueUnwrapper = { name: 'ValueUnwrapper', moduleUrl: CD_MODULE_URL, runtime: ValueUnwrapper };\n      Identifiers.Injector = {\n          name: 'Injector',\n          moduleUrl: assetUrl('core', 'di/injector'),\n          runtime: _angular_core.Injector\n      };\n      Identifiers.ViewEncapsulation = {\n          name: 'ViewEncapsulation',\n          moduleUrl: assetUrl('core', 'metadata/view'),\n          runtime: _angular_core.ViewEncapsulation\n      };\n      Identifiers.ViewType = {\n          name: 'ViewType',\n          moduleUrl: assetUrl('core', 'linker/view_type'),\n          runtime: ViewType\n      };\n      Identifiers.ChangeDetectionStrategy = {\n          name: 'ChangeDetectionStrategy',\n          moduleUrl: CD_MODULE_URL,\n          runtime: _angular_core.ChangeDetectionStrategy\n      };\n      Identifiers.StaticNodeDebugInfo = {\n          name: 'StaticNodeDebugInfo',\n          moduleUrl: assetUrl('core', 'linker/debug_context'),\n          runtime: StaticNodeDebugInfo\n      };\n      Identifiers.DebugContext = {\n          name: 'DebugContext',\n          moduleUrl: assetUrl('core', 'linker/debug_context'),\n          runtime: DebugContext\n      };\n      Identifiers.Renderer = {\n          name: 'Renderer',\n          moduleUrl: assetUrl('core', 'render/api'),\n          runtime: _angular_core.Renderer\n      };\n      Identifiers.SimpleChange = { name: 'SimpleChange', moduleUrl: CD_MODULE_URL, runtime: _angular_core.SimpleChange };\n      Identifiers.UNINITIALIZED = { name: 'UNINITIALIZED', moduleUrl: CD_MODULE_URL, runtime: UNINITIALIZED };\n      Identifiers.ChangeDetectorStatus = {\n          name: 'ChangeDetectorStatus',\n          moduleUrl: CD_MODULE_URL,\n          runtime: ChangeDetectorStatus\n      };\n      Identifiers.checkBinding = {\n          name: 'checkBinding',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.checkBinding\n      };\n      Identifiers.devModeEqual = { name: 'devModeEqual', moduleUrl: CD_MODULE_URL, runtime: devModeEqual };\n      Identifiers.inlineInterpolate = {\n          name: 'inlineInterpolate',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.inlineInterpolate\n      };\n      Identifiers.interpolate = {\n          name: 'interpolate',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.interpolate\n      };\n      Identifiers.castByValue = {\n          name: 'castByValue',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.castByValue\n      };\n      Identifiers.EMPTY_ARRAY = {\n          name: 'EMPTY_ARRAY',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.EMPTY_ARRAY\n      };\n      Identifiers.EMPTY_MAP = {\n          name: 'EMPTY_MAP',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.EMPTY_MAP\n      };\n      Identifiers.createRenderElement = {\n          name: 'createRenderElement',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.createRenderElement\n      };\n      Identifiers.selectOrCreateRenderHostElement = {\n          name: 'selectOrCreateRenderHostElement',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.selectOrCreateRenderHostElement\n      };\n      Identifiers.pureProxies = [\n          null,\n          { name: 'pureProxy1', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy1 },\n          { name: 'pureProxy2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy2 },\n          { name: 'pureProxy3', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy3 },\n          { name: 'pureProxy4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy4 },\n          { name: 'pureProxy5', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy5 },\n          { name: 'pureProxy6', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy6 },\n          { name: 'pureProxy7', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy7 },\n          { name: 'pureProxy8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy8 },\n          { name: 'pureProxy9', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy9 },\n          { name: 'pureProxy10', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy10 },\n      ];\n      Identifiers.SecurityContext = {\n          name: 'SecurityContext',\n          moduleUrl: assetUrl('core', 'security'),\n          runtime: _angular_core.SecurityContext,\n      };\n      Identifiers.AnimationKeyframe = {\n          name: 'AnimationKeyframe',\n          moduleUrl: assetUrl('core', 'animation/animation_keyframe'),\n          runtime: AnimationKeyframe\n      };\n      Identifiers.AnimationStyles = {\n          name: 'AnimationStyles',\n          moduleUrl: assetUrl('core', 'animation/animation_styles'),\n          runtime: AnimationStyles\n      };\n      Identifiers.NoOpAnimationPlayer = {\n          name: 'NoOpAnimationPlayer',\n          moduleUrl: assetUrl('core', 'animation/animation_player'),\n          runtime: NoOpAnimationPlayer\n      };\n      Identifiers.AnimationGroupPlayer = {\n          name: 'AnimationGroupPlayer',\n          moduleUrl: assetUrl('core', 'animation/animation_group_player'),\n          runtime: AnimationGroupPlayer\n      };\n      Identifiers.AnimationSequencePlayer = {\n          name: 'AnimationSequencePlayer',\n          moduleUrl: assetUrl('core', 'animation/animation_sequence_player'),\n          runtime: AnimationSequencePlayer\n      };\n      Identifiers.prepareFinalAnimationStyles = {\n          name: 'prepareFinalAnimationStyles',\n          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,\n          runtime: prepareFinalAnimationStyles\n      };\n      Identifiers.balanceAnimationKeyframes = {\n          name: 'balanceAnimationKeyframes',\n          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,\n          runtime: balanceAnimationKeyframes\n      };\n      Identifiers.clearStyles = {\n          name: 'clearStyles',\n          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,\n          runtime: clearStyles\n      };\n      Identifiers.renderStyles = {\n          name: 'renderStyles',\n          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,\n          runtime: renderStyles\n      };\n      Identifiers.collectAndResolveStyles = {\n          name: 'collectAndResolveStyles',\n          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,\n          runtime: collectAndResolveStyles\n      };\n      Identifiers.LOCALE_ID = {\n          name: 'LOCALE_ID',\n          moduleUrl: assetUrl('core', 'i18n/tokens'),\n          runtime: _angular_core.LOCALE_ID\n      };\n      Identifiers.TRANSLATIONS_FORMAT = {\n          name: 'TRANSLATIONS_FORMAT',\n          moduleUrl: assetUrl('core', 'i18n/tokens'),\n          runtime: _angular_core.TRANSLATIONS_FORMAT\n      };\n      Identifiers.setBindingDebugInfo = {\n          name: 'setBindingDebugInfo',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.setBindingDebugInfo\n      };\n      Identifiers.setBindingDebugInfoForChanges = {\n          name: 'setBindingDebugInfoForChanges',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.setBindingDebugInfoForChanges\n      };\n      Identifiers.AnimationTransition = {\n          name: 'AnimationTransition',\n          moduleUrl: assetUrl('core', 'animation/animation_transition'),\n          runtime: AnimationTransition\n      };\n      // This is just the interface!\n      Identifiers.InlineArray = { name: 'InlineArray', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: null };\n      Identifiers.inlineArrays = [\n          { name: 'InlineArray2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray2 },\n          { name: 'InlineArray2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray2 },\n          { name: 'InlineArray4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray4 },\n          { name: 'InlineArray8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray8 },\n          { name: 'InlineArray16', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.InlineArray16 },\n      ];\n      Identifiers.EMPTY_INLINE_ARRAY = {\n          name: 'EMPTY_INLINE_ARRAY',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.EMPTY_INLINE_ARRAY\n      };\n      Identifiers.InlineArrayDynamic = {\n          name: 'InlineArrayDynamic',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.InlineArrayDynamic\n      };\n      Identifiers.subscribeToRenderElement = {\n          name: 'subscribeToRenderElement',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.subscribeToRenderElement\n      };\n      Identifiers.createRenderComponentType = {\n          name: 'createRenderComponentType',\n          moduleUrl: VIEW_UTILS_MODULE_URL,\n          runtime: view_utils.createRenderComponentType\n      };\n      Identifiers.noop = { name: 'noop', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.noop };\n      return Identifiers;\n  }());\n  function assetUrl(pkg, path, type) {\n      if (path === void 0) { path = null; }\n      if (type === void 0) { type = 'src'; }\n      if (path == null) {\n          return \"asset:@angular/lib/\" + pkg + \"/index\";\n      }\n      else {\n          return \"asset:@angular/lib/\" + pkg + \"/src/\" + path;\n      }\n  }\n  function resolveIdentifier(identifier) {\n      return new CompileIdentifierMetadata({\n          name: identifier.name,\n          moduleUrl: identifier.moduleUrl,\n          reference: reflector.resolveIdentifier(identifier.name, identifier.moduleUrl, identifier.runtime)\n      });\n  }\n  function identifierToken(identifier) {\n      return new CompileTokenMetadata({ identifier: identifier });\n  }\n  function resolveIdentifierToken(identifier) {\n      return identifierToken(resolveIdentifier(identifier));\n  }\n  function resolveEnumIdentifier(enumType, name) {\n      var resolvedEnum = reflector.resolveEnum(enumType.reference, name);\n      return new CompileIdentifierMetadata({ name: enumType.name + \".\" + name, moduleUrl: enumType.moduleUrl, reference: resolvedEnum });\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$8 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var HtmlParser = (function (_super) {\n      __extends$8(HtmlParser, _super);\n      function HtmlParser() {\n          _super.call(this, getHtmlTagDefinition);\n      }\n      HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n          if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n          return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);\n      };\n      HtmlParser.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      HtmlParser.ctorParameters = [];\n      return HtmlParser;\n  }(Parser$1));\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$9 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  // http://cldr.unicode.org/index/cldr-spec/plural-rules\n  var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n  /**\n   * Expands special forms into elements.\n   *\n   * For example,\n   *\n   * ```\n   * { messages.length, plural,\n   *   =0 {zero}\n   *   =1 {one}\n   *   other {more than one}\n   * }\n   * ```\n   *\n   * will be expanded into\n   *\n   * ```\n   * <ng-container [ngPlural]=\"messages.length\">\n   *   <template ngPluralCase=\"=0\">zero</ng-container>\n   *   <template ngPluralCase=\"=1\">one</ng-container>\n   *   <template ngPluralCase=\"other\">more than one</ng-container>\n   * </ng-container>\n   * ```\n   */\n  function expandNodes(nodes) {\n      var expander = new _Expander();\n      return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);\n  }\n  var ExpansionResult = (function () {\n      function ExpansionResult(nodes, expanded, errors) {\n          this.nodes = nodes;\n          this.expanded = expanded;\n          this.errors = errors;\n      }\n      return ExpansionResult;\n  }());\n  var ExpansionError = (function (_super) {\n      __extends$9(ExpansionError, _super);\n      function ExpansionError(span, errorMsg) {\n          _super.call(this, span, errorMsg);\n      }\n      return ExpansionError;\n  }(ParseError));\n  /**\n   * Expand expansion forms (plural, select) to directives\n   *\n   * @internal\n   */\n  var _Expander = (function () {\n      function _Expander() {\n          this.isExpanded = false;\n          this.errors = [];\n      }\n      _Expander.prototype.visitElement = function (element, context) {\n          return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n      };\n      _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };\n      _Expander.prototype.visitText = function (text, context) { return text; };\n      _Expander.prototype.visitComment = function (comment, context) { return comment; };\n      _Expander.prototype.visitExpansion = function (icu, context) {\n          this.isExpanded = true;\n          return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n              _expandDefaultForm(icu, this.errors);\n      };\n      _Expander.prototype.visitExpansionCase = function (icuCase, context) {\n          throw new Error('Should not be reached');\n      };\n      return _Expander;\n  }());\n  function _expandPluralForm(ast, errors) {\n      var children = ast.cases.map(function (c) {\n          if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n              errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \" + PLURAL_CASES.join(\", \")));\n          }\n          var expansionResult = expandNodes(c.expression);\n          errors.push.apply(errors, expansionResult.errors);\n          return new Element(\"template\", [new Attribute$1('ngPluralCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n      });\n      var switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n  }\n  function _expandDefaultForm(ast, errors) {\n      var children = ast.cases.map(function (c) {\n          var expansionResult = expandNodes(c.expression);\n          errors.push.apply(errors, expansionResult.errors);\n          if (c.value === 'other') {\n              // other is the default case when no values match\n              return new Element(\"template\", [new Attribute$1('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n          }\n          return new Element(\"template\", [new Attribute$1('ngSwitchCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n      });\n      var switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$10 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var ProviderError = (function (_super) {\n      __extends$10(ProviderError, _super);\n      function ProviderError(message, span) {\n          _super.call(this, span, message);\n      }\n      return ProviderError;\n  }(ParseError));\n  var ProviderViewContext = (function () {\n      function ProviderViewContext(component, sourceSpan) {\n          var _this = this;\n          this.component = component;\n          this.sourceSpan = sourceSpan;\n          this.errors = [];\n          this.viewQueries = _getViewQueries(component);\n          this.viewProviders = new Map();\n          _normalizeProviders(component.viewProviders, sourceSpan, this.errors).forEach(function (provider) {\n              if (isBlank(_this.viewProviders.get(provider.token.reference))) {\n                  _this.viewProviders.set(provider.token.reference, true);\n              }\n          });\n      }\n      return ProviderViewContext;\n  }());\n  var ProviderElementContext = (function () {\n      function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {\n          var _this = this;\n          this.viewContext = viewContext;\n          this._parent = _parent;\n          this._isViewRoot = _isViewRoot;\n          this._directiveAsts = _directiveAsts;\n          this._sourceSpan = _sourceSpan;\n          this._transformedProviders = new Map();\n          this._seenProviders = new Map();\n          this._hasViewContainer = false;\n          this._attrs = {};\n          attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });\n          var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });\n          this._allProviders =\n              _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n          this._contentQueries = _getContentQueries(directivesMeta);\n          var queriedTokens = new Map();\n          Array.from(this._allProviders.values()).forEach(function (provider) {\n              _this._addQueryReadsTo(provider.token, queriedTokens);\n          });\n          refs.forEach(function (refAst) {\n              _this._addQueryReadsTo(new CompileTokenMetadata({ value: refAst.name }), queriedTokens);\n          });\n          if (isPresent(queriedTokens.get(resolveIdentifierToken(Identifiers.ViewContainerRef).reference))) {\n              this._hasViewContainer = true;\n          }\n          // create the providers that we know are eager first\n          Array.from(this._allProviders.values()).forEach(function (provider) {\n              var eager = provider.eager || isPresent(queriedTokens.get(provider.token.reference));\n              if (eager) {\n                  _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n              }\n          });\n      }\n      ProviderElementContext.prototype.afterElement = function () {\n          var _this = this;\n          // collect lazy providers\n          Array.from(this._allProviders.values()).forEach(function (provider) {\n              _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n          });\n      };\n      Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n          get: function () {\n              return Array.from(this._transformedProviders.values());\n          },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n          get: function () {\n              var sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });\n              var sortedDirectives = this._directiveAsts.slice();\n              sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -\n                  sortedProviderTypes.indexOf(dir2.directive.type); });\n              return sortedDirectives;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(ProviderElementContext.prototype, \"transformedHasViewContainer\", {\n          get: function () { return this._hasViewContainer; },\n          enumerable: true,\n          configurable: true\n      });\n      ProviderElementContext.prototype._addQueryReadsTo = function (token, queryReadTokens) {\n          this._getQueriesFor(token).forEach(function (query) {\n              var queryReadToken = query.read || token;\n              if (isBlank(queryReadTokens.get(queryReadToken.reference))) {\n                  queryReadTokens.set(queryReadToken.reference, true);\n              }\n          });\n      };\n      ProviderElementContext.prototype._getQueriesFor = function (token) {\n          var result = [];\n          var currentEl = this;\n          var distance = 0;\n          var queries;\n          while (currentEl !== null) {\n              queries = currentEl._contentQueries.get(token.reference);\n              if (isPresent(queries)) {\n                  result.push.apply(result, queries.filter(function (query) { return query.descendants || distance <= 1; }));\n              }\n              if (currentEl._directiveAsts.length > 0) {\n                  distance++;\n              }\n              currentEl = currentEl._parent;\n          }\n          queries = this.viewContext.viewQueries.get(token.reference);\n          if (isPresent(queries)) {\n              result.push.apply(result, queries);\n          }\n          return result;\n      };\n      ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n          var _this = this;\n          var resolvedProvider = this._allProviders.get(token.reference);\n          if (!resolvedProvider || ((requestingProviderType === exports.ProviderAstType.Directive ||\n              requestingProviderType === exports.ProviderAstType.PublicService) &&\n              resolvedProvider.providerType === exports.ProviderAstType.PrivateService) ||\n              ((requestingProviderType === exports.ProviderAstType.PrivateService ||\n                  requestingProviderType === exports.ProviderAstType.PublicService) &&\n                  resolvedProvider.providerType === exports.ProviderAstType.Builtin)) {\n              return null;\n          }\n          var transformedProviderAst = this._transformedProviders.get(token.reference);\n          if (isPresent(transformedProviderAst)) {\n              return transformedProviderAst;\n          }\n          if (isPresent(this._seenProviders.get(token.reference))) {\n              this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + token.name, this._sourceSpan));\n              return null;\n          }\n          this._seenProviders.set(token.reference, true);\n          var transformedProviders = resolvedProvider.providers.map(function (provider) {\n              var transformedUseValue = provider.useValue;\n              var transformedUseExisting = provider.useExisting;\n              var transformedDeps;\n              if (isPresent(provider.useExisting)) {\n                  var existingDiDep = _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }), eager);\n                  if (isPresent(existingDiDep.token)) {\n                      transformedUseExisting = existingDiDep.token;\n                  }\n                  else {\n                      transformedUseExisting = null;\n                      transformedUseValue = existingDiDep.value;\n                  }\n              }\n              else if (isPresent(provider.useFactory)) {\n                  var deps = provider.deps || provider.useFactory.diDeps;\n                  transformedDeps =\n                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n              }\n              else if (isPresent(provider.useClass)) {\n                  var deps = provider.deps || provider.useClass.diDeps;\n                  transformedDeps =\n                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n              }\n              return _transformProvider(provider, {\n                  useExisting: transformedUseExisting,\n                  useValue: transformedUseValue,\n                  deps: transformedDeps\n              });\n          });\n          transformedProviderAst =\n              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n          this._transformedProviders.set(token.reference, transformedProviderAst);\n          return transformedProviderAst;\n      };\n      ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n          if (eager === void 0) { eager = null; }\n          if (dep.isAttribute) {\n              var attrValue = this._attrs[dep.token.value];\n              return new CompileDiDependencyMetadata({ isValue: true, value: attrValue == null ? null : attrValue });\n          }\n          if (isPresent(dep.token)) {\n              // access builtints\n              if ((requestingProviderType === exports.ProviderAstType.Directive ||\n                  requestingProviderType === exports.ProviderAstType.Component)) {\n                  if (dep.token.reference === resolveIdentifierToken(Identifiers.Renderer).reference ||\n                      dep.token.reference === resolveIdentifierToken(Identifiers.ElementRef).reference ||\n                      dep.token.reference ===\n                          resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference ||\n                      dep.token.reference === resolveIdentifierToken(Identifiers.TemplateRef).reference) {\n                      return dep;\n                  }\n                  if (dep.token.reference ===\n                      resolveIdentifierToken(Identifiers.ViewContainerRef).reference) {\n                      this._hasViewContainer = true;\n                  }\n              }\n              // access the injector\n              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference) {\n                  return dep;\n              }\n              // access providers\n              if (isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {\n                  return dep;\n              }\n          }\n          return null;\n      };\n      ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n          if (eager === void 0) { eager = null; }\n          var currElement = this;\n          var currEager = eager;\n          var result = null;\n          if (!dep.isSkipSelf) {\n              result = this._getLocalDependency(requestingProviderType, dep, eager);\n          }\n          if (dep.isSelf) {\n              if (!result && dep.isOptional) {\n                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });\n              }\n          }\n          else {\n              // check parent elements\n              while (!result && isPresent(currElement._parent)) {\n                  var prevElement = currElement;\n                  currElement = currElement._parent;\n                  if (prevElement._isViewRoot) {\n                      currEager = false;\n                  }\n                  result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, dep, currEager);\n              }\n              // check @Host restriction\n              if (!result) {\n                  if (!dep.isHost || this.viewContext.component.type.isHost ||\n                      this.viewContext.component.type.reference === dep.token.reference ||\n                      isPresent(this.viewContext.viewProviders.get(dep.token.reference))) {\n                      result = dep;\n                  }\n                  else {\n                      result = dep.isOptional ?\n                          result = new CompileDiDependencyMetadata({ isValue: true, value: null }) :\n                          null;\n                  }\n              }\n          }\n          if (!result) {\n              this.viewContext.errors.push(new ProviderError(\"No provider for \" + dep.token.name, this._sourceSpan));\n          }\n          return result;\n      };\n      return ProviderElementContext;\n  }());\n  var NgModuleProviderAnalyzer = (function () {\n      function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {\n          var _this = this;\n          this._transformedProviders = new Map();\n          this._seenProviders = new Map();\n          this._errors = [];\n          this._allProviders = new Map();\n          var ngModuleTypes = ngModule.transitiveModule.modules.map(function (moduleMeta) { return moduleMeta.type; });\n          ngModuleTypes.forEach(function (ngModuleType) {\n              var ngModuleProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: ngModuleType }), useClass: ngModuleType });\n              _resolveProviders([ngModuleProvider], exports.ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);\n          });\n          _resolveProviders(_normalizeProviders(ngModule.transitiveModule.providers.concat(extraProviders), sourceSpan, this._errors), exports.ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);\n      }\n      NgModuleProviderAnalyzer.prototype.parse = function () {\n          var _this = this;\n          Array.from(this._allProviders.values()).forEach(function (provider) {\n              _this._getOrCreateLocalProvider(provider.token, provider.eager);\n          });\n          if (this._errors.length > 0) {\n              var errorString = this._errors.join('\\n');\n              throw new Error(\"Provider parse errors:\\n\" + errorString);\n          }\n          return Array.from(this._transformedProviders.values());\n      };\n      NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n          var _this = this;\n          var resolvedProvider = this._allProviders.get(token.reference);\n          if (!resolvedProvider) {\n              return null;\n          }\n          var transformedProviderAst = this._transformedProviders.get(token.reference);\n          if (isPresent(transformedProviderAst)) {\n              return transformedProviderAst;\n          }\n          if (isPresent(this._seenProviders.get(token.reference))) {\n              this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + token.name, resolvedProvider.sourceSpan));\n              return null;\n          }\n          this._seenProviders.set(token.reference, true);\n          var transformedProviders = resolvedProvider.providers.map(function (provider) {\n              var transformedUseValue = provider.useValue;\n              var transformedUseExisting = provider.useExisting;\n              var transformedDeps;\n              if (isPresent(provider.useExisting)) {\n                  var existingDiDep = _this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }), eager, resolvedProvider.sourceSpan);\n                  if (isPresent(existingDiDep.token)) {\n                      transformedUseExisting = existingDiDep.token;\n                  }\n                  else {\n                      transformedUseExisting = null;\n                      transformedUseValue = existingDiDep.value;\n                  }\n              }\n              else if (isPresent(provider.useFactory)) {\n                  var deps = provider.deps || provider.useFactory.diDeps;\n                  transformedDeps =\n                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n              }\n              else if (isPresent(provider.useClass)) {\n                  var deps = provider.deps || provider.useClass.diDeps;\n                  transformedDeps =\n                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n              }\n              return _transformProvider(provider, {\n                  useExisting: transformedUseExisting,\n                  useValue: transformedUseValue,\n                  deps: transformedDeps\n              });\n          });\n          transformedProviderAst =\n              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n          this._transformedProviders.set(token.reference, transformedProviderAst);\n          return transformedProviderAst;\n      };\n      NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n          if (eager === void 0) { eager = null; }\n          var foundLocal = false;\n          if (!dep.isSkipSelf && isPresent(dep.token)) {\n              // access the injector\n              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||\n                  dep.token.reference ===\n                      resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference) {\n                  foundLocal = true;\n              }\n              else if (isPresent(this._getOrCreateLocalProvider(dep.token, eager))) {\n                  foundLocal = true;\n              }\n          }\n          var result = dep;\n          if (dep.isSelf && !foundLocal) {\n              if (dep.isOptional) {\n                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });\n              }\n              else {\n                  this._errors.push(new ProviderError(\"No provider for \" + dep.token.name, requestorSourceSpan));\n              }\n          }\n          return result;\n      };\n      return NgModuleProviderAnalyzer;\n  }());\n  function _transformProvider(provider, _a) {\n      var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;\n      return new CompileProviderMetadata({\n          token: provider.token,\n          useClass: provider.useClass,\n          useExisting: useExisting,\n          useFactory: provider.useFactory,\n          useValue: useValue,\n          deps: deps,\n          multi: provider.multi\n      });\n  }\n  function _transformProviderAst(provider, _a) {\n      var eager = _a.eager, providers = _a.providers;\n      return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);\n  }\n  function _normalizeProviders(providers, sourceSpan, targetErrors, targetProviders) {\n      if (targetProviders === void 0) { targetProviders = null; }\n      if (!targetProviders) {\n          targetProviders = [];\n      }\n      if (isPresent(providers)) {\n          providers.forEach(function (provider) {\n              if (Array.isArray(provider)) {\n                  _normalizeProviders(provider, sourceSpan, targetErrors, targetProviders);\n              }\n              else {\n                  var normalizeProvider = void 0;\n                  if (provider instanceof CompileProviderMetadata) {\n                      normalizeProvider = provider;\n                  }\n                  else if (provider instanceof CompileTypeMetadata) {\n                      normalizeProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: provider }), useClass: provider });\n                  }\n                  else {\n                      targetErrors.push(new ProviderError(\"Unknown provider type \" + provider, sourceSpan));\n                  }\n                  if (isPresent(normalizeProvider)) {\n                      targetProviders.push(normalizeProvider);\n                  }\n              }\n          });\n      }\n      return targetProviders;\n  }\n  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n      var providersByToken = new Map();\n      directives.forEach(function (directive) {\n          var dirProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: directive.type }), useClass: directive.type });\n          _resolveProviders([dirProvider], directive.isComponent ? exports.ProviderAstType.Component : exports.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);\n      });\n      // Note: directives need to be able to overwrite providers of a component!\n      var directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));\n      directivesWithComponentFirst.forEach(function (directive) {\n          _resolveProviders(_normalizeProviders(directive.providers, sourceSpan, targetErrors), exports.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);\n          _resolveProviders(_normalizeProviders(directive.viewProviders, sourceSpan, targetErrors), exports.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);\n      });\n      return providersByToken;\n  }\n  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {\n      providers.forEach(function (provider) {\n          var resolvedProvider = targetProvidersByToken.get(provider.token.reference);\n          if (isPresent(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {\n              targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + resolvedProvider.token.name, sourceSpan));\n          }\n          if (!resolvedProvider) {\n              var lifecycleHooks = provider.token.identifier && provider.token.identifier instanceof CompileTypeMetadata ?\n                  provider.token.identifier.lifecycleHooks :\n                  [];\n              resolvedProvider = new ProviderAst(provider.token, provider.multi, eager || lifecycleHooks.length > 0, [provider], providerType, lifecycleHooks, sourceSpan);\n              targetProvidersByToken.set(provider.token.reference, resolvedProvider);\n          }\n          else {\n              if (!provider.multi) {\n                  resolvedProvider.providers.length = 0;\n              }\n              resolvedProvider.providers.push(provider);\n          }\n      });\n  }\n  function _getViewQueries(component) {\n      var viewQueries = new Map();\n      if (isPresent(component.viewQueries)) {\n          component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, query); });\n      }\n      return viewQueries;\n  }\n  function _getContentQueries(directives) {\n      var contentQueries = new Map();\n      directives.forEach(function (directive) {\n          if (isPresent(directive.queries)) {\n              directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, query); });\n          }\n      });\n      return contentQueries;\n  }\n  function _addQueryToTokenMap(map, query) {\n      query.selectors.forEach(function (token) {\n          var entry = map.get(token.reference);\n          if (!entry) {\n              entry = [];\n              map.set(token.reference, entry);\n          }\n          entry.push(query);\n      });\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var ElementSchemaRegistry = (function () {\n      function ElementSchemaRegistry() {\n      }\n      return ElementSchemaRegistry;\n  }());\n\n  var StyleWithImports = (function () {\n      function StyleWithImports(style, styleUrls) {\n          this.style = style;\n          this.styleUrls = styleUrls;\n      }\n      return StyleWithImports;\n  }());\n  function isStyleUrlResolvable(url) {\n      if (isBlank(url) || url.length === 0 || url[0] == '/')\n          return false;\n      var schemeMatch = url.match(_urlWithSchemaRe);\n      return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n  }\n  /**\n   * Rewrites stylesheets by resolving and removing the @import urls that\n   * are either relative or don't have a `package:` scheme\n   */\n  function extractStyleUrls(resolver, baseUrl, cssText) {\n      var foundUrls = [];\n      var modifiedCssText = cssText.replace(_cssImportRe, function () {\n          var m = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              m[_i - 0] = arguments[_i];\n          }\n          var url = m[1] || m[2];\n          if (!isStyleUrlResolvable(url)) {\n              // Do not attempt to resolve non-package absolute URLs with URI scheme\n              return m[0];\n          }\n          foundUrls.push(resolver.resolve(baseUrl, url));\n          return '';\n      });\n      return new StyleWithImports(modifiedCssText, foundUrls);\n  }\n  var _cssImportRe = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\n  var _urlWithSchemaRe = /^([^:/?#]+):/;\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$11 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var PROPERTY_PARTS_SEPARATOR = '.';\n  var ATTRIBUTE_PREFIX = 'attr';\n  var CLASS_PREFIX = 'class';\n  var STYLE_PREFIX = 'style';\n  var ANIMATE_PROP_PREFIX = 'animate-';\n  var BoundPropertyType;\n  (function (BoundPropertyType) {\n      BoundPropertyType[BoundPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n      BoundPropertyType[BoundPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n      BoundPropertyType[BoundPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n  })(BoundPropertyType || (BoundPropertyType = {}));\n  /**\n   * Represents a parsed property.\n   */\n  var BoundProperty = (function () {\n      function BoundProperty(name, expression, type, sourceSpan) {\n          this.name = name;\n          this.expression = expression;\n          this.type = type;\n          this.sourceSpan = sourceSpan;\n      }\n      Object.defineProperty(BoundProperty.prototype, \"isLiteral\", {\n          get: function () { return this.type === BoundPropertyType.LITERAL_ATTR; },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(BoundProperty.prototype, \"isAnimation\", {\n          get: function () { return this.type === BoundPropertyType.ANIMATION; },\n          enumerable: true,\n          configurable: true\n      });\n      return BoundProperty;\n  }());\n  /**\n   * Parses bindings in templates and in the directive host area.\n   */\n  var BindingParser = (function () {\n      function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {\n          var _this = this;\n          this._exprParser = _exprParser;\n          this._interpolationConfig = _interpolationConfig;\n          this._schemaRegistry = _schemaRegistry;\n          this._targetErrors = _targetErrors;\n          this.pipesByName = new Map();\n          pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });\n      }\n      BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, sourceSpan) {\n          var _this = this;\n          if (dirMeta.hostProperties) {\n              var boundProps_1 = [];\n              Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n                  var expression = dirMeta.hostProperties[propName];\n                  if (typeof expression === 'string') {\n                      _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);\n                  }\n                  else {\n                      _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                  }\n              });\n              return boundProps_1.map(function (prop) { return _this.createElementPropertyAst(dirMeta.selector, prop); });\n          }\n      };\n      BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n          var _this = this;\n          if (dirMeta.hostListeners) {\n              var targetEventAsts_1 = [];\n              Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n                  var expression = dirMeta.hostListeners[propName];\n                  if (typeof expression === 'string') {\n                      _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);\n                  }\n                  else {\n                      _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                  }\n              });\n              return targetEventAsts_1;\n          }\n      };\n      BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n          var sourceInfo = sourceSpan.start.toString();\n          try {\n              var ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);\n              if (ast)\n                  this._reportExpressionParserErrors(ast.errors, sourceSpan);\n              this._checkPipes(ast, sourceSpan);\n              return ast;\n          }\n          catch (e) {\n              this._reportError(\"\" + e, sourceSpan);\n              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n          }\n      };\n      BindingParser.prototype.parseInlineTemplateBinding = function (name, prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {\n          var bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n          for (var i = 0; i < bindings.length; i++) {\n              var binding = bindings[i];\n              if (binding.keyIsVar) {\n                  targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n              }\n              else if (isPresent(binding.expression)) {\n                  this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n              }\n              else {\n                  targetMatchableAttrs.push([binding.key, '']);\n                  this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n              }\n          }\n      };\n      BindingParser.prototype._parseTemplateBindings = function (prefixToken, value, sourceSpan) {\n          var _this = this;\n          var sourceInfo = sourceSpan.start.toString();\n          try {\n              var bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n              this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n              bindingsResult.templateBindings.forEach(function (binding) {\n                  if (isPresent(binding.expression)) {\n                      _this._checkPipes(binding.expression, sourceSpan);\n                  }\n              });\n              bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, exports.ParseErrorLevel.WARNING); });\n              return bindingsResult.templateBindings;\n          }\n          catch (e) {\n              this._reportError(\"\" + e, sourceSpan);\n              return [];\n          }\n      };\n      BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n          if (_isAnimationLabel(name)) {\n              name = name.substring(1);\n              if (value) {\n                  this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" +\n                      \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, exports.ParseErrorLevel.FATAL);\n              }\n              this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n          }\n          else {\n              targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));\n          }\n      };\n      BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {\n          var isAnimationProp = false;\n          if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n              isAnimationProp = true;\n              name = name.substring(ANIMATE_PROP_PREFIX.length);\n          }\n          else if (_isAnimationLabel(name)) {\n              isAnimationProp = true;\n              name = name.substring(1);\n          }\n          if (isAnimationProp) {\n              this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n          }\n          else {\n              this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);\n          }\n      };\n      BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n          var expr = this.parseInterpolation(value, sourceSpan);\n          if (isPresent(expr)) {\n              this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n              return true;\n          }\n          return false;\n      };\n      BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {\n          targetMatchableAttrs.push([name, ast.source]);\n          targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n      };\n      BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {\n          // This will occur when a @trigger is not paired with an expression.\n          // For animations it is valid to not have an expression since */void\n          // states will be applied by angular when the element is attached/detached\n          var ast = this._parseBinding(expression || 'null', false, sourceSpan);\n          targetMatchableAttrs.push([name, ast.source]);\n          targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n      };\n      BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan) {\n          var sourceInfo = sourceSpan.start.toString();\n          try {\n              var ast = isHostBinding ?\n                  this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n                  this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n              if (ast)\n                  this._reportExpressionParserErrors(ast.errors, sourceSpan);\n              this._checkPipes(ast, sourceSpan);\n              return ast;\n          }\n          catch (e) {\n              this._reportError(\"\" + e, sourceSpan);\n              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n          }\n      };\n      BindingParser.prototype.createElementPropertyAst = function (elementSelector, boundProp) {\n          if (boundProp.isAnimation) {\n              return new BoundElementPropertyAst(boundProp.name, exports.PropertyBindingType.Animation, _angular_core.SecurityContext.NONE, false, boundProp.expression, null, boundProp.sourceSpan);\n          }\n          var unit = null;\n          var bindingType;\n          var boundPropertyName;\n          var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n          var securityContexts;\n          if (parts.length === 1) {\n              var partValue = parts[0];\n              boundPropertyName = this._schemaRegistry.getMappedPropName(partValue);\n              securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);\n              bindingType = exports.PropertyBindingType.Property;\n              this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n          }\n          else {\n              if (parts[0] == ATTRIBUTE_PREFIX) {\n                  boundPropertyName = parts[1];\n                  this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                  securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                  var nsSeparatorIdx = boundPropertyName.indexOf(':');\n                  if (nsSeparatorIdx > -1) {\n                      var ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                      var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);\n                      boundPropertyName = mergeNsAndName(ns, name_1);\n                  }\n                  bindingType = exports.PropertyBindingType.Attribute;\n              }\n              else if (parts[0] == CLASS_PREFIX) {\n                  boundPropertyName = parts[1];\n                  bindingType = exports.PropertyBindingType.Class;\n                  securityContexts = [_angular_core.SecurityContext.NONE];\n              }\n              else if (parts[0] == STYLE_PREFIX) {\n                  unit = parts.length > 2 ? parts[2] : null;\n                  boundPropertyName = parts[1];\n                  bindingType = exports.PropertyBindingType.Style;\n                  securityContexts = [_angular_core.SecurityContext.STYLE];\n              }\n              else {\n                  this._reportError(\"Invalid property name '\" + boundProp.name + \"'\", boundProp.sourceSpan);\n                  bindingType = null;\n                  securityContexts = [];\n              }\n          }\n          return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts.length === 1 ? securityContexts[0] : null, securityContexts.length > 1, boundProp.expression, unit, boundProp.sourceSpan);\n      };\n      BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n          if (_isAnimationLabel(name)) {\n              name = name.substr(1);\n              this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n          }\n          else {\n              this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n          }\n      };\n      BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {\n          var matches = splitAtPeriod(name, [name, '']);\n          var eventName = matches[0];\n          var phase = matches[1].toLowerCase();\n          if (phase) {\n              switch (phase) {\n                  case 'start':\n                  case 'done':\n                      var ast = this._parseAction(expression, sourceSpan);\n                      targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n                      break;\n                  default:\n                      this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n                      break;\n              }\n          }\n          else {\n              this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n          }\n      };\n      BindingParser.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n          // long format: 'target: eventName'\n          var _a = splitAtColon(name, [null, name]), target = _a[0], eventName = _a[1];\n          var ast = this._parseAction(expression, sourceSpan);\n          targetMatchableAttrs.push([name, ast.source]);\n          targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n          // Don't detect directives for event names for now,\n          // so don't add the event name to the matchableAttrs\n      };\n      BindingParser.prototype._parseAction = function (value, sourceSpan) {\n          var sourceInfo = sourceSpan.start.toString();\n          try {\n              var ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n              if (ast) {\n                  this._reportExpressionParserErrors(ast.errors, sourceSpan);\n              }\n              if (!ast || ast.ast instanceof EmptyExpr) {\n                  this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n                  return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n              }\n              this._checkPipes(ast, sourceSpan);\n              return ast;\n          }\n          catch (e) {\n              this._reportError(\"\" + e, sourceSpan);\n              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n          }\n      };\n      BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }\n          this._targetErrors.push(new ParseError(sourceSpan, message, level));\n      };\n      BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n          for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n              var error = errors_1[_i];\n              this._reportError(error.message, sourceSpan);\n          }\n      };\n      BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n          var _this = this;\n          if (isPresent(ast)) {\n              var collector = new PipeCollector();\n              ast.visit(collector);\n              collector.pipes.forEach(function (pipeName) {\n                  if (!_this.pipesByName.has(pipeName)) {\n                      _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", sourceSpan);\n                  }\n              });\n          }\n      };\n      /**\n       * @param propName the name of the property / attribute\n       * @param sourceSpan\n       * @param isAttr true when binding to an attribute\n       * @private\n       */\n      BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n          var report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n              this._schemaRegistry.validateProperty(propName);\n          if (report.error) {\n              this._reportError(report.msg, sourceSpan, exports.ParseErrorLevel.FATAL);\n          }\n      };\n      return BindingParser;\n  }());\n  var PipeCollector = (function (_super) {\n      __extends$11(PipeCollector, _super);\n      function PipeCollector() {\n          _super.apply(this, arguments);\n          this.pipes = new Set();\n      }\n      PipeCollector.prototype.visitPipe = function (ast, context) {\n          this.pipes.add(ast.name);\n          ast.exp.visit(this);\n          this.visitAll(ast.args, context);\n          return null;\n      };\n      return PipeCollector;\n  }(RecursiveAstVisitor));\n  function _isAnimationLabel(name) {\n      return name[0] == '@';\n  }\n  function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n      var ctxs = [];\n      CssSelector.parse(selector).forEach(function (selector) {\n          var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n          var notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })\n              .map(function (selector) { return selector.element; }));\n          var possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });\n          ctxs.push.apply(ctxs, possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); }));\n      });\n      return ctxs.length === 0 ? [_angular_core.SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n  }\n\n  var NG_CONTENT_SELECT_ATTR = 'select';\n  var NG_CONTENT_ELEMENT = 'ng-content';\n  var LINK_ELEMENT = 'link';\n  var LINK_STYLE_REL_ATTR = 'rel';\n  var LINK_STYLE_HREF_ATTR = 'href';\n  var LINK_STYLE_REL_VALUE = 'stylesheet';\n  var STYLE_ELEMENT = 'style';\n  var SCRIPT_ELEMENT = 'script';\n  var NG_NON_BINDABLE_ATTR = 'ngNonBindable';\n  var NG_PROJECT_AS = 'ngProjectAs';\n  function preparseElement(ast) {\n      var selectAttr = null;\n      var hrefAttr = null;\n      var relAttr = null;\n      var nonBindable = false;\n      var projectAs = null;\n      ast.attrs.forEach(function (attr) {\n          var lcAttrName = attr.name.toLowerCase();\n          if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n              selectAttr = attr.value;\n          }\n          else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n              hrefAttr = attr.value;\n          }\n          else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n              relAttr = attr.value;\n          }\n          else if (attr.name == NG_NON_BINDABLE_ATTR) {\n              nonBindable = true;\n          }\n          else if (attr.name == NG_PROJECT_AS) {\n              if (attr.value.length > 0) {\n                  projectAs = attr.value;\n              }\n          }\n      });\n      selectAttr = normalizeNgContentSelect(selectAttr);\n      var nodeName = ast.name.toLowerCase();\n      var type = PreparsedElementType.OTHER;\n      if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {\n          type = PreparsedElementType.NG_CONTENT;\n      }\n      else if (nodeName == STYLE_ELEMENT) {\n          type = PreparsedElementType.STYLE;\n      }\n      else if (nodeName == SCRIPT_ELEMENT) {\n          type = PreparsedElementType.SCRIPT;\n      }\n      else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n          type = PreparsedElementType.STYLESHEET;\n      }\n      return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n  }\n  var PreparsedElementType;\n  (function (PreparsedElementType) {\n      PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n      PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n      PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n      PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n      PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n  })(PreparsedElementType || (PreparsedElementType = {}));\n  var PreparsedElement = (function () {\n      function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n          this.type = type;\n          this.selectAttr = selectAttr;\n          this.hrefAttr = hrefAttr;\n          this.nonBindable = nonBindable;\n          this.projectAs = projectAs;\n      }\n      return PreparsedElement;\n  }());\n  function normalizeNgContentSelect(selectAttr) {\n      if (selectAttr === null || selectAttr.length === 0) {\n          return '*';\n      }\n      return selectAttr;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  // Group 1 = \"bind-\"\n  // Group 2 = \"let-\"\n  // Group 3 = \"ref-/#\"\n  // Group 4 = \"on-\"\n  // Group 5 = \"bindon-\"\n  // Group 6 = \"@\"\n  // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n  // Group 8 = identifier inside [()]\n  // Group 9 = identifier inside []\n  // Group 10 = identifier inside ()\n  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n  var KW_BIND_IDX = 1;\n  var KW_LET_IDX = 2;\n  var KW_REF_IDX = 3;\n  var KW_ON_IDX = 4;\n  var KW_BINDON_IDX = 5;\n  var KW_AT_IDX = 6;\n  var IDENT_KW_IDX = 7;\n  var IDENT_BANANA_BOX_IDX = 8;\n  var IDENT_PROPERTY_IDX = 9;\n  var IDENT_EVENT_IDX = 10;\n  var TEMPLATE_ELEMENT = 'template';\n  var TEMPLATE_ATTR = 'template';\n  var TEMPLATE_ATTR_PREFIX = '*';\n  var CLASS_ATTR = 'class';\n  var TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n  /**\n   * Provides an array of {@link TemplateAstVisitor}s which will be used to transform\n   * parsed templates before compilation is invoked, allowing custom expression syntax\n   * and other advanced transformations.\n   *\n   * This is currently an internal-only feature and not meant for general use.\n   */\n  var TEMPLATE_TRANSFORMS = new _angular_core.OpaqueToken('TemplateTransforms');\n  var TemplateParseError = (function (_super) {\n      __extends(TemplateParseError, _super);\n      function TemplateParseError(message, span, level) {\n          _super.call(this, span, message, level);\n      }\n      return TemplateParseError;\n  }(ParseError));\n  var TemplateParseResult = (function () {\n      function TemplateParseResult(templateAst, errors) {\n          this.templateAst = templateAst;\n          this.errors = errors;\n      }\n      return TemplateParseResult;\n  }());\n  var TemplateParser = (function () {\n      function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n          this._exprParser = _exprParser;\n          this._schemaRegistry = _schemaRegistry;\n          this._htmlParser = _htmlParser;\n          this._console = _console;\n          this.transforms = transforms;\n      }\n      TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {\n          var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);\n          var warnings = result.errors.filter(function (error) { return error.level === exports.ParseErrorLevel.WARNING; });\n          var errors = result.errors.filter(function (error) { return error.level === exports.ParseErrorLevel.FATAL; });\n          if (warnings.length > 0) {\n              this._console.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n          }\n          if (errors.length > 0) {\n              var errorString = errors.join('\\n');\n              throw new Error(\"Template parse errors:\\n\" + errorString);\n          }\n          return result.templateAst;\n      };\n      TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {\n          return this.tryParseHtml(this.expandHtml(this._htmlParser.parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, template, directives, pipes, schemas, templateUrl);\n      };\n      TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, template, directives, pipes, schemas, templateUrl) {\n          var result;\n          var errors = htmlAstWithErrors.errors;\n          if (htmlAstWithErrors.rootNodes.length > 0) {\n              var uniqDirectives = removeSummaryDuplicates(directives);\n              var uniqPipes = removeSummaryDuplicates(pipes);\n              var providerViewContext = new ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);\n              var interpolationConfig = void 0;\n              if (component.template && component.template.interpolation) {\n                  interpolationConfig = {\n                      start: component.template.interpolation[0],\n                      end: component.template.interpolation[1]\n                  };\n              }\n              var bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n              var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n              result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n              errors.push.apply(errors, providerViewContext.errors);\n          }\n          else {\n              result = [];\n          }\n          this._assertNoReferenceDuplicationOnTemplate(result, errors);\n          if (errors.length > 0) {\n              return new TemplateParseResult(result, errors);\n          }\n          if (isPresent(this.transforms)) {\n              this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });\n          }\n          return new TemplateParseResult(result, errors);\n      };\n      TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n          if (forced === void 0) { forced = false; }\n          var errors = htmlAstWithErrors.errors;\n          if (errors.length == 0 || forced) {\n              // Transform ICU messages to angular directives\n              var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n              errors.push.apply(errors, expandedHtmlAst.errors);\n              htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n          }\n          return htmlAstWithErrors;\n      };\n      TemplateParser.prototype.getInterpolationConfig = function (component) {\n          if (component.template) {\n              return InterpolationConfig.fromArray(component.template.interpolation);\n          }\n      };\n      /** @internal */\n      TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n          var existingReferences = [];\n          result.filter(function (element) { return !!element.references; })\n              .forEach(function (element) { return element.references.forEach(function (reference) {\n              var name = reference.name;\n              if (existingReferences.indexOf(name) < 0) {\n                  existingReferences.push(name);\n              }\n              else {\n                  var error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, exports.ParseErrorLevel.FATAL);\n                  errors.push(error);\n              }\n          }); });\n      };\n      TemplateParser.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      TemplateParser.ctorParameters = [\n          { type: Parser, },\n          { type: ElementSchemaRegistry, },\n          { type: I18NHtmlParser, },\n          { type: Console, },\n          { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [TEMPLATE_TRANSFORMS,] },] },\n      ];\n      return TemplateParser;\n  }());\n  var TemplateParseVisitor = (function () {\n      function TemplateParseVisitor(providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n          var _this = this;\n          this.providerViewContext = providerViewContext;\n          this._bindingParser = _bindingParser;\n          this._schemaRegistry = _schemaRegistry;\n          this._schemas = _schemas;\n          this._targetErrors = _targetErrors;\n          this.selectorMatcher = new SelectorMatcher();\n          this.directivesIndex = new Map();\n          this.ngContentCount = 0;\n          directives.forEach(function (directive, index) {\n              var selector = CssSelector.parse(directive.selector);\n              _this.selectorMatcher.addSelectables(selector, directive);\n              _this.directivesIndex.set(directive, index);\n          });\n      }\n      TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };\n      TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };\n      TemplateParseVisitor.prototype.visitText = function (text, parent) {\n          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);\n          var expr = this._bindingParser.parseInterpolation(text.value, text.sourceSpan);\n          if (isPresent(expr)) {\n              return new BoundTextAst(expr, ngContentIndex, text.sourceSpan);\n          }\n          else {\n              return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n          }\n      };\n      TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n      };\n      TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };\n      TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n          var _this = this;\n          var nodeName = element.name;\n          var preparsedElement = preparseElement(element);\n          if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n              preparsedElement.type === PreparsedElementType.STYLE) {\n              // Skipping <script> for security reasons\n              // Skipping <style> as we already processed them\n              // in the StyleCompiler\n              return null;\n          }\n          if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n              isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n              // Skipping stylesheets with either relative urls or package scheme as we already processed\n              // them in the StyleCompiler\n              return null;\n          }\n          var matchableAttrs = [];\n          var elementOrDirectiveProps = [];\n          var elementOrDirectiveRefs = [];\n          var elementVars = [];\n          var events = [];\n          var templateElementOrDirectiveProps = [];\n          var templateMatchableAttrs = [];\n          var templateElementVars = [];\n          var hasInlineTemplates = false;\n          var attrs = [];\n          var lcElName = splitNsName(nodeName.toLowerCase())[1];\n          var isTemplateElement = lcElName == TEMPLATE_ELEMENT;\n          element.attrs.forEach(function (attr) {\n              var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n              var templateBindingsSource = undefined;\n              var prefixToken = undefined;\n              if (_this._normalizeAttributeName(attr.name) == TEMPLATE_ATTR) {\n                  templateBindingsSource = attr.value;\n              }\n              else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                  templateBindingsSource = attr.value;\n                  prefixToken = attr.name.substring(TEMPLATE_ATTR_PREFIX.length); // remove the star\n              }\n              var hasTemplateBinding = isPresent(templateBindingsSource);\n              if (hasTemplateBinding) {\n                  if (hasInlineTemplates) {\n                      _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *\", attr.sourceSpan);\n                  }\n                  hasInlineTemplates = true;\n                  _this._bindingParser.parseInlineTemplateBinding(attr.name, prefixToken, templateBindingsSource, attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);\n              }\n              if (!hasBinding && !hasTemplateBinding) {\n                  // don't include the bindings as attributes as well in the AST\n                  attrs.push(_this.visitAttribute(attr, null));\n                  matchableAttrs.push([attr.name, attr.value]);\n              }\n          });\n          var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);\n          var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;\n          var references = [];\n          var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);\n          var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts);\n          var isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n          var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);\n          var children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n          providerContext.afterElement();\n          // Override the actual selector when the `ngProjectAs` attribute is provided\n          var projectionSelector = isPresent(preparsedElement.projectAs) ?\n              CssSelector.parse(preparsedElement.projectAs)[0] :\n              elementCssSelector;\n          var ngContentIndex = parent.findNgContentIndex(projectionSelector);\n          var parsedElement;\n          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n              if (element.children && !element.children.every(_isEmptyTextNode)) {\n                  this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n              }\n              parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n          }\n          else if (isTemplateElement) {\n              this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n              this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n              parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n          }\n          else {\n              this._assertElementExists(matchElement, element);\n              this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n              var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n              parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan);\n              this._findComponentDirectives(directiveAsts)\n                  .forEach(function (componentDirectiveAst) { return _this._validateElementAnimationInputOutputs(componentDirectiveAst.hostProperties, componentDirectiveAst.hostEvents, componentDirectiveAst.directive.template); });\n              var componentTemplate = providerContext.viewContext.component.template;\n              this._validateElementAnimationInputOutputs(elementProps, events, componentTemplate.toSummary());\n          }\n          if (hasInlineTemplates) {\n              var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);\n              var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector).directives;\n              var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);\n              var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);\n              this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n              var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);\n              templateProviderContext.afterElement();\n              parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);\n          }\n          return parsedElement;\n      };\n      TemplateParseVisitor.prototype._validateElementAnimationInputOutputs = function (inputs, outputs, template) {\n          var _this = this;\n          var triggerLookup = new Set();\n          template.animations.forEach(function (entry) { triggerLookup.add(entry); });\n          var animationInputs = inputs.filter(function (input) { return input.isAnimation; });\n          animationInputs.forEach(function (input) {\n              var name = input.name;\n              if (!triggerLookup.has(name)) {\n                  _this._reportError(\"Couldn't find an animation entry for \\\"\" + name + \"\\\"\", input.sourceSpan);\n              }\n          });\n          outputs.forEach(function (output) {\n              if (output.isAnimation) {\n                  var found = animationInputs.find(function (input) { return input.name == output.name; });\n                  if (!found) {\n                      _this._reportError(\"Unable to listen on (@\" + output.name + \".\" + output.phase + \") because the animation trigger [@\" + output.name + \"] isn't being used on the same element\", output.sourceSpan);\n                  }\n              }\n          });\n      };\n      TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n          var name = this._normalizeAttributeName(attr.name);\n          var value = attr.value;\n          var srcSpan = attr.sourceSpan;\n          var bindParts = name.match(BIND_NAME_REGEXP);\n          var hasBinding = false;\n          if (bindParts !== null) {\n              hasBinding = true;\n              if (isPresent(bindParts[KW_BIND_IDX])) {\n                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n              }\n              else if (bindParts[KW_LET_IDX]) {\n                  if (isTemplateElement) {\n                      var identifier = bindParts[IDENT_KW_IDX];\n                      this._parseVariable(identifier, value, srcSpan, targetVars);\n                  }\n                  else {\n                      this._reportError(\"\\\"let-\\\" is only supported on template elements.\", srcSpan);\n                  }\n              }\n              else if (bindParts[KW_REF_IDX]) {\n                  var identifier = bindParts[IDENT_KW_IDX];\n                  this._parseReference(identifier, value, srcSpan, targetRefs);\n              }\n              else if (bindParts[KW_ON_IDX]) {\n                  this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n              }\n              else if (bindParts[KW_BINDON_IDX]) {\n                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                  this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n              }\n              else if (bindParts[KW_AT_IDX]) {\n                  this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n              }\n              else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                  this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n              }\n              else if (bindParts[IDENT_PROPERTY_IDX]) {\n                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n              }\n              else if (bindParts[IDENT_EVENT_IDX]) {\n                  this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n              }\n          }\n          else {\n              hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);\n          }\n          if (!hasBinding) {\n              this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n          }\n          return hasBinding;\n      };\n      TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n          return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n      };\n      TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n          if (identifier.indexOf('-') > -1) {\n              this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n          }\n          targetVars.push(new VariableAst(identifier, value, sourceSpan));\n      };\n      TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n          if (identifier.indexOf('-') > -1) {\n              this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n          }\n          targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n      };\n      TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n          this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, targetMatchableAttrs, targetEvents);\n      };\n      TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n          var _this = this;\n          // Need to sort the directives so that we get consistent results throughout,\n          // as selectorMatcher uses Maps inside.\n          // Also deduplicate directives as they might match more than one time!\n          var directives = new Array(this.directivesIndex.size);\n          // Whether any directive selector matches on the element name\n          var matchElement = false;\n          selectorMatcher.match(elementCssSelector, function (selector, directive) {\n              directives[_this.directivesIndex.get(directive)] = directive;\n              matchElement = matchElement || selector.hasElementSelector();\n          });\n          return {\n              directives: directives.filter(function (dir) { return !!dir; }),\n              matchElement: matchElement,\n          };\n      };\n      TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences) {\n          var _this = this;\n          var matchedReferences = new Set();\n          var component = null;\n          var directiveAsts = directives.map(function (directive) {\n              var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \" + directive.type.name);\n              if (directive.isComponent) {\n                  component = directive;\n              }\n              var directiveProperties = [];\n              var hostProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, sourceSpan);\n              // Note: We need to check the host properties here as well,\n              // as we don't know the element name in the DirectiveWrapperCompiler yet.\n              _this._checkPropertiesInSchema(elementName, hostProperties);\n              var hostEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n              _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);\n              elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n                  if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                      (directive.exportAs == elOrDirRef.value)) {\n                      targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));\n                      matchedReferences.add(elOrDirRef.name);\n                  }\n              });\n              return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);\n          });\n          elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n              if (elOrDirRef.value.length > 0) {\n                  if (!matchedReferences.has(elOrDirRef.name)) {\n                      _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n                  }\n              }\n              else if (!component) {\n                  var refToken = null;\n                  if (isTemplateElement) {\n                      refToken = resolveIdentifierToken(Identifiers.TemplateRef);\n                  }\n                  targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));\n              }\n          }); // fix syntax highlighting issue: `\n          return directiveAsts;\n      };\n      TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {\n          if (directiveProperties) {\n              var boundPropsByName_1 = new Map();\n              boundProps.forEach(function (boundProp) {\n                  var prevValue = boundPropsByName_1.get(boundProp.name);\n                  if (!prevValue || prevValue.isLiteral) {\n                      // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                      boundPropsByName_1.set(boundProp.name, boundProp);\n                  }\n              });\n              Object.keys(directiveProperties).forEach(function (dirProp) {\n                  var elProp = directiveProperties[dirProp];\n                  var boundProp = boundPropsByName_1.get(elProp);\n                  // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                  if (boundProp) {\n                      targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                  }\n              });\n          }\n      };\n      TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {\n          var _this = this;\n          var boundElementProps = [];\n          var boundDirectivePropsIndex = new Map();\n          directives.forEach(function (directive) {\n              directive.inputs.forEach(function (prop) {\n                  boundDirectivePropsIndex.set(prop.templateName, prop);\n              });\n          });\n          props.forEach(function (prop) {\n              if (!prop.isLiteral && !boundDirectivePropsIndex.get(prop.name)) {\n                  boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));\n              }\n          });\n          this._checkPropertiesInSchema(elementName, boundElementProps);\n          return boundElementProps;\n      };\n      TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n          return directives.filter(function (directive) { return directive.directive.isComponent; });\n      };\n      TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n          return this._findComponentDirectives(directives)\n              .map(function (directive) { return directive.directive.type.name; });\n      };\n      TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n          var componentTypeNames = this._findComponentDirectiveNames(directives);\n          if (componentTypeNames.length > 1) {\n              this._reportError(\"More than one component matched on this element.\\n\" +\n                  \"Make sure that only one component's selector can match a given element.\\n\" +\n                  (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n          }\n      };\n      /**\n       * Make sure that non-angular tags conform to the schemas.\n       *\n       * Note: An element is considered an angular tag when at least one directive selector matches the\n       * tag name.\n       *\n       * @param matchElement Whether any directive has matched on the tag name\n       * @param element the html element\n       */\n      TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n          var elName = element.name.replace(/^:xhtml:/, '');\n          if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n              var errorMsg = (\"'\" + elName + \"' is not a known element:\\n\") +\n                  (\"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\") +\n                  (\"2. If '\" + elName + \"' is a Web Component then add \\\"CUSTOM_ELEMENTS_SCHEMA\\\" to the '@NgModule.schemas' of this component to suppress this message.\");\n              this._reportError(errorMsg, element.sourceSpan);\n          }\n      };\n      TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n          var _this = this;\n          var componentTypeNames = this._findComponentDirectiveNames(directives);\n          if (componentTypeNames.length > 0) {\n              this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n          }\n          elementProps.forEach(function (prop) {\n              _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"directives\\\" section.\", sourceSpan);\n          });\n      };\n      TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n          var _this = this;\n          var allDirectiveEvents = new Set();\n          directives.forEach(function (directive) {\n              Object.keys(directive.directive.outputs).forEach(function (k) {\n                  var eventName = directive.directive.outputs[k];\n                  allDirectiveEvents.add(eventName);\n              });\n          });\n          events.forEach(function (event) {\n              if (isPresent(event.target) || !allDirectiveEvents.has(event.name)) {\n                  _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"directives\\\" section.\", event.sourceSpan);\n              }\n          });\n      };\n      TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n          var _this = this;\n          boundProps.forEach(function (boundProp) {\n              if (boundProp.type === exports.PropertyBindingType.Property &&\n                  !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n                  var errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n                  if (elementName.indexOf('-') > -1) {\n                      errorMsg +=\n                          (\"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\") +\n                              (\"\\n2. If '\" + elementName + \"' is a Web Component then add \\\"CUSTOM_ELEMENTS_SCHEMA\\\" to the '@NgModule.schemas' of this component to suppress this message.\\n\");\n                  }\n                  _this._reportError(errorMsg, boundProp.sourceSpan);\n              }\n          });\n      };\n      TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }\n          this._targetErrors.push(new ParseError(sourceSpan, message, level));\n      };\n      return TemplateParseVisitor;\n  }());\n  var NonBindableVisitor = (function () {\n      function NonBindableVisitor() {\n      }\n      NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n          var preparsedElement = preparseElement(ast);\n          if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n              preparsedElement.type === PreparsedElementType.STYLE ||\n              preparsedElement.type === PreparsedElementType.STYLESHEET) {\n              // Skipping <script> for security reasons\n              // Skipping <style> and stylesheets as we already processed them\n              // in the StyleCompiler\n              return null;\n          }\n          var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });\n          var selector = createElementCssSelector(ast.name, attrNameAndValues);\n          var ngContentIndex = parent.findNgContentIndex(selector);\n          var children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n          return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n      };\n      NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };\n      NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n      };\n      NonBindableVisitor.prototype.visitText = function (text, parent) {\n          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);\n          return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n      };\n      NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };\n      NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n      return NonBindableVisitor;\n  }());\n  var ElementOrDirectiveRef = (function () {\n      function ElementOrDirectiveRef(name, value, sourceSpan) {\n          this.name = name;\n          this.value = value;\n          this.sourceSpan = sourceSpan;\n      }\n      return ElementOrDirectiveRef;\n  }());\n  function splitClasses(classAttrValue) {\n      return classAttrValue.trim().split(/\\s+/g);\n  }\n  var ElementContext = (function () {\n      function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n          this.isTemplateElement = isTemplateElement;\n          this._ngContentIndexMatcher = _ngContentIndexMatcher;\n          this._wildcardNgContentIndex = _wildcardNgContentIndex;\n          this.providerContext = providerContext;\n      }\n      ElementContext.create = function (isTemplateElement, directives, providerContext) {\n          var matcher = new SelectorMatcher();\n          var wildcardNgContentIndex = null;\n          var component = directives.find(function (directive) { return directive.directive.isComponent; });\n          if (component) {\n              var ngContentSelectors = component.directive.template.ngContentSelectors;\n              for (var i = 0; i < ngContentSelectors.length; i++) {\n                  var selector = ngContentSelectors[i];\n                  if (selector === '*') {\n                      wildcardNgContentIndex = i;\n                  }\n                  else {\n                      matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                  }\n              }\n          }\n          return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n      };\n      ElementContext.prototype.findNgContentIndex = function (selector) {\n          var ngContentIndices = [];\n          this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });\n          ngContentIndices.sort();\n          if (isPresent(this._wildcardNgContentIndex)) {\n              ngContentIndices.push(this._wildcardNgContentIndex);\n          }\n          return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n      };\n      return ElementContext;\n  }());\n  function createElementCssSelector(elementName, matchableAttrs) {\n      var cssSelector = new CssSelector();\n      var elNameNoNs = splitNsName(elementName)[1];\n      cssSelector.setElement(elNameNoNs);\n      for (var i = 0; i < matchableAttrs.length; i++) {\n          var attrName = matchableAttrs[i][0];\n          var attrNameNoNs = splitNsName(attrName)[1];\n          var attrValue = matchableAttrs[i][1];\n          cssSelector.addAttribute(attrNameNoNs, attrValue);\n          if (attrName.toLowerCase() == CLASS_ATTR) {\n              var classes = splitClasses(attrValue);\n              classes.forEach(function (className) { return cssSelector.addClassName(className); });\n          }\n      }\n      return cssSelector;\n  }\n  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\n  var NON_BINDABLE_VISITOR = new NonBindableVisitor();\n  function _isEmptyTextNode(node) {\n      return node instanceof Text && node.value.trim().length == 0;\n  }\n  function removeSummaryDuplicates(items) {\n      var map = new Map();\n      items.forEach(function (item) {\n          if (!map.get(item.type.reference)) {\n              map.set(item.type.reference, item);\n          }\n      });\n      return Array.from(map.values());\n  }\n\n  function unimplemented$1() {\n      throw new Error('unimplemented');\n  }\n  var CompilerConfig = (function () {\n      function CompilerConfig(_a) {\n          var _b = _a === void 0 ? {} : _a, _c = _b.renderTypes, renderTypes = _c === void 0 ? new DefaultRenderTypes() : _c, _d = _b.defaultEncapsulation, defaultEncapsulation = _d === void 0 ? _angular_core.ViewEncapsulation.Emulated : _d, genDebugInfo = _b.genDebugInfo, logBindingUpdate = _b.logBindingUpdate, _e = _b.useJit, useJit = _e === void 0 ? true : _e;\n          this.renderTypes = renderTypes;\n          this.defaultEncapsulation = defaultEncapsulation;\n          this._genDebugInfo = genDebugInfo;\n          this._logBindingUpdate = logBindingUpdate;\n          this.useJit = useJit;\n      }\n      Object.defineProperty(CompilerConfig.prototype, \"genDebugInfo\", {\n          get: function () {\n              return this._genDebugInfo === void 0 ? _angular_core.isDevMode() : this._genDebugInfo;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(CompilerConfig.prototype, \"logBindingUpdate\", {\n          get: function () {\n              return this._logBindingUpdate === void 0 ? _angular_core.isDevMode() : this._logBindingUpdate;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      return CompilerConfig;\n  }());\n  /**\n   * Types used for the renderer.\n   * Can be replaced to specialize the generated output to a specific renderer\n   * to help tree shaking.\n   */\n  var RenderTypes = (function () {\n      function RenderTypes() {\n      }\n      Object.defineProperty(RenderTypes.prototype, \"renderer\", {\n          get: function () { return unimplemented$1(); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RenderTypes.prototype, \"renderText\", {\n          get: function () { return unimplemented$1(); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RenderTypes.prototype, \"renderElement\", {\n          get: function () { return unimplemented$1(); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RenderTypes.prototype, \"renderComment\", {\n          get: function () { return unimplemented$1(); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RenderTypes.prototype, \"renderNode\", {\n          get: function () { return unimplemented$1(); },\n          enumerable: true,\n          configurable: true\n      });\n      Object.defineProperty(RenderTypes.prototype, \"renderEvent\", {\n          get: function () { return unimplemented$1(); },\n          enumerable: true,\n          configurable: true\n      });\n      return RenderTypes;\n  }());\n  var DefaultRenderTypes = (function () {\n      function DefaultRenderTypes() {\n          this.renderText = null;\n          this.renderElement = null;\n          this.renderComment = null;\n          this.renderNode = null;\n          this.renderEvent = null;\n      }\n      Object.defineProperty(DefaultRenderTypes.prototype, \"renderer\", {\n          get: function () { return resolveIdentifier(Identifiers.Renderer); },\n          enumerable: true,\n          configurable: true\n      });\n      ;\n      return DefaultRenderTypes;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$12 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  //// Types\n  var TypeModifier;\n  (function (TypeModifier) {\n      TypeModifier[TypeModifier[\"Const\"] = 0] = \"Const\";\n  })(TypeModifier || (TypeModifier = {}));\n  var Type$1 = (function () {\n      function Type(modifiers) {\n          if (modifiers === void 0) { modifiers = null; }\n          this.modifiers = modifiers;\n          if (!modifiers) {\n              this.modifiers = [];\n          }\n      }\n      Type.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n      return Type;\n  }());\n  var BuiltinTypeName;\n  (function (BuiltinTypeName) {\n      BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n      BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n      BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n      BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n      BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n      BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n      BuiltinTypeName[BuiltinTypeName[\"Null\"] = 6] = \"Null\";\n  })(BuiltinTypeName || (BuiltinTypeName = {}));\n  var BuiltinType = (function (_super) {\n      __extends$12(BuiltinType, _super);\n      function BuiltinType(name, modifiers) {\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, modifiers);\n          this.name = name;\n      }\n      BuiltinType.prototype.visitType = function (visitor, context) {\n          return visitor.visitBuiltintType(this, context);\n      };\n      return BuiltinType;\n  }(Type$1));\n  var ExternalType = (function (_super) {\n      __extends$12(ExternalType, _super);\n      function ExternalType(value, typeParams, modifiers) {\n          if (typeParams === void 0) { typeParams = null; }\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, modifiers);\n          this.value = value;\n          this.typeParams = typeParams;\n      }\n      ExternalType.prototype.visitType = function (visitor, context) {\n          return visitor.visitExternalType(this, context);\n      };\n      return ExternalType;\n  }(Type$1));\n  var ArrayType = (function (_super) {\n      __extends$12(ArrayType, _super);\n      function ArrayType(of, modifiers) {\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, modifiers);\n          this.of = of;\n      }\n      ArrayType.prototype.visitType = function (visitor, context) {\n          return visitor.visitArrayType(this, context);\n      };\n      return ArrayType;\n  }(Type$1));\n  var MapType = (function (_super) {\n      __extends$12(MapType, _super);\n      function MapType(valueType, modifiers) {\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, modifiers);\n          this.valueType = valueType;\n      }\n      MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };\n      return MapType;\n  }(Type$1));\n  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\n  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\n  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\n  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\n  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\n  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\n  var NULL_TYPE = new BuiltinType(BuiltinTypeName.Null);\n  ///// Expressions\n  var BinaryOperator;\n  (function (BinaryOperator) {\n      BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n      BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n      BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n      BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n      BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n      BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n      BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n      BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n      BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n      BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n      BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n      BinaryOperator[BinaryOperator[\"Lower\"] = 11] = \"Lower\";\n      BinaryOperator[BinaryOperator[\"LowerEquals\"] = 12] = \"LowerEquals\";\n      BinaryOperator[BinaryOperator[\"Bigger\"] = 13] = \"Bigger\";\n      BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 14] = \"BiggerEquals\";\n  })(BinaryOperator || (BinaryOperator = {}));\n  var Expression = (function () {\n      function Expression(type) {\n          this.type = type;\n      }\n      Expression.prototype.prop = function (name) { return new ReadPropExpr(this, name); };\n      Expression.prototype.key = function (index, type) {\n          if (type === void 0) { type = null; }\n          return new ReadKeyExpr(this, index, type);\n      };\n      Expression.prototype.callMethod = function (name, params) {\n          return new InvokeMethodExpr(this, name, params);\n      };\n      Expression.prototype.callFn = function (params) { return new InvokeFunctionExpr(this, params); };\n      Expression.prototype.instantiate = function (params, type) {\n          if (type === void 0) { type = null; }\n          return new InstantiateExpr(this, params, type);\n      };\n      Expression.prototype.conditional = function (trueCase, falseCase) {\n          if (falseCase === void 0) { falseCase = null; }\n          return new ConditionalExpr(this, trueCase, falseCase);\n      };\n      Expression.prototype.equals = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);\n      };\n      Expression.prototype.notEquals = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);\n      };\n      Expression.prototype.identical = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);\n      };\n      Expression.prototype.notIdentical = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);\n      };\n      Expression.prototype.minus = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);\n      };\n      Expression.prototype.plus = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);\n      };\n      Expression.prototype.divide = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);\n      };\n      Expression.prototype.multiply = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);\n      };\n      Expression.prototype.modulo = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);\n      };\n      Expression.prototype.and = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);\n      };\n      Expression.prototype.or = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);\n      };\n      Expression.prototype.lower = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);\n      };\n      Expression.prototype.lowerEquals = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);\n      };\n      Expression.prototype.bigger = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);\n      };\n      Expression.prototype.biggerEquals = function (rhs) {\n          return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);\n      };\n      Expression.prototype.isBlank = function () {\n          // Note: We use equals by purpose here to compare to null and undefined in JS.\n          // We use the typed null to allow strictNullChecks to narrow types.\n          return this.equals(TYPED_NULL_EXPR);\n      };\n      Expression.prototype.cast = function (type) { return new CastExpr(this, type); };\n      Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };\n      return Expression;\n  }());\n  var BuiltinVar;\n  (function (BuiltinVar) {\n      BuiltinVar[BuiltinVar[\"This\"] = 0] = \"This\";\n      BuiltinVar[BuiltinVar[\"Super\"] = 1] = \"Super\";\n      BuiltinVar[BuiltinVar[\"CatchError\"] = 2] = \"CatchError\";\n      BuiltinVar[BuiltinVar[\"CatchStack\"] = 3] = \"CatchStack\";\n  })(BuiltinVar || (BuiltinVar = {}));\n  var ReadVarExpr = (function (_super) {\n      __extends$12(ReadVarExpr, _super);\n      function ReadVarExpr(name, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          if (typeof name === 'string') {\n              this.name = name;\n              this.builtin = null;\n          }\n          else {\n              this.name = null;\n              this.builtin = name;\n          }\n      }\n      ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitReadVarExpr(this, context);\n      };\n      ReadVarExpr.prototype.set = function (value) { return new WriteVarExpr(this.name, value); };\n      return ReadVarExpr;\n  }(Expression));\n  var WriteVarExpr = (function (_super) {\n      __extends$12(WriteVarExpr, _super);\n      function WriteVarExpr(name, value, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type || value.type);\n          this.name = name;\n          this.value = value;\n      }\n      WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitWriteVarExpr(this, context);\n      };\n      WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n          if (type === void 0) { type = null; }\n          if (modifiers === void 0) { modifiers = null; }\n          return new DeclareVarStmt(this.name, this.value, type, modifiers);\n      };\n      return WriteVarExpr;\n  }(Expression));\n  var WriteKeyExpr = (function (_super) {\n      __extends$12(WriteKeyExpr, _super);\n      function WriteKeyExpr(receiver, index, value, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type || value.type);\n          this.receiver = receiver;\n          this.index = index;\n          this.value = value;\n      }\n      WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitWriteKeyExpr(this, context);\n      };\n      return WriteKeyExpr;\n  }(Expression));\n  var WritePropExpr = (function (_super) {\n      __extends$12(WritePropExpr, _super);\n      function WritePropExpr(receiver, name, value, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type || value.type);\n          this.receiver = receiver;\n          this.name = name;\n          this.value = value;\n      }\n      WritePropExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitWritePropExpr(this, context);\n      };\n      return WritePropExpr;\n  }(Expression));\n  var BuiltinMethod;\n  (function (BuiltinMethod) {\n      BuiltinMethod[BuiltinMethod[\"ConcatArray\"] = 0] = \"ConcatArray\";\n      BuiltinMethod[BuiltinMethod[\"SubscribeObservable\"] = 1] = \"SubscribeObservable\";\n      BuiltinMethod[BuiltinMethod[\"Bind\"] = 2] = \"Bind\";\n  })(BuiltinMethod || (BuiltinMethod = {}));\n  var InvokeMethodExpr = (function (_super) {\n      __extends$12(InvokeMethodExpr, _super);\n      function InvokeMethodExpr(receiver, method, args, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.receiver = receiver;\n          this.args = args;\n          if (typeof method === 'string') {\n              this.name = method;\n              this.builtin = null;\n          }\n          else {\n              this.name = null;\n              this.builtin = method;\n          }\n      }\n      InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitInvokeMethodExpr(this, context);\n      };\n      return InvokeMethodExpr;\n  }(Expression));\n  var InvokeFunctionExpr = (function (_super) {\n      __extends$12(InvokeFunctionExpr, _super);\n      function InvokeFunctionExpr(fn, args, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.fn = fn;\n          this.args = args;\n      }\n      InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitInvokeFunctionExpr(this, context);\n      };\n      return InvokeFunctionExpr;\n  }(Expression));\n  var InstantiateExpr = (function (_super) {\n      __extends$12(InstantiateExpr, _super);\n      function InstantiateExpr(classExpr, args, type) {\n          _super.call(this, type);\n          this.classExpr = classExpr;\n          this.args = args;\n      }\n      InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitInstantiateExpr(this, context);\n      };\n      return InstantiateExpr;\n  }(Expression));\n  var LiteralExpr = (function (_super) {\n      __extends$12(LiteralExpr, _super);\n      function LiteralExpr(value, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.value = value;\n      }\n      LiteralExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitLiteralExpr(this, context);\n      };\n      return LiteralExpr;\n  }(Expression));\n  var ExternalExpr = (function (_super) {\n      __extends$12(ExternalExpr, _super);\n      function ExternalExpr(value, type, typeParams) {\n          if (type === void 0) { type = null; }\n          if (typeParams === void 0) { typeParams = null; }\n          _super.call(this, type);\n          this.value = value;\n          this.typeParams = typeParams;\n      }\n      ExternalExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitExternalExpr(this, context);\n      };\n      return ExternalExpr;\n  }(Expression));\n  var ConditionalExpr = (function (_super) {\n      __extends$12(ConditionalExpr, _super);\n      function ConditionalExpr(condition, trueCase, falseCase, type) {\n          if (falseCase === void 0) { falseCase = null; }\n          if (type === void 0) { type = null; }\n          _super.call(this, type || trueCase.type);\n          this.condition = condition;\n          this.falseCase = falseCase;\n          this.trueCase = trueCase;\n      }\n      ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitConditionalExpr(this, context);\n      };\n      return ConditionalExpr;\n  }(Expression));\n  var NotExpr = (function (_super) {\n      __extends$12(NotExpr, _super);\n      function NotExpr(condition) {\n          _super.call(this, BOOL_TYPE);\n          this.condition = condition;\n      }\n      NotExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitNotExpr(this, context);\n      };\n      return NotExpr;\n  }(Expression));\n  var CastExpr = (function (_super) {\n      __extends$12(CastExpr, _super);\n      function CastExpr(value, type) {\n          _super.call(this, type);\n          this.value = value;\n      }\n      CastExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitCastExpr(this, context);\n      };\n      return CastExpr;\n  }(Expression));\n  var FnParam = (function () {\n      function FnParam(name, type) {\n          if (type === void 0) { type = null; }\n          this.name = name;\n          this.type = type;\n      }\n      return FnParam;\n  }());\n  var FunctionExpr = (function (_super) {\n      __extends$12(FunctionExpr, _super);\n      function FunctionExpr(params, statements, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.params = params;\n          this.statements = statements;\n      }\n      FunctionExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitFunctionExpr(this, context);\n      };\n      FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n          if (modifiers === void 0) { modifiers = null; }\n          return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);\n      };\n      return FunctionExpr;\n  }(Expression));\n  var BinaryOperatorExpr = (function (_super) {\n      __extends$12(BinaryOperatorExpr, _super);\n      function BinaryOperatorExpr(operator, lhs, rhs, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type || lhs.type);\n          this.operator = operator;\n          this.rhs = rhs;\n          this.lhs = lhs;\n      }\n      BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitBinaryOperatorExpr(this, context);\n      };\n      return BinaryOperatorExpr;\n  }(Expression));\n  var ReadPropExpr = (function (_super) {\n      __extends$12(ReadPropExpr, _super);\n      function ReadPropExpr(receiver, name, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.receiver = receiver;\n          this.name = name;\n      }\n      ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitReadPropExpr(this, context);\n      };\n      ReadPropExpr.prototype.set = function (value) {\n          return new WritePropExpr(this.receiver, this.name, value);\n      };\n      return ReadPropExpr;\n  }(Expression));\n  var ReadKeyExpr = (function (_super) {\n      __extends$12(ReadKeyExpr, _super);\n      function ReadKeyExpr(receiver, index, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.receiver = receiver;\n          this.index = index;\n      }\n      ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitReadKeyExpr(this, context);\n      };\n      ReadKeyExpr.prototype.set = function (value) {\n          return new WriteKeyExpr(this.receiver, this.index, value);\n      };\n      return ReadKeyExpr;\n  }(Expression));\n  var LiteralArrayExpr = (function (_super) {\n      __extends$12(LiteralArrayExpr, _super);\n      function LiteralArrayExpr(entries, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.entries = entries;\n      }\n      LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitLiteralArrayExpr(this, context);\n      };\n      return LiteralArrayExpr;\n  }(Expression));\n  var LiteralMapExpr = (function (_super) {\n      __extends$12(LiteralMapExpr, _super);\n      function LiteralMapExpr(entries, type) {\n          if (type === void 0) { type = null; }\n          _super.call(this, type);\n          this.entries = entries;\n          this.valueType = null;\n          if (isPresent(type)) {\n              this.valueType = type.valueType;\n          }\n      }\n      LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n          return visitor.visitLiteralMapExpr(this, context);\n      };\n      return LiteralMapExpr;\n  }(Expression));\n  var THIS_EXPR = new ReadVarExpr(BuiltinVar.This);\n  var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);\n  var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);\n  var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);\n  var NULL_EXPR = new LiteralExpr(null, null);\n  var TYPED_NULL_EXPR = new LiteralExpr(null, NULL_TYPE);\n  //// Statements\n  var StmtModifier;\n  (function (StmtModifier) {\n      StmtModifier[StmtModifier[\"Final\"] = 0] = \"Final\";\n      StmtModifier[StmtModifier[\"Private\"] = 1] = \"Private\";\n  })(StmtModifier || (StmtModifier = {}));\n  var Statement = (function () {\n      function Statement(modifiers) {\n          if (modifiers === void 0) { modifiers = null; }\n          this.modifiers = modifiers;\n          if (!modifiers) {\n              this.modifiers = [];\n          }\n      }\n      Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n      return Statement;\n  }());\n  var DeclareVarStmt = (function (_super) {\n      __extends$12(DeclareVarStmt, _super);\n      function DeclareVarStmt(name, value, type, modifiers) {\n          if (type === void 0) { type = null; }\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, modifiers);\n          this.name = name;\n          this.value = value;\n          this.type = type || value.type;\n      }\n      DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitDeclareVarStmt(this, context);\n      };\n      return DeclareVarStmt;\n  }(Statement));\n  var DeclareFunctionStmt = (function (_super) {\n      __extends$12(DeclareFunctionStmt, _super);\n      function DeclareFunctionStmt(name, params, statements, type, modifiers) {\n          if (type === void 0) { type = null; }\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, modifiers);\n          this.name = name;\n          this.params = params;\n          this.statements = statements;\n          this.type = type;\n      }\n      DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitDeclareFunctionStmt(this, context);\n      };\n      return DeclareFunctionStmt;\n  }(Statement));\n  var ExpressionStatement = (function (_super) {\n      __extends$12(ExpressionStatement, _super);\n      function ExpressionStatement(expr) {\n          _super.call(this);\n          this.expr = expr;\n      }\n      ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitExpressionStmt(this, context);\n      };\n      return ExpressionStatement;\n  }(Statement));\n  var ReturnStatement = (function (_super) {\n      __extends$12(ReturnStatement, _super);\n      function ReturnStatement(value) {\n          _super.call(this);\n          this.value = value;\n      }\n      ReturnStatement.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitReturnStmt(this, context);\n      };\n      return ReturnStatement;\n  }(Statement));\n  var AbstractClassPart = (function () {\n      function AbstractClassPart(type, modifiers) {\n          if (type === void 0) { type = null; }\n          this.type = type;\n          this.modifiers = modifiers;\n          if (!modifiers) {\n              this.modifiers = [];\n          }\n      }\n      AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n      return AbstractClassPart;\n  }());\n  var ClassField = (function (_super) {\n      __extends$12(ClassField, _super);\n      function ClassField(name, type, modifiers) {\n          if (type === void 0) { type = null; }\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, type, modifiers);\n          this.name = name;\n      }\n      return ClassField;\n  }(AbstractClassPart));\n  var ClassMethod = (function (_super) {\n      __extends$12(ClassMethod, _super);\n      function ClassMethod(name, params, body, type, modifiers) {\n          if (type === void 0) { type = null; }\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, type, modifiers);\n          this.name = name;\n          this.params = params;\n          this.body = body;\n      }\n      return ClassMethod;\n  }(AbstractClassPart));\n  var ClassGetter = (function (_super) {\n      __extends$12(ClassGetter, _super);\n      function ClassGetter(name, body, type, modifiers) {\n          if (type === void 0) { type = null; }\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, type, modifiers);\n          this.name = name;\n          this.body = body;\n      }\n      return ClassGetter;\n  }(AbstractClassPart));\n  var ClassStmt = (function (_super) {\n      __extends$12(ClassStmt, _super);\n      function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {\n          if (modifiers === void 0) { modifiers = null; }\n          _super.call(this, modifiers);\n          this.name = name;\n          this.parent = parent;\n          this.fields = fields;\n          this.getters = getters;\n          this.constructorMethod = constructorMethod;\n          this.methods = methods;\n      }\n      ClassStmt.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitDeclareClassStmt(this, context);\n      };\n      return ClassStmt;\n  }(Statement));\n  var IfStmt = (function (_super) {\n      __extends$12(IfStmt, _super);\n      function IfStmt(condition, trueCase, falseCase) {\n          if (falseCase === void 0) { falseCase = []; }\n          _super.call(this);\n          this.condition = condition;\n          this.trueCase = trueCase;\n          this.falseCase = falseCase;\n      }\n      IfStmt.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitIfStmt(this, context);\n      };\n      return IfStmt;\n  }(Statement));\n  var CommentStmt = (function (_super) {\n      __extends$12(CommentStmt, _super);\n      function CommentStmt(comment) {\n          _super.call(this);\n          this.comment = comment;\n      }\n      CommentStmt.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitCommentStmt(this, context);\n      };\n      return CommentStmt;\n  }(Statement));\n  var TryCatchStmt = (function (_super) {\n      __extends$12(TryCatchStmt, _super);\n      function TryCatchStmt(bodyStmts, catchStmts) {\n          _super.call(this);\n          this.bodyStmts = bodyStmts;\n          this.catchStmts = catchStmts;\n      }\n      TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitTryCatchStmt(this, context);\n      };\n      return TryCatchStmt;\n  }(Statement));\n  var ThrowStmt = (function (_super) {\n      __extends$12(ThrowStmt, _super);\n      function ThrowStmt(error) {\n          _super.call(this);\n          this.error = error;\n      }\n      ThrowStmt.prototype.visitStatement = function (visitor, context) {\n          return visitor.visitThrowStmt(this, context);\n      };\n      return ThrowStmt;\n  }(Statement));\n  var ExpressionTransformer = (function () {\n      function ExpressionTransformer() {\n      }\n      ExpressionTransformer.prototype.visitReadVarExpr = function (ast, context) { return ast; };\n      ExpressionTransformer.prototype.visitWriteVarExpr = function (expr, context) {\n          return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitWriteKeyExpr = function (expr, context) {\n          return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitWritePropExpr = function (expr, context) {\n          return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {\n          var method = ast.builtin || ast.name;\n          return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);\n      };\n      ExpressionTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {\n          return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);\n      };\n      ExpressionTransformer.prototype.visitInstantiateExpr = function (ast, context) {\n          return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);\n      };\n      ExpressionTransformer.prototype.visitLiteralExpr = function (ast, context) { return ast; };\n      ExpressionTransformer.prototype.visitExternalExpr = function (ast, context) { return ast; };\n      ExpressionTransformer.prototype.visitConditionalExpr = function (ast, context) {\n          return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitNotExpr = function (ast, context) {\n          return new NotExpr(ast.condition.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitCastExpr = function (ast, context) {\n          return new CastExpr(ast.value.visitExpression(this, context), context);\n      };\n      ExpressionTransformer.prototype.visitFunctionExpr = function (ast, context) {\n          // Don't descend into nested functions\n          return ast;\n      };\n      ExpressionTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {\n          return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);\n      };\n      ExpressionTransformer.prototype.visitReadPropExpr = function (ast, context) {\n          return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);\n      };\n      ExpressionTransformer.prototype.visitReadKeyExpr = function (ast, context) {\n          return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);\n      };\n      ExpressionTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {\n          return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));\n      };\n      ExpressionTransformer.prototype.visitLiteralMapExpr = function (ast, context) {\n          var _this = this;\n          var entries = ast.entries.map(function (entry) { return [entry[0], entry[1].visitExpression(_this, context),]; });\n          return new LiteralMapExpr(entries);\n      };\n      ExpressionTransformer.prototype.visitAllExpressions = function (exprs, context) {\n          var _this = this;\n          return exprs.map(function (expr) { return expr.visitExpression(_this, context); });\n      };\n      ExpressionTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {\n          return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);\n      };\n      ExpressionTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n          // Don't descend into nested functions\n          return stmt;\n      };\n      ExpressionTransformer.prototype.visitExpressionStmt = function (stmt, context) {\n          return new ExpressionStatement(stmt.expr.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitReturnStmt = function (stmt, context) {\n          return new ReturnStatement(stmt.value.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {\n          // Don't descend into nested functions\n          return stmt;\n      };\n      ExpressionTransformer.prototype.visitIfStmt = function (stmt, context) {\n          return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));\n      };\n      ExpressionTransformer.prototype.visitTryCatchStmt = function (stmt, context) {\n          return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));\n      };\n      ExpressionTransformer.prototype.visitThrowStmt = function (stmt, context) {\n          return new ThrowStmt(stmt.error.visitExpression(this, context));\n      };\n      ExpressionTransformer.prototype.visitCommentStmt = function (stmt, context) { return stmt; };\n      ExpressionTransformer.prototype.visitAllStatements = function (stmts, context) {\n          var _this = this;\n          return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });\n      };\n      return ExpressionTransformer;\n  }());\n  var RecursiveExpressionVisitor = (function () {\n      function RecursiveExpressionVisitor() {\n      }\n      RecursiveExpressionVisitor.prototype.visitReadVarExpr = function (ast, context) { return ast; };\n      RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function (expr, context) {\n          expr.value.visitExpression(this, context);\n          return expr;\n      };\n      RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function (expr, context) {\n          expr.receiver.visitExpression(this, context);\n          expr.index.visitExpression(this, context);\n          expr.value.visitExpression(this, context);\n          return expr;\n      };\n      RecursiveExpressionVisitor.prototype.visitWritePropExpr = function (expr, context) {\n          expr.receiver.visitExpression(this, context);\n          expr.value.visitExpression(this, context);\n          return expr;\n      };\n      RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {\n          ast.receiver.visitExpression(this, context);\n          this.visitAllExpressions(ast.args, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {\n          ast.fn.visitExpression(this, context);\n          this.visitAllExpressions(ast.args, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function (ast, context) {\n          ast.classExpr.visitExpression(this, context);\n          this.visitAllExpressions(ast.args, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitLiteralExpr = function (ast, context) { return ast; };\n      RecursiveExpressionVisitor.prototype.visitExternalExpr = function (ast, context) { return ast; };\n      RecursiveExpressionVisitor.prototype.visitConditionalExpr = function (ast, context) {\n          ast.condition.visitExpression(this, context);\n          ast.trueCase.visitExpression(this, context);\n          ast.falseCase.visitExpression(this, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitNotExpr = function (ast, context) {\n          ast.condition.visitExpression(this, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitCastExpr = function (ast, context) {\n          ast.value.visitExpression(this, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitFunctionExpr = function (ast, context) { return ast; };\n      RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {\n          ast.lhs.visitExpression(this, context);\n          ast.rhs.visitExpression(this, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitReadPropExpr = function (ast, context) {\n          ast.receiver.visitExpression(this, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function (ast, context) {\n          ast.receiver.visitExpression(this, context);\n          ast.index.visitExpression(this, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n          this.visitAllExpressions(ast.entries, context);\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n          var _this = this;\n          ast.entries.forEach(function (entry) { return entry[1].visitExpression(_this, context); });\n          return ast;\n      };\n      RecursiveExpressionVisitor.prototype.visitAllExpressions = function (exprs, context) {\n          var _this = this;\n          exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });\n      };\n      RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {\n          stmt.value.visitExpression(this, context);\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n          // Don't descend into nested functions\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitExpressionStmt = function (stmt, context) {\n          stmt.expr.visitExpression(this, context);\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitReturnStmt = function (stmt, context) {\n          stmt.value.visitExpression(this, context);\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n          // Don't descend into nested functions\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitIfStmt = function (stmt, context) {\n          stmt.condition.visitExpression(this, context);\n          this.visitAllStatements(stmt.trueCase, context);\n          this.visitAllStatements(stmt.falseCase, context);\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function (stmt, context) {\n          this.visitAllStatements(stmt.bodyStmts, context);\n          this.visitAllStatements(stmt.catchStmts, context);\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitThrowStmt = function (stmt, context) {\n          stmt.error.visitExpression(this, context);\n          return stmt;\n      };\n      RecursiveExpressionVisitor.prototype.visitCommentStmt = function (stmt, context) { return stmt; };\n      RecursiveExpressionVisitor.prototype.visitAllStatements = function (stmts, context) {\n          var _this = this;\n          stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });\n      };\n      return RecursiveExpressionVisitor;\n  }());\n  function replaceVarInExpression(varName, newValue, expression) {\n      var transformer = new _ReplaceVariableTransformer(varName, newValue);\n      return expression.visitExpression(transformer, null);\n  }\n  var _ReplaceVariableTransformer = (function (_super) {\n      __extends$12(_ReplaceVariableTransformer, _super);\n      function _ReplaceVariableTransformer(_varName, _newValue) {\n          _super.call(this);\n          this._varName = _varName;\n          this._newValue = _newValue;\n      }\n      _ReplaceVariableTransformer.prototype.visitReadVarExpr = function (ast, context) {\n          return ast.name == this._varName ? this._newValue : ast;\n      };\n      return _ReplaceVariableTransformer;\n  }(ExpressionTransformer));\n  function findReadVarNames(stmts) {\n      var finder = new _VariableFinder();\n      finder.visitAllStatements(stmts, null);\n      return finder.varNames;\n  }\n  var _VariableFinder = (function (_super) {\n      __extends$12(_VariableFinder, _super);\n      function _VariableFinder() {\n          _super.apply(this, arguments);\n          this.varNames = new Set();\n      }\n      _VariableFinder.prototype.visitReadVarExpr = function (ast, context) {\n          this.varNames.add(ast.name);\n          return null;\n      };\n      return _VariableFinder;\n  }(RecursiveExpressionVisitor));\n  function variable(name, type) {\n      if (type === void 0) { type = null; }\n      return new ReadVarExpr(name, type);\n  }\n  function importExpr(id, typeParams) {\n      if (typeParams === void 0) { typeParams = null; }\n      return new ExternalExpr(id, null, typeParams);\n  }\n  function importType(id, typeParams, typeModifiers) {\n      if (typeParams === void 0) { typeParams = null; }\n      if (typeModifiers === void 0) { typeModifiers = null; }\n      return isPresent(id) ? new ExternalType(id, typeParams, typeModifiers) : null;\n  }\n  function literalArr(values, type) {\n      if (type === void 0) { type = null; }\n      return new LiteralArrayExpr(values, type);\n  }\n  function literalMap(values, type) {\n      if (type === void 0) { type = null; }\n      return new LiteralMapExpr(values, type);\n  }\n  function not(expr) {\n      return new NotExpr(expr);\n  }\n  function fn(params, body, type) {\n      if (type === void 0) { type = null; }\n      return new FunctionExpr(params, body, type);\n  }\n  function literal(value, type) {\n      if (type === void 0) { type = null; }\n      return new LiteralExpr(value, type);\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$13 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var AnimationAst = (function () {\n      function AnimationAst() {\n          this.startTime = 0;\n          this.playTime = 0;\n      }\n      return AnimationAst;\n  }());\n  var AnimationStateAst = (function (_super) {\n      __extends$13(AnimationStateAst, _super);\n      function AnimationStateAst() {\n          _super.apply(this, arguments);\n      }\n      return AnimationStateAst;\n  }(AnimationAst));\n  var AnimationEntryAst = (function (_super) {\n      __extends$13(AnimationEntryAst, _super);\n      function AnimationEntryAst(name, stateDeclarations, stateTransitions) {\n          _super.call(this);\n          this.name = name;\n          this.stateDeclarations = stateDeclarations;\n          this.stateTransitions = stateTransitions;\n      }\n      AnimationEntryAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationEntry(this, context);\n      };\n      return AnimationEntryAst;\n  }(AnimationAst));\n  var AnimationStateDeclarationAst = (function (_super) {\n      __extends$13(AnimationStateDeclarationAst, _super);\n      function AnimationStateDeclarationAst(stateName, styles) {\n          _super.call(this);\n          this.stateName = stateName;\n          this.styles = styles;\n      }\n      AnimationStateDeclarationAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationStateDeclaration(this, context);\n      };\n      return AnimationStateDeclarationAst;\n  }(AnimationStateAst));\n  var AnimationStateTransitionExpression = (function () {\n      function AnimationStateTransitionExpression(fromState, toState) {\n          this.fromState = fromState;\n          this.toState = toState;\n      }\n      return AnimationStateTransitionExpression;\n  }());\n  var AnimationStateTransitionAst = (function (_super) {\n      __extends$13(AnimationStateTransitionAst, _super);\n      function AnimationStateTransitionAst(stateChanges, animation) {\n          _super.call(this);\n          this.stateChanges = stateChanges;\n          this.animation = animation;\n      }\n      AnimationStateTransitionAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationStateTransition(this, context);\n      };\n      return AnimationStateTransitionAst;\n  }(AnimationStateAst));\n  var AnimationStepAst = (function (_super) {\n      __extends$13(AnimationStepAst, _super);\n      function AnimationStepAst(startingStyles, keyframes, duration, delay, easing) {\n          _super.call(this);\n          this.startingStyles = startingStyles;\n          this.keyframes = keyframes;\n          this.duration = duration;\n          this.delay = delay;\n          this.easing = easing;\n      }\n      AnimationStepAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationStep(this, context);\n      };\n      return AnimationStepAst;\n  }(AnimationAst));\n  var AnimationStylesAst = (function (_super) {\n      __extends$13(AnimationStylesAst, _super);\n      function AnimationStylesAst(styles) {\n          _super.call(this);\n          this.styles = styles;\n      }\n      AnimationStylesAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationStyles(this, context);\n      };\n      return AnimationStylesAst;\n  }(AnimationAst));\n  var AnimationKeyframeAst = (function (_super) {\n      __extends$13(AnimationKeyframeAst, _super);\n      function AnimationKeyframeAst(offset, styles) {\n          _super.call(this);\n          this.offset = offset;\n          this.styles = styles;\n      }\n      AnimationKeyframeAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationKeyframe(this, context);\n      };\n      return AnimationKeyframeAst;\n  }(AnimationAst));\n  var AnimationWithStepsAst = (function (_super) {\n      __extends$13(AnimationWithStepsAst, _super);\n      function AnimationWithStepsAst(steps) {\n          _super.call(this);\n          this.steps = steps;\n      }\n      return AnimationWithStepsAst;\n  }(AnimationAst));\n  var AnimationGroupAst = (function (_super) {\n      __extends$13(AnimationGroupAst, _super);\n      function AnimationGroupAst(steps) {\n          _super.call(this, steps);\n      }\n      AnimationGroupAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationGroup(this, context);\n      };\n      return AnimationGroupAst;\n  }(AnimationWithStepsAst));\n  var AnimationSequenceAst = (function (_super) {\n      __extends$13(AnimationSequenceAst, _super);\n      function AnimationSequenceAst(steps) {\n          _super.call(this, steps);\n      }\n      AnimationSequenceAst.prototype.visit = function (visitor, context) {\n          return visitor.visitAnimationSequence(this, context);\n      };\n      return AnimationSequenceAst;\n  }(AnimationWithStepsAst));\n\n  var AnimationEntryCompileResult = (function () {\n      function AnimationEntryCompileResult(name, statements, fnExp) {\n          this.name = name;\n          this.statements = statements;\n          this.fnExp = fnExp;\n      }\n      return AnimationEntryCompileResult;\n  }());\n  var AnimationCompiler = (function () {\n      function AnimationCompiler() {\n      }\n      AnimationCompiler.prototype.compile = function (factoryNamePrefix, parsedAnimations) {\n          return parsedAnimations.map(function (entry) {\n              var factoryName = factoryNamePrefix + \"_\" + entry.name;\n              var visitor = new _AnimationBuilder(entry.name, factoryName);\n              return visitor.build(entry);\n          });\n      };\n      return AnimationCompiler;\n  }());\n  var _ANIMATION_FACTORY_ELEMENT_VAR = variable('element');\n  var _ANIMATION_DEFAULT_STATE_VAR = variable('defaultStateStyles');\n  var _ANIMATION_FACTORY_VIEW_VAR = variable('view');\n  var _ANIMATION_FACTORY_VIEW_CONTEXT = _ANIMATION_FACTORY_VIEW_VAR.prop('animationContext');\n  var _ANIMATION_FACTORY_RENDERER_VAR = _ANIMATION_FACTORY_VIEW_VAR.prop('renderer');\n  var _ANIMATION_CURRENT_STATE_VAR = variable('currentState');\n  var _ANIMATION_NEXT_STATE_VAR = variable('nextState');\n  var _ANIMATION_PLAYER_VAR = variable('player');\n  var _ANIMATION_TIME_VAR = variable('totalTime');\n  var _ANIMATION_START_STATE_STYLES_VAR = variable('startStateStyles');\n  var _ANIMATION_END_STATE_STYLES_VAR = variable('endStateStyles');\n  var _ANIMATION_COLLECTED_STYLES = variable('collectedStyles');\n  var EMPTY_MAP = literalMap([]);\n  var _AnimationBuilder = (function () {\n      function _AnimationBuilder(animationName, factoryName) {\n          this.animationName = animationName;\n          this._fnVarName = factoryName + '_factory';\n          this._statesMapVarName = factoryName + '_states';\n          this._statesMapVar = variable(this._statesMapVarName);\n      }\n      _AnimationBuilder.prototype.visitAnimationStyles = function (ast, context) {\n          var stylesArr = [];\n          if (context.isExpectingFirstStyleStep) {\n              stylesArr.push(_ANIMATION_START_STATE_STYLES_VAR);\n              context.isExpectingFirstStyleStep = false;\n          }\n          ast.styles.forEach(function (entry) {\n              var entries = Object.keys(entry).map(function (key) { return [key, literal(entry[key])]; });\n              stylesArr.push(literalMap(entries));\n          });\n          return importExpr(resolveIdentifier(Identifiers.AnimationStyles)).instantiate([\n              importExpr(resolveIdentifier(Identifiers.collectAndResolveStyles)).callFn([\n                  _ANIMATION_COLLECTED_STYLES, literalArr(stylesArr)\n              ])\n          ]);\n      };\n      _AnimationBuilder.prototype.visitAnimationKeyframe = function (ast, context) {\n          return importExpr(resolveIdentifier(Identifiers.AnimationKeyframe)).instantiate([\n              literal(ast.offset), ast.styles.visit(this, context)\n          ]);\n      };\n      _AnimationBuilder.prototype.visitAnimationStep = function (ast, context) {\n          var _this = this;\n          if (context.endStateAnimateStep === ast) {\n              return this._visitEndStateAnimation(ast, context);\n          }\n          var startingStylesExpr = ast.startingStyles.visit(this, context);\n          var keyframeExpressions = ast.keyframes.map(function (keyframeEntry) { return keyframeEntry.visit(_this, context); });\n          return this._callAnimateMethod(ast, startingStylesExpr, literalArr(keyframeExpressions), context);\n      };\n      /** @internal */\n      _AnimationBuilder.prototype._visitEndStateAnimation = function (ast, context) {\n          var _this = this;\n          var startingStylesExpr = ast.startingStyles.visit(this, context);\n          var keyframeExpressions = ast.keyframes.map(function (keyframe) { return keyframe.visit(_this, context); });\n          var keyframesExpr = importExpr(resolveIdentifier(Identifiers.balanceAnimationKeyframes)).callFn([\n              _ANIMATION_COLLECTED_STYLES, _ANIMATION_END_STATE_STYLES_VAR,\n              literalArr(keyframeExpressions)\n          ]);\n          return this._callAnimateMethod(ast, startingStylesExpr, keyframesExpr, context);\n      };\n      /** @internal */\n      _AnimationBuilder.prototype._callAnimateMethod = function (ast, startingStylesExpr, keyframesExpr, context) {\n          context.totalTransitionTime += ast.duration + ast.delay;\n          return _ANIMATION_FACTORY_RENDERER_VAR.callMethod('animate', [\n              _ANIMATION_FACTORY_ELEMENT_VAR, startingStylesExpr, keyframesExpr, literal(ast.duration),\n              literal(ast.delay), literal(ast.easing)\n          ]);\n      };\n      _AnimationBuilder.prototype.visitAnimationSequence = function (ast, context) {\n          var _this = this;\n          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });\n          return importExpr(resolveIdentifier(Identifiers.AnimationSequencePlayer)).instantiate([\n              literalArr(playerExprs)\n          ]);\n      };\n      _AnimationBuilder.prototype.visitAnimationGroup = function (ast, context) {\n          var _this = this;\n          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });\n          return importExpr(resolveIdentifier(Identifiers.AnimationGroupPlayer)).instantiate([\n              literalArr(playerExprs)\n          ]);\n      };\n      _AnimationBuilder.prototype.visitAnimationStateDeclaration = function (ast, context) {\n          var flatStyles = {};\n          _getStylesArray(ast).forEach(function (entry) { Object.keys(entry).forEach(function (key) { flatStyles[key] = entry[key]; }); });\n          context.stateMap.registerState(ast.stateName, flatStyles);\n      };\n      _AnimationBuilder.prototype.visitAnimationStateTransition = function (ast, context) {\n          var steps = ast.animation.steps;\n          var lastStep = steps[steps.length - 1];\n          if (_isEndStateAnimateStep(lastStep)) {\n              context.endStateAnimateStep = lastStep;\n          }\n          context.totalTransitionTime = 0;\n          context.isExpectingFirstStyleStep = true;\n          var stateChangePreconditions = [];\n          ast.stateChanges.forEach(function (stateChange) {\n              stateChangePreconditions.push(_compareToAnimationStateExpr(_ANIMATION_CURRENT_STATE_VAR, stateChange.fromState)\n                  .and(_compareToAnimationStateExpr(_ANIMATION_NEXT_STATE_VAR, stateChange.toState)));\n              if (stateChange.fromState != ANY_STATE) {\n                  context.stateMap.registerState(stateChange.fromState);\n              }\n              if (stateChange.toState != ANY_STATE) {\n                  context.stateMap.registerState(stateChange.toState);\n              }\n          });\n          var animationPlayerExpr = ast.animation.visit(this, context);\n          var reducedStateChangesPrecondition = stateChangePreconditions.reduce(function (a, b) { return a.or(b); });\n          var precondition = _ANIMATION_PLAYER_VAR.equals(NULL_EXPR).and(reducedStateChangesPrecondition);\n          var animationStmt = _ANIMATION_PLAYER_VAR.set(animationPlayerExpr).toStmt();\n          var totalTimeStmt = _ANIMATION_TIME_VAR.set(literal(context.totalTransitionTime)).toStmt();\n          return new IfStmt(precondition, [animationStmt, totalTimeStmt]);\n      };\n      _AnimationBuilder.prototype.visitAnimationEntry = function (ast, context) {\n          var _this = this;\n          // visit each of the declarations first to build the context state map\n          ast.stateDeclarations.forEach(function (def) { return def.visit(_this, context); });\n          // this should always be defined even if the user overrides it\n          context.stateMap.registerState(DEFAULT_STATE, {});\n          var statements = [];\n          statements.push(_ANIMATION_FACTORY_VIEW_CONTEXT\n              .callMethod('cancelActiveAnimation', [\n              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),\n              _ANIMATION_NEXT_STATE_VAR.equals(literal(EMPTY_ANIMATION_STATE))\n          ])\n              .toStmt());\n          statements.push(_ANIMATION_COLLECTED_STYLES.set(EMPTY_MAP).toDeclStmt());\n          statements.push(_ANIMATION_PLAYER_VAR.set(NULL_EXPR).toDeclStmt());\n          statements.push(_ANIMATION_TIME_VAR.set(literal(0)).toDeclStmt());\n          statements.push(_ANIMATION_DEFAULT_STATE_VAR.set(this._statesMapVar.key(literal(DEFAULT_STATE)))\n              .toDeclStmt());\n          statements.push(_ANIMATION_START_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_CURRENT_STATE_VAR))\n              .toDeclStmt());\n          statements.push(new IfStmt(_ANIMATION_START_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_START_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));\n          statements.push(_ANIMATION_END_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_NEXT_STATE_VAR))\n              .toDeclStmt());\n          statements.push(new IfStmt(_ANIMATION_END_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_END_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));\n          var RENDER_STYLES_FN = importExpr(resolveIdentifier(Identifiers.renderStyles));\n          // before we start any animation we want to clear out the starting\n          // styles from the element's style property (since they were placed\n          // there at the end of the last animation\n          statements.push(RENDER_STYLES_FN\n              .callFn([\n              _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,\n              importExpr(resolveIdentifier(Identifiers.clearStyles))\n                  .callFn([_ANIMATION_START_STATE_STYLES_VAR])\n          ])\n              .toStmt());\n          ast.stateTransitions.forEach(function (transAst) { return statements.push(transAst.visit(_this, context)); });\n          // this check ensures that the animation factory always returns a player\n          // so that the onDone callback can be used for tracking\n          statements.push(new IfStmt(_ANIMATION_PLAYER_VAR.equals(NULL_EXPR), [_ANIMATION_PLAYER_VAR\n                  .set(importExpr(resolveIdentifier(Identifiers.NoOpAnimationPlayer)).instantiate([]))\n                  .toStmt()]));\n          // once complete we want to apply the styles on the element\n          // since the destination state's values should persist once\n          // the animation sequence has completed.\n          statements.push(_ANIMATION_PLAYER_VAR\n              .callMethod('onDone', [fn([], [\n                  _ANIMATION_PLAYER_VAR.callMethod('destroy', []).toStmt(),\n                  RENDER_STYLES_FN\n                      .callFn([\n                      _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,\n                      importExpr(resolveIdentifier(Identifiers.prepareFinalAnimationStyles))\n                          .callFn([\n                          _ANIMATION_START_STATE_STYLES_VAR,\n                          _ANIMATION_END_STATE_STYLES_VAR\n                      ])\n                  ])\n                      .toStmt()\n              ])])\n              .toStmt());\n          statements.push(_ANIMATION_FACTORY_VIEW_CONTEXT\n              .callMethod('queueAnimation', [\n              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),\n              _ANIMATION_PLAYER_VAR\n          ])\n              .toStmt());\n          statements.push(new ReturnStatement(importExpr(resolveIdentifier(Identifiers.AnimationTransition)).instantiate([\n              _ANIMATION_PLAYER_VAR, _ANIMATION_CURRENT_STATE_VAR, _ANIMATION_NEXT_STATE_VAR,\n              _ANIMATION_TIME_VAR\n          ])));\n          return fn([\n              new FnParam(_ANIMATION_FACTORY_VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n              new FnParam(_ANIMATION_FACTORY_ELEMENT_VAR.name, DYNAMIC_TYPE),\n              new FnParam(_ANIMATION_CURRENT_STATE_VAR.name, DYNAMIC_TYPE),\n              new FnParam(_ANIMATION_NEXT_STATE_VAR.name, DYNAMIC_TYPE)\n          ], statements, importType(resolveIdentifier(Identifiers.AnimationTransition)));\n      };\n      _AnimationBuilder.prototype.build = function (ast) {\n          var context = new _AnimationBuilderContext();\n          var fnStatement = ast.visit(this, context).toDeclStmt(this._fnVarName);\n          var fnVariable = variable(this._fnVarName);\n          var lookupMap = [];\n          Object.keys(context.stateMap.states).forEach(function (stateName) {\n              var value = context.stateMap.states[stateName];\n              var variableValue = EMPTY_MAP;\n              if (isPresent(value)) {\n                  var styleMap_1 = [];\n                  Object.keys(value).forEach(function (key) { styleMap_1.push([key, literal(value[key])]); });\n                  variableValue = literalMap(styleMap_1);\n              }\n              lookupMap.push([stateName, variableValue]);\n          });\n          var compiledStatesMapStmt = this._statesMapVar.set(literalMap(lookupMap)).toDeclStmt();\n          var statements = [compiledStatesMapStmt, fnStatement];\n          return new AnimationEntryCompileResult(this.animationName, statements, fnVariable);\n      };\n      return _AnimationBuilder;\n  }());\n  var _AnimationBuilderContext = (function () {\n      function _AnimationBuilderContext() {\n          this.stateMap = new _AnimationBuilderStateMap();\n          this.endStateAnimateStep = null;\n          this.isExpectingFirstStyleStep = false;\n          this.totalTransitionTime = 0;\n      }\n      return _AnimationBuilderContext;\n  }());\n  var _AnimationBuilderStateMap = (function () {\n      function _AnimationBuilderStateMap() {\n          this._states = {};\n      }\n      Object.defineProperty(_AnimationBuilderStateMap.prototype, \"states\", {\n          get: function () { return this._states; },\n          enumerable: true,\n          configurable: true\n      });\n      _AnimationBuilderStateMap.prototype.registerState = function (name, value) {\n          if (value === void 0) { value = null; }\n          var existingEntry = this._states[name];\n          if (!existingEntry) {\n              this._states[name] = value;\n          }\n      };\n      return _AnimationBuilderStateMap;\n  }());\n  function _compareToAnimationStateExpr(value, animationState) {\n      var emptyStateLiteral = literal(EMPTY_ANIMATION_STATE);\n      switch (animationState) {\n          case EMPTY_ANIMATION_STATE:\n              return value.equals(emptyStateLiteral);\n          case ANY_STATE:\n              return literal(true);\n          default:\n              return value.equals(literal(animationState));\n      }\n  }\n  function _isEndStateAnimateStep(step) {\n      // the final animation step is characterized by having only TWO\n      // keyframe values and it must have zero styles for both keyframes\n      if (step instanceof AnimationStepAst && step.duration > 0 && step.keyframes.length == 2) {\n          var styles1 = _getStylesArray(step.keyframes[0])[0];\n          var styles2 = _getStylesArray(step.keyframes[1])[0];\n          return Object.keys(styles1).length === 0 && Object.keys(styles2).length === 0;\n      }\n      return false;\n  }\n  function _getStylesArray(obj) {\n      return obj.styles.styles;\n  }\n\n  function createDiTokenExpression(token) {\n      if (isPresent(token.value)) {\n          return literal(token.value);\n      }\n      else if (token.identifierIsInstance) {\n          return importExpr(token.identifier)\n              .instantiate([], importType(token.identifier, [], [TypeModifier.Const]));\n      }\n      else {\n          return importExpr(token.identifier);\n      }\n  }\n  function createInlineArray(values) {\n      if (values.length === 0) {\n          return importExpr(resolveIdentifier(Identifiers.EMPTY_INLINE_ARRAY));\n      }\n      var log2 = Math.log(values.length) / Math.log(2);\n      var index = Math.ceil(log2);\n      var identifierSpec = index < Identifiers.inlineArrays.length ? Identifiers.inlineArrays[index] :\n          Identifiers.InlineArrayDynamic;\n      var identifier = resolveIdentifier(identifierSpec);\n      return importExpr(identifier).instantiate([\n          literal(values.length)\n      ].concat(values));\n  }\n  function createPureProxy(fn, argCount, pureProxyProp, builder) {\n      builder.fields.push(new ClassField(pureProxyProp.name, null));\n      var pureProxyId = argCount < Identifiers.pureProxies.length ? Identifiers.pureProxies[argCount] : null;\n      if (!pureProxyId) {\n          throw new Error(\"Unsupported number of argument for pure functions: \" + argCount);\n      }\n      builder.ctorStmts.push(THIS_EXPR.prop(pureProxyProp.name)\n          .set(importExpr(resolveIdentifier(pureProxyId)).callFn([fn]))\n          .toStmt());\n  }\n  function createEnumExpression(enumType, enumValue) {\n      var enumName = Object.keys(enumType.runtime).find(function (propName) { return enumType.runtime[propName] === enumValue; });\n      if (!enumName) {\n          throw new Error(\"Unknown enum value \" + enumValue + \" in \" + enumType.name);\n      }\n      return importExpr(resolveEnumIdentifier(resolveIdentifier(enumType), enumName));\n  }\n\n  var CheckBindingField = (function () {\n      function CheckBindingField(expression, bindingId) {\n          this.expression = expression;\n          this.bindingId = bindingId;\n      }\n      return CheckBindingField;\n  }());\n  function createCheckBindingField(builder) {\n      var bindingId = \"\" + builder.fields.length;\n      var fieldExpr = createBindFieldExpr(bindingId);\n      // private is fine here as no child view will reference the cached value...\n      builder.fields.push(new ClassField(fieldExpr.name, null, [StmtModifier.Private]));\n      builder.ctorStmts.push(THIS_EXPR.prop(fieldExpr.name)\n          .set(importExpr(resolveIdentifier(Identifiers.UNINITIALIZED)))\n          .toStmt());\n      return new CheckBindingField(fieldExpr, bindingId);\n  }\n  function createCheckBindingStmt(evalResult, fieldExpr, throwOnChangeVar, actions) {\n      var condition = importExpr(resolveIdentifier(Identifiers.checkBinding)).callFn([\n          throwOnChangeVar, fieldExpr, evalResult.currValExpr\n      ]);\n      if (evalResult.forceUpdate) {\n          condition = evalResult.forceUpdate.or(condition);\n      }\n      return evalResult.stmts.concat([\n          new IfStmt(condition, actions.concat([\n              THIS_EXPR.prop(fieldExpr.name).set(evalResult.currValExpr).toStmt()\n          ]))\n      ]);\n  }\n  function createBindFieldExpr(bindingId) {\n      return THIS_EXPR.prop(\"_expr_\" + bindingId);\n  }\n\n  var VAL_UNWRAPPER_VAR = variable(\"valUnwrapper\");\n  var EventHandlerVars = (function () {\n      function EventHandlerVars() {\n      }\n      EventHandlerVars.event = variable('$event');\n      return EventHandlerVars;\n  }());\n  var ConvertPropertyBindingResult = (function () {\n      function ConvertPropertyBindingResult(stmts, currValExpr, forceUpdate) {\n          this.stmts = stmts;\n          this.currValExpr = currValExpr;\n          this.forceUpdate = forceUpdate;\n      }\n      return ConvertPropertyBindingResult;\n  }());\n  /**\n   * Converts the given expression AST into an executable output AST, assuming the expression is\n   * used in a property binding.\n   */\n  function convertPropertyBinding(builder, nameResolver, implicitReceiver, expression, bindingId) {\n      var currValExpr = createCurrValueExpr(bindingId);\n      var stmts = [];\n      if (!nameResolver) {\n          nameResolver = new DefaultNameResolver();\n      }\n      var visitor = new _AstToIrVisitor(builder, nameResolver, implicitReceiver, VAL_UNWRAPPER_VAR, bindingId, false);\n      var outputExpr = expression.visit(visitor, _Mode.Expression);\n      if (!outputExpr) {\n          // e.g. an empty expression was given\n          return null;\n      }\n      if (visitor.temporaryCount) {\n          for (var i = 0; i < visitor.temporaryCount; i++) {\n              stmts.push(temporaryDeclaration(bindingId, i));\n          }\n      }\n      if (visitor.needsValueUnwrapper) {\n          var initValueUnwrapperStmt = VAL_UNWRAPPER_VAR.callMethod('reset', []).toStmt();\n          stmts.push(initValueUnwrapperStmt);\n      }\n      stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));\n      if (visitor.needsValueUnwrapper) {\n          return new ConvertPropertyBindingResult(stmts, currValExpr, VAL_UNWRAPPER_VAR.prop('hasWrappedValue'));\n      }\n      else {\n          return new ConvertPropertyBindingResult(stmts, currValExpr, null);\n      }\n  }\n  var ConvertActionBindingResult = (function () {\n      function ConvertActionBindingResult(stmts, preventDefault) {\n          this.stmts = stmts;\n          this.preventDefault = preventDefault;\n      }\n      return ConvertActionBindingResult;\n  }());\n  /**\n   * Converts the given expression AST into an executable output AST, assuming the expression is\n   * used in an action binding (e.g. an event handler).\n   */\n  function convertActionBinding(builder, nameResolver, implicitReceiver, action, bindingId) {\n      if (!nameResolver) {\n          nameResolver = new DefaultNameResolver();\n      }\n      var visitor = new _AstToIrVisitor(builder, nameResolver, implicitReceiver, null, bindingId, true);\n      var actionStmts = [];\n      flattenStatements(action.visit(visitor, _Mode.Statement), actionStmts);\n      prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n      var lastIndex = actionStmts.length - 1;\n      var preventDefaultVar = null;\n      if (lastIndex >= 0) {\n          var lastStatement = actionStmts[lastIndex];\n          var returnExpr = convertStmtIntoExpression(lastStatement);\n          if (returnExpr) {\n              // Note: We need to cast the result of the method call to dynamic,\n              // as it might be a void method!\n              preventDefaultVar = createPreventDefaultVar(bindingId);\n              actionStmts[lastIndex] =\n                  preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\n                      .toDeclStmt(null, [StmtModifier.Final]);\n          }\n      }\n      return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n  }\n  /**\n   * Creates variables that are shared by multiple calls to `convertActionBinding` /\n   * `convertPropertyBinding`\n   */\n  function createSharedBindingVariablesIfNeeded(stmts) {\n      var unwrapperStmts = [];\n      var readVars = findReadVarNames(stmts);\n      if (readVars.has(VAL_UNWRAPPER_VAR.name)) {\n          unwrapperStmts.push(VAL_UNWRAPPER_VAR\n              .set(importExpr(resolveIdentifier(Identifiers.ValueUnwrapper)).instantiate([]))\n              .toDeclStmt(null, [StmtModifier.Final]));\n      }\n      return unwrapperStmts;\n  }\n  function temporaryName(bindingId, temporaryNumber) {\n      return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n  }\n  function temporaryDeclaration(bindingId, temporaryNumber) {\n      return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n  }\n  function prependTemporaryDecls(temporaryCount, bindingId, statements) {\n      for (var i = temporaryCount - 1; i >= 0; i--) {\n          statements.unshift(temporaryDeclaration(bindingId, i));\n      }\n  }\n  var _Mode;\n  (function (_Mode) {\n      _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n      _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n  })(_Mode || (_Mode = {}));\n  function ensureStatementMode(mode, ast) {\n      if (mode !== _Mode.Statement) {\n          throw new Error(\"Expected a statement, but saw \" + ast);\n      }\n  }\n  function ensureExpressionMode(mode, ast) {\n      if (mode !== _Mode.Expression) {\n          throw new Error(\"Expected an expression, but saw \" + ast);\n      }\n  }\n  function convertToStatementIfNeeded(mode, expr) {\n      if (mode === _Mode.Statement) {\n          return expr.toStmt();\n      }\n      else {\n          return expr;\n      }\n  }\n  var _AstToIrVisitor = (function () {\n      function _AstToIrVisitor(_builder, _nameResolver, _implicitReceiver, _valueUnwrapper, bindingId, isAction) {\n          this._builder = _builder;\n          this._nameResolver = _nameResolver;\n          this._implicitReceiver = _implicitReceiver;\n          this._valueUnwrapper = _valueUnwrapper;\n          this.bindingId = bindingId;\n          this.isAction = isAction;\n          this._nodeMap = new Map();\n          this._resultMap = new Map();\n          this._currentTemporary = 0;\n          this.needsValueUnwrapper = false;\n          this.temporaryCount = 0;\n      }\n      _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n          var op;\n          switch (ast.operation) {\n              case '+':\n                  op = BinaryOperator.Plus;\n                  break;\n              case '-':\n                  op = BinaryOperator.Minus;\n                  break;\n              case '*':\n                  op = BinaryOperator.Multiply;\n                  break;\n              case '/':\n                  op = BinaryOperator.Divide;\n                  break;\n              case '%':\n                  op = BinaryOperator.Modulo;\n                  break;\n              case '&&':\n                  op = BinaryOperator.And;\n                  break;\n              case '||':\n                  op = BinaryOperator.Or;\n                  break;\n              case '==':\n                  op = BinaryOperator.Equals;\n                  break;\n              case '!=':\n                  op = BinaryOperator.NotEquals;\n                  break;\n              case '===':\n                  op = BinaryOperator.Identical;\n                  break;\n              case '!==':\n                  op = BinaryOperator.NotIdentical;\n                  break;\n              case '<':\n                  op = BinaryOperator.Lower;\n                  break;\n              case '>':\n                  op = BinaryOperator.Bigger;\n                  break;\n              case '<=':\n                  op = BinaryOperator.LowerEquals;\n                  break;\n              case '>=':\n                  op = BinaryOperator.BiggerEquals;\n                  break;\n              default:\n                  throw new Error(\"Unsupported operation \" + ast.operation);\n          }\n          return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));\n      };\n      _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n          ensureStatementMode(mode, ast);\n          return this.visitAll(ast.expressions, mode);\n      };\n      _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n          var value = this.visit(ast.condition, _Mode.Expression);\n          return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));\n      };\n      _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n          var input = this.visit(ast.exp, _Mode.Expression);\n          var args = this.visitAll(ast.args, _Mode.Expression);\n          var value = this._nameResolver.callPipe(ast.name, input, args);\n          if (!value) {\n              throw new Error(\"Illegal state: Pipe \" + ast.name + \" is not allowed here!\");\n          }\n          this.needsValueUnwrapper = true;\n          return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));\n      };\n      _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n          return convertToStatementIfNeeded(mode, this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));\n      };\n      _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n          ensureExpressionMode(mode, ast);\n          return this._implicitReceiver;\n      };\n      _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n          ensureExpressionMode(mode, ast);\n          var args = [literal(ast.expressions.length)];\n          for (var i = 0; i < ast.strings.length - 1; i++) {\n              args.push(literal(ast.strings[i]));\n              args.push(this.visit(ast.expressions[i], _Mode.Expression));\n          }\n          args.push(literal(ast.strings[ast.strings.length - 1]));\n          return ast.expressions.length <= 9 ?\n              importExpr(resolveIdentifier(Identifiers.inlineInterpolate)).callFn(args) :\n              importExpr(resolveIdentifier(Identifiers.interpolate)).callFn([\n                  args[0], literalArr(args.slice(1))\n              ]);\n      };\n      _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n          return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));\n      };\n      _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n          var obj = this.visit(ast.obj, _Mode.Expression);\n          var key = this.visit(ast.key, _Mode.Expression);\n          var value = this.visit(ast.value, _Mode.Expression);\n          return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n      };\n      _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n          var parts = this.visitAll(ast.expressions, mode);\n          var literalArr$$ = this.isAction ? literalArr(parts) : createCachedLiteralArray(this._builder, parts);\n          return convertToStatementIfNeeded(mode, literalArr$$);\n      };\n      _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n          var parts = [];\n          for (var i = 0; i < ast.keys.length; i++) {\n              parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);\n          }\n          var literalMap$$ = this.isAction ? literalMap(parts) : createCachedLiteralMap(this._builder, parts);\n          return convertToStatementIfNeeded(mode, literalMap$$);\n      };\n      _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n          return convertToStatementIfNeeded(mode, literal(ast.value));\n      };\n      _AstToIrVisitor.prototype._getLocal = function (name) {\n          if (this.isAction && name == EventHandlerVars.event.name) {\n              return EventHandlerVars.event;\n          }\n          return this._nameResolver.getLocal(name);\n      };\n      _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n          var leftMostSafe = this.leftMostSafeNode(ast);\n          if (leftMostSafe) {\n              return this.convertSafeAccess(ast, leftMostSafe, mode);\n          }\n          else {\n              var args = this.visitAll(ast.args, _Mode.Expression);\n              var result = null;\n              var receiver = this.visit(ast.receiver, _Mode.Expression);\n              if (receiver === this._implicitReceiver) {\n                  var varExpr = this._getLocal(ast.name);\n                  if (isPresent(varExpr)) {\n                      result = varExpr.callFn(args);\n                  }\n              }\n              if (isBlank(result)) {\n                  result = receiver.callMethod(ast.name, args);\n              }\n              return convertToStatementIfNeeded(mode, result);\n          }\n      };\n      _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n          return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));\n      };\n      _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n          var leftMostSafe = this.leftMostSafeNode(ast);\n          if (leftMostSafe) {\n              return this.convertSafeAccess(ast, leftMostSafe, mode);\n          }\n          else {\n              var result = null;\n              var receiver = this.visit(ast.receiver, _Mode.Expression);\n              if (receiver === this._implicitReceiver) {\n                  result = this._getLocal(ast.name);\n              }\n              if (isBlank(result)) {\n                  result = receiver.prop(ast.name);\n              }\n              return convertToStatementIfNeeded(mode, result);\n          }\n      };\n      _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n          var receiver = this.visit(ast.receiver, _Mode.Expression);\n          if (receiver === this._implicitReceiver) {\n              var varExpr = this._getLocal(ast.name);\n              if (isPresent(varExpr)) {\n                  throw new Error('Cannot assign to a reference or variable!');\n              }\n          }\n          return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));\n      };\n      _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n      };\n      _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n      };\n      _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n          var _this = this;\n          return asts.map(function (ast) { return _this.visit(ast, mode); });\n      };\n      _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n          throw new Error('Quotes are not supported for evaluation!');\n      };\n      _AstToIrVisitor.prototype.visit = function (ast, mode) {\n          var result = this._resultMap.get(ast);\n          if (result)\n              return result;\n          return (this._nodeMap.get(ast) || ast).visit(this, mode);\n      };\n      _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n          // If the expression contains a safe access node on the left it needs to be converted to\n          // an expression that guards the access to the member by checking the receiver for blank. As\n          // execution proceeds from left to right, the left most part of the expression must be guarded\n          // first but, because member access is left associative, the right side of the expression is at\n          // the top of the AST. The desired result requires lifting a copy of the the left part of the\n          // expression up to test it for blank before generating the unguarded version.\n          // Consider, for example the following expression: a?.b.c?.d.e\n          // This results in the ast:\n          //         .\n          //        / \\\n          //       ?.   e\n          //      /  \\\n          //     .    d\n          //    / \\\n          //   ?.  c\n          //  /  \\\n          // a    b\n          // The following tree should be generated:\n          //\n          //        /---- ? ----\\\n          //       /      |      \\\n          //     a   /--- ? ---\\  null\n          //        /     |     \\\n          //       .      .     null\n          //      / \\    / \\\n          //     .  c   .   e\n          //    / \\    / \\\n          //   a   b  ,   d\n          //         / \\\n          //        .   c\n          //       / \\\n          //      a   b\n          //\n          // Notice that the first guard condition is the left hand of the left most safe access node\n          // which comes in as leftMostSafe to this routine.\n          var guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);\n          var temporary;\n          if (this.needsTemporary(leftMostSafe.receiver)) {\n              // If the expression has method calls or pipes then we need to save the result into a\n              // temporary variable to avoid calling stateful or impure code more than once.\n              temporary = this.allocateTemporary();\n              // Preserve the result in the temporary variable\n              guardedExpression = temporary.set(guardedExpression);\n              // Ensure all further references to the guarded expression refer to the temporary instead.\n              this._resultMap.set(leftMostSafe.receiver, temporary);\n          }\n          var condition = guardedExpression.isBlank();\n          // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n          // leftMostNode with its unguarded version in the call to `this.visit()`.\n          if (leftMostSafe instanceof SafeMethodCall) {\n              this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n          }\n          else {\n              this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n          }\n          // Recursively convert the node now without the guarded member access.\n          var access = this.visit(ast, _Mode.Expression);\n          // Remove the mapping. This is not strictly required as the converter only traverses each node\n          // once but is safer if the conversion is changed to traverse the nodes more than once.\n          this._nodeMap.delete(leftMostSafe);\n          // If we allcoated a temporary, release it.\n          if (temporary) {\n              this.releaseTemporary(temporary);\n          }\n          // Produce the conditional\n          return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n      };\n      // Given a expression of the form a?.b.c?.d.e the the left most safe node is\n      // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n      // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n      // safe method call as this needs be transform initially to:\n      //   a == null ? null : a.c.b.c?.d.e\n      // then to:\n      //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n      _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n          var _this = this;\n          var visit = function (visitor, ast) {\n              return (_this._nodeMap.get(ast) || ast).visit(visitor);\n          };\n          return ast.visit({\n              visitBinary: function (ast) { return null; },\n              visitChain: function (ast) { return null; },\n              visitConditional: function (ast) { return null; },\n              visitFunctionCall: function (ast) { return null; },\n              visitImplicitReceiver: function (ast) { return null; },\n              visitInterpolation: function (ast) { return null; },\n              visitKeyedRead: function (ast) { return visit(this, ast.obj); },\n              visitKeyedWrite: function (ast) { return null; },\n              visitLiteralArray: function (ast) { return null; },\n              visitLiteralMap: function (ast) { return null; },\n              visitLiteralPrimitive: function (ast) { return null; },\n              visitMethodCall: function (ast) { return visit(this, ast.receiver); },\n              visitPipe: function (ast) { return null; },\n              visitPrefixNot: function (ast) { return null; },\n              visitPropertyRead: function (ast) { return visit(this, ast.receiver); },\n              visitPropertyWrite: function (ast) { return null; },\n              visitQuote: function (ast) { return null; },\n              visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },\n              visitSafePropertyRead: function (ast) {\n                  return visit(this, ast.receiver) || ast;\n              }\n          });\n      };\n      // Returns true of the AST includes a method or a pipe indicating that, if the\n      // expression is used as the target of a safe property or method access then\n      // the expression should be stored into a temporary variable.\n      _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n          var _this = this;\n          var visit = function (visitor, ast) {\n              return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n          };\n          var visitSome = function (visitor, ast) {\n              return ast.some(function (ast) { return visit(visitor, ast); });\n          };\n          return ast.visit({\n              visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },\n              visitChain: function (ast) { return false; },\n              visitConditional: function (ast) {\n                  return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);\n              },\n              visitFunctionCall: function (ast) { return true; },\n              visitImplicitReceiver: function (ast) { return false; },\n              visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },\n              visitKeyedRead: function (ast) { return false; },\n              visitKeyedWrite: function (ast) { return false; },\n              visitLiteralArray: function (ast) { return true; },\n              visitLiteralMap: function (ast) { return true; },\n              visitLiteralPrimitive: function (ast) { return false; },\n              visitMethodCall: function (ast) { return true; },\n              visitPipe: function (ast) { return true; },\n              visitPrefixNot: function (ast) { return visit(this, ast.expression); },\n              visitPropertyRead: function (ast) { return false; },\n              visitPropertyWrite: function (ast) { return false; },\n              visitQuote: function (ast) { return false; },\n              visitSafeMethodCall: function (ast) { return true; },\n              visitSafePropertyRead: function (ast) { return false; }\n          });\n      };\n      _AstToIrVisitor.prototype.allocateTemporary = function () {\n          var tempNumber = this._currentTemporary++;\n          this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n          return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n      };\n      _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n          this._currentTemporary--;\n          if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n              throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n          }\n      };\n      return _AstToIrVisitor;\n  }());\n  function flattenStatements(arg, output) {\n      if (Array.isArray(arg)) {\n          arg.forEach(function (entry) { return flattenStatements(entry, output); });\n      }\n      else {\n          output.push(arg);\n      }\n  }\n  function createCachedLiteralArray(builder, values) {\n      if (values.length === 0) {\n          return importExpr(resolveIdentifier(Identifiers.EMPTY_ARRAY));\n      }\n      var proxyExpr = THIS_EXPR.prop(\"_arr_\" + builder.fields.length);\n      var proxyParams = [];\n      var proxyReturnEntries = [];\n      for (var i = 0; i < values.length; i++) {\n          var paramName = \"p\" + i;\n          proxyParams.push(new FnParam(paramName));\n          proxyReturnEntries.push(variable(paramName));\n      }\n      createPureProxy(fn(proxyParams, [new ReturnStatement(literalArr(proxyReturnEntries))], new ArrayType(DYNAMIC_TYPE)), values.length, proxyExpr, builder);\n      return proxyExpr.callFn(values);\n  }\n  function createCachedLiteralMap(builder, entries) {\n      if (entries.length === 0) {\n          return importExpr(resolveIdentifier(Identifiers.EMPTY_MAP));\n      }\n      var proxyExpr = THIS_EXPR.prop(\"_map_\" + builder.fields.length);\n      var proxyParams = [];\n      var proxyReturnEntries = [];\n      var values = [];\n      for (var i = 0; i < entries.length; i++) {\n          var paramName = \"p\" + i;\n          proxyParams.push(new FnParam(paramName));\n          proxyReturnEntries.push([entries[i][0], variable(paramName)]);\n          values.push(entries[i][1]);\n      }\n      createPureProxy(fn(proxyParams, [new ReturnStatement(literalMap(proxyReturnEntries))], new MapType(DYNAMIC_TYPE)), entries.length, proxyExpr, builder);\n      return proxyExpr.callFn(values);\n  }\n  var DefaultNameResolver = (function () {\n      function DefaultNameResolver() {\n      }\n      DefaultNameResolver.prototype.callPipe = function (name, input, args) { return null; };\n      DefaultNameResolver.prototype.getLocal = function (name) { return null; };\n      return DefaultNameResolver;\n  }());\n  function createCurrValueExpr(bindingId) {\n      return variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n  }\n  function createPreventDefaultVar(bindingId) {\n      return variable(\"pd_\" + bindingId);\n  }\n  function convertStmtIntoExpression(stmt) {\n      if (stmt instanceof ExpressionStatement) {\n          return stmt.expr;\n      }\n      else if (stmt instanceof ReturnStatement) {\n          return stmt.value;\n      }\n      return null;\n  }\n\n  function writeToRenderer(view, boundProp, renderElement, renderValue, logBindingUpdate, securityContextExpression) {\n      var updateStmts = [];\n      var renderer = view.prop('renderer');\n      renderValue = sanitizedValue(view, boundProp, renderValue, securityContextExpression);\n      switch (boundProp.type) {\n          case exports.PropertyBindingType.Property:\n              if (logBindingUpdate) {\n                  updateStmts.push(importExpr(resolveIdentifier(Identifiers.setBindingDebugInfo))\n                      .callFn([renderer, renderElement, literal(boundProp.name), renderValue])\n                      .toStmt());\n              }\n              updateStmts.push(renderer\n                  .callMethod('setElementProperty', [renderElement, literal(boundProp.name), renderValue])\n                  .toStmt());\n              break;\n          case exports.PropertyBindingType.Attribute:\n              renderValue =\n                  renderValue.isBlank().conditional(NULL_EXPR, renderValue.callMethod('toString', []));\n              updateStmts.push(renderer\n                  .callMethod('setElementAttribute', [renderElement, literal(boundProp.name), renderValue])\n                  .toStmt());\n              break;\n          case exports.PropertyBindingType.Class:\n              updateStmts.push(renderer\n                  .callMethod('setElementClass', [renderElement, literal(boundProp.name), renderValue])\n                  .toStmt());\n              break;\n          case exports.PropertyBindingType.Style:\n              var strValue = renderValue.callMethod('toString', []);\n              if (isPresent(boundProp.unit)) {\n                  strValue = strValue.plus(literal(boundProp.unit));\n              }\n              renderValue = renderValue.isBlank().conditional(NULL_EXPR, strValue);\n              updateStmts.push(renderer\n                  .callMethod('setElementStyle', [renderElement, literal(boundProp.name), renderValue])\n                  .toStmt());\n              break;\n          case exports.PropertyBindingType.Animation:\n              throw new Error('Illegal state: Should not come here!');\n      }\n      return updateStmts;\n  }\n  function sanitizedValue(view, boundProp, renderValue, securityContextExpression) {\n      if (boundProp.securityContext === _angular_core.SecurityContext.NONE) {\n          return renderValue; // No sanitization needed.\n      }\n      if (!boundProp.needsRuntimeSecurityContext) {\n          securityContextExpression =\n              createEnumExpression(Identifiers.SecurityContext, boundProp.securityContext);\n      }\n      if (!securityContextExpression) {\n          throw new Error(\"internal error, no SecurityContext given \" + boundProp.name);\n      }\n      var ctx = view.prop('viewUtils').prop('sanitizer');\n      var args = [securityContextExpression, renderValue];\n      return ctx.callMethod('sanitize', args);\n  }\n  function triggerAnimation(view, componentView, boundProp, eventListener, renderElement, renderValue, lastRenderValue) {\n      var detachStmts = [];\n      var updateStmts = [];\n      var animationName = boundProp.name;\n      var animationFnExpr = componentView.prop('componentType').prop('animations').key(literal(animationName));\n      // it's important to normalize the void value as `void` explicitly\n      // so that the styles data can be obtained from the stringmap\n      var emptyStateValue = literal(EMPTY_ANIMATION_STATE);\n      var unitializedValue = importExpr(resolveIdentifier(Identifiers.UNINITIALIZED));\n      var animationTransitionVar = variable('animationTransition_' + animationName);\n      updateStmts.push(animationTransitionVar\n          .set(animationFnExpr.callFn([\n          view, renderElement,\n          lastRenderValue.equals(unitializedValue).conditional(emptyStateValue, lastRenderValue),\n          renderValue.equals(unitializedValue).conditional(emptyStateValue, renderValue)\n      ]))\n          .toDeclStmt());\n      detachStmts.push(animationTransitionVar\n          .set(animationFnExpr.callFn([view, renderElement, lastRenderValue, emptyStateValue]))\n          .toDeclStmt());\n      var registerStmts = [\n          animationTransitionVar\n              .callMethod('onStart', [eventListener.callMethod(BuiltinMethod.Bind, [view, literal(BoundEventAst.calcFullName(animationName, null, 'start'))])])\n              .toStmt(),\n          animationTransitionVar\n              .callMethod('onDone', [eventListener.callMethod(BuiltinMethod.Bind, [view, literal(BoundEventAst.calcFullName(animationName, null, 'done'))])])\n              .toStmt(),\n      ];\n      updateStmts.push.apply(updateStmts, registerStmts);\n      detachStmts.push.apply(detachStmts, registerStmts);\n      return { updateStmts: updateStmts, detachStmts: detachStmts };\n  }\n\n  /**\n   * Create a new class stmts based on the given data.\n   */\n  function createClassStmt(config) {\n      var parentArgs = config.parentArgs || [];\n      var superCtorStmts = config.parent ? [SUPER_EXPR.callFn(parentArgs).toStmt()] : [];\n      var builder = concatClassBuilderParts(Array.isArray(config.builders) ? config.builders : [config.builders]);\n      var ctor = new ClassMethod(null, config.ctorParams || [], superCtorStmts.concat(builder.ctorStmts));\n      return new ClassStmt(config.name, config.parent, builder.fields, builder.getters, ctor, builder.methods, config.modifiers || []);\n  }\n  function concatClassBuilderParts(builders) {\n      return {\n          fields: (_a = []).concat.apply(_a, builders.map(function (builder) { return builder.fields || []; })),\n          methods: (_b = []).concat.apply(_b, builders.map(function (builder) { return builder.methods || []; })),\n          getters: (_c = []).concat.apply(_c, builders.map(function (builder) { return builder.getters || []; })),\n          ctorStmts: (_d = []).concat.apply(_d, builders.map(function (builder) { return builder.ctorStmts || []; })),\n      };\n      var _a, _b, _c, _d;\n  }\n\n  var DirectiveWrapperCompileResult = (function () {\n      function DirectiveWrapperCompileResult(statements, dirWrapperClassVar) {\n          this.statements = statements;\n          this.dirWrapperClassVar = dirWrapperClassVar;\n      }\n      return DirectiveWrapperCompileResult;\n  }());\n  var CONTEXT_FIELD_NAME = 'context';\n  var CHANGES_FIELD_NAME = '_changes';\n  var CHANGED_FIELD_NAME = '_changed';\n  var EVENT_HANDLER_FIELD_NAME = '_eventHandler';\n  var CURR_VALUE_VAR = variable('currValue');\n  var THROW_ON_CHANGE_VAR = variable('throwOnChange');\n  var FORCE_UPDATE_VAR = variable('forceUpdate');\n  var VIEW_VAR = variable('view');\n  var COMPONENT_VIEW_VAR = variable('componentView');\n  var RENDER_EL_VAR = variable('el');\n  var EVENT_NAME_VAR = variable('eventName');\n  var RESET_CHANGES_STMT = THIS_EXPR.prop(CHANGES_FIELD_NAME).set(literalMap([])).toStmt();\n  /**\n   * We generate directive wrappers to prevent code bloat when a directive is used.\n   * A directive wrapper encapsulates\n   * the dirty checking for `@Input`, the handling of `@HostListener` / `@HostBinding`\n   * and calling the lifecyclehooks `ngOnInit`, `ngOnChanges`, `ngDoCheck`.\n   *\n   * So far, only `@Input` and the lifecycle hooks have been implemented.\n   */\n  var DirectiveWrapperCompiler = (function () {\n      function DirectiveWrapperCompiler(compilerConfig, _exprParser, _schemaRegistry, _console) {\n          this.compilerConfig = compilerConfig;\n          this._exprParser = _exprParser;\n          this._schemaRegistry = _schemaRegistry;\n          this._console = _console;\n      }\n      DirectiveWrapperCompiler.dirWrapperClassName = function (id) { return \"Wrapper_\" + id.name; };\n      DirectiveWrapperCompiler.prototype.compile = function (dirMeta) {\n          var hostParseResult = parseHostBindings(dirMeta, this._exprParser, this._schemaRegistry);\n          reportParseErrors(hostParseResult.errors, this._console);\n          var builder = new DirectiveWrapperBuilder(this.compilerConfig, dirMeta);\n          Object.keys(dirMeta.inputs).forEach(function (inputFieldName) {\n              addCheckInputMethod(inputFieldName, builder);\n          });\n          addNgDoCheckMethod(builder);\n          addCheckHostMethod(hostParseResult.hostProps, builder);\n          addHandleEventMethod(hostParseResult.hostListeners, builder);\n          addSubscribeMethod(dirMeta, builder);\n          var classStmt = builder.build();\n          return new DirectiveWrapperCompileResult([classStmt], classStmt.name);\n      };\n      DirectiveWrapperCompiler.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      DirectiveWrapperCompiler.ctorParameters = [\n          { type: CompilerConfig, },\n          { type: Parser, },\n          { type: ElementSchemaRegistry, },\n          { type: Console, },\n      ];\n      return DirectiveWrapperCompiler;\n  }());\n  var DirectiveWrapperBuilder = (function () {\n      function DirectiveWrapperBuilder(compilerConfig, dirMeta) {\n          this.compilerConfig = compilerConfig;\n          this.dirMeta = dirMeta;\n          this.fields = [];\n          this.getters = [];\n          this.methods = [];\n          this.ctorStmts = [];\n          this.detachStmts = [];\n          this.destroyStmts = [];\n          var dirLifecycleHooks = dirMeta.type.lifecycleHooks;\n          this.genChanges = dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1 ||\n              this.compilerConfig.logBindingUpdate;\n          this.ngOnChanges = dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1;\n          this.ngOnInit = dirLifecycleHooks.indexOf(LifecycleHooks.OnInit) !== -1;\n          this.ngDoCheck = dirLifecycleHooks.indexOf(LifecycleHooks.DoCheck) !== -1;\n          this.ngOnDestroy = dirLifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1;\n          if (this.ngOnDestroy) {\n              this.destroyStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngOnDestroy', []).toStmt());\n          }\n      }\n      DirectiveWrapperBuilder.prototype.build = function () {\n          var dirDepParamNames = [];\n          for (var i = 0; i < this.dirMeta.type.diDeps.length; i++) {\n              dirDepParamNames.push(\"p\" + i);\n          }\n          var methods = [\n              new ClassMethod('ngOnDetach', [\n                  new FnParam(VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n                  new FnParam(COMPONENT_VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n                  new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),\n              ], this.detachStmts),\n              new ClassMethod('ngOnDestroy', [], this.destroyStmts),\n          ];\n          var fields = [\n              new ClassField(EVENT_HANDLER_FIELD_NAME, FUNCTION_TYPE, [StmtModifier.Private]),\n              new ClassField(CONTEXT_FIELD_NAME, importType(this.dirMeta.type)),\n              new ClassField(CHANGED_FIELD_NAME, BOOL_TYPE, [StmtModifier.Private]),\n          ];\n          var ctorStmts = [THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt()];\n          if (this.genChanges) {\n              fields.push(new ClassField(CHANGES_FIELD_NAME, new MapType(DYNAMIC_TYPE), [StmtModifier.Private]));\n              ctorStmts.push(RESET_CHANGES_STMT);\n          }\n          ctorStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)\n              .set(importExpr(this.dirMeta.type)\n              .instantiate(dirDepParamNames.map(function (paramName) { return variable(paramName); })))\n              .toStmt());\n          return createClassStmt({\n              name: DirectiveWrapperCompiler.dirWrapperClassName(this.dirMeta.type),\n              ctorParams: dirDepParamNames.map(function (paramName) { return new FnParam(paramName, DYNAMIC_TYPE); }),\n              builders: [{ fields: fields, ctorStmts: ctorStmts, methods: methods }, this]\n          });\n      };\n      return DirectiveWrapperBuilder;\n  }());\n  function addNgDoCheckMethod(builder) {\n      var changedVar = variable('changed');\n      var stmts = [\n          changedVar.set(THIS_EXPR.prop(CHANGED_FIELD_NAME)).toDeclStmt(),\n          THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt(),\n      ];\n      var lifecycleStmts = [];\n      if (builder.genChanges) {\n          var onChangesStmts = [];\n          if (builder.ngOnChanges) {\n              onChangesStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)\n                  .callMethod('ngOnChanges', [THIS_EXPR.prop(CHANGES_FIELD_NAME)])\n                  .toStmt());\n          }\n          if (builder.compilerConfig.logBindingUpdate) {\n              onChangesStmts.push(importExpr(resolveIdentifier(Identifiers.setBindingDebugInfoForChanges))\n                  .callFn([VIEW_VAR.prop('renderer'), RENDER_EL_VAR, THIS_EXPR.prop(CHANGES_FIELD_NAME)])\n                  .toStmt());\n          }\n          onChangesStmts.push(RESET_CHANGES_STMT);\n          lifecycleStmts.push(new IfStmt(changedVar, onChangesStmts));\n      }\n      if (builder.ngOnInit) {\n          lifecycleStmts.push(new IfStmt(VIEW_VAR.prop('numberOfChecks').identical(new LiteralExpr(0)), [THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngOnInit', []).toStmt()]));\n      }\n      if (builder.ngDoCheck) {\n          lifecycleStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngDoCheck', []).toStmt());\n      }\n      if (lifecycleStmts.length > 0) {\n          stmts.push(new IfStmt(not(THROW_ON_CHANGE_VAR), lifecycleStmts));\n      }\n      stmts.push(new ReturnStatement(changedVar));\n      builder.methods.push(new ClassMethod('ngDoCheck', [\n          new FnParam(VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n          new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),\n          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),\n      ], stmts, BOOL_TYPE));\n  }\n  function addCheckInputMethod(input, builder) {\n      var field = createCheckBindingField(builder);\n      var onChangeStatements = [\n          THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(true)).toStmt(),\n          THIS_EXPR.prop(CONTEXT_FIELD_NAME).prop(input).set(CURR_VALUE_VAR).toStmt(),\n      ];\n      if (builder.genChanges) {\n          onChangeStatements.push(THIS_EXPR.prop(CHANGES_FIELD_NAME)\n              .key(literal(input))\n              .set(importExpr(resolveIdentifier(Identifiers.SimpleChange))\n              .instantiate([field.expression, CURR_VALUE_VAR]))\n              .toStmt());\n      }\n      var methodBody = createCheckBindingStmt({ currValExpr: CURR_VALUE_VAR, forceUpdate: FORCE_UPDATE_VAR, stmts: [] }, field.expression, THROW_ON_CHANGE_VAR, onChangeStatements);\n      builder.methods.push(new ClassMethod(\"check_\" + input, [\n          new FnParam(CURR_VALUE_VAR.name, DYNAMIC_TYPE),\n          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),\n          new FnParam(FORCE_UPDATE_VAR.name, BOOL_TYPE),\n      ], methodBody));\n  }\n  function addCheckHostMethod(hostProps, builder) {\n      var stmts = [];\n      var methodParams = [\n          new FnParam(VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n          new FnParam(COMPONENT_VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n          new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),\n          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),\n      ];\n      hostProps.forEach(function (hostProp, hostPropIdx) {\n          var field = createCheckBindingField(builder);\n          var evalResult = convertPropertyBinding(builder, null, THIS_EXPR.prop(CONTEXT_FIELD_NAME), hostProp.value, field.bindingId);\n          if (!evalResult) {\n              return;\n          }\n          var securityContextExpr;\n          if (hostProp.needsRuntimeSecurityContext) {\n              securityContextExpr = variable(\"secCtx_\" + methodParams.length);\n              methodParams.push(new FnParam(securityContextExpr.name, importType(resolveIdentifier(Identifiers.SecurityContext))));\n          }\n          var checkBindingStmts;\n          if (hostProp.isAnimation) {\n              var _a = triggerAnimation(VIEW_VAR, COMPONENT_VIEW_VAR, hostProp, THIS_EXPR.prop(EVENT_HANDLER_FIELD_NAME)\n                  .or(importExpr(resolveIdentifier(Identifiers.noop))), RENDER_EL_VAR, evalResult.currValExpr, field.expression), updateStmts = _a.updateStmts, detachStmts = _a.detachStmts;\n              checkBindingStmts = updateStmts;\n              (_b = builder.detachStmts).push.apply(_b, detachStmts);\n          }\n          else {\n              checkBindingStmts = writeToRenderer(VIEW_VAR, hostProp, RENDER_EL_VAR, evalResult.currValExpr, builder.compilerConfig.logBindingUpdate, securityContextExpr);\n          }\n          stmts.push.apply(stmts, createCheckBindingStmt(evalResult, field.expression, THROW_ON_CHANGE_VAR, checkBindingStmts));\n          var _b;\n      });\n      builder.methods.push(new ClassMethod('checkHost', methodParams, stmts));\n  }\n  function addHandleEventMethod(hostListeners, builder) {\n      var resultVar = variable(\"result\");\n      var actionStmts = [resultVar.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n      hostListeners.forEach(function (hostListener, eventIdx) {\n          var evalResult = convertActionBinding(builder, null, THIS_EXPR.prop(CONTEXT_FIELD_NAME), hostListener.handler, \"sub_\" + eventIdx);\n          var trueStmts = evalResult.stmts;\n          if (evalResult.preventDefault) {\n              trueStmts.push(resultVar.set(evalResult.preventDefault.and(resultVar)).toStmt());\n          }\n          // TODO(tbosch): convert this into a `switch` once our OutputAst supports it.\n          actionStmts.push(new IfStmt(EVENT_NAME_VAR.equals(literal(hostListener.fullName)), trueStmts));\n      });\n      actionStmts.push(new ReturnStatement(resultVar));\n      builder.methods.push(new ClassMethod('handleEvent', [\n          new FnParam(EVENT_NAME_VAR.name, STRING_TYPE),\n          new FnParam(EventHandlerVars.event.name, DYNAMIC_TYPE)\n      ], actionStmts, BOOL_TYPE));\n  }\n  function addSubscribeMethod(dirMeta, builder) {\n      var methodParams = [\n          new FnParam(VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n          new FnParam(EVENT_HANDLER_FIELD_NAME, DYNAMIC_TYPE)\n      ];\n      var stmts = [\n          THIS_EXPR.prop(EVENT_HANDLER_FIELD_NAME).set(variable(EVENT_HANDLER_FIELD_NAME)).toStmt()\n      ];\n      Object.keys(dirMeta.outputs).forEach(function (emitterPropName, emitterIdx) {\n          var eventName = dirMeta.outputs[emitterPropName];\n          var paramName = \"emit\" + emitterIdx;\n          methodParams.push(new FnParam(paramName, BOOL_TYPE));\n          var subscriptionFieldName = \"subscription\" + emitterIdx;\n          builder.fields.push(new ClassField(subscriptionFieldName, DYNAMIC_TYPE));\n          stmts.push(new IfStmt(variable(paramName), [\n              THIS_EXPR.prop(subscriptionFieldName)\n                  .set(THIS_EXPR.prop(CONTEXT_FIELD_NAME)\n                  .prop(emitterPropName)\n                  .callMethod(BuiltinMethod.SubscribeObservable, [variable(EVENT_HANDLER_FIELD_NAME)\n                      .callMethod(BuiltinMethod.Bind, [VIEW_VAR, literal(eventName)])]))\n                  .toStmt()\n          ]));\n          builder.destroyStmts.push(THIS_EXPR.prop(subscriptionFieldName)\n              .and(THIS_EXPR.prop(subscriptionFieldName).callMethod('unsubscribe', []))\n              .toStmt());\n      });\n      builder.methods.push(new ClassMethod('subscribe', methodParams, stmts));\n  }\n  var ParseResult = (function () {\n      function ParseResult(hostProps, hostListeners, errors) {\n          this.hostProps = hostProps;\n          this.hostListeners = hostListeners;\n          this.errors = errors;\n      }\n      return ParseResult;\n  }());\n  function parseHostBindings(dirMeta, exprParser, schemaRegistry) {\n      var errors = [];\n      var parser = new BindingParser(exprParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [], errors);\n      var sourceFileName = dirMeta.type.moduleUrl ?\n          \"in Directive \" + dirMeta.type.name + \" in \" + dirMeta.type.moduleUrl :\n          \"in Directive \" + dirMeta.type.name;\n      var sourceFile = new ParseSourceFile('', sourceFileName);\n      var sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));\n      var parsedHostProps = parser.createDirectiveHostPropertyAsts(dirMeta.toSummary(), sourceSpan);\n      var parsedHostListeners = parser.createDirectiveHostEventAsts(dirMeta.toSummary(), sourceSpan);\n      return new ParseResult(parsedHostProps, parsedHostListeners, errors);\n  }\n  function reportParseErrors(parseErrors, console) {\n      var warnings = parseErrors.filter(function (error) { return error.level === exports.ParseErrorLevel.WARNING; });\n      var errors = parseErrors.filter(function (error) { return error.level === exports.ParseErrorLevel.FATAL; });\n      if (warnings.length > 0) {\n          this._console.warn(\"Directive parse warnings:\\n\" + warnings.join('\\n'));\n      }\n      if (errors.length > 0) {\n          throw new Error(\"Directive parse errors:\\n\" + errors.join('\\n'));\n      }\n  }\n  var DirectiveWrapperExpressions = (function () {\n      function DirectiveWrapperExpressions() {\n      }\n      DirectiveWrapperExpressions.create = function (dir, depsExpr) {\n          return importExpr(dir).instantiate(depsExpr, importType(dir));\n      };\n      DirectiveWrapperExpressions.context = function (dirWrapper) {\n          return dirWrapper.prop(CONTEXT_FIELD_NAME);\n      };\n      DirectiveWrapperExpressions.ngDoCheck = function (dirWrapper, view, renderElement, throwOnChange) {\n          return dirWrapper.callMethod('ngDoCheck', [view, renderElement, throwOnChange]);\n      };\n      DirectiveWrapperExpressions.checkHost = function (hostProps, dirWrapper, view, componentView, renderElement, throwOnChange, runtimeSecurityContexts) {\n          if (hostProps.length) {\n              return [dirWrapper\n                      .callMethod('checkHost', [view, componentView, renderElement, throwOnChange].concat(runtimeSecurityContexts))\n                      .toStmt()];\n          }\n          else {\n              return [];\n          }\n      };\n      DirectiveWrapperExpressions.ngOnDetach = function (hostProps, dirWrapper, view, componentView, renderEl) {\n          if (hostProps.some(function (prop) { return prop.isAnimation; })) {\n              return [dirWrapper\n                      .callMethod('ngOnDetach', [\n                      view,\n                      componentView,\n                      renderEl,\n                  ])\n                      .toStmt()];\n          }\n          else {\n              return [];\n          }\n      };\n      DirectiveWrapperExpressions.ngOnDestroy = function (dir, dirWrapper) {\n          if (dir.type.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1 ||\n              Object.keys(dir.outputs).length > 0) {\n              return [dirWrapper.callMethod('ngOnDestroy', []).toStmt()];\n          }\n          else {\n              return [];\n          }\n      };\n      DirectiveWrapperExpressions.subscribe = function (dirMeta, hostProps, usedEvents, dirWrapper, view, eventListener) {\n          var needsSubscribe = false;\n          var eventFlags = [];\n          Object.keys(dirMeta.outputs).forEach(function (propName) {\n              var eventName = dirMeta.outputs[propName];\n              var eventUsed = usedEvents.indexOf(eventName) > -1;\n              needsSubscribe = needsSubscribe || eventUsed;\n              eventFlags.push(literal(eventUsed));\n          });\n          hostProps.forEach(function (hostProp) {\n              if (hostProp.isAnimation && usedEvents.length > 0) {\n                  needsSubscribe = true;\n              }\n          });\n          if (needsSubscribe) {\n              return [\n                  dirWrapper.callMethod('subscribe', [view, eventListener].concat(eventFlags)).toStmt()\n              ];\n          }\n          else {\n              return [];\n          }\n      };\n      DirectiveWrapperExpressions.handleEvent = function (hostEvents, dirWrapper, eventName, event) {\n          return dirWrapper.callMethod('handleEvent', [eventName, event]);\n      };\n      return DirectiveWrapperExpressions;\n  }());\n\n  function convertValueToOutputAst(value, type) {\n      if (type === void 0) { type = null; }\n      return visitValue(value, new _ValueOutputAstTransformer(), type);\n  }\n  var _ValueOutputAstTransformer = (function () {\n      function _ValueOutputAstTransformer() {\n      }\n      _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n          var _this = this;\n          return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);\n      };\n      _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n          var _this = this;\n          var entries = [];\n          Object.keys(map).forEach(function (key) { entries.push([key, visitValue(map[key], _this, null)]); });\n          return literalMap(entries, type);\n      };\n      _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };\n      _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n          if (value instanceof CompileIdentifierMetadata) {\n              return importExpr(value);\n          }\n          else if (value instanceof Expression) {\n              return value;\n          }\n          else {\n              throw new Error(\"Illegal state: Don't now how to compile value \" + value);\n          }\n      };\n      return _ValueOutputAstTransformer;\n  }());\n\n  var _DebugState = (function () {\n      function _DebugState(nodeIndex, sourceAst) {\n          this.nodeIndex = nodeIndex;\n          this.sourceAst = sourceAst;\n      }\n      return _DebugState;\n  }());\n  var NULL_DEBUG_STATE = new _DebugState(null, null);\n  var CompileMethod = (function () {\n      function CompileMethod(_view) {\n          this._view = _view;\n          this._newState = NULL_DEBUG_STATE;\n          this._currState = NULL_DEBUG_STATE;\n          this._bodyStatements = [];\n          this._debugEnabled = this._view.genConfig.genDebugInfo;\n      }\n      CompileMethod.prototype._updateDebugContextIfNeeded = function () {\n          if (this._newState.nodeIndex !== this._currState.nodeIndex ||\n              this._newState.sourceAst !== this._currState.sourceAst) {\n              var expr = this._updateDebugContext(this._newState);\n              if (isPresent(expr)) {\n                  this._bodyStatements.push(expr.toStmt());\n              }\n          }\n      };\n      CompileMethod.prototype._updateDebugContext = function (newState) {\n          this._currState = this._newState = newState;\n          if (this._debugEnabled) {\n              var sourceLocation = isPresent(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;\n              return THIS_EXPR.callMethod('debug', [\n                  literal(newState.nodeIndex),\n                  isPresent(sourceLocation) ? literal(sourceLocation.line) : NULL_EXPR,\n                  isPresent(sourceLocation) ? literal(sourceLocation.col) : NULL_EXPR\n              ]);\n          }\n          else {\n              return null;\n          }\n      };\n      CompileMethod.prototype.resetDebugInfoExpr = function (nodeIndex, templateAst) {\n          var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));\n          return res || NULL_EXPR;\n      };\n      CompileMethod.prototype.resetDebugInfo = function (nodeIndex, templateAst) {\n          this._newState = new _DebugState(nodeIndex, templateAst);\n      };\n      CompileMethod.prototype.push = function () {\n          var stmts = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              stmts[_i - 0] = arguments[_i];\n          }\n          this.addStmts(stmts);\n      };\n      CompileMethod.prototype.addStmt = function (stmt) {\n          this._updateDebugContextIfNeeded();\n          this._bodyStatements.push(stmt);\n      };\n      CompileMethod.prototype.addStmts = function (stmts) {\n          this._updateDebugContextIfNeeded();\n          (_a = this._bodyStatements).push.apply(_a, stmts);\n          var _a;\n      };\n      CompileMethod.prototype.finish = function () { return this._bodyStatements; };\n      CompileMethod.prototype.isEmpty = function () { return this._bodyStatements.length === 0; };\n      return CompileMethod;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$15 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  function getPropertyInView(property, callingView, definedView) {\n      if (callingView === definedView) {\n          return property;\n      }\n      else {\n          var viewProp = THIS_EXPR;\n          var currView = callingView;\n          while (currView !== definedView && isPresent(currView.declarationElement.view)) {\n              currView = currView.declarationElement.view;\n              viewProp = viewProp.prop('parentView');\n          }\n          if (currView !== definedView) {\n              throw new Error(\"Internal error: Could not calculate a property in a parent view: \" + property);\n          }\n          return property.visitExpression(new _ReplaceViewTransformer(viewProp, definedView), null);\n      }\n  }\n  var _ReplaceViewTransformer = (function (_super) {\n      __extends$15(_ReplaceViewTransformer, _super);\n      function _ReplaceViewTransformer(_viewExpr, _view) {\n          _super.call(this);\n          this._viewExpr = _viewExpr;\n          this._view = _view;\n      }\n      _ReplaceViewTransformer.prototype._isThis = function (expr) {\n          return expr instanceof ReadVarExpr && expr.builtin === BuiltinVar.This;\n      };\n      _ReplaceViewTransformer.prototype.visitReadVarExpr = function (ast, context) {\n          return this._isThis(ast) ? this._viewExpr : ast;\n      };\n      _ReplaceViewTransformer.prototype.visitReadPropExpr = function (ast, context) {\n          if (this._isThis(ast.receiver)) {\n              // Note: Don't cast for members of the AppView base class...\n              if (this._view.fields.some(function (field) { return field.name == ast.name; }) ||\n                  this._view.getters.some(function (field) { return field.name == ast.name; })) {\n                  return this._viewExpr.cast(this._view.classType).prop(ast.name);\n              }\n          }\n          return _super.prototype.visitReadPropExpr.call(this, ast, context);\n      };\n      return _ReplaceViewTransformer;\n  }(ExpressionTransformer));\n  function injectFromViewParentInjector(view, token, optional) {\n      var viewExpr;\n      if (view.viewType === ViewType.HOST) {\n          viewExpr = THIS_EXPR;\n      }\n      else {\n          viewExpr = THIS_EXPR.prop('parentView');\n      }\n      var args = [createDiTokenExpression(token), THIS_EXPR.prop('parentIndex')];\n      if (optional) {\n          args.push(NULL_EXPR);\n      }\n      return viewExpr.callMethod('injectorGet', args);\n  }\n  function getViewClassName(component, embeddedTemplateIndex) {\n      return \"View_\" + component.type.name + embeddedTemplateIndex;\n  }\n  function getHandleEventMethodName(elementIndex) {\n      return \"handleEvent_\" + elementIndex;\n  }\n\n  var ViewQueryValues = (function () {\n      function ViewQueryValues(view, values) {\n          this.view = view;\n          this.values = values;\n      }\n      return ViewQueryValues;\n  }());\n  var CompileQuery = (function () {\n      function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {\n          this.meta = meta;\n          this.queryList = queryList;\n          this.ownerDirectiveExpression = ownerDirectiveExpression;\n          this.view = view;\n          this._values = new ViewQueryValues(view, []);\n      }\n      CompileQuery.prototype.addValue = function (value, view) {\n          var currentView = view;\n          var elPath = [];\n          while (isPresent(currentView) && currentView !== this.view) {\n              var parentEl = currentView.declarationElement;\n              elPath.unshift(parentEl);\n              currentView = parentEl.view;\n          }\n          var queryListForDirtyExpr = getPropertyInView(this.queryList, view, this.view);\n          var viewValues = this._values;\n          elPath.forEach(function (el) {\n              var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;\n              if (last instanceof ViewQueryValues && last.view === el.embeddedView) {\n                  viewValues = last;\n              }\n              else {\n                  var newViewValues = new ViewQueryValues(el.embeddedView, []);\n                  viewValues.values.push(newViewValues);\n                  viewValues = newViewValues;\n              }\n          });\n          viewValues.values.push(value);\n          if (elPath.length > 0) {\n              view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());\n          }\n      };\n      CompileQuery.prototype._isStatic = function () {\n          return !this._values.values.some(function (value) { return value instanceof ViewQueryValues; });\n      };\n      CompileQuery.prototype.afterChildren = function (targetStaticMethod, targetDynamicMethod) {\n          var values = createQueryValues(this._values);\n          var updateStmts = [this.queryList.callMethod('reset', [literalArr(values)]).toStmt()];\n          if (isPresent(this.ownerDirectiveExpression)) {\n              var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;\n              updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());\n          }\n          if (!this.meta.first) {\n              updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());\n          }\n          if (this.meta.first && this._isStatic()) {\n              // for queries that don't change and the user asked for a single element,\n              // set it immediately. That is e.g. needed for querying for ViewContainerRefs, ...\n              // we don't do this for QueryLists for now as this would break the timing when\n              // we call QueryList listeners...\n              targetStaticMethod.addStmts(updateStmts);\n          }\n          else {\n              targetDynamicMethod.addStmt(new IfStmt(this.queryList.prop('dirty'), updateStmts));\n          }\n      };\n      return CompileQuery;\n  }());\n  function createQueryValues(viewValues) {\n      return ListWrapper.flatten(viewValues.values.map(function (entry) {\n          if (entry instanceof ViewQueryValues) {\n              return mapNestedViews(entry.view.declarationElement.viewContainer, entry.view, createQueryValues(entry));\n          }\n          else {\n              return entry;\n          }\n      }));\n  }\n  function mapNestedViews(viewContainer, view, expressions) {\n      var adjustedExpressions = expressions.map(function (expr) { return replaceVarInExpression(THIS_EXPR.name, variable('nestedView'), expr); });\n      return viewContainer.callMethod('mapNestedViews', [\n          variable(view.className),\n          fn([new FnParam('nestedView', view.classType)], [new ReturnStatement(literalArr(adjustedExpressions))], DYNAMIC_TYPE)\n      ]);\n  }\n  function createQueryList(query, directiveInstance, propertyName, compileView) {\n      compileView.fields.push(new ClassField(propertyName, importType(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])));\n      var expr = THIS_EXPR.prop(propertyName);\n      compileView.createMethod.addStmt(THIS_EXPR.prop(propertyName)\n          .set(importExpr(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])\n          .instantiate([]))\n          .toStmt());\n      return expr;\n  }\n  function addQueryToTokenMap(map, query) {\n      query.meta.selectors.forEach(function (selector) {\n          var entry = map.get(selector.reference);\n          if (!entry) {\n              entry = [];\n              map.set(selector.reference, entry);\n          }\n          entry.push(query);\n      });\n  }\n\n  var ViewTypeEnum = (function () {\n      function ViewTypeEnum() {\n      }\n      ViewTypeEnum.fromValue = function (value) {\n          return createEnumExpression(Identifiers.ViewType, value);\n      };\n      return ViewTypeEnum;\n  }());\n  var ViewEncapsulationEnum = (function () {\n      function ViewEncapsulationEnum() {\n      }\n      ViewEncapsulationEnum.fromValue = function (value) {\n          return createEnumExpression(Identifiers.ViewEncapsulation, value);\n      };\n      return ViewEncapsulationEnum;\n  }());\n  var ChangeDetectorStatusEnum = (function () {\n      function ChangeDetectorStatusEnum() {\n      }\n      ChangeDetectorStatusEnum.fromValue = function (value) {\n          return createEnumExpression(Identifiers.ChangeDetectorStatus, value);\n      };\n      return ChangeDetectorStatusEnum;\n  }());\n  var ViewConstructorVars = (function () {\n      function ViewConstructorVars() {\n      }\n      ViewConstructorVars.viewUtils = variable('viewUtils');\n      ViewConstructorVars.parentView = variable('parentView');\n      ViewConstructorVars.parentIndex = variable('parentIndex');\n      ViewConstructorVars.parentElement = variable('parentElement');\n      return ViewConstructorVars;\n  }());\n  var ViewProperties = (function () {\n      function ViewProperties() {\n      }\n      ViewProperties.renderer = THIS_EXPR.prop('renderer');\n      ViewProperties.viewUtils = THIS_EXPR.prop('viewUtils');\n      return ViewProperties;\n  }());\n  var InjectMethodVars = (function () {\n      function InjectMethodVars() {\n      }\n      InjectMethodVars.token = variable('token');\n      InjectMethodVars.requestNodeIndex = variable('requestNodeIndex');\n      InjectMethodVars.notFoundResult = variable('notFoundResult');\n      return InjectMethodVars;\n  }());\n  var DetectChangesVars = (function () {\n      function DetectChangesVars() {\n      }\n      DetectChangesVars.throwOnChange = variable(\"throwOnChange\");\n      DetectChangesVars.changes = variable(\"changes\");\n      DetectChangesVars.changed = variable(\"changed\");\n      return DetectChangesVars;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var ViewClassDependency = (function () {\n      function ViewClassDependency(comp, placeholder) {\n          this.comp = comp;\n          this.placeholder = placeholder;\n      }\n      return ViewClassDependency;\n  }());\n  var ComponentFactoryDependency = (function () {\n      function ComponentFactoryDependency(comp, placeholder) {\n          this.comp = comp;\n          this.placeholder = placeholder;\n      }\n      return ComponentFactoryDependency;\n  }());\n  var DirectiveWrapperDependency = (function () {\n      function DirectiveWrapperDependency(dir, placeholder) {\n          this.dir = dir;\n          this.placeholder = placeholder;\n      }\n      return DirectiveWrapperDependency;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$14 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var CompileNode = (function () {\n      function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {\n          this.parent = parent;\n          this.view = view;\n          this.nodeIndex = nodeIndex;\n          this.renderNode = renderNode;\n          this.sourceAst = sourceAst;\n      }\n      CompileNode.prototype.isNull = function () { return !this.renderNode; };\n      CompileNode.prototype.isRootElement = function () { return this.view != this.parent.view; };\n      return CompileNode;\n  }());\n  var CompileElement = (function (_super) {\n      __extends$14(CompileElement, _super);\n      function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references, _targetDependencies) {\n          var _this = this;\n          _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);\n          this.component = component;\n          this._directives = _directives;\n          this._resolvedProvidersArray = _resolvedProvidersArray;\n          this.hasViewContainer = hasViewContainer;\n          this.hasEmbeddedView = hasEmbeddedView;\n          this._targetDependencies = _targetDependencies;\n          this.compViewExpr = null;\n          this.instances = new Map();\n          this.directiveWrapperInstance = new Map();\n          this._queryCount = 0;\n          this._queries = new Map();\n          this.contentNodesByNgContentIndex = null;\n          this.referenceTokens = {};\n          references.forEach(function (ref) { return _this.referenceTokens[ref.name] = ref.value; });\n          this.elementRef =\n              importExpr(resolveIdentifier(Identifiers.ElementRef)).instantiate([this.renderNode]);\n          this.instances.set(resolveIdentifierToken(Identifiers.ElementRef).reference, this.elementRef);\n          this.instances.set(resolveIdentifierToken(Identifiers.Injector).reference, THIS_EXPR.callMethod('injector', [literal(this.nodeIndex)]));\n          this.instances.set(resolveIdentifierToken(Identifiers.Renderer).reference, THIS_EXPR.prop('renderer'));\n          if (this.hasViewContainer || this.hasEmbeddedView) {\n              this._createViewContainer();\n          }\n          if (this.component) {\n              this._createComponentFactoryResolver();\n          }\n      }\n      CompileElement.createNull = function () {\n          return new CompileElement(null, null, null, null, null, null, [], [], false, false, [], []);\n      };\n      CompileElement.prototype._createViewContainer = function () {\n          var fieldName = \"_vc_\" + this.nodeIndex;\n          var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;\n          // private is fine here as no child view will reference a ViewContainer\n          this.view.fields.push(new ClassField(fieldName, importType(resolveIdentifier(Identifiers.ViewContainer)), [StmtModifier.Private]));\n          var statement = THIS_EXPR.prop(fieldName)\n              .set(importExpr(resolveIdentifier(Identifiers.ViewContainer)).instantiate([\n              literal(this.nodeIndex), literal(parentNodeIndex), THIS_EXPR, this.renderNode\n          ]))\n              .toStmt();\n          this.view.createMethod.addStmt(statement);\n          this.viewContainer = THIS_EXPR.prop(fieldName);\n          this.instances.set(resolveIdentifierToken(Identifiers.ViewContainer).reference, this.viewContainer);\n          this.view.viewContainers.push(this.viewContainer);\n      };\n      CompileElement.prototype._createComponentFactoryResolver = function () {\n          var _this = this;\n          var entryComponents = this.component.entryComponents.map(function (entryComponent) {\n              var id = new CompileIdentifierMetadata({ name: entryComponent.name });\n              _this._targetDependencies.push(new ComponentFactoryDependency(entryComponent, id));\n              return id;\n          });\n          if (!entryComponents || entryComponents.length === 0) {\n              return;\n          }\n          var createComponentFactoryResolverExpr = importExpr(resolveIdentifier(Identifiers.CodegenComponentFactoryResolver)).instantiate([\n              literalArr(entryComponents.map(function (entryComponent) { return importExpr(entryComponent); })),\n              injectFromViewParentInjector(this.view, resolveIdentifierToken(Identifiers.ComponentFactoryResolver), false)\n          ]);\n          var provider = new CompileProviderMetadata({\n              token: resolveIdentifierToken(Identifiers.ComponentFactoryResolver),\n              useValue: createComponentFactoryResolverExpr\n          });\n          // Add ComponentFactoryResolver as first provider as it does not have deps on other providers\n          // ProviderAstType.PrivateService as only the component and its view can see it,\n          // but nobody else\n          this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.PrivateService, [], this.sourceAst.sourceSpan));\n      };\n      CompileElement.prototype.setComponentView = function (compViewExpr) {\n          this.compViewExpr = compViewExpr;\n          this.contentNodesByNgContentIndex =\n              new Array(this.component.template.ngContentSelectors.length);\n          for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {\n              this.contentNodesByNgContentIndex[i] = [];\n          }\n      };\n      CompileElement.prototype.setEmbeddedView = function (embeddedView) {\n          this.embeddedView = embeddedView;\n          if (isPresent(embeddedView)) {\n              var createTemplateRefExpr = importExpr(resolveIdentifier(Identifiers.TemplateRef_)).instantiate([\n                  THIS_EXPR, literal(this.nodeIndex), this.renderNode\n              ]);\n              var provider = new CompileProviderMetadata({\n                  token: resolveIdentifierToken(Identifiers.TemplateRef),\n                  useValue: createTemplateRefExpr\n              });\n              // Add TemplateRef as first provider as it does not have deps on other providers\n              this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.Builtin, [], this.sourceAst.sourceSpan));\n          }\n      };\n      CompileElement.prototype.beforeChildren = function () {\n          var _this = this;\n          if (this.hasViewContainer) {\n              this.instances.set(resolveIdentifierToken(Identifiers.ViewContainerRef).reference, this.viewContainer.prop('vcRef'));\n          }\n          this._resolvedProviders = new Map();\n          this._resolvedProvidersArray.forEach(function (provider) { return _this._resolvedProviders.set(provider.token.reference, provider); });\n          // create all the provider instances, some in the view constructor,\n          // some as getters. We rely on the fact that they are already sorted topologically.\n          Array.from(this._resolvedProviders.values()).forEach(function (resolvedProvider) {\n              var isDirectiveWrapper = resolvedProvider.providerType === exports.ProviderAstType.Component ||\n                  resolvedProvider.providerType === exports.ProviderAstType.Directive;\n              var providerValueExpressions = resolvedProvider.providers.map(function (provider) {\n                  if (provider.useExisting) {\n                      return _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }));\n                  }\n                  else if (provider.useFactory) {\n                      var deps = provider.deps || provider.useFactory.diDeps;\n                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });\n                      return importExpr(provider.useFactory).callFn(depsExpr);\n                  }\n                  else if (provider.useClass) {\n                      var deps = provider.deps || provider.useClass.diDeps;\n                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });\n                      if (isDirectiveWrapper) {\n                          var directiveWrapperIdentifier = new CompileIdentifierMetadata({ name: DirectiveWrapperCompiler.dirWrapperClassName(provider.useClass) });\n                          _this._targetDependencies.push(new DirectiveWrapperDependency(provider.useClass, directiveWrapperIdentifier));\n                          return DirectiveWrapperExpressions.create(directiveWrapperIdentifier, depsExpr);\n                      }\n                      else {\n                          return importExpr(provider.useClass)\n                              .instantiate(depsExpr, importType(provider.useClass));\n                      }\n                  }\n                  else {\n                      return convertValueToOutputAst(provider.useValue);\n                  }\n              });\n              var propName = \"_\" + resolvedProvider.token.name + \"_\" + _this.nodeIndex + \"_\" + _this.instances.size;\n              var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);\n              if (isDirectiveWrapper) {\n                  _this.directiveWrapperInstance.set(resolvedProvider.token.reference, instance);\n                  _this.instances.set(resolvedProvider.token.reference, DirectiveWrapperExpressions.context(instance));\n              }\n              else {\n                  _this.instances.set(resolvedProvider.token.reference, instance);\n              }\n          });\n          var _loop_1 = function(i) {\n              var directive = this_1._directives[i];\n              var directiveInstance = this_1.instances.get(identifierToken(directive.type).reference);\n              directive.queries.forEach(function (queryMeta) { _this._addQuery(queryMeta, directiveInstance); });\n          };\n          var this_1 = this;\n          for (var i = 0; i < this._directives.length; i++) {\n              _loop_1(i);\n          }\n          var queriesWithReads = [];\n          Array.from(this._resolvedProviders.values()).forEach(function (resolvedProvider) {\n              var queriesForProvider = _this._getQueriesFor(resolvedProvider.token);\n              queriesWithReads.push.apply(queriesWithReads, queriesForProvider.map(function (query) { return new _QueryWithRead(query, resolvedProvider.token); }));\n          });\n          Object.keys(this.referenceTokens).forEach(function (varName) {\n              var token = _this.referenceTokens[varName];\n              var varValue;\n              if (token) {\n                  varValue = _this.instances.get(token.reference);\n              }\n              else {\n                  varValue = _this.renderNode;\n              }\n              _this.view.locals.set(varName, varValue);\n              var varToken = new CompileTokenMetadata({ value: varName });\n              queriesWithReads.push.apply(queriesWithReads, _this._getQueriesFor(varToken).map(function (query) { return new _QueryWithRead(query, varToken); }));\n          });\n          queriesWithReads.forEach(function (queryWithRead) {\n              var value;\n              if (isPresent(queryWithRead.read.identifier)) {\n                  // query for an identifier\n                  value = _this.instances.get(queryWithRead.read.reference);\n              }\n              else {\n                  // query for a reference\n                  var token = _this.referenceTokens[queryWithRead.read.value];\n                  if (isPresent(token)) {\n                      value = _this.instances.get(token.reference);\n                  }\n                  else {\n                      value = _this.elementRef;\n                  }\n              }\n              if (isPresent(value)) {\n                  queryWithRead.query.addValue(value, _this.view);\n              }\n          });\n      };\n      CompileElement.prototype.afterChildren = function (childNodeCount) {\n          var _this = this;\n          Array.from(this._resolvedProviders.values()).forEach(function (resolvedProvider) {\n              // Note: afterChildren is called after recursing into children.\n              // This is good so that an injector match in an element that is closer to a requesting element\n              // matches first.\n              var providerExpr = _this.instances.get(resolvedProvider.token.reference);\n              // Note: view providers are only visible on the injector of that element.\n              // This is not fully correct as the rules during codegen don't allow a directive\n              // to get hold of a view provdier on the same element. We still do this semantic\n              // as it simplifies our model to having only one runtime injector per element.\n              var providerChildNodeCount = resolvedProvider.providerType === exports.ProviderAstType.PrivateService ? 0 : childNodeCount;\n              _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));\n          });\n          Array.from(this._queries.values())\n              .forEach(function (queries) { return queries.forEach(function (q) {\n              return q.afterChildren(_this.view.createMethod, _this.view.updateContentQueriesMethod);\n          }); });\n      };\n      CompileElement.prototype.addContentNode = function (ngContentIndex, nodeExpr) {\n          this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);\n      };\n      CompileElement.prototype.getComponent = function () {\n          return isPresent(this.component) ?\n              this.instances.get(identifierToken(this.component.type).reference) :\n              null;\n      };\n      CompileElement.prototype.getProviderTokens = function () {\n          return Array.from(this._resolvedProviders.values())\n              .map(function (resolvedProvider) { return createDiTokenExpression(resolvedProvider.token); });\n      };\n      CompileElement.prototype._getQueriesFor = function (token) {\n          var result = [];\n          var currentEl = this;\n          var distance = 0;\n          var queries;\n          while (!currentEl.isNull()) {\n              queries = currentEl._queries.get(token.reference);\n              if (isPresent(queries)) {\n                  result.push.apply(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));\n              }\n              if (currentEl._directives.length > 0) {\n                  distance++;\n              }\n              currentEl = currentEl.parent;\n          }\n          queries = this.view.componentView.viewQueries.get(token.reference);\n          if (isPresent(queries)) {\n              result.push.apply(result, queries);\n          }\n          return result;\n      };\n      CompileElement.prototype._addQuery = function (queryMeta, directiveInstance) {\n          var propName = \"_query_\" + queryMeta.selectors[0].name + \"_\" + this.nodeIndex + \"_\" + this._queryCount++;\n          var queryList = createQueryList(queryMeta, directiveInstance, propName, this.view);\n          var query = new CompileQuery(queryMeta, queryList, directiveInstance, this.view);\n          addQueryToTokenMap(this._queries, query);\n          return query;\n      };\n      CompileElement.prototype._getLocalDependency = function (requestingProviderType, dep) {\n          var result = null;\n          if (isPresent(dep.token)) {\n              // access builtins with special visibility\n              if (!result) {\n                  if (dep.token.reference ===\n                      resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {\n                      if (requestingProviderType === exports.ProviderAstType.Component) {\n                          return this.compViewExpr.prop('ref');\n                      }\n                      else {\n                          return getPropertyInView(THIS_EXPR.prop('ref'), this.view, this.view.componentView);\n                      }\n                  }\n              }\n              // access regular providers on the element\n              if (!result) {\n                  var resolvedProvider = this._resolvedProviders.get(dep.token.reference);\n                  // don't allow directives / public services to access private services.\n                  // only components and private services can access private services.\n                  if (resolvedProvider && (requestingProviderType === exports.ProviderAstType.Directive ||\n                      requestingProviderType === exports.ProviderAstType.PublicService) &&\n                      resolvedProvider.providerType === exports.ProviderAstType.PrivateService) {\n                      return null;\n                  }\n                  result = this.instances.get(dep.token.reference);\n              }\n          }\n          return result;\n      };\n      CompileElement.prototype._getDependency = function (requestingProviderType, dep) {\n          var currElement = this;\n          var result = null;\n          if (dep.isValue) {\n              result = literal(dep.value);\n          }\n          if (!result && !dep.isSkipSelf) {\n              result = this._getLocalDependency(requestingProviderType, dep);\n          }\n          // check parent elements\n          while (!result && !currElement.parent.isNull()) {\n              currElement = currElement.parent;\n              result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, new CompileDiDependencyMetadata({ token: dep.token }));\n          }\n          if (!result) {\n              result = injectFromViewParentInjector(this.view, dep.token, dep.isOptional);\n          }\n          if (!result) {\n              result = NULL_EXPR;\n          }\n          return getPropertyInView(result, this.view, currElement.view);\n      };\n      return CompileElement;\n  }(CompileNode));\n  function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {\n      var indexCondition;\n      if (childNodeCount > 0) {\n          indexCondition = literal(nodeIndex)\n              .lowerEquals(InjectMethodVars.requestNodeIndex)\n              .and(InjectMethodVars.requestNodeIndex.lowerEquals(literal(nodeIndex + childNodeCount)));\n      }\n      else {\n          indexCondition = literal(nodeIndex).identical(InjectMethodVars.requestNodeIndex);\n      }\n      return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(provider.token)).and(indexCondition), [new ReturnStatement(providerExpr)]);\n  }\n  function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {\n      var view = compileElement.view;\n      var resolvedProviderValueExpr;\n      var type;\n      if (isMulti) {\n          resolvedProviderValueExpr = literalArr(providerValueExpressions);\n          type = new ArrayType(DYNAMIC_TYPE);\n      }\n      else {\n          resolvedProviderValueExpr = providerValueExpressions[0];\n          type = providerValueExpressions[0].type;\n      }\n      if (!type) {\n          type = DYNAMIC_TYPE;\n      }\n      if (isEager) {\n          view.fields.push(new ClassField(propName, type));\n          view.createMethod.addStmt(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());\n      }\n      else {\n          var internalField = \"_\" + propName;\n          view.fields.push(new ClassField(internalField, type));\n          var getter = new CompileMethod(view);\n          getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n          // Note: Equals is important for JS so that it also checks the undefined case!\n          getter.addStmt(new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));\n          getter.addStmt(new ReturnStatement(THIS_EXPR.prop(internalField)));\n          view.getters.push(new ClassGetter(propName, getter.finish(), type));\n      }\n      return THIS_EXPR.prop(propName);\n  }\n  var _QueryWithRead = (function () {\n      function _QueryWithRead(query, match) {\n          this.query = query;\n          this.read = query.meta.read || match;\n      }\n      return _QueryWithRead;\n  }());\n\n  var CompilePipe = (function () {\n      function CompilePipe(view, meta) {\n          var _this = this;\n          this.view = view;\n          this.meta = meta;\n          this._purePipeProxyCount = 0;\n          this.instance = THIS_EXPR.prop(\"_pipe_\" + meta.name + \"_\" + view.pipeCount++);\n          var deps = this.meta.type.diDeps.map(function (diDep) {\n              if (diDep.token.reference ===\n                  resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {\n                  return getPropertyInView(THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);\n              }\n              return injectFromViewParentInjector(view, diDep.token, false);\n          });\n          this.view.fields.push(new ClassField(this.instance.name, importType(this.meta.type)));\n          this.view.createMethod.resetDebugInfo(null, null);\n          this.view.createMethod.addStmt(THIS_EXPR.prop(this.instance.name)\n              .set(importExpr(this.meta.type).instantiate(deps))\n              .toStmt());\n      }\n      CompilePipe.call = function (view, name, args) {\n          var compView = view.componentView;\n          var meta = _findPipeMeta(compView, name);\n          var pipe;\n          if (meta.pure) {\n              // pure pipes live on the component view\n              pipe = compView.purePipes.get(name);\n              if (!pipe) {\n                  pipe = new CompilePipe(compView, meta);\n                  compView.purePipes.set(name, pipe);\n                  compView.pipes.push(pipe);\n              }\n          }\n          else {\n              // Non pure pipes live on the view that called it\n              pipe = new CompilePipe(view, meta);\n              view.pipes.push(pipe);\n          }\n          return pipe._call(view, args);\n      };\n      Object.defineProperty(CompilePipe.prototype, \"pure\", {\n          get: function () { return this.meta.pure; },\n          enumerable: true,\n          configurable: true\n      });\n      CompilePipe.prototype._call = function (callingView, args) {\n          if (this.meta.pure) {\n              // PurePipeProxies live on the view that called them.\n              var purePipeProxyInstance = THIS_EXPR.prop(this.instance.name + \"_\" + this._purePipeProxyCount++);\n              var pipeInstanceSeenFromPureProxy = getPropertyInView(this.instance, callingView, this.view);\n              createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform')\n                  .callMethod(BuiltinMethod.Bind, [pipeInstanceSeenFromPureProxy]), args.length, purePipeProxyInstance, { fields: callingView.fields, ctorStmts: callingView.createMethod });\n              return importExpr(resolveIdentifier(Identifiers.castByValue))\n                  .callFn([purePipeProxyInstance, pipeInstanceSeenFromPureProxy.prop('transform')])\n                  .callFn(args);\n          }\n          else {\n              return getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);\n          }\n      };\n      return CompilePipe;\n  }());\n  function _findPipeMeta(view, name) {\n      var pipeMeta = null;\n      for (var i = view.pipeMetas.length - 1; i >= 0; i--) {\n          var localPipeMeta = view.pipeMetas[i];\n          if (localPipeMeta.name == name) {\n              pipeMeta = localPipeMeta;\n              break;\n          }\n      }\n      if (!pipeMeta) {\n          throw new Error(\"Illegal state: Could not find pipe \" + name + \" although the parser should have detected this error!\");\n      }\n      return pipeMeta;\n  }\n\n  var CompileViewRootNodeType;\n  (function (CompileViewRootNodeType) {\n      CompileViewRootNodeType[CompileViewRootNodeType[\"Node\"] = 0] = \"Node\";\n      CompileViewRootNodeType[CompileViewRootNodeType[\"ViewContainer\"] = 1] = \"ViewContainer\";\n      CompileViewRootNodeType[CompileViewRootNodeType[\"NgContent\"] = 2] = \"NgContent\";\n  })(CompileViewRootNodeType || (CompileViewRootNodeType = {}));\n  var CompileViewRootNode = (function () {\n      function CompileViewRootNode(type, expr, ngContentIndex) {\n          this.type = type;\n          this.expr = expr;\n          this.ngContentIndex = ngContentIndex;\n      }\n      return CompileViewRootNode;\n  }());\n  var CompileView = (function () {\n      function CompileView(component, genConfig, pipeMetas, styles, animations, viewIndex, declarationElement, templateVariableBindings) {\n          var _this = this;\n          this.component = component;\n          this.genConfig = genConfig;\n          this.pipeMetas = pipeMetas;\n          this.styles = styles;\n          this.animations = animations;\n          this.viewIndex = viewIndex;\n          this.declarationElement = declarationElement;\n          this.templateVariableBindings = templateVariableBindings;\n          this.viewChildren = [];\n          this.nodes = [];\n          this.rootNodes = [];\n          this.lastRenderNode = NULL_EXPR;\n          this.viewContainers = [];\n          this.methods = [];\n          this.ctorStmts = [];\n          this.fields = [];\n          this.getters = [];\n          this.disposables = [];\n          this.purePipes = new Map();\n          this.pipes = [];\n          this.locals = new Map();\n          this.literalArrayCount = 0;\n          this.literalMapCount = 0;\n          this.pipeCount = 0;\n          this.createMethod = new CompileMethod(this);\n          this.animationBindingsMethod = new CompileMethod(this);\n          this.injectorGetMethod = new CompileMethod(this);\n          this.updateContentQueriesMethod = new CompileMethod(this);\n          this.dirtyParentQueriesMethod = new CompileMethod(this);\n          this.updateViewQueriesMethod = new CompileMethod(this);\n          this.detectChangesInInputsMethod = new CompileMethod(this);\n          this.detectChangesRenderPropertiesMethod = new CompileMethod(this);\n          this.afterContentLifecycleCallbacksMethod = new CompileMethod(this);\n          this.afterViewLifecycleCallbacksMethod = new CompileMethod(this);\n          this.destroyMethod = new CompileMethod(this);\n          this.detachMethod = new CompileMethod(this);\n          this.viewType = getViewType(component, viewIndex);\n          this.className = getViewClassName(component, viewIndex);\n          this.classType = importType(new CompileIdentifierMetadata({ name: this.className }));\n          this.classExpr = variable(this.className);\n          if (this.viewType === ViewType.COMPONENT || this.viewType === ViewType.HOST) {\n              this.componentView = this;\n          }\n          else {\n              this.componentView = this.declarationElement.view.componentView;\n          }\n          this.componentContext =\n              getPropertyInView(THIS_EXPR.prop('context'), this, this.componentView);\n          var viewQueries = new Map();\n          if (this.viewType === ViewType.COMPONENT) {\n              var directiveInstance_1 = THIS_EXPR.prop('context');\n              this.component.viewQueries.forEach(function (queryMeta, queryIndex) {\n                  var propName = \"_viewQuery_\" + queryMeta.selectors[0].name + \"_\" + queryIndex;\n                  var queryList = createQueryList(queryMeta, directiveInstance_1, propName, _this);\n                  var query = new CompileQuery(queryMeta, queryList, directiveInstance_1, _this);\n                  addQueryToTokenMap(viewQueries, query);\n              });\n          }\n          this.viewQueries = viewQueries;\n          templateVariableBindings.forEach(function (entry) { _this.locals.set(entry[1], THIS_EXPR.prop('context').prop(entry[0])); });\n          if (!this.declarationElement.isNull()) {\n              this.declarationElement.setEmbeddedView(this);\n          }\n      }\n      CompileView.prototype.callPipe = function (name, input, args) {\n          return CompilePipe.call(this, name, [input].concat(args));\n      };\n      CompileView.prototype.getLocal = function (name) {\n          if (name == EventHandlerVars.event.name) {\n              return EventHandlerVars.event;\n          }\n          var currView = this;\n          var result = currView.locals.get(name);\n          while (!result && isPresent(currView.declarationElement.view)) {\n              currView = currView.declarationElement.view;\n              result = currView.locals.get(name);\n          }\n          if (isPresent(result)) {\n              return getPropertyInView(result, this, currView);\n          }\n          else {\n              return null;\n          }\n      };\n      CompileView.prototype.afterNodes = function () {\n          var _this = this;\n          Array.from(this.viewQueries.values())\n              .forEach(function (queries) { return queries.forEach(function (q) { return q.afterChildren(_this.createMethod, _this.updateViewQueriesMethod); }); });\n      };\n      return CompileView;\n  }());\n  function getViewType(component, embeddedTemplateIndex) {\n      if (embeddedTemplateIndex > 0) {\n          return ViewType.EMBEDDED;\n      }\n      if (component.type.isHost) {\n          return ViewType.HOST;\n      }\n      return ViewType.COMPONENT;\n  }\n\n  function bindOutputs(boundEvents, directives, compileElement, bindToRenderer) {\n      var usedEvents = collectEvents(boundEvents, directives);\n      if (!usedEvents.size) {\n          return false;\n      }\n      if (bindToRenderer) {\n          subscribeToRenderEvents(usedEvents, compileElement);\n      }\n      subscribeToDirectiveEvents(usedEvents, directives, compileElement);\n      generateHandleEventMethod(boundEvents, directives, compileElement);\n      return true;\n  }\n  function collectEvents(boundEvents, directives) {\n      var usedEvents = new Map();\n      boundEvents.forEach(function (event) { usedEvents.set(event.fullName, event); });\n      directives.forEach(function (dirAst) {\n          dirAst.hostEvents.forEach(function (event) { usedEvents.set(event.fullName, event); });\n      });\n      return usedEvents;\n  }\n  function subscribeToRenderEvents(usedEvents, compileElement) {\n      var eventAndTargetExprs = [];\n      usedEvents.forEach(function (event) {\n          if (!event.phase) {\n              eventAndTargetExprs.push(literal(event.name), literal(event.target));\n          }\n      });\n      if (eventAndTargetExprs.length) {\n          var disposableVar = variable(\"disposable_\" + compileElement.view.disposables.length);\n          compileElement.view.disposables.push(disposableVar);\n          compileElement.view.createMethod.addStmt(disposableVar\n              .set(importExpr(resolveIdentifier(Identifiers.subscribeToRenderElement)).callFn([\n              THIS_EXPR, compileElement.renderNode, createInlineArray(eventAndTargetExprs),\n              handleEventExpr(compileElement)\n          ]))\n              .toDeclStmt(FUNCTION_TYPE, [StmtModifier.Private]));\n      }\n  }\n  function subscribeToDirectiveEvents(usedEvents, directives, compileElement) {\n      var usedEventNames = Array.from(usedEvents.keys());\n      directives.forEach(function (dirAst) {\n          var dirWrapper = compileElement.directiveWrapperInstance.get(dirAst.directive.type.reference);\n          compileElement.view.createMethod.addStmts(DirectiveWrapperExpressions.subscribe(dirAst.directive, dirAst.hostProperties, usedEventNames, dirWrapper, THIS_EXPR, handleEventExpr(compileElement)));\n      });\n  }\n  function generateHandleEventMethod(boundEvents, directives, compileElement) {\n      var hasComponentHostListener = directives.some(function (dirAst) { return dirAst.hostEvents.some(function (event) { return dirAst.directive.isComponent; }); });\n      var markPathToRootStart = hasComponentHostListener ? compileElement.compViewExpr : THIS_EXPR;\n      var handleEventStmts = new CompileMethod(compileElement.view);\n      handleEventStmts.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n      handleEventStmts.push(markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt());\n      var eventNameVar = variable('eventName');\n      var resultVar = variable('result');\n      handleEventStmts.push(resultVar.set(literal(true)).toDeclStmt(BOOL_TYPE));\n      directives.forEach(function (dirAst, dirIdx) {\n          var dirWrapper = compileElement.directiveWrapperInstance.get(dirAst.directive.type.reference);\n          if (dirAst.hostEvents.length > 0) {\n              handleEventStmts.push(resultVar\n                  .set(DirectiveWrapperExpressions\n                  .handleEvent(dirAst.hostEvents, dirWrapper, eventNameVar, EventHandlerVars.event)\n                  .and(resultVar))\n                  .toStmt());\n          }\n      });\n      boundEvents.forEach(function (renderEvent, renderEventIdx) {\n          var evalResult = convertActionBinding(compileElement.view, compileElement.view, compileElement.view.componentContext, renderEvent.handler, \"sub_\" + renderEventIdx);\n          var trueStmts = evalResult.stmts;\n          if (evalResult.preventDefault) {\n              trueStmts.push(resultVar.set(evalResult.preventDefault.and(resultVar)).toStmt());\n          }\n          // TODO(tbosch): convert this into a `switch` once our OutputAst supports it.\n          handleEventStmts.push(new IfStmt(eventNameVar.equals(literal(renderEvent.fullName)), trueStmts));\n      });\n      handleEventStmts.push(new ReturnStatement(resultVar));\n      compileElement.view.methods.push(new ClassMethod(getHandleEventMethodName(compileElement.nodeIndex), [\n          new FnParam(eventNameVar.name, STRING_TYPE),\n          new FnParam(EventHandlerVars.event.name, DYNAMIC_TYPE)\n      ], handleEventStmts.finish(), BOOL_TYPE));\n  }\n  function handleEventExpr(compileElement) {\n      var handleEventMethodName = getHandleEventMethodName(compileElement.nodeIndex);\n      return THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(handleEventMethodName)]);\n  }\n\n  var STATE_IS_NEVER_CHECKED = THIS_EXPR.prop('numberOfChecks').identical(new LiteralExpr(0));\n  var NOT_THROW_ON_CHANGES = not(DetectChangesVars.throwOnChange);\n  function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {\n      var view = compileElement.view;\n      var lifecycleHooks = directiveMeta.type.lifecycleHooks;\n      var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;\n      afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentInit) !== -1) {\n          afterContentLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));\n      }\n      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentChecked) !== -1) {\n          afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());\n      }\n  }\n  function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {\n      var view = compileElement.view;\n      var lifecycleHooks = directiveMeta.type.lifecycleHooks;\n      var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;\n      afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewInit) !== -1) {\n          afterViewLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));\n      }\n      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewChecked) !== -1) {\n          afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());\n      }\n  }\n  function bindDirectiveWrapperLifecycleCallbacks(dir, directiveWrapperIntance, compileElement) {\n      compileElement.view.destroyMethod.addStmts(DirectiveWrapperExpressions.ngOnDestroy(dir.directive, directiveWrapperIntance));\n      compileElement.view.detachMethod.addStmts(DirectiveWrapperExpressions.ngOnDetach(dir.hostProperties, directiveWrapperIntance, THIS_EXPR, compileElement.compViewExpr || THIS_EXPR, compileElement.renderNode));\n  }\n  function bindInjectableDestroyLifecycleCallbacks(provider, providerInstance, compileElement) {\n      var onDestroyMethod = compileElement.view.destroyMethod;\n      onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n      if (provider.providerType !== exports.ProviderAstType.Directive &&\n          provider.providerType !== exports.ProviderAstType.Component &&\n          provider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {\n          onDestroyMethod.addStmt(providerInstance.callMethod('ngOnDestroy', []).toStmt());\n      }\n  }\n  function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {\n      var onDestroyMethod = view.destroyMethod;\n      if (pipeMeta.type.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {\n          onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());\n      }\n  }\n\n  function bindRenderText(boundText, compileNode, view) {\n      var valueField = createCheckBindingField(view);\n      var evalResult = convertPropertyBinding(view, view, view.componentContext, boundText.value, valueField.bindingId);\n      if (!evalResult) {\n          return null;\n      }\n      view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);\n      view.detectChangesRenderPropertiesMethod.addStmts(createCheckBindingStmt(evalResult, valueField.expression, DetectChangesVars.throwOnChange, [THIS_EXPR.prop('renderer')\n              .callMethod('setText', [compileNode.renderNode, evalResult.currValExpr])\n              .toStmt()]));\n  }\n  function bindRenderInputs(boundProps, hasEvents, compileElement) {\n      var view = compileElement.view;\n      var renderNode = compileElement.renderNode;\n      boundProps.forEach(function (boundProp) {\n          var bindingField = createCheckBindingField(view);\n          view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);\n          var evalResult = convertPropertyBinding(view, view, compileElement.view.componentContext, boundProp.value, bindingField.bindingId);\n          if (!evalResult) {\n              return;\n          }\n          var checkBindingStmts = [];\n          var compileMethod = view.detectChangesRenderPropertiesMethod;\n          switch (boundProp.type) {\n              case exports.PropertyBindingType.Property:\n              case exports.PropertyBindingType.Attribute:\n              case exports.PropertyBindingType.Class:\n              case exports.PropertyBindingType.Style:\n                  checkBindingStmts.push.apply(checkBindingStmts, writeToRenderer(THIS_EXPR, boundProp, renderNode, evalResult.currValExpr, view.genConfig.logBindingUpdate));\n                  break;\n              case exports.PropertyBindingType.Animation:\n                  compileMethod = view.animationBindingsMethod;\n                  var _a = triggerAnimation(THIS_EXPR, THIS_EXPR, boundProp, (hasEvents ? THIS_EXPR.prop(getHandleEventMethodName(compileElement.nodeIndex)) :\n                      importExpr(resolveIdentifier(Identifiers.noop)))\n                      .callMethod(BuiltinMethod.Bind, [THIS_EXPR]), compileElement.renderNode, evalResult.currValExpr, bindingField.expression), updateStmts = _a.updateStmts, detachStmts = _a.detachStmts;\n                  checkBindingStmts.push.apply(checkBindingStmts, updateStmts);\n                  view.detachMethod.addStmts(detachStmts);\n                  break;\n          }\n          compileMethod.addStmts(createCheckBindingStmt(evalResult, bindingField.expression, DetectChangesVars.throwOnChange, checkBindingStmts));\n      });\n  }\n  function bindDirectiveHostProps(directiveAst, directiveWrapperInstance, compileElement, elementName, schemaRegistry) {\n      // We need to provide the SecurityContext for properties that could need sanitization.\n      var runtimeSecurityCtxExprs = directiveAst.hostProperties.filter(function (boundProp) { return boundProp.needsRuntimeSecurityContext; })\n          .map(function (boundProp) {\n          var ctx;\n          switch (boundProp.type) {\n              case exports.PropertyBindingType.Property:\n                  ctx = schemaRegistry.securityContext(elementName, boundProp.name, false);\n                  break;\n              case exports.PropertyBindingType.Attribute:\n                  ctx = schemaRegistry.securityContext(elementName, boundProp.name, true);\n                  break;\n              default:\n                  throw new Error(\"Illegal state: Only property / attribute bindings can have an unknown security context! Binding \" + boundProp.name);\n          }\n          return createEnumExpression(Identifiers.SecurityContext, ctx);\n      });\n      compileElement.view.detectChangesRenderPropertiesMethod.addStmts(DirectiveWrapperExpressions.checkHost(directiveAst.hostProperties, directiveWrapperInstance, THIS_EXPR, compileElement.compViewExpr || THIS_EXPR, compileElement.renderNode, DetectChangesVars.throwOnChange, runtimeSecurityCtxExprs));\n  }\n  function bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement) {\n      var view = compileElement.view;\n      var detectChangesInInputsMethod = view.detectChangesInInputsMethod;\n      detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);\n      directiveAst.inputs.forEach(function (input, inputIdx) {\n          // Note: We can't use `fields.length` here, as we are not adding a field!\n          var bindingId = compileElement.nodeIndex + \"_\" + dirIndex + \"_\" + inputIdx;\n          detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);\n          var evalResult = convertPropertyBinding(view, view, view.componentContext, input.value, bindingId);\n          if (!evalResult) {\n              return;\n          }\n          detectChangesInInputsMethod.addStmts(evalResult.stmts);\n          detectChangesInInputsMethod.addStmt(directiveWrapperInstance\n              .callMethod(\"check_\" + input.directiveName, [\n              evalResult.currValExpr, DetectChangesVars.throwOnChange,\n              evalResult.forceUpdate || literal(false)\n          ])\n              .toStmt());\n      });\n      var isOnPushComp = directiveAst.directive.isComponent &&\n          !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);\n      var directiveDetectChangesExpr = DirectiveWrapperExpressions.ngDoCheck(directiveWrapperInstance, THIS_EXPR, compileElement.renderNode, DetectChangesVars.throwOnChange);\n      var directiveDetectChangesStmt = isOnPushComp ?\n          new IfStmt(directiveDetectChangesExpr, [compileElement.compViewExpr.callMethod('markAsCheckOnce', []).toStmt()]) :\n          directiveDetectChangesExpr.toStmt();\n      detectChangesInInputsMethod.addStmt(directiveDetectChangesStmt);\n  }\n\n  function bindView(view, parsedTemplate, schemaRegistry) {\n      var visitor = new ViewBinderVisitor(view, schemaRegistry);\n      templateVisitAll(visitor, parsedTemplate);\n      view.pipes.forEach(function (pipe) { bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view); });\n  }\n  var ViewBinderVisitor = (function () {\n      function ViewBinderVisitor(view, _schemaRegistry) {\n          this.view = view;\n          this._schemaRegistry = _schemaRegistry;\n          this._nodeIndex = 0;\n      }\n      ViewBinderVisitor.prototype.visitBoundText = function (ast, parent) {\n          var node = this.view.nodes[this._nodeIndex++];\n          bindRenderText(ast, node, this.view);\n          return null;\n      };\n      ViewBinderVisitor.prototype.visitText = function (ast, parent) {\n          this._nodeIndex++;\n          return null;\n      };\n      ViewBinderVisitor.prototype.visitNgContent = function (ast, parent) { return null; };\n      ViewBinderVisitor.prototype.visitElement = function (ast, parent) {\n          var _this = this;\n          var compileElement = this.view.nodes[this._nodeIndex++];\n          var hasEvents = bindOutputs(ast.outputs, ast.directives, compileElement, true);\n          bindRenderInputs(ast.inputs, hasEvents, compileElement);\n          ast.directives.forEach(function (directiveAst, dirIndex) {\n              var directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);\n              bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement);\n              bindDirectiveHostProps(directiveAst, directiveWrapperInstance, compileElement, ast.name, _this._schemaRegistry);\n          });\n          templateVisitAll(this, ast.children, compileElement);\n          // afterContent and afterView lifecycles need to be called bottom up\n          // so that children are notified before parents\n          ast.directives.forEach(function (directiveAst) {\n              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);\n              var directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);\n              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);\n              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);\n              bindDirectiveWrapperLifecycleCallbacks(directiveAst, directiveWrapperInstance, compileElement);\n          });\n          ast.providers.forEach(function (providerAst) {\n              var providerInstance = compileElement.instances.get(providerAst.token.reference);\n              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);\n          });\n          return null;\n      };\n      ViewBinderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {\n          var compileElement = this.view.nodes[this._nodeIndex++];\n          bindOutputs(ast.outputs, ast.directives, compileElement, false);\n          ast.directives.forEach(function (directiveAst, dirIndex) {\n              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);\n              var directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);\n              bindDirectiveInputs(directiveAst, directiveWrapperInstance, dirIndex, compileElement);\n              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);\n              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);\n              bindDirectiveWrapperLifecycleCallbacks(directiveAst, directiveWrapperInstance, compileElement);\n          });\n          ast.providers.forEach(function (providerAst) {\n              var providerInstance = compileElement.instances.get(providerAst.token.reference);\n              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);\n          });\n          bindView(compileElement.embeddedView, ast.children, this._schemaRegistry);\n          return null;\n      };\n      ViewBinderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };\n      ViewBinderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };\n      ViewBinderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {\n          return null;\n      };\n      ViewBinderVisitor.prototype.visitReference = function (ast, ctx) { return null; };\n      ViewBinderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };\n      ViewBinderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };\n      ViewBinderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };\n      return ViewBinderVisitor;\n  }());\n\n  var IMPLICIT_TEMPLATE_VAR = '\\$implicit';\n  var CLASS_ATTR$1 = 'class';\n  var STYLE_ATTR = 'style';\n  var NG_CONTAINER_TAG = 'ng-container';\n  var parentRenderNodeVar = variable('parentRenderNode');\n  var rootSelectorVar = variable('rootSelector');\n  function buildView(view, template, targetDependencies) {\n      var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);\n      var parentEl = view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent;\n      templateVisitAll(builderVisitor, template, parentEl);\n      if (view.viewType === ViewType.EMBEDDED || view.viewType === ViewType.HOST) {\n          view.lastRenderNode = builderVisitor.getOrCreateLastRenderNode();\n      }\n      return builderVisitor.nestedViewCount;\n  }\n  function finishView(view, targetStatements) {\n      view.afterNodes();\n      createViewTopLevelStmts(view, targetStatements);\n      view.nodes.forEach(function (node) {\n          if (node instanceof CompileElement && node.hasEmbeddedView) {\n              finishView(node.embeddedView, targetStatements);\n          }\n      });\n  }\n  var ViewBuilderVisitor = (function () {\n      function ViewBuilderVisitor(view, targetDependencies) {\n          this.view = view;\n          this.targetDependencies = targetDependencies;\n          this.nestedViewCount = 0;\n      }\n      ViewBuilderVisitor.prototype._isRootNode = function (parent) { return parent.view !== this.view; };\n      ViewBuilderVisitor.prototype._addRootNodeAndProject = function (node) {\n          var projectedNode = _getOuterContainerOrSelf(node);\n          var parent = projectedNode.parent;\n          var ngContentIndex = projectedNode.sourceAst.ngContentIndex;\n          var viewContainer = (node instanceof CompileElement && node.hasViewContainer) ? node.viewContainer : null;\n          if (this._isRootNode(parent)) {\n              if (this.view.viewType !== ViewType.COMPONENT) {\n                  this.view.rootNodes.push(new CompileViewRootNode(viewContainer ? CompileViewRootNodeType.ViewContainer : CompileViewRootNodeType.Node, viewContainer || node.renderNode));\n              }\n          }\n          else if (isPresent(parent.component) && isPresent(ngContentIndex)) {\n              parent.addContentNode(ngContentIndex, new CompileViewRootNode(viewContainer ? CompileViewRootNodeType.ViewContainer : CompileViewRootNodeType.Node, viewContainer || node.renderNode));\n          }\n      };\n      ViewBuilderVisitor.prototype._getParentRenderNode = function (parent) {\n          parent = _getOuterContainerParentOrSelf(parent);\n          if (this._isRootNode(parent)) {\n              if (this.view.viewType === ViewType.COMPONENT) {\n                  return parentRenderNodeVar;\n              }\n              else {\n                  // root node of an embedded/host view\n                  return NULL_EXPR;\n              }\n          }\n          else {\n              return isPresent(parent.component) &&\n                  parent.component.template.encapsulation !== _angular_core.ViewEncapsulation.Native ?\n                  NULL_EXPR :\n                  parent.renderNode;\n          }\n      };\n      ViewBuilderVisitor.prototype.getOrCreateLastRenderNode = function () {\n          var view = this.view;\n          if (view.rootNodes.length === 0 ||\n              view.rootNodes[view.rootNodes.length - 1].type !== CompileViewRootNodeType.Node) {\n              var fieldName = \"_el_\" + view.nodes.length;\n              view.fields.push(new ClassField(fieldName, importType(view.genConfig.renderTypes.renderElement)));\n              view.createMethod.addStmt(THIS_EXPR.prop(fieldName)\n                  .set(ViewProperties.renderer.callMethod('createTemplateAnchor', [NULL_EXPR, NULL_EXPR]))\n                  .toStmt());\n              view.rootNodes.push(new CompileViewRootNode(CompileViewRootNodeType.Node, THIS_EXPR.prop(fieldName)));\n          }\n          return view.rootNodes[view.rootNodes.length - 1].expr;\n      };\n      ViewBuilderVisitor.prototype.visitBoundText = function (ast, parent) {\n          return this._visitText(ast, '', parent);\n      };\n      ViewBuilderVisitor.prototype.visitText = function (ast, parent) {\n          return this._visitText(ast, ast.value, parent);\n      };\n      ViewBuilderVisitor.prototype._visitText = function (ast, value, parent) {\n          var fieldName = \"_text_\" + this.view.nodes.length;\n          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderText)));\n          var renderNode = THIS_EXPR.prop(fieldName);\n          var compileNode = new CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);\n          var createRenderNode = THIS_EXPR.prop(fieldName)\n              .set(ViewProperties.renderer.callMethod('createText', [\n              this._getParentRenderNode(parent), literal(value),\n              this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)\n          ]))\n              .toStmt();\n          this.view.nodes.push(compileNode);\n          this.view.createMethod.addStmt(createRenderNode);\n          this._addRootNodeAndProject(compileNode);\n          return renderNode;\n      };\n      ViewBuilderVisitor.prototype.visitNgContent = function (ast, parent) {\n          // the projected nodes originate from a different view, so we don't\n          // have debug information for them...\n          this.view.createMethod.resetDebugInfo(null, ast);\n          var parentRenderNode = this._getParentRenderNode(parent);\n          if (parentRenderNode !== NULL_EXPR) {\n              this.view.createMethod.addStmt(THIS_EXPR.callMethod('projectNodes', [parentRenderNode, literal(ast.index)])\n                  .toStmt());\n          }\n          else if (this._isRootNode(parent)) {\n              if (this.view.viewType !== ViewType.COMPONENT) {\n                  // store root nodes only for embedded/host views\n                  this.view.rootNodes.push(new CompileViewRootNode(CompileViewRootNodeType.NgContent, null, ast.index));\n              }\n          }\n          else {\n              if (isPresent(parent.component) && isPresent(ast.ngContentIndex)) {\n                  parent.addContentNode(ast.ngContentIndex, new CompileViewRootNode(CompileViewRootNodeType.NgContent, null, ast.index));\n              }\n          }\n          return null;\n      };\n      ViewBuilderVisitor.prototype.visitElement = function (ast, parent) {\n          var nodeIndex = this.view.nodes.length;\n          var createRenderNodeExpr;\n          var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);\n          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });\n          var component = directives.find(function (directive) { return directive.isComponent; });\n          if (ast.name === NG_CONTAINER_TAG) {\n              createRenderNodeExpr = ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), debugContextExpr]);\n          }\n          else {\n              var htmlAttrs = _readHtmlAttrs(ast.attrs);\n              var attrNameAndValues = createInlineArray(_mergeHtmlAndDirectiveAttrs(htmlAttrs, directives).map(function (v) { return literal(v); }));\n              if (nodeIndex === 0 && this.view.viewType === ViewType.HOST) {\n                  createRenderNodeExpr =\n                      importExpr(resolveIdentifier(Identifiers.selectOrCreateRenderHostElement)).callFn([\n                          ViewProperties.renderer, literal(ast.name), attrNameAndValues, rootSelectorVar,\n                          debugContextExpr\n                      ]);\n              }\n              else {\n                  createRenderNodeExpr =\n                      importExpr(resolveIdentifier(Identifiers.createRenderElement)).callFn([\n                          ViewProperties.renderer, this._getParentRenderNode(parent), literal(ast.name),\n                          attrNameAndValues, debugContextExpr\n                      ]);\n              }\n          }\n          var fieldName = \"_el_\" + nodeIndex;\n          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderElement)));\n          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());\n          var renderNode = THIS_EXPR.prop(fieldName);\n          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references, this.targetDependencies);\n          this.view.nodes.push(compileElement);\n          var compViewExpr = null;\n          if (isPresent(component)) {\n              var nestedComponentIdentifier = new CompileIdentifierMetadata({ name: getViewClassName(component, 0) });\n              this.targetDependencies.push(new ViewClassDependency(component.type, nestedComponentIdentifier));\n              compViewExpr = THIS_EXPR.prop(\"compView_\" + nodeIndex); // fix highlighting: `\n              this.view.fields.push(new ClassField(compViewExpr.name, importType(resolveIdentifier(Identifiers.AppView), [importType(component.type)])));\n              this.view.viewChildren.push(compViewExpr);\n              compileElement.setComponentView(compViewExpr);\n              this.view.createMethod.addStmt(compViewExpr\n                  .set(importExpr(nestedComponentIdentifier).instantiate([\n                  ViewProperties.viewUtils, THIS_EXPR, literal(nodeIndex), renderNode\n              ]))\n                  .toStmt());\n          }\n          compileElement.beforeChildren();\n          this._addRootNodeAndProject(compileElement);\n          templateVisitAll(this, ast.children, compileElement);\n          compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);\n          if (isPresent(compViewExpr)) {\n              this.view.createMethod.addStmt(compViewExpr.callMethod('create', [compileElement.getComponent()]).toStmt());\n          }\n          return null;\n      };\n      ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {\n          var nodeIndex = this.view.nodes.length;\n          var fieldName = \"_anchor_\" + nodeIndex;\n          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderComment)));\n          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName)\n              .set(ViewProperties.renderer.callMethod('createTemplateAnchor', [\n              this._getParentRenderNode(parent),\n              this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)\n          ]))\n              .toStmt());\n          var renderNode = THIS_EXPR.prop(fieldName);\n          var templateVariableBindings = ast.variables.map(function (varAst) { return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]; });\n          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });\n          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references, this.targetDependencies);\n          this.view.nodes.push(compileElement);\n          this.nestedViewCount++;\n          var embeddedView = new CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, NULL_EXPR, this.view.animations, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);\n          this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);\n          compileElement.beforeChildren();\n          this._addRootNodeAndProject(compileElement);\n          compileElement.afterChildren(0);\n          return null;\n      };\n      ViewBuilderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };\n      ViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };\n      ViewBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {\n          return null;\n      };\n      ViewBuilderVisitor.prototype.visitReference = function (ast, ctx) { return null; };\n      ViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };\n      ViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };\n      ViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };\n      return ViewBuilderVisitor;\n  }());\n  /**\n   * Walks up the nodes while the direct parent is a container.\n   *\n   * Returns the outer container or the node itself when it is not a direct child of a container.\n   *\n   * @internal\n   */\n  function _getOuterContainerOrSelf(node) {\n      var view = node.view;\n      while (_isNgContainer(node.parent, view)) {\n          node = node.parent;\n      }\n      return node;\n  }\n  /**\n   * Walks up the nodes while they are container and returns the first parent which is not.\n   *\n   * Returns the parent of the outer container or the node itself when it is not a container.\n   *\n   * @internal\n   */\n  function _getOuterContainerParentOrSelf(el) {\n      var view = el.view;\n      while (_isNgContainer(el, view)) {\n          el = el.parent;\n      }\n      return el;\n  }\n  function _isNgContainer(node, view) {\n      return !node.isNull() && node.sourceAst.name === NG_CONTAINER_TAG &&\n          node.view === view;\n  }\n  function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {\n      var mapResult = {};\n      Object.keys(declaredHtmlAttrs).forEach(function (key) { mapResult[key] = declaredHtmlAttrs[key]; });\n      directives.forEach(function (directiveMeta) {\n          Object.keys(directiveMeta.hostAttributes).forEach(function (name) {\n              var value = directiveMeta.hostAttributes[name];\n              var prevValue = mapResult[name];\n              mapResult[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;\n          });\n      });\n      var arrResult = [];\n      // Note: We need to sort to get a defined output order\n      // for tests and for caching generated artifacts...\n      Object.keys(mapResult).sort().forEach(function (attrName) { arrResult.push(attrName, mapResult[attrName]); });\n      return arrResult;\n  }\n  function _readHtmlAttrs(attrs) {\n      var htmlAttrs = {};\n      attrs.forEach(function (ast) { htmlAttrs[ast.name] = ast.value; });\n      return htmlAttrs;\n  }\n  function mergeAttributeValue(attrName, attrValue1, attrValue2) {\n      if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n          return attrValue1 + \" \" + attrValue2;\n      }\n      else {\n          return attrValue2;\n      }\n  }\n  function createViewTopLevelStmts(view, targetStatements) {\n      var nodeDebugInfosVar = NULL_EXPR;\n      if (view.genConfig.genDebugInfo) {\n          nodeDebugInfosVar = variable(\"nodeDebugInfos_\" + view.component.type.name + view.viewIndex); // fix highlighting: `\n          targetStatements.push(nodeDebugInfosVar\n              .set(literalArr(view.nodes.map(createStaticNodeDebugInfo), new ArrayType(new ExternalType(resolveIdentifier(Identifiers.StaticNodeDebugInfo)), [TypeModifier.Const])))\n              .toDeclStmt(null, [StmtModifier.Final]));\n      }\n      var renderCompTypeVar = variable(\"renderType_\" + view.component.type.name); // fix highlighting: `\n      if (view.viewIndex === 0) {\n          var templateUrlInfo = void 0;\n          if (view.component.template.templateUrl == view.component.type.moduleUrl) {\n              templateUrlInfo =\n                  view.component.type.moduleUrl + \" class \" + view.component.type.name + \" - inline template\";\n          }\n          else {\n              templateUrlInfo = view.component.template.templateUrl;\n          }\n          targetStatements.push(renderCompTypeVar\n              .set(importExpr(resolveIdentifier(Identifiers.createRenderComponentType)).callFn([\n              view.genConfig.genDebugInfo ? literal(templateUrlInfo) : literal(''),\n              literal(view.component.template.ngContentSelectors.length),\n              ViewEncapsulationEnum.fromValue(view.component.template.encapsulation),\n              view.styles,\n              literalMap(view.animations.map(function (entry) { return [entry.name, entry.fnExp]; })),\n          ]))\n              .toDeclStmt(importType(resolveIdentifier(Identifiers.RenderComponentType))));\n      }\n      var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);\n      targetStatements.push(viewClass);\n  }\n  function createStaticNodeDebugInfo(node) {\n      var compileElement = node instanceof CompileElement ? node : null;\n      var providerTokens = [];\n      var componentToken = NULL_EXPR;\n      var varTokenEntries = [];\n      if (isPresent(compileElement)) {\n          providerTokens = compileElement.getProviderTokens();\n          if (isPresent(compileElement.component)) {\n              componentToken = createDiTokenExpression(identifierToken(compileElement.component.type));\n          }\n          Object.keys(compileElement.referenceTokens).forEach(function (varName) {\n              var token = compileElement.referenceTokens[varName];\n              varTokenEntries.push([varName, isPresent(token) ? createDiTokenExpression(token) : NULL_EXPR]);\n          });\n      }\n      return importExpr(resolveIdentifier(Identifiers.StaticNodeDebugInfo))\n          .instantiate([\n          literalArr(providerTokens, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])),\n          componentToken,\n          literalMap(varTokenEntries, new MapType(DYNAMIC_TYPE, [TypeModifier.Const]))\n      ], importType(resolveIdentifier(Identifiers.StaticNodeDebugInfo), null, [TypeModifier.Const]));\n  }\n  function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {\n      var viewConstructorArgs = [\n          new FnParam(ViewConstructorVars.viewUtils.name, importType(resolveIdentifier(Identifiers.ViewUtils))),\n          new FnParam(ViewConstructorVars.parentView.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),\n          new FnParam(ViewConstructorVars.parentIndex.name, NUMBER_TYPE),\n          new FnParam(ViewConstructorVars.parentElement.name, DYNAMIC_TYPE)\n      ];\n      var superConstructorArgs = [\n          variable(view.className), renderCompTypeVar, ViewTypeEnum.fromValue(view.viewType),\n          ViewConstructorVars.viewUtils, ViewConstructorVars.parentView, ViewConstructorVars.parentIndex,\n          ViewConstructorVars.parentElement,\n          ChangeDetectorStatusEnum.fromValue(getChangeDetectionMode(view))\n      ];\n      if (view.genConfig.genDebugInfo) {\n          superConstructorArgs.push(nodeDebugInfosVar);\n      }\n      if (view.viewType === ViewType.EMBEDDED) {\n          viewConstructorArgs.push(new FnParam('declaredViewContainer', importType(resolveIdentifier(Identifiers.ViewContainer))));\n          superConstructorArgs.push(variable('declaredViewContainer'));\n      }\n      var viewMethods = [\n          new ClassMethod('createInternal', [new FnParam(rootSelectorVar.name, STRING_TYPE)], generateCreateMethod(view), importType(resolveIdentifier(Identifiers.ComponentRef), [DYNAMIC_TYPE])),\n          new ClassMethod('injectorGetInternal', [\n              new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),\n              // Note: Can't use o.INT_TYPE here as the method in AppView uses number\n              new FnParam(InjectMethodVars.requestNodeIndex.name, NUMBER_TYPE),\n              new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)\n          ], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), InjectMethodVars.notFoundResult), DYNAMIC_TYPE),\n          new ClassMethod('detectChangesInternal', [new FnParam(DetectChangesVars.throwOnChange.name, BOOL_TYPE)], generateDetectChangesMethod(view)),\n          new ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()),\n          new ClassMethod('destroyInternal', [], generateDestroyMethod(view)),\n          new ClassMethod('detachInternal', [], view.detachMethod.finish()),\n          generateVisitRootNodesMethod(view), generateVisitProjectableNodesMethod(view),\n          generateCreateEmbeddedViewsMethod(view)\n      ].filter(function (method) { return method.body.length > 0; });\n      var superClass = view.genConfig.genDebugInfo ? Identifiers.DebugAppView : Identifiers.AppView;\n      var viewClass = createClassStmt({\n          name: view.className,\n          parent: importExpr(resolveIdentifier(superClass), [getContextType(view)]),\n          parentArgs: superConstructorArgs,\n          ctorParams: viewConstructorArgs,\n          builders: [{ methods: viewMethods }, view]\n      });\n      return viewClass;\n  }\n  function generateDestroyMethod(view) {\n      var stmts = [];\n      view.viewContainers.forEach(function (viewContainer) {\n          stmts.push(viewContainer.callMethod('destroyNestedViews', []).toStmt());\n      });\n      view.viewChildren.forEach(function (viewChild) { stmts.push(viewChild.callMethod('destroy', []).toStmt()); });\n      stmts.push.apply(stmts, view.destroyMethod.finish());\n      return stmts;\n  }\n  function generateCreateMethod(view) {\n      var parentRenderNodeExpr = NULL_EXPR;\n      var parentRenderNodeStmts = [];\n      if (view.viewType === ViewType.COMPONENT) {\n          parentRenderNodeExpr =\n              ViewProperties.renderer.callMethod('createViewRoot', [THIS_EXPR.prop('parentElement')]);\n          parentRenderNodeStmts =\n              [parentRenderNodeVar.set(parentRenderNodeExpr)\n                      .toDeclStmt(importType(view.genConfig.renderTypes.renderNode), [StmtModifier.Final])];\n      }\n      var resultExpr;\n      if (view.viewType === ViewType.HOST) {\n          var hostEl = view.nodes[0];\n          resultExpr =\n              importExpr(resolveIdentifier(Identifiers.ComponentRef_), [DYNAMIC_TYPE]).instantiate([\n                  literal(hostEl.nodeIndex), THIS_EXPR, hostEl.renderNode, hostEl.getComponent()\n              ]);\n      }\n      else {\n          resultExpr = NULL_EXPR;\n      }\n      var allNodesExpr = ViewProperties.renderer.cast(DYNAMIC_TYPE)\n          .prop('directRenderer')\n          .conditional(NULL_EXPR, literalArr(view.nodes.map(function (node) { return node.renderNode; })));\n      return parentRenderNodeStmts.concat(view.createMethod.finish(), [\n          THIS_EXPR\n              .callMethod('init', [\n              view.lastRenderNode,\n              allNodesExpr,\n              view.disposables.length ? literalArr(view.disposables) : NULL_EXPR,\n          ])\n              .toStmt(),\n          new ReturnStatement(resultExpr)\n      ]);\n  }\n  function generateDetectChangesMethod(view) {\n      var stmts = [];\n      if (view.animationBindingsMethod.isEmpty() && view.detectChangesInInputsMethod.isEmpty() &&\n          view.updateContentQueriesMethod.isEmpty() &&\n          view.afterContentLifecycleCallbacksMethod.isEmpty() &&\n          view.detectChangesRenderPropertiesMethod.isEmpty() &&\n          view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty() &&\n          view.viewContainers.length === 0 && view.viewChildren.length === 0) {\n          return stmts;\n      }\n      stmts.push.apply(stmts, view.animationBindingsMethod.finish());\n      stmts.push.apply(stmts, view.detectChangesInInputsMethod.finish());\n      view.viewContainers.forEach(function (viewContainer) {\n          stmts.push(viewContainer.callMethod('detectChangesInNestedViews', [DetectChangesVars.throwOnChange])\n              .toStmt());\n      });\n      var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());\n      if (afterContentStmts.length > 0) {\n          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterContentStmts));\n      }\n      stmts.push.apply(stmts, view.detectChangesRenderPropertiesMethod.finish());\n      view.viewChildren.forEach(function (viewChild) {\n          stmts.push(viewChild.callMethod('detectChanges', [DetectChangesVars.throwOnChange]).toStmt());\n      });\n      var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());\n      if (afterViewStmts.length > 0) {\n          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterViewStmts));\n      }\n      var varStmts = [];\n      var readVars = findReadVarNames(stmts);\n      if (readVars.has(DetectChangesVars.changed.name)) {\n          varStmts.push(DetectChangesVars.changed.set(literal(true)).toDeclStmt(BOOL_TYPE));\n      }\n      if (readVars.has(DetectChangesVars.changes.name)) {\n          varStmts.push(DetectChangesVars.changes.set(NULL_EXPR)\n              .toDeclStmt(new MapType(importType(resolveIdentifier(Identifiers.SimpleChange)))));\n      }\n      varStmts.push.apply(varStmts, createSharedBindingVariablesIfNeeded(stmts));\n      return varStmts.concat(stmts);\n  }\n  function addReturnValuefNotEmpty(statements, value) {\n      if (statements.length > 0) {\n          return statements.concat([new ReturnStatement(value)]);\n      }\n      else {\n          return statements;\n      }\n  }\n  function getContextType(view) {\n      if (view.viewType === ViewType.COMPONENT) {\n          return importType(view.component.type);\n      }\n      return DYNAMIC_TYPE;\n  }\n  function getChangeDetectionMode(view) {\n      var mode;\n      if (view.viewType === ViewType.COMPONENT) {\n          mode = isDefaultChangeDetectionStrategy(view.component.changeDetection) ?\n              ChangeDetectorStatus.CheckAlways :\n              ChangeDetectorStatus.CheckOnce;\n      }\n      else {\n          mode = ChangeDetectorStatus.CheckAlways;\n      }\n      return mode;\n  }\n  function generateVisitRootNodesMethod(view) {\n      var cbVar = variable('cb');\n      var ctxVar = variable('ctx');\n      var stmts = generateVisitNodesStmts(view.rootNodes, cbVar, ctxVar);\n      return new ClassMethod('visitRootNodesInternal', [new FnParam(cbVar.name, DYNAMIC_TYPE), new FnParam(ctxVar.name, DYNAMIC_TYPE)], stmts);\n  }\n  function generateVisitProjectableNodesMethod(view) {\n      var nodeIndexVar = variable('nodeIndex');\n      var ngContentIndexVar = variable('ngContentIndex');\n      var cbVar = variable('cb');\n      var ctxVar = variable('ctx');\n      var stmts = [];\n      view.nodes.forEach(function (node) {\n          if (node instanceof CompileElement && node.component) {\n              node.contentNodesByNgContentIndex.forEach(function (projectedNodes, ngContentIndex) {\n                  stmts.push(new IfStmt(nodeIndexVar.equals(literal(node.nodeIndex))\n                      .and(ngContentIndexVar.equals(literal(ngContentIndex))), generateVisitNodesStmts(projectedNodes, cbVar, ctxVar)));\n              });\n          }\n      });\n      return new ClassMethod('visitProjectableNodesInternal', [\n          new FnParam(nodeIndexVar.name, NUMBER_TYPE),\n          new FnParam(ngContentIndexVar.name, NUMBER_TYPE),\n          new FnParam(cbVar.name, DYNAMIC_TYPE), new FnParam(ctxVar.name, DYNAMIC_TYPE)\n      ], stmts);\n  }\n  function generateVisitNodesStmts(nodes, cb, ctx) {\n      var stmts = [];\n      nodes.forEach(function (node) {\n          switch (node.type) {\n              case CompileViewRootNodeType.Node:\n                  stmts.push(cb.callFn([node.expr, ctx]).toStmt());\n                  break;\n              case CompileViewRootNodeType.ViewContainer:\n                  stmts.push(cb.callFn([node.expr.prop('nativeElement'), ctx]).toStmt());\n                  stmts.push(node.expr.callMethod('visitNestedViewRootNodes', [cb, ctx]).toStmt());\n                  break;\n              case CompileViewRootNodeType.NgContent:\n                  stmts.push(THIS_EXPR.callMethod('visitProjectedNodes', [literal(node.ngContentIndex), cb, ctx])\n                      .toStmt());\n                  break;\n          }\n      });\n      return stmts;\n  }\n  function generateCreateEmbeddedViewsMethod(view) {\n      var nodeIndexVar = variable('nodeIndex');\n      var stmts = [];\n      view.nodes.forEach(function (node) {\n          if (node instanceof CompileElement) {\n              if (node.embeddedView) {\n                  var parentNodeIndex = node.isRootElement() ? null : node.parent.nodeIndex;\n                  stmts.push(new IfStmt(nodeIndexVar.equals(literal(node.nodeIndex)), [new ReturnStatement(node.embeddedView.classExpr.instantiate([\n                          ViewProperties.viewUtils, THIS_EXPR, literal(node.nodeIndex), node.renderNode,\n                          node.viewContainer\n                      ]))]));\n              }\n          }\n      });\n      if (stmts.length > 0) {\n          stmts.push(new ReturnStatement(NULL_EXPR));\n      }\n      return new ClassMethod('createEmbeddedViewInternal', [new FnParam(nodeIndexVar.name, NUMBER_TYPE)], stmts, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE]));\n  }\n\n  var ViewCompileResult = (function () {\n      function ViewCompileResult(statements, viewClassVar, dependencies) {\n          this.statements = statements;\n          this.viewClassVar = viewClassVar;\n          this.dependencies = dependencies;\n      }\n      return ViewCompileResult;\n  }());\n  var ViewCompiler = (function () {\n      function ViewCompiler(_genConfig, _schemaRegistry) {\n          this._genConfig = _genConfig;\n          this._schemaRegistry = _schemaRegistry;\n      }\n      ViewCompiler.prototype.compileComponent = function (component, template, styles, pipes, compiledAnimations) {\n          var dependencies = [];\n          var view = new CompileView(component, this._genConfig, pipes, styles, compiledAnimations, 0, CompileElement.createNull(), []);\n          var statements = [];\n          buildView(view, template, dependencies);\n          // Need to separate binding from creation to be able to refer to\n          // variables that have been declared after usage.\n          bindView(view, template, this._schemaRegistry);\n          finishView(view, statements);\n          return new ViewCompileResult(statements, view.classExpr.name, dependencies);\n      };\n      ViewCompiler.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      ViewCompiler.ctorParameters = [\n          { type: CompilerConfig, },\n          { type: ElementSchemaRegistry, },\n      ];\n      return ViewCompiler;\n  }());\n\n  var SourceModule = (function () {\n      function SourceModule(fileUrl, moduleUrl, source) {\n          this.fileUrl = fileUrl;\n          this.moduleUrl = moduleUrl;\n          this.source = source;\n      }\n      return SourceModule;\n  }());\n  // Returns all the source files and a mapping from modules to directives\n  function analyzeNgModules(programStaticSymbols, options, metadataResolver) {\n      return _loadNgModules(programStaticSymbols, options, metadataResolver).then(_analyzeNgModules);\n  }\n  function _analyzeNgModules(ngModuleMetas) {\n      var moduleMetasByRef = new Map();\n      ngModuleMetas.forEach(function (ngModule) { return moduleMetasByRef.set(ngModule.type.reference, ngModule); });\n      var ngModuleByPipeOrDirective = new Map();\n      var ngModulesByFile = new Map();\n      var ngDirectivesByFile = new Map();\n      var filePaths = new Set();\n      // Looping over all modules to construct:\n      // - a map from file to modules `ngModulesByFile`,\n      // - a map from file to directives `ngDirectivesByFile`,\n      // - a map from directive/pipe to module `ngModuleByPipeOrDirective`.\n      ngModuleMetas.forEach(function (ngModuleMeta) {\n          var srcFileUrl = ngModuleMeta.type.reference.filePath;\n          filePaths.add(srcFileUrl);\n          ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));\n          ngModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n              var fileUrl = dirIdentifier.reference.filePath;\n              filePaths.add(fileUrl);\n              ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirIdentifier.reference));\n              ngModuleByPipeOrDirective.set(dirIdentifier.reference, ngModuleMeta);\n          });\n          ngModuleMeta.declaredPipes.forEach(function (pipeIdentifier) {\n              var fileUrl = pipeIdentifier.reference.filePath;\n              filePaths.add(fileUrl);\n              ngModuleByPipeOrDirective.set(pipeIdentifier.reference, ngModuleMeta);\n          });\n      });\n      var files = [];\n      filePaths.forEach(function (srcUrl) {\n          var directives = ngDirectivesByFile.get(srcUrl) || [];\n          var ngModules = ngModulesByFile.get(srcUrl) || [];\n          files.push({ srcUrl: srcUrl, directives: directives, ngModules: ngModules });\n      });\n      return {\n          // map directive/pipe to module\n          ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n          // list modules and directives for every source file\n          files: files,\n      };\n  }\n  var OfflineCompiler = (function () {\n      function OfflineCompiler(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _dirWrapperCompiler, _ngModuleCompiler, _outputEmitter, _localeId, _translationFormat, _animationParser) {\n          this._metadataResolver = _metadataResolver;\n          this._templateParser = _templateParser;\n          this._styleCompiler = _styleCompiler;\n          this._viewCompiler = _viewCompiler;\n          this._dirWrapperCompiler = _dirWrapperCompiler;\n          this._ngModuleCompiler = _ngModuleCompiler;\n          this._outputEmitter = _outputEmitter;\n          this._localeId = _localeId;\n          this._translationFormat = _translationFormat;\n          this._animationParser = _animationParser;\n          this._animationCompiler = new AnimationCompiler();\n      }\n      OfflineCompiler.prototype.clearCache = function () { this._metadataResolver.clearCache(); };\n      OfflineCompiler.prototype.compileModules = function (staticSymbols, options) {\n          var _this = this;\n          return analyzeNgModules(staticSymbols, options, this._metadataResolver)\n              .then(function (_a) {\n              var ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files;\n              var sourceModules = files.map(function (file) { return _this._compileSrcFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.ngModules); });\n              return ListWrapper.flatten(sourceModules);\n          });\n      };\n      OfflineCompiler.prototype._compileSrcFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, ngModules) {\n          var _this = this;\n          var fileSuffix = _splitTypescriptSuffix(srcFileUrl)[1];\n          var statements = [];\n          var exportedVars = [];\n          var outputSourceModules = [];\n          // compile all ng modules\n          exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));\n          // compile directive wrappers\n          exportedVars.push.apply(exportedVars, directives.map(function (directiveType) { return _this._compileDirectiveWrapper(directiveType, statements); }));\n          // compile components\n          directives.forEach(function (dirType) {\n              var compMeta = _this._metadataResolver.getDirectiveMetadata(dirType);\n              if (!compMeta.isComponent) {\n                  return Promise.resolve(null);\n              }\n              var ngModule = ngModuleByPipeOrDirective.get(dirType);\n              if (!ngModule) {\n                  throw new Error(\"Internal Error: cannot determine the module for component \" + compMeta.type.name + \"!\");\n              }\n              _assertComponent(compMeta);\n              // compile styles\n              var stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);\n              stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {\n                  outputSourceModules.push(_this._codgenStyles(srcFileUrl, compiledStyleSheet, fileSuffix));\n              });\n              // compile components\n              exportedVars.push(_this._compileComponentFactory(compMeta, ngModule, fileSuffix, statements), _this._compileComponent(compMeta, ngModule, ngModule.transitiveModule.directives, stylesCompileResults.componentStylesheet, fileSuffix, statements));\n          });\n          if (statements.length > 0) {\n              var srcModule = this._codegenSourceModule(srcFileUrl, _ngfactoryModuleUrl(srcFileUrl), statements, exportedVars);\n              outputSourceModules.unshift(srcModule);\n          }\n          return outputSourceModules;\n      };\n      OfflineCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {\n          var ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);\n          var providers = [];\n          if (this._localeId) {\n              providers.push(new CompileProviderMetadata({\n                  token: resolveIdentifierToken(Identifiers.LOCALE_ID),\n                  useValue: this._localeId,\n              }));\n          }\n          if (this._translationFormat) {\n              providers.push(new CompileProviderMetadata({\n                  token: resolveIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),\n                  useValue: this._translationFormat\n              }));\n          }\n          var appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);\n          appCompileResult.dependencies.forEach(function (dep) {\n              dep.placeholder.name = _componentFactoryName(dep.comp);\n              dep.placeholder.moduleUrl = _ngfactoryModuleUrl(dep.comp.moduleUrl);\n          });\n          targetStatements.push.apply(targetStatements, appCompileResult.statements);\n          return appCompileResult.ngModuleFactoryVar;\n      };\n      OfflineCompiler.prototype._compileDirectiveWrapper = function (directiveType, targetStatements) {\n          var dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);\n          var dirCompileResult = this._dirWrapperCompiler.compile(dirMeta);\n          targetStatements.push.apply(targetStatements, dirCompileResult.statements);\n          return dirCompileResult.dirWrapperClassVar;\n      };\n      OfflineCompiler.prototype._compileComponentFactory = function (compMeta, ngModule, fileSuffix, targetStatements) {\n          var hostMeta = createHostComponentMeta(compMeta);\n          var hostViewFactoryVar = this._compileComponent(hostMeta, ngModule, [compMeta.type], null, fileSuffix, targetStatements);\n          var compFactoryVar = _componentFactoryName(compMeta.type);\n          targetStatements.push(variable(compFactoryVar)\n              .set(importExpr(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)])\n              .instantiate([\n              literal(compMeta.selector),\n              variable(hostViewFactoryVar),\n              importExpr(compMeta.type),\n          ], importType(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)], [TypeModifier.Const])))\n              .toDeclStmt(null, [StmtModifier.Final]));\n          return compFactoryVar;\n      };\n      OfflineCompiler.prototype._compileComponent = function (compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix, targetStatements) {\n          var _this = this;\n          var parsedAnimations = this._animationParser.parseComponent(compMeta);\n          var directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n          var pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, ngModule.schemas, compMeta.type.name);\n          var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);\n          var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, pipes, compiledAnimations);\n          if (componentStyles) {\n              targetStatements.push.apply(targetStatements, _resolveStyleStatements(componentStyles, fileSuffix));\n          }\n          compiledAnimations.forEach(function (entry) { return targetStatements.push.apply(targetStatements, entry.statements); });\n          targetStatements.push.apply(targetStatements, _resolveViewStatements(viewResult));\n          return viewResult.viewClassVar;\n      };\n      OfflineCompiler.prototype._codgenStyles = function (fileUrl, stylesCompileResult, fileSuffix) {\n          _resolveStyleStatements(stylesCompileResult, fileSuffix);\n          return this._codegenSourceModule(fileUrl, _stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);\n      };\n      OfflineCompiler.prototype._codegenSourceModule = function (fileUrl, moduleUrl, statements, exportedVars) {\n          return new SourceModule(fileUrl, moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));\n      };\n      return OfflineCompiler;\n  }());\n  function _resolveViewStatements(compileResult) {\n      compileResult.dependencies.forEach(function (dep) {\n          if (dep instanceof ViewClassDependency) {\n              var vfd = dep;\n              vfd.placeholder.moduleUrl = _ngfactoryModuleUrl(vfd.comp.moduleUrl);\n          }\n          else if (dep instanceof ComponentFactoryDependency) {\n              var cfd = dep;\n              cfd.placeholder.name = _componentFactoryName(cfd.comp);\n              cfd.placeholder.moduleUrl = _ngfactoryModuleUrl(cfd.comp.moduleUrl);\n          }\n          else if (dep instanceof DirectiveWrapperDependency) {\n              var dwd = dep;\n              dwd.placeholder.moduleUrl = _ngfactoryModuleUrl(dwd.dir.moduleUrl);\n          }\n      });\n      return compileResult.statements;\n  }\n  function _resolveStyleStatements(compileResult, fileSuffix) {\n      compileResult.dependencies.forEach(function (dep) {\n          dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix);\n      });\n      return compileResult.statements;\n  }\n  function _ngfactoryModuleUrl(dirUrl) {\n      var urlWithSuffix = _splitTypescriptSuffix(dirUrl);\n      return urlWithSuffix[0] + \".ngfactory\" + urlWithSuffix[1];\n  }\n  function _componentFactoryName(comp) {\n      return comp.name + \"NgFactory\";\n  }\n  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n      return shim ? stylesheetUrl + \".shim\" + suffix : \"\" + stylesheetUrl + suffix;\n  }\n  function _assertComponent(meta) {\n      if (!meta.isComponent) {\n          throw new Error(\"Could not compile '\" + meta.type.name + \"' because it is not a component.\");\n      }\n  }\n  function _splitTypescriptSuffix(path) {\n      if (path.endsWith('.d.ts')) {\n          return [path.slice(0, -5), '.ts'];\n      }\n      var lastDot = path.lastIndexOf('.');\n      if (lastDot !== -1) {\n          return [path.substring(0, lastDot), path.substring(lastDot)];\n      }\n      return [path, ''];\n  }\n  // Load the NgModules and check\n  // that all directives / pipes that are present in the program\n  // are also declared by a module.\n  function _loadNgModules(programStaticSymbols, options, metadataResolver) {\n      var ngModules = new Map();\n      var programPipesAndDirectives = [];\n      var ngModulePipesAndDirective = new Set();\n      var loadingPromises = [];\n      var addNgModule = function (staticSymbol) {\n          if (ngModules.has(staticSymbol)) {\n              return false;\n          }\n          var _a = metadataResolver.loadNgModuleMetadata(staticSymbol, false, false), ngModule = _a.ngModule, loading = _a.loading;\n          if (ngModule) {\n              ngModules.set(ngModule.type.reference, ngModule);\n              loadingPromises.push(loading);\n              ngModule.declaredDirectives.forEach(function (dir) { return ngModulePipesAndDirective.add(dir.reference); });\n              ngModule.declaredPipes.forEach(function (pipe) { return ngModulePipesAndDirective.add(pipe.reference); });\n              if (options.transitiveModules) {\n                  // For every input modules add the list of transitively included modules\n                  ngModule.transitiveModule.modules.forEach(function (modMeta) { return addNgModule(modMeta.type.reference); });\n              }\n          }\n          return !!ngModule;\n      };\n      programStaticSymbols.forEach(function (staticSymbol) {\n          if (!addNgModule(staticSymbol) &&\n              (metadataResolver.isDirective(staticSymbol) || metadataResolver.isPipe(staticSymbol))) {\n              programPipesAndDirectives.push(staticSymbol);\n          }\n      });\n      // Throw an error if any of the program pipe or directives is not declared by a module\n      var symbolsMissingModule = programPipesAndDirectives.filter(function (s) { return !ngModulePipesAndDirective.has(s); });\n      if (symbolsMissingModule.length) {\n          var messages = symbolsMissingModule.map(function (s) { return (\"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"!\"); });\n          throw new Error(messages.join('\\n'));\n      }\n      return Promise.all(loadingPromises).then(function () { return Array.from(ngModules.values()); });\n  }\n\n  var StylesCollectionEntry = (function () {\n      function StylesCollectionEntry(time, value) {\n          this.time = time;\n          this.value = value;\n      }\n      StylesCollectionEntry.prototype.matches = function (time, value) {\n          return time == this.time && value == this.value;\n      };\n      return StylesCollectionEntry;\n  }());\n  var StylesCollection = (function () {\n      function StylesCollection() {\n          this.styles = {};\n      }\n      StylesCollection.prototype.insertAtTime = function (property, time, value) {\n          var tuple = new StylesCollectionEntry(time, value);\n          var entries = this.styles[property];\n          if (!isPresent(entries)) {\n              entries = this.styles[property] = [];\n          }\n          // insert this at the right stop in the array\n          // this way we can keep it sorted\n          var insertionIndex = 0;\n          for (var i = entries.length - 1; i >= 0; i--) {\n              if (entries[i].time <= time) {\n                  insertionIndex = i + 1;\n                  break;\n              }\n          }\n          entries.splice(insertionIndex, 0, tuple);\n      };\n      StylesCollection.prototype.getByIndex = function (property, index) {\n          var items = this.styles[property];\n          if (isPresent(items)) {\n              return index >= items.length ? null : items[index];\n          }\n          return null;\n      };\n      StylesCollection.prototype.indexOfAtOrBeforeTime = function (property, time) {\n          var entries = this.styles[property];\n          if (isPresent(entries)) {\n              for (var i = entries.length - 1; i >= 0; i--) {\n                  if (entries[i].time <= time)\n                      return i;\n              }\n          }\n          return null;\n      };\n      return StylesCollection;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$16 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var _INITIAL_KEYFRAME = 0;\n  var _TERMINAL_KEYFRAME = 1;\n  var _ONE_SECOND = 1000;\n  var AnimationParseError = (function (_super) {\n      __extends$16(AnimationParseError, _super);\n      function AnimationParseError(message) {\n          _super.call(this, null, message);\n      }\n      AnimationParseError.prototype.toString = function () { return \"\" + this.msg; };\n      return AnimationParseError;\n  }(ParseError));\n  var AnimationEntryParseResult = (function () {\n      function AnimationEntryParseResult(ast, errors) {\n          this.ast = ast;\n          this.errors = errors;\n      }\n      return AnimationEntryParseResult;\n  }());\n  var AnimationParser = (function () {\n      function AnimationParser(_schema) {\n          this._schema = _schema;\n      }\n      AnimationParser.prototype.parseComponent = function (component) {\n          var _this = this;\n          var errors = [];\n          var componentName = component.type.name;\n          var animationTriggerNames = new Set();\n          var asts = component.template.animations.map(function (entry) {\n              var result = _this.parseEntry(entry);\n              var ast = result.ast;\n              var triggerName = ast.name;\n              if (animationTriggerNames.has(triggerName)) {\n                  result.errors.push(new AnimationParseError(\"The animation trigger \\\"\" + triggerName + \"\\\" has already been registered for the \" + componentName + \" component\"));\n              }\n              else {\n                  animationTriggerNames.add(triggerName);\n              }\n              if (result.errors.length > 0) {\n                  var errorMessage_1 = \"- Unable to parse the animation sequence for \\\"\" + triggerName + \"\\\" on the \" + componentName + \" component due to the following errors:\";\n                  result.errors.forEach(function (error) { errorMessage_1 += '\\n-- ' + error.msg; });\n                  errors.push(errorMessage_1);\n              }\n              return ast;\n          });\n          if (errors.length > 0) {\n              var errorString = errors.join('\\n');\n              throw new Error(\"Animation parse errors:\\n\" + errorString);\n          }\n          return asts;\n      };\n      AnimationParser.prototype.parseEntry = function (entry) {\n          var _this = this;\n          var errors = [];\n          var stateStyles = {};\n          var transitions = [];\n          var stateDeclarationAsts = [];\n          entry.definitions.forEach(function (def) {\n              if (def instanceof CompileAnimationStateDeclarationMetadata) {\n                  _parseAnimationDeclarationStates(def, _this._schema, errors).forEach(function (ast) {\n                      stateDeclarationAsts.push(ast);\n                      stateStyles[ast.stateName] = ast.styles;\n                  });\n              }\n              else {\n                  transitions.push(def);\n              }\n          });\n          var stateTransitionAsts = transitions.map(function (transDef) { return _parseAnimationStateTransition(transDef, stateStyles, _this._schema, errors); });\n          var ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);\n          return new AnimationEntryParseResult(ast, errors);\n      };\n      AnimationParser.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      AnimationParser.ctorParameters = [\n          { type: ElementSchemaRegistry, },\n      ];\n      return AnimationParser;\n  }());\n  function _parseAnimationDeclarationStates(stateMetadata, schema, errors) {\n      var normalizedStyles = _normalizeStyleMetadata(stateMetadata.styles, {}, schema, errors, false);\n      var defStyles = new AnimationStylesAst(normalizedStyles);\n      var states = stateMetadata.stateNameExpr.split(/\\s*,\\s*/);\n      return states.map(function (state) { return new AnimationStateDeclarationAst(state, defStyles); });\n  }\n  function _parseAnimationStateTransition(transitionStateMetadata, stateStyles, schema, errors) {\n      var styles = new StylesCollection();\n      var transitionExprs = [];\n      var transitionStates = transitionStateMetadata.stateChangeExpr.split(/\\s*,\\s*/);\n      transitionStates.forEach(function (expr) { transitionExprs.push.apply(transitionExprs, _parseAnimationTransitionExpr(expr, errors)); });\n      var entry = _normalizeAnimationEntry(transitionStateMetadata.steps);\n      var animation = _normalizeStyleSteps(entry, stateStyles, schema, errors);\n      var animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);\n      if (errors.length == 0) {\n          _fillAnimationAstStartingKeyframes(animationAst, styles, errors);\n      }\n      var stepsAst = (animationAst instanceof AnimationWithStepsAst) ?\n          animationAst :\n          new AnimationSequenceAst([animationAst]);\n      return new AnimationStateTransitionAst(transitionExprs, stepsAst);\n  }\n  function _parseAnimationAlias(alias, errors) {\n      switch (alias) {\n          case ':enter':\n              return 'void => *';\n          case ':leave':\n              return '* => void';\n          default:\n              errors.push(new AnimationParseError(\"the transition alias value \\\"\" + alias + \"\\\" is not supported\"));\n              return '* => *';\n      }\n  }\n  function _parseAnimationTransitionExpr(eventStr, errors) {\n      var expressions = [];\n      if (eventStr[0] == ':') {\n          eventStr = _parseAnimationAlias(eventStr, errors);\n      }\n      var match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n      if (!isPresent(match) || match.length < 4) {\n          errors.push(new AnimationParseError(\"the provided \" + eventStr + \" is not of a supported format\"));\n          return expressions;\n      }\n      var fromState = match[1];\n      var separator = match[2];\n      var toState = match[3];\n      expressions.push(new AnimationStateTransitionExpression(fromState, toState));\n      var isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n      if (separator[0] == '<' && !isFullAnyStateExpr) {\n          expressions.push(new AnimationStateTransitionExpression(toState, fromState));\n      }\n      return expressions;\n  }\n  function _normalizeAnimationEntry(entry) {\n      return Array.isArray(entry) ? new CompileAnimationSequenceMetadata(entry) : entry;\n  }\n  function _normalizeStyleMetadata(entry, stateStyles, schema, errors, permitStateReferences) {\n      var normalizedStyles = [];\n      entry.styles.forEach(function (styleEntry) {\n          if (typeof styleEntry === 'string') {\n              if (permitStateReferences) {\n                  normalizedStyles.push.apply(normalizedStyles, _resolveStylesFromState(styleEntry, stateStyles, errors));\n              }\n              else {\n                  errors.push(new AnimationParseError(\"State based animations cannot contain references to other states\"));\n              }\n          }\n          else {\n              var stylesObj_1 = styleEntry;\n              var normalizedStylesObj_1 = {};\n              Object.keys(stylesObj_1).forEach(function (propName) {\n                  var normalizedProp = schema.normalizeAnimationStyleProperty(propName);\n                  var normalizedOutput = schema.normalizeAnimationStyleValue(normalizedProp, propName, stylesObj_1[propName]);\n                  var normalizationError = normalizedOutput['error'];\n                  if (normalizationError) {\n                      errors.push(new AnimationParseError(normalizationError));\n                  }\n                  normalizedStylesObj_1[normalizedProp] = normalizedOutput['value'];\n              });\n              normalizedStyles.push(normalizedStylesObj_1);\n          }\n      });\n      return normalizedStyles;\n  }\n  function _normalizeStyleSteps(entry, stateStyles, schema, errors) {\n      var steps = _normalizeStyleStepEntry(entry, stateStyles, schema, errors);\n      return (entry instanceof CompileAnimationGroupMetadata) ?\n          new CompileAnimationGroupMetadata(steps) :\n          new CompileAnimationSequenceMetadata(steps);\n  }\n  function _mergeAnimationStyles(stylesList, newItem) {\n      if (typeof newItem === 'object' && newItem !== null && stylesList.length > 0) {\n          var lastIndex = stylesList.length - 1;\n          var lastItem = stylesList[lastIndex];\n          if (typeof lastItem === 'object' && lastItem !== null) {\n              stylesList[lastIndex] = StringMapWrapper.merge(lastItem, newItem);\n              return;\n          }\n      }\n      stylesList.push(newItem);\n  }\n  function _normalizeStyleStepEntry(entry, stateStyles, schema, errors) {\n      var steps;\n      if (entry instanceof CompileAnimationWithStepsMetadata) {\n          steps = entry.steps;\n      }\n      else {\n          return [entry];\n      }\n      var newSteps = [];\n      var combinedStyles;\n      steps.forEach(function (step) {\n          if (step instanceof CompileAnimationStyleMetadata) {\n              // this occurs when a style step is followed by a previous style step\n              // or when the first style step is run. We want to concatenate all subsequent\n              // style steps together into a single style step such that we have the correct\n              // starting keyframe data to pass into the animation player.\n              if (!isPresent(combinedStyles)) {\n                  combinedStyles = [];\n              }\n              _normalizeStyleMetadata(step, stateStyles, schema, errors, true)\n                  .forEach(function (entry) { _mergeAnimationStyles(combinedStyles, entry); });\n          }\n          else {\n              // it is important that we create a metadata entry of the combined styles\n              // before we go on an process the animate, sequence or group metadata steps.\n              // This will ensure that the AST will have the previous styles painted on\n              // screen before any further animations that use the styles take place.\n              if (isPresent(combinedStyles)) {\n                  newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));\n                  combinedStyles = null;\n              }\n              if (step instanceof CompileAnimationAnimateMetadata) {\n                  // we do not recurse into CompileAnimationAnimateMetadata since\n                  // those style steps are not going to be squashed\n                  var animateStyleValue = step.styles;\n                  if (animateStyleValue instanceof CompileAnimationStyleMetadata) {\n                      animateStyleValue.styles =\n                          _normalizeStyleMetadata(animateStyleValue, stateStyles, schema, errors, true);\n                  }\n                  else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {\n                      animateStyleValue.steps.forEach(function (step) {\n                          step.styles = _normalizeStyleMetadata(step, stateStyles, schema, errors, true);\n                      });\n                  }\n              }\n              else if (step instanceof CompileAnimationWithStepsMetadata) {\n                  var innerSteps = _normalizeStyleStepEntry(step, stateStyles, schema, errors);\n                  step = step instanceof CompileAnimationGroupMetadata ?\n                      new CompileAnimationGroupMetadata(innerSteps) :\n                      new CompileAnimationSequenceMetadata(innerSteps);\n              }\n              newSteps.push(step);\n          }\n      });\n      // this happens when only styles were animated within the sequence\n      if (isPresent(combinedStyles)) {\n          newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));\n      }\n      return newSteps;\n  }\n  function _resolveStylesFromState(stateName, stateStyles, errors) {\n      var styles = [];\n      if (stateName[0] != ':') {\n          errors.push(new AnimationParseError(\"Animation states via styles must be prefixed with a \\\":\\\"\"));\n      }\n      else {\n          var normalizedStateName = stateName.substring(1);\n          var value = stateStyles[normalizedStateName];\n          if (!isPresent(value)) {\n              errors.push(new AnimationParseError(\"Unable to apply styles due to missing a state: \\\"\" + normalizedStateName + \"\\\"\"));\n          }\n          else {\n              value.styles.forEach(function (stylesEntry) {\n                  if (typeof stylesEntry === 'object' && stylesEntry !== null) {\n                      styles.push(stylesEntry);\n                  }\n              });\n          }\n      }\n      return styles;\n  }\n  var _AnimationTimings = (function () {\n      function _AnimationTimings(duration, delay, easing) {\n          this.duration = duration;\n          this.delay = delay;\n          this.easing = easing;\n      }\n      return _AnimationTimings;\n  }());\n  function _parseAnimationKeyframes(keyframeSequence, currentTime, collectedStyles, stateStyles, errors) {\n      var totalEntries = keyframeSequence.steps.length;\n      var totalOffsets = 0;\n      keyframeSequence.steps.forEach(function (step) { return totalOffsets += (isPresent(step.offset) ? 1 : 0); });\n      if (totalOffsets > 0 && totalOffsets < totalEntries) {\n          errors.push(new AnimationParseError(\"Not all style() entries contain an offset for the provided keyframe()\"));\n          totalOffsets = totalEntries;\n      }\n      var limit = totalEntries - 1;\n      var margin = totalOffsets == 0 ? (1 / limit) : 0;\n      var rawKeyframes = [];\n      var index = 0;\n      var doSortKeyframes = false;\n      var lastOffset = 0;\n      keyframeSequence.steps.forEach(function (styleMetadata) {\n          var offset = styleMetadata.offset;\n          var keyframeStyles = {};\n          styleMetadata.styles.forEach(function (entry) {\n              Object.keys(entry).forEach(function (prop) {\n                  if (prop != 'offset') {\n                      keyframeStyles[prop] = entry[prop];\n                  }\n              });\n          });\n          if (isPresent(offset)) {\n              doSortKeyframes = doSortKeyframes || (offset < lastOffset);\n          }\n          else {\n              offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);\n          }\n          rawKeyframes.push([offset, keyframeStyles]);\n          lastOffset = offset;\n          index++;\n      });\n      if (doSortKeyframes) {\n          rawKeyframes.sort(function (a, b) { return a[0] <= b[0] ? -1 : 1; });\n      }\n      var firstKeyframe = rawKeyframes[0];\n      if (firstKeyframe[0] != _INITIAL_KEYFRAME) {\n          rawKeyframes.splice(0, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);\n      }\n      var firstKeyframeStyles = firstKeyframe[1];\n      limit = rawKeyframes.length - 1;\n      var lastKeyframe = rawKeyframes[limit];\n      if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {\n          rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);\n          limit++;\n      }\n      var lastKeyframeStyles = lastKeyframe[1];\n      for (var i = 1; i <= limit; i++) {\n          var entry = rawKeyframes[i];\n          var styles = entry[1];\n          Object.keys(styles).forEach(function (prop) {\n              if (!isPresent(firstKeyframeStyles[prop])) {\n                  firstKeyframeStyles[prop] = FILL_STYLE_FLAG;\n              }\n          });\n      }\n      var _loop_1 = function(i) {\n          var entry = rawKeyframes[i];\n          var styles = entry[1];\n          Object.keys(styles).forEach(function (prop) {\n              if (!isPresent(lastKeyframeStyles[prop])) {\n                  lastKeyframeStyles[prop] = styles[prop];\n              }\n          });\n      };\n      for (var i = limit - 1; i >= 0; i--) {\n          _loop_1(i);\n      }\n      return rawKeyframes.map(function (entry) { return new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]])); });\n  }\n  function _parseTransitionAnimation(entry, currentTime, collectedStyles, stateStyles, errors) {\n      var ast;\n      var playTime = 0;\n      var startingTime = currentTime;\n      if (entry instanceof CompileAnimationWithStepsMetadata) {\n          var maxDuration_1 = 0;\n          var steps_1 = [];\n          var isGroup_1 = entry instanceof CompileAnimationGroupMetadata;\n          var previousStyles_1;\n          entry.steps.forEach(function (entry) {\n              // these will get picked up by the next step...\n              var time = isGroup_1 ? startingTime : currentTime;\n              if (entry instanceof CompileAnimationStyleMetadata) {\n                  entry.styles.forEach(function (stylesEntry) {\n                      // by this point we know that we only have stringmap values\n                      var map = stylesEntry;\n                      Object.keys(map).forEach(function (prop) { collectedStyles.insertAtTime(prop, time, map[prop]); });\n                  });\n                  previousStyles_1 = entry.styles;\n                  return;\n              }\n              var innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);\n              if (isPresent(previousStyles_1)) {\n                  if (entry instanceof CompileAnimationWithStepsMetadata) {\n                      var startingStyles = new AnimationStylesAst(previousStyles_1);\n                      steps_1.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));\n                  }\n                  else {\n                      var innerStep = innerAst;\n                      (_a = innerStep.startingStyles.styles).push.apply(_a, previousStyles_1);\n                  }\n                  previousStyles_1 = null;\n              }\n              var astDuration = innerAst.playTime;\n              currentTime += astDuration;\n              playTime += astDuration;\n              maxDuration_1 = Math.max(astDuration, maxDuration_1);\n              steps_1.push(innerAst);\n              var _a;\n          });\n          if (isPresent(previousStyles_1)) {\n              var startingStyles = new AnimationStylesAst(previousStyles_1);\n              steps_1.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));\n          }\n          if (isGroup_1) {\n              ast = new AnimationGroupAst(steps_1);\n              playTime = maxDuration_1;\n              currentTime = startingTime + playTime;\n          }\n          else {\n              ast = new AnimationSequenceAst(steps_1);\n          }\n      }\n      else if (entry instanceof CompileAnimationAnimateMetadata) {\n          var timings = _parseTimeExpression(entry.timings, errors);\n          var styles = entry.styles;\n          var keyframes = void 0;\n          if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {\n              keyframes =\n                  _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);\n          }\n          else {\n              var styleData = styles;\n              var offset = _TERMINAL_KEYFRAME;\n              var styleAst = new AnimationStylesAst(styleData.styles);\n              var keyframe = new AnimationKeyframeAst(offset, styleAst);\n              keyframes = [keyframe];\n          }\n          ast = new AnimationStepAst(new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);\n          playTime = timings.duration + timings.delay;\n          currentTime += playTime;\n          keyframes.forEach(function (keyframe /** TODO #9100 */) { return keyframe.styles.styles.forEach(function (entry /** TODO #9100 */) { return Object.keys(entry).forEach(function (prop) { collectedStyles.insertAtTime(prop, currentTime, entry[prop]); }); }); });\n      }\n      else {\n          // if the code reaches this stage then an error\n          // has already been populated within the _normalizeStyleSteps()\n          // operation...\n          ast = new AnimationStepAst(null, [], 0, 0, '');\n      }\n      ast.playTime = playTime;\n      ast.startTime = startingTime;\n      return ast;\n  }\n  function _fillAnimationAstStartingKeyframes(ast, collectedStyles, errors) {\n      // steps that only contain style will not be filled\n      if ((ast instanceof AnimationStepAst) && ast.keyframes.length > 0) {\n          var keyframes = ast.keyframes;\n          if (keyframes.length == 1) {\n              var endKeyframe = keyframes[0];\n              var startKeyframe = _createStartKeyframeFromEndKeyframe(endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);\n              ast.keyframes = [startKeyframe, endKeyframe];\n          }\n      }\n      else if (ast instanceof AnimationWithStepsAst) {\n          ast.steps.forEach(function (entry) { return _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors); });\n      }\n  }\n  function _parseTimeExpression(exp, errors) {\n      var regex = /^([\\.\\d]+)(m?s)(?:\\s+([\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?/i;\n      var duration;\n      var delay = 0;\n      var easing = null;\n      if (typeof exp === 'string') {\n          var matches = exp.match(regex);\n          if (matches === null) {\n              errors.push(new AnimationParseError(\"The provided timing value \\\"\" + exp + \"\\\" is invalid.\"));\n              return new _AnimationTimings(0, 0, null);\n          }\n          var durationMatch = parseFloat(matches[1]);\n          var durationUnit = matches[2];\n          if (durationUnit == 's') {\n              durationMatch *= _ONE_SECOND;\n          }\n          duration = Math.floor(durationMatch);\n          var delayMatch = matches[3];\n          var delayUnit = matches[4];\n          if (isPresent(delayMatch)) {\n              var delayVal = parseFloat(delayMatch);\n              if (isPresent(delayUnit) && delayUnit == 's') {\n                  delayVal *= _ONE_SECOND;\n              }\n              delay = Math.floor(delayVal);\n          }\n          var easingVal = matches[5];\n          if (!isBlank(easingVal)) {\n              easing = easingVal;\n          }\n      }\n      else {\n          duration = exp;\n      }\n      return new _AnimationTimings(duration, delay, easing);\n  }\n  function _createStartKeyframeFromEndKeyframe(endKeyframe, startTime, duration, collectedStyles, errors) {\n      var values = {};\n      var endTime = startTime + duration;\n      endKeyframe.styles.styles.forEach(function (styleData) {\n          Object.keys(styleData).forEach(function (prop) {\n              var val = styleData[prop];\n              if (prop == 'offset')\n                  return;\n              var resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);\n              var resultEntry /** TODO #9100 */, nextEntry /** TODO #9100 */, value;\n              if (isPresent(resultIndex)) {\n                  resultEntry = collectedStyles.getByIndex(prop, resultIndex);\n                  value = resultEntry.value;\n                  nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);\n              }\n              else {\n                  // this is a flag that the runtime code uses to pass\n                  // in a value either from the state declaration styles\n                  // or using the AUTO_STYLE value (e.g. getComputedStyle)\n                  value = FILL_STYLE_FLAG;\n              }\n              if (isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {\n                  errors.push(new AnimationParseError(\"The animated CSS property \\\"\" + prop + \"\\\" unexpectedly changes between steps \\\"\" + resultEntry.time + \"ms\\\" and \\\"\" + endTime + \"ms\\\" at \\\"\" + nextEntry.time + \"ms\\\"\"));\n              }\n              values[prop] = value;\n          });\n      });\n      return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   * An interface for retrieving documents by URL that the compiler uses\n   * to load templates.\n   */\n  var ResourceLoader = (function () {\n      function ResourceLoader() {\n      }\n      ResourceLoader.prototype.get = function (url) { return null; };\n      return ResourceLoader;\n  }());\n\n  var _ASSET_SCHEME = 'asset:';\n  /**\n   * Create a {@link UrlResolver} with no package prefix.\n   */\n  function createUrlResolverWithoutPackagePrefix() {\n      return new UrlResolver();\n  }\n  function createOfflineCompileUrlResolver() {\n      return new UrlResolver(_ASSET_SCHEME);\n  }\n  /**\n   * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.\n   */\n  var DEFAULT_PACKAGE_URL_PROVIDER = {\n      provide: _angular_core.PACKAGE_ROOT_URL,\n      useValue: '/'\n  };\n  /**\n   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.\n   *\n   * This class can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}\n   *\n   * ## Example\n   *\n   * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}\n   *\n   * @security  When compiling templates at runtime, you must\n   * ensure that the entire template comes from a trusted source.\n   * Attacker-controlled data introduced by a template could expose your\n   * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n   */\n  var UrlResolver = (function () {\n      function UrlResolver(_packagePrefix) {\n          if (_packagePrefix === void 0) { _packagePrefix = null; }\n          this._packagePrefix = _packagePrefix;\n      }\n      /**\n       * Resolves the `url` given the `baseUrl`:\n       * - when the `url` is null, the `baseUrl` is returned,\n       * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n       * `baseUrl` and `url`,\n       * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n       * returned as is (ignoring the `baseUrl`)\n       */\n      UrlResolver.prototype.resolve = function (baseUrl, url) {\n          var resolvedUrl = url;\n          if (isPresent(baseUrl) && baseUrl.length > 0) {\n              resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n          }\n          var resolvedParts = _split(resolvedUrl);\n          var prefix = this._packagePrefix;\n          if (isPresent(prefix) && isPresent(resolvedParts) &&\n              resolvedParts[_ComponentIndex.Scheme] == 'package') {\n              var path = resolvedParts[_ComponentIndex.Path];\n              if (this._packagePrefix === _ASSET_SCHEME) {\n                  var pathSegements = path.split(/\\//);\n                  resolvedUrl = \"asset:\" + pathSegements[0] + \"/lib/\" + pathSegements.slice(1).join('/');\n              }\n              else {\n                  prefix = prefix.replace(/\\/+$/, '');\n                  path = path.replace(/^\\/+/, '');\n                  return prefix + \"/\" + path;\n              }\n          }\n          return resolvedUrl;\n      };\n      UrlResolver.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      UrlResolver.ctorParameters = [\n          { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PACKAGE_ROOT_URL,] },] },\n      ];\n      return UrlResolver;\n  }());\n  /**\n   * Extract the scheme of a URL.\n   */\n  function getUrlScheme(url) {\n      var match = _split(url);\n      return (match && match[_ComponentIndex.Scheme]) || '';\n  }\n  // The code below is adapted from Traceur:\n  // https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\n  /**\n   * Builds a URI string from already-encoded parts.\n   *\n   * No encoding is performed.  Any component may be omitted as either null or\n   * undefined.\n   *\n   * @param opt_scheme The scheme such as 'http'.\n   * @param opt_userInfo The user name before the '@'.\n   * @param opt_domain The domain such as 'www.google.com', already\n   *     URI-encoded.\n   * @param opt_port The port number.\n   * @param opt_path The path, already URI-encoded.  If it is not\n   *     empty, it must begin with a slash.\n   * @param opt_queryData The URI-encoded query data.\n   * @param opt_fragment The URI-encoded fragment identifier.\n   * @return The fully combined URI.\n   */\n  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n      var out = [];\n      if (isPresent(opt_scheme)) {\n          out.push(opt_scheme + ':');\n      }\n      if (isPresent(opt_domain)) {\n          out.push('//');\n          if (isPresent(opt_userInfo)) {\n              out.push(opt_userInfo + '@');\n          }\n          out.push(opt_domain);\n          if (isPresent(opt_port)) {\n              out.push(':' + opt_port);\n          }\n      }\n      if (isPresent(opt_path)) {\n          out.push(opt_path);\n      }\n      if (isPresent(opt_queryData)) {\n          out.push('?' + opt_queryData);\n      }\n      if (isPresent(opt_fragment)) {\n          out.push('#' + opt_fragment);\n      }\n      return out.join('');\n  }\n  /**\n   * A regular expression for breaking a URI into its component parts.\n   *\n   * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n   * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n   * disambiguation method used by POSIX regular expressions, it is natural and\n   * commonplace to use a regular expression for parsing the potential five\n   * components of a URI reference.\n   *\n   * The following line is the regular expression for breaking-down a\n   * well-formed URI reference into its components.\n   *\n   * <pre>\n   * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n   *  12            3  4          5       6  7        8 9\n   * </pre>\n   *\n   * The numbers in the second line above are only to assist readability; they\n   * indicate the reference points for each subexpression (i.e., each paired\n   * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n   * For example, matching the above expression to\n   * <pre>\n   *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n   * </pre>\n   * results in the following subexpression matches:\n   * <pre>\n   *    $1 = http:\n   *    $2 = http\n   *    $3 = //www.ics.uci.edu\n   *    $4 = www.ics.uci.edu\n   *    $5 = /pub/ietf/uri/\n   *    $6 = <undefined>\n   *    $7 = <undefined>\n   *    $8 = #Related\n   *    $9 = Related\n   * </pre>\n   * where <undefined> indicates that the component is not present, as is the\n   * case for the query component in the above example. Therefore, we can\n   * determine the value of the five components as\n   * <pre>\n   *    scheme    = $2\n   *    authority = $4\n   *    path      = $5\n   *    query     = $7\n   *    fragment  = $9\n   * </pre>\n   *\n   * The regular expression has been modified slightly to expose the\n   * userInfo, domain, and port separately from the authority.\n   * The modified version yields\n   * <pre>\n   *    $1 = http              scheme\n   *    $2 = <undefined>       userInfo -\\\n   *    $3 = www.ics.uci.edu   domain     | authority\n   *    $4 = <undefined>       port     -/\n   *    $5 = /pub/ietf/uri/    path\n   *    $6 = <undefined>       query without ?\n   *    $7 = Related           fragment without #\n   * </pre>\n   * @type {!RegExp}\n   * @internal\n   */\n  var _splitRe = new RegExp('^' +\n      '(?:' +\n      '([^:/?#.]+)' +\n      // used by other URL parts such as :,\n      // ?, /, #, and .\n      ':)?' +\n      '(?://' +\n      '(?:([^/?#]*)@)?' +\n      '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +\n      // digits, dashes, dots, percent\n      // escapes, and unicode characters.\n      '(?::([0-9]+))?' +\n      ')?' +\n      '([^?#]+)?' +\n      '(?:\\\\?([^#]*))?' +\n      '(?:#(.*))?' +\n      '$');\n  /**\n   * The index of each URI component in the return value of goog.uri.utils.split.\n   * @enum {number}\n   */\n  var _ComponentIndex;\n  (function (_ComponentIndex) {\n      _ComponentIndex[_ComponentIndex[\"Scheme\"] = 1] = \"Scheme\";\n      _ComponentIndex[_ComponentIndex[\"UserInfo\"] = 2] = \"UserInfo\";\n      _ComponentIndex[_ComponentIndex[\"Domain\"] = 3] = \"Domain\";\n      _ComponentIndex[_ComponentIndex[\"Port\"] = 4] = \"Port\";\n      _ComponentIndex[_ComponentIndex[\"Path\"] = 5] = \"Path\";\n      _ComponentIndex[_ComponentIndex[\"QueryData\"] = 6] = \"QueryData\";\n      _ComponentIndex[_ComponentIndex[\"Fragment\"] = 7] = \"Fragment\";\n  })(_ComponentIndex || (_ComponentIndex = {}));\n  /**\n   * Splits a URI into its component parts.\n   *\n   * Each component can be accessed via the component indices; for example:\n   * <pre>\n   * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n   * </pre>\n   *\n   * @param uri The URI string to examine.\n   * @return Each component still URI-encoded.\n   *     Each component that is present will contain the encoded value, whereas\n   *     components that are not present will be undefined or empty, depending\n   *     on the browser's regular expression implementation.  Never null, since\n   *     arbitrary strings may still look like path names.\n   */\n  function _split(uri) {\n      return uri.match(_splitRe);\n  }\n  /**\n    * Removes dot segments in given path component, as described in\n    * RFC 3986, section 5.2.4.\n    *\n    * @param path A non-empty path component.\n    * @return Path component with removed dot segments.\n    */\n  function _removeDotSegments(path) {\n      if (path == '/')\n          return '/';\n      var leadingSlash = path[0] == '/' ? '/' : '';\n      var trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n      var segments = path.split('/');\n      var out = [];\n      var up = 0;\n      for (var pos = 0; pos < segments.length; pos++) {\n          var segment = segments[pos];\n          switch (segment) {\n              case '':\n              case '.':\n                  break;\n              case '..':\n                  if (out.length > 0) {\n                      out.pop();\n                  }\n                  else {\n                      up++;\n                  }\n                  break;\n              default:\n                  out.push(segment);\n          }\n      }\n      if (leadingSlash == '') {\n          while (up-- > 0) {\n              out.unshift('..');\n          }\n          if (out.length === 0)\n              out.push('.');\n      }\n      return leadingSlash + out.join('/') + trailingSlash;\n  }\n  /**\n   * Takes an array of the parts from split and canonicalizes the path part\n   * and then joins all the parts.\n   */\n  function _joinAndCanonicalizePath(parts) {\n      var path = parts[_ComponentIndex.Path];\n      path = isBlank(path) ? '' : _removeDotSegments(path);\n      parts[_ComponentIndex.Path] = path;\n      return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n  }\n  /**\n   * Resolves a URL.\n   * @param base The URL acting as the base URL.\n   * @param to The URL to resolve.\n   */\n  function _resolveUrl(base, url) {\n      var parts = _split(encodeURI(url));\n      var baseParts = _split(base);\n      if (isPresent(parts[_ComponentIndex.Scheme])) {\n          return _joinAndCanonicalizePath(parts);\n      }\n      else {\n          parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n      }\n      for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n          if (isBlank(parts[i])) {\n              parts[i] = baseParts[i];\n          }\n      }\n      if (parts[_ComponentIndex.Path][0] == '/') {\n          return _joinAndCanonicalizePath(parts);\n      }\n      var path = baseParts[_ComponentIndex.Path];\n      if (isBlank(path))\n          path = '/';\n      var index = path.lastIndexOf('/');\n      path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n      parts[_ComponentIndex.Path] = path;\n      return _joinAndCanonicalizePath(parts);\n  }\n\n  var DirectiveNormalizer = (function () {\n      function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n          this._resourceLoader = _resourceLoader;\n          this._urlResolver = _urlResolver;\n          this._htmlParser = _htmlParser;\n          this._config = _config;\n          this._resourceLoaderCache = new Map();\n      }\n      DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };\n      DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {\n          var _this = this;\n          if (!normalizedDirective.isComponent) {\n              return;\n          }\n          this._resourceLoaderCache.delete(normalizedDirective.template.templateUrl);\n          normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });\n      };\n      DirectiveNormalizer.prototype._fetch = function (url) {\n          var result = this._resourceLoaderCache.get(url);\n          if (!result) {\n              result = this._resourceLoader.get(url);\n              this._resourceLoaderCache.set(url, result);\n          }\n          return result;\n      };\n      DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {\n          var _this = this;\n          var normalizedTemplateSync = null;\n          var normalizedTemplateAsync;\n          if (isPresent(prenormData.template)) {\n              normalizedTemplateSync = this.normalizeTemplateSync(prenormData);\n              normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);\n          }\n          else if (prenormData.templateUrl) {\n              normalizedTemplateAsync = this.normalizeTemplateAsync(prenormData);\n          }\n          else {\n              throw new Error(\"No template specified for component \" + stringify(prenormData.componentType));\n          }\n          if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {\n              // sync case\n              return new SyncAsyncResult(normalizedTemplateSync);\n          }\n          else {\n              // async case\n              return new SyncAsyncResult(null, normalizedTemplateAsync.then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); }));\n          }\n      };\n      DirectiveNormalizer.prototype.normalizeTemplateSync = function (prenomData) {\n          return this.normalizeLoadedTemplate(prenomData, prenomData.template, prenomData.moduleUrl);\n      };\n      DirectiveNormalizer.prototype.normalizeTemplateAsync = function (prenomData) {\n          var _this = this;\n          var templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);\n          return this._fetch(templateUrl)\n              .then(function (value) { return _this.normalizeLoadedTemplate(prenomData, value, templateUrl); });\n      };\n      DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (prenomData, template, templateAbsUrl) {\n          var interpolationConfig = InterpolationConfig.fromArray(prenomData.interpolation);\n          var rootNodesAndErrors = this._htmlParser.parse(template, stringify(prenomData.componentType), false, interpolationConfig);\n          if (rootNodesAndErrors.errors.length > 0) {\n              var errorString = rootNodesAndErrors.errors.join('\\n');\n              throw new Error(\"Template parse errors:\\n\" + errorString);\n          }\n          var templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({\n              styles: prenomData.styles,\n              styleUrls: prenomData.styleUrls,\n              moduleUrl: prenomData.moduleUrl\n          }));\n          var visitor = new TemplatePreparseVisitor();\n          visitAll(visitor, rootNodesAndErrors.rootNodes);\n          var templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n          var encapsulation = prenomData.encapsulation;\n          if (isBlank(encapsulation)) {\n              encapsulation = this._config.defaultEncapsulation;\n          }\n          var styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n          var styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n          if (encapsulation === _angular_core.ViewEncapsulation.Emulated && styles.length === 0 &&\n              styleUrls.length === 0) {\n              encapsulation = _angular_core.ViewEncapsulation.None;\n          }\n          return new CompileTemplateMetadata({\n              encapsulation: encapsulation,\n              template: template,\n              templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,\n              ngContentSelectors: visitor.ngContentSelectors,\n              animations: prenomData.animations,\n              interpolation: prenomData.interpolation,\n          });\n      };\n      DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {\n          return this._loadMissingExternalStylesheets(templateMeta.styleUrls)\n              .then(function (externalStylesheets) { return new CompileTemplateMetadata({\n              encapsulation: templateMeta.encapsulation,\n              template: templateMeta.template,\n              templateUrl: templateMeta.templateUrl,\n              styles: templateMeta.styles,\n              styleUrls: templateMeta.styleUrls,\n              externalStylesheets: externalStylesheets,\n              ngContentSelectors: templateMeta.ngContentSelectors,\n              animations: templateMeta.animations,\n              interpolation: templateMeta.interpolation\n          }); });\n      };\n      DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {\n          var _this = this;\n          if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }\n          return Promise\n              .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })\n              .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {\n              var stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n              loadedStylesheets.set(styleUrl, stylesheet);\n              return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n          }); }))\n              .then(function (_) { return Array.from(loadedStylesheets.values()); });\n      };\n      DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {\n          var _this = this;\n          var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n              .map(function (url) { return _this._urlResolver.resolve(stylesheet.moduleUrl, url); });\n          var allStyles = stylesheet.styles.map(function (style) {\n              var styleWithImports = extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style);\n              allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);\n              return styleWithImports.style;\n          });\n          return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });\n      };\n      DirectiveNormalizer.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      DirectiveNormalizer.ctorParameters = [\n          { type: ResourceLoader, },\n          { type: UrlResolver, },\n          { type: HtmlParser, },\n          { type: CompilerConfig, },\n      ];\n      return DirectiveNormalizer;\n  }());\n  var TemplatePreparseVisitor = (function () {\n      function TemplatePreparseVisitor() {\n          this.ngContentSelectors = [];\n          this.styles = [];\n          this.styleUrls = [];\n          this.ngNonBindableStackCount = 0;\n      }\n      TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\n          var preparsedElement = preparseElement(ast);\n          switch (preparsedElement.type) {\n              case PreparsedElementType.NG_CONTENT:\n                  if (this.ngNonBindableStackCount === 0) {\n                      this.ngContentSelectors.push(preparsedElement.selectAttr);\n                  }\n                  break;\n              case PreparsedElementType.STYLE:\n                  var textContent_1 = '';\n                  ast.children.forEach(function (child) {\n                      if (child instanceof Text) {\n                          textContent_1 += child.value;\n                      }\n                  });\n                  this.styles.push(textContent_1);\n                  break;\n              case PreparsedElementType.STYLESHEET:\n                  this.styleUrls.push(preparsedElement.hrefAttr);\n                  break;\n              default:\n                  break;\n          }\n          if (preparsedElement.nonBindable) {\n              this.ngNonBindableStackCount++;\n          }\n          visitAll(this, ast.children);\n          if (preparsedElement.nonBindable) {\n              this.ngNonBindableStackCount--;\n          }\n          return null;\n      };\n      TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };\n      TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };\n      TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };\n      TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { return null; };\n      TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) { return null; };\n      return TemplatePreparseVisitor;\n  }());\n\n  /*\n   * Resolve a `Type` for {@link Directive}.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}\n   */\n  var DirectiveResolver = (function () {\n      function DirectiveResolver(_reflector) {\n          if (_reflector === void 0) { _reflector = reflector; }\n          this._reflector = _reflector;\n      }\n      DirectiveResolver.prototype.isDirective = function (type) {\n          var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));\n          return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n      };\n      /**\n       * Return {@link Directive} for a given `Type`.\n       */\n      DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n          if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n          var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));\n          if (typeMetadata) {\n              var metadata = typeMetadata.find(isDirectiveMetadata);\n              if (metadata) {\n                  var propertyMetadata = this._reflector.propMetadata(type);\n                  return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n              }\n          }\n          if (throwIfNotFound) {\n              throw new Error(\"No Directive annotation found on \" + stringify(type));\n          }\n          return null;\n      };\n      DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {\n          var inputs = [];\n          var outputs = [];\n          var host = {};\n          var queries = {};\n          Object.keys(propertyMetadata).forEach(function (propName) {\n              propertyMetadata[propName].forEach(function (a) {\n                  if (a instanceof _angular_core.Input) {\n                      if (a.bindingPropertyName) {\n                          inputs.push(propName + \": \" + a.bindingPropertyName);\n                      }\n                      else {\n                          inputs.push(propName);\n                      }\n                  }\n                  else if (a instanceof _angular_core.Output) {\n                      var output = a;\n                      if (output.bindingPropertyName) {\n                          outputs.push(propName + \": \" + output.bindingPropertyName);\n                      }\n                      else {\n                          outputs.push(propName);\n                      }\n                  }\n                  else if (a instanceof _angular_core.HostBinding) {\n                      var hostBinding = a;\n                      if (hostBinding.hostPropertyName) {\n                          var startWith = hostBinding.hostPropertyName[0];\n                          if (startWith === '(') {\n                              throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n                          }\n                          else if (startWith === '[') {\n                              throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n                          }\n                          host[(\"[\" + hostBinding.hostPropertyName + \"]\")] = propName;\n                      }\n                      else {\n                          host[(\"[\" + propName + \"]\")] = propName;\n                      }\n                  }\n                  else if (a instanceof _angular_core.HostListener) {\n                      var hostListener = a;\n                      var args = hostListener.args || [];\n                      host[(\"(\" + hostListener.eventName + \")\")] = propName + \"(\" + args.join(',') + \")\";\n                  }\n                  else if (a instanceof _angular_core.Query) {\n                      queries[propName] = a;\n                  }\n              });\n          });\n          return this._merge(dm, inputs, outputs, host, queries, directiveType);\n      };\n      DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };\n      DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {\n          var _this = this;\n          var mergedInputs = inputs;\n          if (directive.inputs) {\n              var inputNames_1 = directive.inputs.map(function (def) { return _this._extractPublicName(def); });\n              inputs.forEach(function (inputDef) {\n                  var publicName = _this._extractPublicName(inputDef);\n                  if (inputNames_1.indexOf(publicName) > -1) {\n                      throw new Error(\"Input '\" + publicName + \"' defined multiple times in '\" + stringify(directiveType) + \"'\");\n                  }\n              });\n              mergedInputs.unshift.apply(mergedInputs, directive.inputs);\n          }\n          var mergedOutputs = outputs;\n          if (directive.outputs) {\n              var outputNames_1 = directive.outputs.map(function (def) { return _this._extractPublicName(def); });\n              outputs.forEach(function (outputDef) {\n                  var publicName = _this._extractPublicName(outputDef);\n                  if (outputNames_1.indexOf(publicName) > -1) {\n                      throw new Error(\"Output event '\" + publicName + \"' defined multiple times in '\" + stringify(directiveType) + \"'\");\n                  }\n              });\n              mergedOutputs.unshift.apply(mergedOutputs, directive.outputs);\n          }\n          var mergedHost = directive.host ? StringMapWrapper.merge(directive.host, host) : host;\n          var mergedQueries = directive.queries ? StringMapWrapper.merge(directive.queries, queries) : queries;\n          if (directive instanceof _angular_core.Component) {\n              return new _angular_core.Component({\n                  selector: directive.selector,\n                  inputs: mergedInputs,\n                  outputs: mergedOutputs,\n                  host: mergedHost,\n                  exportAs: directive.exportAs,\n                  moduleId: directive.moduleId,\n                  queries: mergedQueries,\n                  changeDetection: directive.changeDetection,\n                  providers: directive.providers,\n                  viewProviders: directive.viewProviders,\n                  entryComponents: directive.entryComponents,\n                  template: directive.template,\n                  templateUrl: directive.templateUrl,\n                  styles: directive.styles,\n                  styleUrls: directive.styleUrls,\n                  encapsulation: directive.encapsulation,\n                  animations: directive.animations,\n                  interpolation: directive.interpolation\n              });\n          }\n          else {\n              return new _angular_core.Directive({\n                  selector: directive.selector,\n                  inputs: mergedInputs,\n                  outputs: mergedOutputs,\n                  host: mergedHost,\n                  exportAs: directive.exportAs,\n                  queries: mergedQueries,\n                  providers: directive.providers\n              });\n          }\n      };\n      DirectiveResolver.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      DirectiveResolver.ctorParameters = [\n          { type: ReflectorReader, },\n      ];\n      return DirectiveResolver;\n  }());\n  function isDirectiveMetadata(type) {\n      return type instanceof _angular_core.Directive;\n  }\n\n  function hasLifecycleHook(hook, token) {\n      return reflector.hasLifecycleHook(token, getHookName(hook));\n  }\n  function getHookName(hook) {\n      switch (hook) {\n          case LifecycleHooks.OnInit:\n              return 'ngOnInit';\n          case LifecycleHooks.OnDestroy:\n              return 'ngOnDestroy';\n          case LifecycleHooks.DoCheck:\n              return 'ngDoCheck';\n          case LifecycleHooks.OnChanges:\n              return 'ngOnChanges';\n          case LifecycleHooks.AfterContentInit:\n              return 'ngAfterContentInit';\n          case LifecycleHooks.AfterContentChecked:\n              return 'ngAfterContentChecked';\n          case LifecycleHooks.AfterViewInit:\n              return 'ngAfterViewInit';\n          case LifecycleHooks.AfterViewChecked:\n              return 'ngAfterViewChecked';\n      }\n  }\n\n  function _isNgModuleMetadata(obj) {\n      return obj instanceof _angular_core.NgModule;\n  }\n  /**\n   * Resolves types to {@link NgModule}.\n   */\n  var NgModuleResolver = (function () {\n      function NgModuleResolver(_reflector) {\n          if (_reflector === void 0) { _reflector = reflector; }\n          this._reflector = _reflector;\n      }\n      NgModuleResolver.prototype.isNgModule = function (type) { return this._reflector.annotations(type).some(_isNgModuleMetadata); };\n      NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {\n          if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n          var ngModuleMeta = this._reflector.annotations(type).find(_isNgModuleMetadata);\n          if (isPresent(ngModuleMeta)) {\n              return ngModuleMeta;\n          }\n          else {\n              if (throwIfNotFound) {\n                  throw new Error(\"No NgModule metadata found for '\" + stringify(type) + \"'.\");\n              }\n              return null;\n          }\n      };\n      NgModuleResolver.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      NgModuleResolver.ctorParameters = [\n          { type: ReflectorReader, },\n      ];\n      return NgModuleResolver;\n  }());\n\n  function _isPipeMetadata(type) {\n      return type instanceof _angular_core.Pipe;\n  }\n  /**\n   * Resolve a `Type` for {@link Pipe}.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}\n   */\n  var PipeResolver = (function () {\n      function PipeResolver(_reflector) {\n          if (_reflector === void 0) { _reflector = reflector; }\n          this._reflector = _reflector;\n      }\n      PipeResolver.prototype.isPipe = function (type) {\n          var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));\n          return typeMetadata && typeMetadata.some(_isPipeMetadata);\n      };\n      /**\n       * Return {@link Pipe} for a given `Type`.\n       */\n      PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n          if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n          var metas = this._reflector.annotations(_angular_core.resolveForwardRef(type));\n          if (isPresent(metas)) {\n              var annotation = metas.find(_isPipeMetadata);\n              if (isPresent(annotation)) {\n                  return annotation;\n              }\n          }\n          if (throwIfNotFound) {\n              throw new Error(\"No Pipe decorator found on \" + stringify(type));\n          }\n          return null;\n      };\n      PipeResolver.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      PipeResolver.ctorParameters = [\n          { type: ReflectorReader, },\n      ];\n      return PipeResolver;\n  }());\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$17 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  // Design notes:\n  // - don't lazily create metadata:\n  //   For some metadata, we need to do async work sometimes,\n  //   so the user has to kick off this loading.\n  //   But we want to report errors even when the async work is\n  //   not required to check that the user would have been able\n  //   to wait correctly.\n  var CompileMetadataResolver = (function () {\n      function CompileMetadataResolver(_ngModuleResolver, _directiveResolver, _pipeResolver, _schemaRegistry, _directiveNormalizer, _reflector) {\n          if (_reflector === void 0) { _reflector = reflector; }\n          this._ngModuleResolver = _ngModuleResolver;\n          this._directiveResolver = _directiveResolver;\n          this._pipeResolver = _pipeResolver;\n          this._schemaRegistry = _schemaRegistry;\n          this._directiveNormalizer = _directiveNormalizer;\n          this._reflector = _reflector;\n          this._directiveCache = new Map();\n          this._directiveSummaryCache = new Map();\n          this._pipeCache = new Map();\n          this._pipeSummaryCache = new Map();\n          this._ngModuleCache = new Map();\n          this._ngModuleOfTypes = new Map();\n          this._anonymousTypes = new Map();\n          this._anonymousTypeIndex = 0;\n      }\n      CompileMetadataResolver.prototype.sanitizeTokenName = function (token) {\n          var identifier = stringify(token);\n          if (identifier.indexOf('(') >= 0) {\n              // case: anonymous functions!\n              var found = this._anonymousTypes.get(token);\n              if (!found) {\n                  this._anonymousTypes.set(token, this._anonymousTypeIndex++);\n                  found = this._anonymousTypes.get(token);\n              }\n              identifier = \"anonymous_token_\" + found + \"_\";\n          }\n          return sanitizeIdentifier(identifier);\n      };\n      CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n          var dirMeta = this._directiveCache.get(type);\n          this._directiveCache.delete(type);\n          this._directiveSummaryCache.delete(type);\n          this._pipeCache.delete(type);\n          this._pipeSummaryCache.delete(type);\n          this._ngModuleOfTypes.delete(type);\n          // Clear all of the NgModule as they contain transitive information!\n          this._ngModuleCache.clear();\n          if (dirMeta) {\n              this._directiveNormalizer.clearCacheFor(dirMeta);\n          }\n      };\n      CompileMetadataResolver.prototype.clearCache = function () {\n          this._directiveCache.clear();\n          this._directiveSummaryCache.clear();\n          this._pipeCache.clear();\n          this._pipeSummaryCache.clear();\n          this._ngModuleCache.clear();\n          this._ngModuleOfTypes.clear();\n          this._directiveNormalizer.clearCache();\n      };\n      CompileMetadataResolver.prototype.getAnimationEntryMetadata = function (entry) {\n          var _this = this;\n          var defs = entry.definitions.map(function (def) { return _this._getAnimationStateMetadata(def); });\n          return new CompileAnimationEntryMetadata(entry.name, defs);\n      };\n      CompileMetadataResolver.prototype._getAnimationStateMetadata = function (value) {\n          if (value instanceof _angular_core.AnimationStateDeclarationMetadata) {\n              var styles = this._getAnimationStyleMetadata(value.styles);\n              return new CompileAnimationStateDeclarationMetadata(value.stateNameExpr, styles);\n          }\n          if (value instanceof _angular_core.AnimationStateTransitionMetadata) {\n              return new CompileAnimationStateTransitionMetadata(value.stateChangeExpr, this._getAnimationMetadata(value.steps));\n          }\n          return null;\n      };\n      CompileMetadataResolver.prototype._getAnimationStyleMetadata = function (value) {\n          return new CompileAnimationStyleMetadata(value.offset, value.styles);\n      };\n      CompileMetadataResolver.prototype._getAnimationMetadata = function (value) {\n          var _this = this;\n          if (value instanceof _angular_core.AnimationStyleMetadata) {\n              return this._getAnimationStyleMetadata(value);\n          }\n          if (value instanceof _angular_core.AnimationKeyframesSequenceMetadata) {\n              return new CompileAnimationKeyframesSequenceMetadata(value.steps.map(function (entry) { return _this._getAnimationStyleMetadata(entry); }));\n          }\n          if (value instanceof _angular_core.AnimationAnimateMetadata) {\n              var animateData = this\n                  ._getAnimationMetadata(value.styles);\n              return new CompileAnimationAnimateMetadata(value.timings, animateData);\n          }\n          if (value instanceof _angular_core.AnimationWithStepsMetadata) {\n              var steps = value.steps.map(function (step) { return _this._getAnimationMetadata(step); });\n              if (value instanceof _angular_core.AnimationGroupMetadata) {\n                  return new CompileAnimationGroupMetadata(steps);\n              }\n              return new CompileAnimationSequenceMetadata(steps);\n          }\n          return null;\n      };\n      CompileMetadataResolver.prototype._loadDirectiveMetadata = function (directiveType, isSync) {\n          var _this = this;\n          if (this._directiveCache.has(directiveType)) {\n              return;\n          }\n          directiveType = _angular_core.resolveForwardRef(directiveType);\n          var dirMeta = this._directiveResolver.resolve(directiveType);\n          if (!dirMeta) {\n              return null;\n          }\n          var moduleUrl = staticTypeModuleUrl(directiveType);\n          var createDirectiveMetadata = function (templateMeta) {\n              var changeDetectionStrategy = null;\n              var viewProviders = [];\n              var entryComponentMetadata = [];\n              var selector = dirMeta.selector;\n              if (dirMeta instanceof _angular_core.Component) {\n                  // Component\n                  changeDetectionStrategy = dirMeta.changeDetection;\n                  if (dirMeta.viewProviders) {\n                      viewProviders = _this._getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringify(directiveType) + \"\\\"\");\n                  }\n                  if (dirMeta.entryComponents) {\n                      entryComponentMetadata =\n                          flattenAndDedupeArray(dirMeta.entryComponents)\n                              .map(function (type) { return _this._getIdentifierMetadata(type, staticTypeModuleUrl(type)); })\n                              .concat(entryComponentMetadata);\n                  }\n                  if (!selector) {\n                      selector = _this._schemaRegistry.getDefaultComponentElementName();\n                  }\n              }\n              else {\n                  // Directive\n                  if (!selector) {\n                      throw new Error(\"Directive \" + stringify(directiveType) + \" has no selector, please add it!\");\n                  }\n              }\n              var providers = [];\n              if (isPresent(dirMeta.providers)) {\n                  providers = _this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringify(directiveType) + \"\\\"\");\n              }\n              var queries = [];\n              var viewQueries = [];\n              if (isPresent(dirMeta.queries)) {\n                  queries = _this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n                  viewQueries = _this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n              }\n              var meta = CompileDirectiveMetadata.create({\n                  selector: selector,\n                  exportAs: dirMeta.exportAs,\n                  isComponent: !!templateMeta,\n                  type: _this._getTypeMetadata(directiveType, moduleUrl),\n                  template: templateMeta,\n                  changeDetection: changeDetectionStrategy,\n                  inputs: dirMeta.inputs,\n                  outputs: dirMeta.outputs,\n                  host: dirMeta.host,\n                  providers: providers,\n                  viewProviders: viewProviders,\n                  queries: queries,\n                  viewQueries: viewQueries,\n                  entryComponents: entryComponentMetadata\n              });\n              _this._directiveCache.set(directiveType, meta);\n              _this._directiveSummaryCache.set(directiveType, meta.toSummary());\n              return meta;\n          };\n          if (dirMeta instanceof _angular_core.Component) {\n              // component\n              moduleUrl = componentModuleUrl(this._reflector, directiveType, dirMeta);\n              assertArrayOfStrings('styles', dirMeta.styles);\n              assertArrayOfStrings('styleUrls', dirMeta.styleUrls);\n              assertInterpolationSymbols('interpolation', dirMeta.interpolation);\n              var animations = dirMeta.animations ?\n                  dirMeta.animations.map(function (e) { return _this.getAnimationEntryMetadata(e); }) :\n                  null;\n              var templateMeta = this._directiveNormalizer.normalizeTemplate({\n                  componentType: directiveType,\n                  moduleUrl: moduleUrl,\n                  encapsulation: dirMeta.encapsulation,\n                  template: dirMeta.template,\n                  templateUrl: dirMeta.templateUrl,\n                  styles: dirMeta.styles,\n                  styleUrls: dirMeta.styleUrls,\n                  animations: animations,\n                  interpolation: dirMeta.interpolation\n              });\n              if (templateMeta.syncResult) {\n                  createDirectiveMetadata(templateMeta.syncResult);\n                  return null;\n              }\n              else {\n                  if (isSync) {\n                      throw new ComponentStillLoadingError(directiveType);\n                  }\n                  return templateMeta.asyncResult.then(createDirectiveMetadata);\n              }\n          }\n          else {\n              // directive\n              createDirectiveMetadata(null);\n              return null;\n          }\n      };\n      /**\n       * Gets the metadata for the given directive.\n       * This assumes `loadNgModuleMetadata` has been called first.\n       */\n      CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n          var dirMeta = this._directiveCache.get(directiveType);\n          if (!dirMeta) {\n              throw new Error(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleMetadata for a module that declares it. Directive \" + stringify(directiveType) + \".\");\n          }\n          return dirMeta;\n      };\n      CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n          var dirSummary = this._directiveSummaryCache.get(dirType);\n          if (!dirSummary) {\n              throw new Error(\"Illegal state: getDirectiveSummary can only be called after loadNgModuleMetadata for a module that imports it. Directive \" + stringify(dirType) + \".\");\n          }\n          return dirSummary;\n      };\n      CompileMetadataResolver.prototype.isDirective = function (type) { return this._directiveResolver.isDirective(type); };\n      CompileMetadataResolver.prototype.isPipe = function (type) { return this._pipeResolver.isPipe(type); };\n      /**\n       * Gets the metadata for the given module.\n       * This assumes `loadNgModuleMetadata` has been called first.\n       */\n      CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType) {\n          var modMeta = this._ngModuleCache.get(moduleType);\n          if (!modMeta) {\n              throw new Error(\"Illegal state: getNgModuleMetadata can only be called after loadNgModuleMetadata. Module \" + stringify(moduleType) + \".\");\n          }\n          return modMeta;\n      };\n      CompileMetadataResolver.prototype._loadNgModuleSummary = function (moduleType, isSync) {\n          // TODO(tbosch): add logic to read summary files!\n          // - needs to add directive / pipe summaries to this._directiveSummaryCache /\n          // this._pipeSummaryCache as well!\n          var moduleMeta = this._loadNgModuleMetadata(moduleType, isSync, false);\n          return moduleMeta ? moduleMeta.toSummary() : null;\n      };\n      /**\n       * Loads an NgModule and all of its directives. This includes loading the exported directives of\n       * imported modules,\n       * but not private directives of imported modules.\n       */\n      CompileMetadataResolver.prototype.loadNgModuleMetadata = function (moduleType, isSync, throwIfNotFound) {\n          if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n          var ngModule = this._loadNgModuleMetadata(moduleType, isSync, throwIfNotFound);\n          var loading = ngModule ? Promise.all(ngModule.transitiveModule.loadingPromises) : Promise.resolve(null);\n          return { ngModule: ngModule, loading: loading };\n      };\n      CompileMetadataResolver.prototype._loadNgModuleMetadata = function (moduleType, isSync, throwIfNotFound) {\n          var _this = this;\n          if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n          moduleType = _angular_core.resolveForwardRef(moduleType);\n          var compileMeta = this._ngModuleCache.get(moduleType);\n          if (compileMeta) {\n              return compileMeta;\n          }\n          var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n          if (!meta) {\n              return null;\n          }\n          var declaredDirectives = [];\n          var exportedNonModuleIdentifiers = [];\n          var declaredPipes = [];\n          var importedModules = [];\n          var exportedModules = [];\n          var providers = [];\n          var entryComponents = [];\n          var bootstrapComponents = [];\n          var schemas = [];\n          if (meta.imports) {\n              flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n                  var importedModuleType;\n                  if (isValidType(importedType)) {\n                      importedModuleType = importedType;\n                  }\n                  else if (importedType && importedType.ngModule) {\n                      var moduleWithProviders = importedType;\n                      importedModuleType = moduleWithProviders.ngModule;\n                      if (moduleWithProviders.providers) {\n                          providers.push.apply(providers, _this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringify(importedModuleType) + \"'\"));\n                      }\n                  }\n                  if (importedModuleType) {\n                      var importedModuleSummary = _this._loadNgModuleSummary(importedModuleType, isSync);\n                      if (!importedModuleSummary) {\n                          throw new Error(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringify(importedType) + \"' imported by the module '\" + stringify(moduleType) + \"'\");\n                      }\n                      importedModules.push(importedModuleSummary);\n                  }\n                  else {\n                      throw new Error(\"Unexpected value '\" + stringify(importedType) + \"' imported by the module '\" + stringify(moduleType) + \"'\");\n                  }\n              });\n          }\n          if (meta.exports) {\n              flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n                  if (!isValidType(exportedType)) {\n                      throw new Error(\"Unexpected value '\" + stringify(exportedType) + \"' exported by the module '\" + stringify(moduleType) + \"'\");\n                  }\n                  var exportedModuleSummary = _this._loadNgModuleSummary(exportedType, isSync);\n                  if (exportedModuleSummary) {\n                      exportedModules.push(exportedModuleSummary);\n                  }\n                  else {\n                      exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType, staticTypeModuleUrl(exportedType)));\n                  }\n              });\n          }\n          // Note: This will be modified later, so we rely on\n          // getting a new instance every time!\n          var transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n          if (meta.declarations) {\n              flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n                  if (!isValidType(declaredType)) {\n                      throw new Error(\"Unexpected value '\" + stringify(declaredType) + \"' declared by the module '\" + stringify(moduleType) + \"'\");\n                  }\n                  var declaredIdentifier = _this._getIdentifierMetadata(declaredType, staticTypeModuleUrl(declaredType));\n                  if (_this._directiveResolver.isDirective(declaredType)) {\n                      transitiveModule.directivesSet.add(declaredType);\n                      transitiveModule.directives.push(declaredIdentifier);\n                      declaredDirectives.push(declaredIdentifier);\n                      _this._addTypeToModule(declaredType, moduleType);\n                      var loadingPromise = _this._loadDirectiveMetadata(declaredType, isSync);\n                      if (loadingPromise) {\n                          transitiveModule.loadingPromises.push(loadingPromise);\n                      }\n                  }\n                  else if (_this._pipeResolver.isPipe(declaredType)) {\n                      transitiveModule.pipesSet.add(declaredType);\n                      transitiveModule.pipes.push(declaredIdentifier);\n                      declaredPipes.push(declaredIdentifier);\n                      _this._addTypeToModule(declaredType, moduleType);\n                      _this._loadPipeMetadata(declaredType);\n                  }\n                  else {\n                      throw new Error(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringify(declaredType) + \"' declared by the module '\" + stringify(moduleType) + \"'\");\n                  }\n              });\n          }\n          var exportedDirectives = [];\n          var exportedPipes = [];\n          exportedNonModuleIdentifiers.forEach(function (exportedId) {\n              if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                  exportedDirectives.push(exportedId);\n              }\n              else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                  exportedPipes.push(exportedId);\n              }\n              else {\n                  throw new Error(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringify(exportedId.reference) + \" from \" + stringify(moduleType) + \" as it was neither declared nor imported!\");\n              }\n          });\n          // The providers of the module have to go last\n          // so that they overwrite any other provider we already added.\n          if (meta.providers) {\n              providers.push.apply(providers, this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringify(moduleType) + \"'\"));\n          }\n          if (meta.entryComponents) {\n              entryComponents.push.apply(entryComponents, flattenAndDedupeArray(meta.entryComponents)\n                  .map(function (type) { return _this._getTypeMetadata(type, staticTypeModuleUrl(type)); }));\n          }\n          if (meta.bootstrap) {\n              var typeMetadata = flattenAndDedupeArray(meta.bootstrap).map(function (type) {\n                  if (!isValidType(type)) {\n                      throw new Error(\"Unexpected value '\" + stringify(type) + \"' used in the bootstrap property of module '\" + stringify(moduleType) + \"'\");\n                  }\n                  return _this._getTypeMetadata(type, staticTypeModuleUrl(type));\n              });\n              bootstrapComponents.push.apply(bootstrapComponents, typeMetadata);\n          }\n          entryComponents.push.apply(entryComponents, bootstrapComponents);\n          if (meta.schemas) {\n              schemas.push.apply(schemas, flattenAndDedupeArray(meta.schemas));\n          }\n          (_a = transitiveModule.entryComponents).push.apply(_a, entryComponents);\n          (_b = transitiveModule.providers).push.apply(_b, providers);\n          compileMeta = new CompileNgModuleMetadata({\n              type: this._getTypeMetadata(moduleType, staticTypeModuleUrl(moduleType)),\n              providers: providers,\n              entryComponents: entryComponents,\n              bootstrapComponents: bootstrapComponents,\n              schemas: schemas,\n              declaredDirectives: declaredDirectives,\n              exportedDirectives: exportedDirectives,\n              declaredPipes: declaredPipes,\n              exportedPipes: exportedPipes,\n              importedModules: importedModules,\n              exportedModules: exportedModules,\n              transitiveModule: transitiveModule,\n              id: meta.id,\n          });\n          transitiveModule.modules.push(compileMeta.toInjectorSummary());\n          this._ngModuleCache.set(moduleType, compileMeta);\n          return compileMeta;\n          var _a, _b;\n      };\n      CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n          if (this._directiveResolver.isDirective(type)) {\n              return 'directive';\n          }\n          if (this._pipeResolver.isPipe(type)) {\n              return 'pipe';\n          }\n          if (this._ngModuleResolver.isNgModule(type)) {\n              return 'module';\n          }\n          if (type.provide) {\n              return 'provider';\n          }\n          return 'value';\n      };\n      CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n          var oldModule = this._ngModuleOfTypes.get(type);\n          if (oldModule && oldModule !== moduleType) {\n              throw new Error((\"Type \" + stringify(type) + \" is part of the declarations of 2 modules: \" + stringify(oldModule) + \" and \" + stringify(moduleType) + \"! \") +\n                  (\"Please consider moving \" + stringify(type) + \" to a higher module that imports \" + stringify(oldModule) + \" and \" + stringify(moduleType) + \". \") +\n                  (\"You can also create a new NgModule that exports and includes \" + stringify(type) + \" then import that NgModule in \" + stringify(oldModule) + \" and \" + stringify(moduleType) + \".\"));\n          }\n          this._ngModuleOfTypes.set(type, moduleType);\n      };\n      CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n          // collect `providers` / `entryComponents` from all imported and all exported modules\n          var transitiveModules = getTransitiveImportedModules(importedModules.concat(exportedModules));\n          var providers = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.providers; }));\n          var entryComponents = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.entryComponents; }));\n          var transitiveExportedModules = getTransitiveExportedModules(importedModules);\n          var directives = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedDirectives; }));\n          var pipes = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedPipes; }));\n          var loadingPromises = ListWrapper.flatten(transitiveExportedModules.map(function (ngModule) { return ngModule.loadingPromises; }));\n          return new TransitiveCompileNgModuleMetadata(transitiveModules, providers, entryComponents, directives, pipes, loadingPromises);\n      };\n      CompileMetadataResolver.prototype._getIdentifierMetadata = function (type, moduleUrl) {\n          type = _angular_core.resolveForwardRef(type);\n          return new CompileIdentifierMetadata({ name: this.sanitizeTokenName(type), moduleUrl: moduleUrl, reference: type });\n      };\n      CompileMetadataResolver.prototype._getTypeMetadata = function (type, moduleUrl, dependencies) {\n          if (dependencies === void 0) { dependencies = null; }\n          var identifier = this._getIdentifierMetadata(type, moduleUrl);\n          return new CompileTypeMetadata({\n              name: identifier.name,\n              moduleUrl: identifier.moduleUrl,\n              reference: identifier.reference,\n              diDeps: this._getDependenciesMetadata(identifier.reference, dependencies),\n              lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(hook, identifier.reference); }),\n          });\n      };\n      CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, moduleUrl, dependencies) {\n          if (dependencies === void 0) { dependencies = null; }\n          factory = _angular_core.resolveForwardRef(factory);\n          return new CompileFactoryMetadata({\n              name: this.sanitizeTokenName(factory),\n              moduleUrl: moduleUrl,\n              reference: factory,\n              diDeps: this._getDependenciesMetadata(factory, dependencies)\n          });\n      };\n      /**\n       * Gets the metadata for the given pipe.\n       * This assumes `loadNgModuleMetadata` has been called first.\n       */\n      CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n          var pipeMeta = this._pipeCache.get(pipeType);\n          if (!pipeMeta) {\n              throw new Error(\"Illegal state: getPipeMetadata can only be called after loadNgModuleMetadata for a module that declares it. Pipe \" + stringify(pipeType) + \".\");\n          }\n          return pipeMeta;\n      };\n      CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n          var pipeSummary = this._pipeSummaryCache.get(pipeType);\n          if (!pipeSummary) {\n              throw new Error(\"Illegal state: getPipeSummary can only be called after loadNgModuleMetadata for a module that imports it. Pipe \" + stringify(pipeType) + \".\");\n          }\n          return pipeSummary;\n      };\n      CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n          pipeType = _angular_core.resolveForwardRef(pipeType);\n          var pipeMeta = this._pipeResolver.resolve(pipeType);\n          if (!pipeMeta) {\n              return null;\n          }\n          var meta = new CompilePipeMetadata({\n              type: this._getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),\n              name: pipeMeta.name,\n              pure: pipeMeta.pure\n          });\n          this._pipeCache.set(pipeType, meta);\n          this._pipeSummaryCache.set(pipeType, meta.toSummary());\n      };\n      CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies) {\n          var _this = this;\n          var hasUnknownDeps = false;\n          var params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n          var dependenciesMetadata = params.map(function (param) {\n              var isAttribute = false;\n              var isHost = false;\n              var isSelf = false;\n              var isSkipSelf = false;\n              var isOptional = false;\n              var token = null;\n              if (Array.isArray(param)) {\n                  param.forEach(function (paramEntry) {\n                      if (paramEntry instanceof _angular_core.Host) {\n                          isHost = true;\n                      }\n                      else if (paramEntry instanceof _angular_core.Self) {\n                          isSelf = true;\n                      }\n                      else if (paramEntry instanceof _angular_core.SkipSelf) {\n                          isSkipSelf = true;\n                      }\n                      else if (paramEntry instanceof _angular_core.Optional) {\n                          isOptional = true;\n                      }\n                      else if (paramEntry instanceof _angular_core.Attribute) {\n                          isAttribute = true;\n                          token = paramEntry.attributeName;\n                      }\n                      else if (paramEntry instanceof _angular_core.Inject) {\n                          token = paramEntry.token;\n                      }\n                      else if (isValidType(paramEntry) && isBlank(token)) {\n                          token = paramEntry;\n                      }\n                  });\n              }\n              else {\n                  token = param;\n              }\n              if (isBlank(token)) {\n                  hasUnknownDeps = true;\n                  return null;\n              }\n              return new CompileDiDependencyMetadata({\n                  isAttribute: isAttribute,\n                  isHost: isHost,\n                  isSelf: isSelf,\n                  isSkipSelf: isSkipSelf,\n                  isOptional: isOptional,\n                  token: _this._getTokenMetadata(token)\n              });\n          });\n          if (hasUnknownDeps) {\n              var depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringify(dep.token) : '?'; }).join(', ');\n              throw new Error(\"Can't resolve all parameters for \" + stringify(typeOrFunc) + \": (\" + depsTokens + \").\");\n          }\n          return dependenciesMetadata;\n      };\n      CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n          token = _angular_core.resolveForwardRef(token);\n          var compileToken;\n          if (typeof token === 'string') {\n              compileToken = new CompileTokenMetadata({ value: token });\n          }\n          else {\n              compileToken = new CompileTokenMetadata({\n                  identifier: new CompileIdentifierMetadata({\n                      reference: token,\n                      name: this.sanitizeTokenName(token),\n                      moduleUrl: staticTypeModuleUrl(token)\n                  })\n              });\n          }\n          return compileToken;\n      };\n      CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo) {\n          var _this = this;\n          var compileProviders = [];\n          providers.forEach(function (provider, providerIdx) {\n              provider = _angular_core.resolveForwardRef(provider);\n              if (provider && typeof provider == 'object' && provider.hasOwnProperty('provide')) {\n                  provider = new ProviderMeta(provider.provide, provider);\n              }\n              var compileProvider;\n              if (Array.isArray(provider)) {\n                  compileProvider = _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo);\n              }\n              else if (provider instanceof ProviderMeta) {\n                  var tokenMeta = _this._getTokenMetadata(provider.token);\n                  if (tokenMeta.reference ===\n                      resolveIdentifierToken(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS).reference) {\n                      targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(provider));\n                  }\n                  else {\n                      compileProvider = _this.getProviderMetadata(provider);\n                  }\n              }\n              else if (isValidType(provider)) {\n                  compileProvider = _this._getTypeMetadata(provider, staticTypeModuleUrl(provider));\n              }\n              else {\n                  var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n                      if (seenProviderIdx < providerIdx) {\n                          soFar.push(\"\" + stringify(seenProvider));\n                      }\n                      else if (seenProviderIdx == providerIdx) {\n                          soFar.push(\"?\" + stringify(seenProvider) + \"?\");\n                      }\n                      else if (seenProviderIdx == providerIdx + 1) {\n                          soFar.push('...');\n                      }\n                      return soFar;\n                  }, [])\n                      .join(', ');\n                  throw new Error(\"Invalid \" + (debugInfo ? debugInfo : 'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\");\n              }\n              if (compileProvider) {\n                  compileProviders.push(compileProvider);\n              }\n          });\n          return compileProviders;\n      };\n      CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider) {\n          var _this = this;\n          var components = [];\n          var collectedIdentifiers = [];\n          if (provider.useFactory || provider.useExisting || provider.useClass) {\n              throw new Error(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\");\n          }\n          if (!provider.multi) {\n              throw new Error(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\");\n          }\n          convertToCompileValue(provider.useValue, collectedIdentifiers);\n          collectedIdentifiers.forEach(function (identifier) {\n              if (_this._directiveResolver.isDirective(identifier.reference)) {\n                  components.push(identifier);\n              }\n          });\n          return components;\n      };\n      CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n          var compileDeps;\n          var compileTypeMetadata = null;\n          var compileFactoryMetadata = null;\n          if (provider.useClass) {\n              compileTypeMetadata = this._getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass), provider.dependencies);\n              compileDeps = compileTypeMetadata.diDeps;\n          }\n          else if (provider.useFactory) {\n              compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory), provider.dependencies);\n              compileDeps = compileFactoryMetadata.diDeps;\n          }\n          return new CompileProviderMetadata({\n              token: this._getTokenMetadata(provider.token),\n              useClass: compileTypeMetadata,\n              useValue: convertToCompileValue(provider.useValue, []),\n              useFactory: compileFactoryMetadata,\n              useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : null,\n              deps: compileDeps,\n              multi: provider.multi\n          });\n      };\n      CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n          var _this = this;\n          var res = [];\n          Object.keys(queries).forEach(function (propertyName) {\n              var query = queries[propertyName];\n              if (query.isViewQuery === isViewQuery) {\n                  res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n              }\n          });\n          return res;\n      };\n      CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\\s*,\\s*/); };\n      CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n          var _this = this;\n          var selectors;\n          if (typeof q.selector === 'string') {\n              selectors =\n                  this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });\n          }\n          else {\n              if (!q.selector) {\n                  throw new Error(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringify(typeOrFunc) + \"\\\" since the query selector wasn't defined.\");\n              }\n              selectors = [this._getTokenMetadata(q.selector)];\n          }\n          return new CompileQueryMetadata({\n              selectors: selectors,\n              first: q.first,\n              descendants: q.descendants, propertyName: propertyName,\n              read: q.read ? this._getTokenMetadata(q.read) : null\n          });\n      };\n      CompileMetadataResolver.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      CompileMetadataResolver.ctorParameters = [\n          { type: NgModuleResolver, },\n          { type: DirectiveResolver, },\n          { type: PipeResolver, },\n          { type: ElementSchemaRegistry, },\n          { type: DirectiveNormalizer, },\n          { type: ReflectorReader, },\n      ];\n      return CompileMetadataResolver;\n  }());\n  function getTransitiveExportedModules(modules, targetModules, visitedModules) {\n      if (targetModules === void 0) { targetModules = []; }\n      if (visitedModules === void 0) { visitedModules = new Set(); }\n      modules.forEach(function (ngModule) {\n          if (!visitedModules.has(ngModule.type.reference)) {\n              visitedModules.add(ngModule.type.reference);\n              getTransitiveExportedModules(ngModule.exportedModules, targetModules, visitedModules);\n              // Add after recursing so imported/exported modules are before the module itself.\n              // This is important for overwriting providers of imported modules!\n              targetModules.push(ngModule);\n          }\n      });\n      return targetModules;\n  }\n  function getTransitiveImportedModules(modules, targetModules, visitedModules) {\n      if (targetModules === void 0) { targetModules = []; }\n      if (visitedModules === void 0) { visitedModules = new Set(); }\n      modules.forEach(function (ngModule) {\n          if (!visitedModules.has(ngModule.type.reference)) {\n              visitedModules.add(ngModule.type.reference);\n              var nestedModules = ngModule.importedModules.concat(ngModule.exportedModules);\n              getTransitiveImportedModules(nestedModules, targetModules, visitedModules);\n              // Add after recursing so imported/exported modules are before the module itself.\n              // This is important for overwriting providers of imported modules!\n              targetModules.push(ngModule);\n          }\n      });\n      return targetModules;\n  }\n  function flattenArray(tree, out) {\n      if (out === void 0) { out = []; }\n      if (tree) {\n          for (var i = 0; i < tree.length; i++) {\n              var item = _angular_core.resolveForwardRef(tree[i]);\n              if (Array.isArray(item)) {\n                  flattenArray(item, out);\n              }\n              else {\n                  out.push(item);\n              }\n          }\n      }\n      return out;\n  }\n  function dedupeArray(array) {\n      if (array) {\n          return Array.from(new Set(array));\n      }\n      return [];\n  }\n  function flattenAndDedupeArray(tree) {\n      return dedupeArray(flattenArray(tree));\n  }\n  function isValidType(value) {\n      return isStaticSymbol(value) || (value instanceof _angular_core.Type);\n  }\n  function staticTypeModuleUrl(value) {\n      return isStaticSymbol(value) ? value.filePath : null;\n  }\n  function componentModuleUrl(reflector, type, cmpMetadata) {\n      if (isStaticSymbol(type)) {\n          return staticTypeModuleUrl(type);\n      }\n      var moduleId = cmpMetadata.moduleId;\n      if (typeof moduleId === 'string') {\n          var scheme = getUrlScheme(moduleId);\n          return scheme ? moduleId : \"package:\" + moduleId + MODULE_SUFFIX;\n      }\n      else if (moduleId !== null && moduleId !== void 0) {\n          throw new Error((\"moduleId should be a string in \\\"\" + stringify(type) + \"\\\". See https://goo.gl/wIDDiL for more information.\\n\") +\n              \"If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.\");\n      }\n      return reflector.importUri(type);\n  }\n  function convertToCompileValue(value, targetIdentifiers) {\n      return visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n  }\n  var _CompileValueConverter = (function (_super) {\n      __extends$17(_CompileValueConverter, _super);\n      function _CompileValueConverter() {\n          _super.apply(this, arguments);\n      }\n      _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n          var identifier;\n          if (isStaticSymbol(value)) {\n              identifier = new CompileIdentifierMetadata({ name: value.name, moduleUrl: value.filePath, reference: value });\n          }\n          else {\n              identifier = new CompileIdentifierMetadata({ reference: value });\n          }\n          targetIdentifiers.push(identifier);\n          return identifier;\n      };\n      return _CompileValueConverter;\n  }(ValueTransformer));\n\n  var ComponentFactoryDependency$1 = (function () {\n      function ComponentFactoryDependency(comp, placeholder) {\n          this.comp = comp;\n          this.placeholder = placeholder;\n      }\n      return ComponentFactoryDependency;\n  }());\n  var NgModuleCompileResult = (function () {\n      function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {\n          this.statements = statements;\n          this.ngModuleFactoryVar = ngModuleFactoryVar;\n          this.dependencies = dependencies;\n      }\n      return NgModuleCompileResult;\n  }());\n  var NgModuleCompiler = (function () {\n      function NgModuleCompiler() {\n      }\n      NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {\n          var sourceFileName = isPresent(ngModuleMeta.type.moduleUrl) ?\n              \"in NgModule \" + ngModuleMeta.type.name + \" in \" + ngModuleMeta.type.moduleUrl :\n              \"in NgModule \" + ngModuleMeta.type.name;\n          var sourceFile = new ParseSourceFile('', sourceFileName);\n          var sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));\n          var deps = [];\n          var bootstrapComponentFactories = [];\n          var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {\n              var id = new CompileIdentifierMetadata({ name: entryComponent.name });\n              if (ngModuleMeta.bootstrapComponents.indexOf(entryComponent) > -1) {\n                  bootstrapComponentFactories.push(id);\n              }\n              deps.push(new ComponentFactoryDependency$1(entryComponent, id));\n              return id;\n          });\n          var builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);\n          var providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);\n          providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });\n          var injectorClass = builder.build();\n          var ngModuleFactoryVar = ngModuleMeta.type.name + \"NgFactory\";\n          var ngModuleFactoryStmt = variable(ngModuleFactoryVar)\n              .set(importExpr(resolveIdentifier(Identifiers.NgModuleFactory))\n              .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(resolveIdentifier(Identifiers.NgModuleFactory), [importType(ngModuleMeta.type)], [TypeModifier.Const])))\n              .toDeclStmt(null, [StmtModifier.Final]);\n          var stmts = [injectorClass, ngModuleFactoryStmt];\n          if (ngModuleMeta.id) {\n              var registerFactoryStmt = importExpr(resolveIdentifier(Identifiers.RegisterModuleFactoryFn))\n                  .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])\n                  .toStmt();\n              stmts.push(registerFactoryStmt);\n          }\n          return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);\n      };\n      NgModuleCompiler.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      NgModuleCompiler.ctorParameters = [];\n      return NgModuleCompiler;\n  }());\n  var _InjectorBuilder = (function () {\n      function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {\n          this._ngModuleMeta = _ngModuleMeta;\n          this._entryComponentFactories = _entryComponentFactories;\n          this._bootstrapComponentFactories = _bootstrapComponentFactories;\n          this._sourceSpan = _sourceSpan;\n          this.fields = [];\n          this.getters = [];\n          this.methods = [];\n          this.ctorStmts = [];\n          this._tokens = [];\n          this._instances = new Map();\n          this._createStmts = [];\n          this._destroyStmts = [];\n      }\n      _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {\n          var _this = this;\n          var providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });\n          var propName = \"_\" + resolvedProvider.token.name + \"_\" + this._instances.size;\n          var instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);\n          if (resolvedProvider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {\n              this._destroyStmts.push(instance.callMethod('ngOnDestroy', []).toStmt());\n          }\n          this._tokens.push(resolvedProvider.token);\n          this._instances.set(resolvedProvider.token.reference, instance);\n      };\n      _InjectorBuilder.prototype.build = function () {\n          var _this = this;\n          var getMethodStmts = this._tokens.map(function (token) {\n              var providerExpr = _this._instances.get(token.reference);\n              return new IfStmt(InjectMethodVars$1.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);\n          });\n          var methods = [\n              new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(this._instances.get(this._ngModuleMeta.type.reference))), importType(this._ngModuleMeta.type)),\n              new ClassMethod('getInternal', [\n                  new FnParam(InjectMethodVars$1.token.name, DYNAMIC_TYPE),\n                  new FnParam(InjectMethodVars$1.notFoundResult.name, DYNAMIC_TYPE)\n              ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars$1.notFoundResult)]), DYNAMIC_TYPE),\n              new ClassMethod('destroyInternal', [], this._destroyStmts),\n          ];\n          var parentArgs = [\n              variable(InjectorProps.parent.name),\n              literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),\n              literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))\n          ];\n          var injClassName = this._ngModuleMeta.type.name + \"Injector\";\n          return createClassStmt({\n              name: injClassName,\n              ctorParams: [new FnParam(InjectorProps.parent.name, importType(resolveIdentifier(Identifiers.Injector)))],\n              parent: importExpr(resolveIdentifier(Identifiers.NgModuleInjector), [importType(this._ngModuleMeta.type)]),\n              parentArgs: parentArgs,\n              builders: [{ methods: methods }, this]\n          });\n      };\n      _InjectorBuilder.prototype._getProviderValue = function (provider) {\n          var _this = this;\n          var result;\n          if (isPresent(provider.useExisting)) {\n              result = this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }));\n          }\n          else if (isPresent(provider.useFactory)) {\n              var deps = provider.deps || provider.useFactory.diDeps;\n              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n              result = importExpr(provider.useFactory).callFn(depsExpr);\n          }\n          else if (isPresent(provider.useClass)) {\n              var deps = provider.deps || provider.useClass.diDeps;\n              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n              result =\n                  importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));\n          }\n          else {\n              result = convertValueToOutputAst(provider.useValue);\n          }\n          return result;\n      };\n      _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {\n          var resolvedProviderValueExpr;\n          var type;\n          if (isMulti) {\n              resolvedProviderValueExpr = literalArr(providerValueExpressions);\n              type = new ArrayType(DYNAMIC_TYPE);\n          }\n          else {\n              resolvedProviderValueExpr = providerValueExpressions[0];\n              type = providerValueExpressions[0].type;\n          }\n          if (!type) {\n              type = DYNAMIC_TYPE;\n          }\n          if (isEager) {\n              this.fields.push(new ClassField(propName, type));\n              this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());\n          }\n          else {\n              var internalField = \"_\" + propName;\n              this.fields.push(new ClassField(internalField, type));\n              // Note: Equals is important for JS so that it also checks the undefined case!\n              var getterStmts = [\n                  new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]),\n                  new ReturnStatement(THIS_EXPR.prop(internalField))\n              ];\n              this.getters.push(new ClassGetter(propName, getterStmts, type));\n          }\n          return THIS_EXPR.prop(propName);\n      };\n      _InjectorBuilder.prototype._getDependency = function (dep) {\n          var result = null;\n          if (dep.isValue) {\n              result = literal(dep.value);\n          }\n          if (!dep.isSkipSelf) {\n              if (dep.token &&\n                  (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||\n                      dep.token.reference ===\n                          resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference)) {\n                  result = THIS_EXPR;\n              }\n              if (!result) {\n                  result = this._instances.get(dep.token.reference);\n              }\n          }\n          if (!result) {\n              var args = [createDiTokenExpression(dep.token)];\n              if (dep.isOptional) {\n                  args.push(NULL_EXPR);\n              }\n              result = InjectorProps.parent.callMethod('get', args);\n          }\n          return result;\n      };\n      return _InjectorBuilder;\n  }());\n  var InjectorProps = (function () {\n      function InjectorProps() {\n      }\n      InjectorProps.parent = THIS_EXPR.prop('parent');\n      return InjectorProps;\n  }());\n  var InjectMethodVars$1 = (function () {\n      function InjectMethodVars() {\n      }\n      InjectMethodVars.token = variable('token');\n      InjectMethodVars.notFoundResult = variable('notFoundResult');\n      return InjectMethodVars;\n  }());\n\n  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\n  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\n  var CATCH_ERROR_VAR$2 = variable('error');\n  var CATCH_STACK_VAR$2 = variable('stack');\n  var _EmittedLine = (function () {\n      function _EmittedLine(indent) {\n          this.indent = indent;\n          this.parts = [];\n      }\n      return _EmittedLine;\n  }());\n  var EmitterVisitorContext = (function () {\n      function EmitterVisitorContext(_exportedVars, _indent) {\n          this._exportedVars = _exportedVars;\n          this._indent = _indent;\n          this._classes = [];\n          this._lines = [new _EmittedLine(_indent)];\n      }\n      EmitterVisitorContext.createRoot = function (exportedVars) {\n          return new EmitterVisitorContext(exportedVars, 0);\n      };\n      Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n          get: function () { return this._lines[this._lines.length - 1]; },\n          enumerable: true,\n          configurable: true\n      });\n      EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };\n      EmitterVisitorContext.prototype.println = function (lastPart) {\n          if (lastPart === void 0) { lastPart = ''; }\n          this.print(lastPart, true);\n      };\n      EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };\n      EmitterVisitorContext.prototype.print = function (part, newLine) {\n          if (newLine === void 0) { newLine = false; }\n          if (part.length > 0) {\n              this._currentLine.parts.push(part);\n          }\n          if (newLine) {\n              this._lines.push(new _EmittedLine(this._indent));\n          }\n      };\n      EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n          if (this.lineIsEmpty()) {\n              this._lines.pop();\n          }\n      };\n      EmitterVisitorContext.prototype.incIndent = function () {\n          this._indent++;\n          this._currentLine.indent = this._indent;\n      };\n      EmitterVisitorContext.prototype.decIndent = function () {\n          this._indent--;\n          this._currentLine.indent = this._indent;\n      };\n      EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };\n      EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };\n      Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n          get: function () {\n              return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n          },\n          enumerable: true,\n          configurable: true\n      });\n      EmitterVisitorContext.prototype.toSource = function () {\n          var lines = this._lines;\n          if (lines[lines.length - 1].parts.length === 0) {\n              lines = lines.slice(0, lines.length - 1);\n          }\n          return lines\n              .map(function (line) {\n              if (line.parts.length > 0) {\n                  return _createIndent(line.indent) + line.parts.join('');\n              }\n              else {\n                  return '';\n              }\n          })\n              .join('\\n');\n      };\n      return EmitterVisitorContext;\n  }());\n  var AbstractEmitterVisitor = (function () {\n      function AbstractEmitterVisitor(_escapeDollarInStrings) {\n          this._escapeDollarInStrings = _escapeDollarInStrings;\n      }\n      AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n          stmt.expr.visitExpression(this, ctx);\n          ctx.println(';');\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n          ctx.print(\"return \");\n          stmt.value.visitExpression(this, ctx);\n          ctx.println(';');\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n          ctx.print(\"if (\");\n          stmt.condition.visitExpression(this, ctx);\n          ctx.print(\") {\");\n          var hasElseCase = isPresent(stmt.falseCase) && stmt.falseCase.length > 0;\n          if (stmt.trueCase.length <= 1 && !hasElseCase) {\n              ctx.print(\" \");\n              this.visitAllStatements(stmt.trueCase, ctx);\n              ctx.removeEmptyLastLine();\n              ctx.print(\" \");\n          }\n          else {\n              ctx.println();\n              ctx.incIndent();\n              this.visitAllStatements(stmt.trueCase, ctx);\n              ctx.decIndent();\n              if (hasElseCase) {\n                  ctx.println(\"} else {\");\n                  ctx.incIndent();\n                  this.visitAllStatements(stmt.falseCase, ctx);\n                  ctx.decIndent();\n              }\n          }\n          ctx.println(\"}\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n          ctx.print(\"throw \");\n          stmt.error.visitExpression(this, ctx);\n          ctx.println(\";\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {\n          var lines = stmt.comment.split('\\n');\n          lines.forEach(function (line) { ctx.println(\"// \" + line); });\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n          var lineWasEmpty = ctx.lineIsEmpty();\n          if (!lineWasEmpty) {\n              ctx.print('(');\n          }\n          ctx.print(expr.name + \" = \");\n          expr.value.visitExpression(this, ctx);\n          if (!lineWasEmpty) {\n              ctx.print(')');\n          }\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n          var lineWasEmpty = ctx.lineIsEmpty();\n          if (!lineWasEmpty) {\n              ctx.print('(');\n          }\n          expr.receiver.visitExpression(this, ctx);\n          ctx.print(\"[\");\n          expr.index.visitExpression(this, ctx);\n          ctx.print(\"] = \");\n          expr.value.visitExpression(this, ctx);\n          if (!lineWasEmpty) {\n              ctx.print(')');\n          }\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n          var lineWasEmpty = ctx.lineIsEmpty();\n          if (!lineWasEmpty) {\n              ctx.print('(');\n          }\n          expr.receiver.visitExpression(this, ctx);\n          ctx.print(\".\" + expr.name + \" = \");\n          expr.value.visitExpression(this, ctx);\n          if (!lineWasEmpty) {\n              ctx.print(')');\n          }\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n          expr.receiver.visitExpression(this, ctx);\n          var name = expr.name;\n          if (isPresent(expr.builtin)) {\n              name = this.getBuiltinMethodName(expr.builtin);\n              if (isBlank(name)) {\n                  // some builtins just mean to skip the call.\n                  return null;\n              }\n          }\n          ctx.print(\".\" + name + \"(\");\n          this.visitAllExpressions(expr.args, ctx, \",\");\n          ctx.print(\")\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n          expr.fn.visitExpression(this, ctx);\n          ctx.print(\"(\");\n          this.visitAllExpressions(expr.args, ctx, ',');\n          ctx.print(\")\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n          var varName = ast.name;\n          if (isPresent(ast.builtin)) {\n              switch (ast.builtin) {\n                  case BuiltinVar.Super:\n                      varName = 'super';\n                      break;\n                  case BuiltinVar.This:\n                      varName = 'this';\n                      break;\n                  case BuiltinVar.CatchError:\n                      varName = CATCH_ERROR_VAR$2.name;\n                      break;\n                  case BuiltinVar.CatchStack:\n                      varName = CATCH_STACK_VAR$2.name;\n                      break;\n                  default:\n                      throw new Error(\"Unknown builtin variable \" + ast.builtin);\n              }\n          }\n          ctx.print(varName);\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n          ctx.print(\"new \");\n          ast.classExpr.visitExpression(this, ctx);\n          ctx.print(\"(\");\n          this.visitAllExpressions(ast.args, ctx, ',');\n          ctx.print(\")\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n          var value = ast.value;\n          if (typeof value === 'string') {\n              ctx.print(escapeIdentifier(value, this._escapeDollarInStrings));\n          }\n          else {\n              ctx.print(\"\" + value);\n          }\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n          ctx.print(\"(\");\n          ast.condition.visitExpression(this, ctx);\n          ctx.print('? ');\n          ast.trueCase.visitExpression(this, ctx);\n          ctx.print(': ');\n          ast.falseCase.visitExpression(this, ctx);\n          ctx.print(\")\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n          ctx.print('!');\n          ast.condition.visitExpression(this, ctx);\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n          var opStr;\n          switch (ast.operator) {\n              case BinaryOperator.Equals:\n                  opStr = '==';\n                  break;\n              case BinaryOperator.Identical:\n                  opStr = '===';\n                  break;\n              case BinaryOperator.NotEquals:\n                  opStr = '!=';\n                  break;\n              case BinaryOperator.NotIdentical:\n                  opStr = '!==';\n                  break;\n              case BinaryOperator.And:\n                  opStr = '&&';\n                  break;\n              case BinaryOperator.Or:\n                  opStr = '||';\n                  break;\n              case BinaryOperator.Plus:\n                  opStr = '+';\n                  break;\n              case BinaryOperator.Minus:\n                  opStr = '-';\n                  break;\n              case BinaryOperator.Divide:\n                  opStr = '/';\n                  break;\n              case BinaryOperator.Multiply:\n                  opStr = '*';\n                  break;\n              case BinaryOperator.Modulo:\n                  opStr = '%';\n                  break;\n              case BinaryOperator.Lower:\n                  opStr = '<';\n                  break;\n              case BinaryOperator.LowerEquals:\n                  opStr = '<=';\n                  break;\n              case BinaryOperator.Bigger:\n                  opStr = '>';\n                  break;\n              case BinaryOperator.BiggerEquals:\n                  opStr = '>=';\n                  break;\n              default:\n                  throw new Error(\"Unknown operator \" + ast.operator);\n          }\n          ctx.print(\"(\");\n          ast.lhs.visitExpression(this, ctx);\n          ctx.print(\" \" + opStr + \" \");\n          ast.rhs.visitExpression(this, ctx);\n          ctx.print(\")\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n          ast.receiver.visitExpression(this, ctx);\n          ctx.print(\".\");\n          ctx.print(ast.name);\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n          ast.receiver.visitExpression(this, ctx);\n          ctx.print(\"[\");\n          ast.index.visitExpression(this, ctx);\n          ctx.print(\"]\");\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n          var useNewLine = ast.entries.length > 1;\n          ctx.print(\"[\", useNewLine);\n          ctx.incIndent();\n          this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);\n          ctx.decIndent();\n          ctx.print(\"]\", useNewLine);\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n          var _this = this;\n          var useNewLine = ast.entries.length > 1;\n          ctx.print(\"{\", useNewLine);\n          ctx.incIndent();\n          this.visitAllObjects(function (entry) {\n              ctx.print(escapeIdentifier(entry[0], _this._escapeDollarInStrings, false) + \": \");\n              entry[1].visitExpression(_this, ctx);\n          }, ast.entries, ctx, ',', useNewLine);\n          ctx.decIndent();\n          ctx.print(\"}\", useNewLine);\n          return null;\n      };\n      AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {\n          var _this = this;\n          if (newLine === void 0) { newLine = false; }\n          this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);\n      };\n      AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {\n          if (newLine === void 0) { newLine = false; }\n          for (var i = 0; i < expressions.length; i++) {\n              if (i > 0) {\n                  ctx.print(separator, newLine);\n              }\n              handler(expressions[i]);\n          }\n          if (newLine) {\n              ctx.println();\n          }\n      };\n      AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n          var _this = this;\n          statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });\n      };\n      return AbstractEmitterVisitor;\n  }());\n  function escapeIdentifier(input, escapeDollar, alwaysQuote) {\n      if (alwaysQuote === void 0) { alwaysQuote = true; }\n      if (isBlank(input)) {\n          return null;\n      }\n      var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n          var match = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              match[_i - 0] = arguments[_i];\n          }\n          if (match[0] == '$') {\n              return escapeDollar ? '\\\\$' : '$';\n          }\n          else if (match[0] == '\\n') {\n              return '\\\\n';\n          }\n          else if (match[0] == '\\r') {\n              return '\\\\r';\n          }\n          else {\n              return \"\\\\\" + match[0];\n          }\n      });\n      var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n      return requiresQuotes ? \"'\" + body + \"'\" : body;\n  }\n  function _createIndent(count) {\n      var res = '';\n      for (var i = 0; i < count; i++) {\n          res += '  ';\n      }\n      return res;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$18 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var _debugModuleUrl = 'asset://debug/lib';\n  function debugOutputAstAsTypeScript(ast) {\n      var converter = new _TsEmitterVisitor(_debugModuleUrl);\n      var ctx = EmitterVisitorContext.createRoot([]);\n      var asts = Array.isArray(ast) ? ast : [ast];\n      asts.forEach(function (ast) {\n          if (ast instanceof Statement) {\n              ast.visitStatement(converter, ctx);\n          }\n          else if (ast instanceof Expression) {\n              ast.visitExpression(converter, ctx);\n          }\n          else if (ast instanceof Type$1) {\n              ast.visitType(converter, ctx);\n          }\n          else {\n              throw new Error(\"Don't know how to print debug info for \" + ast);\n          }\n      });\n      return ctx.toSource();\n  }\n  var TypeScriptEmitter = (function () {\n      function TypeScriptEmitter(_importGenerator) {\n          this._importGenerator = _importGenerator;\n      }\n      TypeScriptEmitter.prototype.emitStatements = function (moduleUrl, stmts, exportedVars) {\n          var _this = this;\n          var converter = new _TsEmitterVisitor(moduleUrl);\n          var ctx = EmitterVisitorContext.createRoot(exportedVars);\n          converter.visitAllStatements(stmts, ctx);\n          var srcParts = [];\n          converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {\n              // Note: can't write the real word for import as it screws up system.js auto detection...\n              srcParts.push(\"imp\" +\n                  (\"ort * as \" + prefix + \" from '\" + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + \"';\"));\n          });\n          srcParts.push(ctx.toSource());\n          return srcParts.join('\\n');\n      };\n      return TypeScriptEmitter;\n  }());\n  var _TsEmitterVisitor = (function (_super) {\n      __extends$18(_TsEmitterVisitor, _super);\n      function _TsEmitterVisitor(_moduleUrl) {\n          _super.call(this, false);\n          this._moduleUrl = _moduleUrl;\n          this.importsWithPrefixes = new Map();\n      }\n      _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n          if (defaultType === void 0) { defaultType = 'any'; }\n          if (isPresent(t)) {\n              t.visitType(this, ctx);\n          }\n          else {\n              ctx.print(defaultType);\n          }\n      };\n      _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n          var value = ast.value;\n          if (isBlank(value) && ast.type != NULL_TYPE) {\n              ctx.print(\"(\" + value + \" as any)\");\n              return null;\n          }\n          return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n      };\n      // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\n      // In SNC mode, [] have the type never[], so we cast here to any[].\n      // TODO: narrow the cast to a more explicit type, or use a pattern that does not\n      // start with [].concat. see https://github.com/angular/angular/pull/11846\n      _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n          if (ast.entries.length === 0) {\n              ctx.print('(');\n          }\n          var result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n          if (ast.entries.length === 0) {\n              ctx.print(' as any[])');\n          }\n          return result;\n      };\n      _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n          this._visitIdentifier(ast.value, ast.typeParams, ctx);\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n          if (ctx.isExportedVar(stmt.name)) {\n              ctx.print(\"export \");\n          }\n          if (stmt.hasModifier(StmtModifier.Final)) {\n              ctx.print(\"const\");\n          }\n          else {\n              ctx.print(\"var\");\n          }\n          ctx.print(\" \" + stmt.name + \":\");\n          this.visitType(stmt.type, ctx);\n          ctx.print(\" = \");\n          stmt.value.visitExpression(this, ctx);\n          ctx.println(\";\");\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n          ctx.print(\"(<\");\n          ast.type.visitType(this, ctx);\n          ctx.print(\">\");\n          ast.value.visitExpression(this, ctx);\n          ctx.print(\")\");\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n          var _this = this;\n          ctx.pushClass(stmt);\n          if (ctx.isExportedVar(stmt.name)) {\n              ctx.print(\"export \");\n          }\n          ctx.print(\"class \" + stmt.name);\n          if (isPresent(stmt.parent)) {\n              ctx.print(\" extends \");\n              stmt.parent.visitExpression(this, ctx);\n          }\n          ctx.println(\" {\");\n          ctx.incIndent();\n          stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });\n          if (isPresent(stmt.constructorMethod)) {\n              this._visitClassConstructor(stmt, ctx);\n          }\n          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });\n          stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });\n          ctx.decIndent();\n          ctx.println(\"}\");\n          ctx.popClass();\n          return null;\n      };\n      _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n          if (field.hasModifier(StmtModifier.Private)) {\n              // comment out as a workaround for #10967\n              ctx.print(\"/*private*/ \");\n          }\n          ctx.print(field.name);\n          ctx.print(':');\n          this.visitType(field.type, ctx);\n          ctx.println(\";\");\n      };\n      _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n          if (getter.hasModifier(StmtModifier.Private)) {\n              ctx.print(\"private \");\n          }\n          ctx.print(\"get \" + getter.name + \"()\");\n          ctx.print(':');\n          this.visitType(getter.type, ctx);\n          ctx.println(\" {\");\n          ctx.incIndent();\n          this.visitAllStatements(getter.body, ctx);\n          ctx.decIndent();\n          ctx.println(\"}\");\n      };\n      _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n          ctx.print(\"constructor(\");\n          this._visitParams(stmt.constructorMethod.params, ctx);\n          ctx.println(\") {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.constructorMethod.body, ctx);\n          ctx.decIndent();\n          ctx.println(\"}\");\n      };\n      _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n          if (method.hasModifier(StmtModifier.Private)) {\n              ctx.print(\"private \");\n          }\n          ctx.print(method.name + \"(\");\n          this._visitParams(method.params, ctx);\n          ctx.print(\"):\");\n          this.visitType(method.type, ctx, 'void');\n          ctx.println(\" {\");\n          ctx.incIndent();\n          this.visitAllStatements(method.body, ctx);\n          ctx.decIndent();\n          ctx.println(\"}\");\n      };\n      _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n          ctx.print(\"(\");\n          this._visitParams(ast.params, ctx);\n          ctx.print(\"):\");\n          this.visitType(ast.type, ctx, 'void');\n          ctx.println(\" => {\");\n          ctx.incIndent();\n          this.visitAllStatements(ast.statements, ctx);\n          ctx.decIndent();\n          ctx.print(\"}\");\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n          if (ctx.isExportedVar(stmt.name)) {\n              ctx.print(\"export \");\n          }\n          ctx.print(\"function \" + stmt.name + \"(\");\n          this._visitParams(stmt.params, ctx);\n          ctx.print(\"):\");\n          this.visitType(stmt.type, ctx, 'void');\n          ctx.println(\" {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.statements, ctx);\n          ctx.decIndent();\n          ctx.println(\"}\");\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n          ctx.println(\"try {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.bodyStmts, ctx);\n          ctx.decIndent();\n          ctx.println(\"} catch (\" + CATCH_ERROR_VAR$2.name + \") {\");\n          ctx.incIndent();\n          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [\n                  StmtModifier.Final\n              ])].concat(stmt.catchStmts);\n          this.visitAllStatements(catchStmts, ctx);\n          ctx.decIndent();\n          ctx.println(\"}\");\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {\n          var typeStr;\n          switch (type.name) {\n              case BuiltinTypeName.Bool:\n                  typeStr = 'boolean';\n                  break;\n              case BuiltinTypeName.Dynamic:\n                  typeStr = 'any';\n                  break;\n              case BuiltinTypeName.Function:\n                  typeStr = 'Function';\n                  break;\n              case BuiltinTypeName.Number:\n                  typeStr = 'number';\n                  break;\n              case BuiltinTypeName.Int:\n                  typeStr = 'number';\n                  break;\n              case BuiltinTypeName.String:\n                  typeStr = 'string';\n                  break;\n              default:\n                  throw new Error(\"Unsupported builtin type \" + type.name);\n          }\n          ctx.print(typeStr);\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitExternalType = function (ast, ctx) {\n          this._visitIdentifier(ast.value, ast.typeParams, ctx);\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n          this.visitType(type.of, ctx);\n          ctx.print(\"[]\");\n          return null;\n      };\n      _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n          ctx.print(\"{[key: string]:\");\n          this.visitType(type.valueType, ctx);\n          ctx.print(\"}\");\n          return null;\n      };\n      _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n          var name;\n          switch (method) {\n              case BuiltinMethod.ConcatArray:\n                  name = 'concat';\n                  break;\n              case BuiltinMethod.SubscribeObservable:\n                  name = 'subscribe';\n                  break;\n              case BuiltinMethod.Bind:\n                  name = 'bind';\n                  break;\n              default:\n                  throw new Error(\"Unknown builtin method: \" + method);\n          }\n          return name;\n      };\n      _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n          var _this = this;\n          this.visitAllObjects(function (param) {\n              ctx.print(param.name);\n              ctx.print(':');\n              _this.visitType(param.type, ctx);\n          }, params, ctx, ',');\n      };\n      _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n          var _this = this;\n          if (isBlank(value.name)) {\n              throw new Error(\"Internal error: unknown identifier \" + value);\n          }\n          if (isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {\n              var prefix = this.importsWithPrefixes.get(value.moduleUrl);\n              if (isBlank(prefix)) {\n                  prefix = \"import\" + this.importsWithPrefixes.size;\n                  this.importsWithPrefixes.set(value.moduleUrl, prefix);\n              }\n              ctx.print(prefix + \".\");\n          }\n          if (value.reference && value.reference.members) {\n              ctx.print(value.reference.name);\n              ctx.print('.');\n              ctx.print(value.reference.members.join('.'));\n          }\n          else {\n              ctx.print(value.name);\n          }\n          if (isPresent(typeParams) && typeParams.length > 0) {\n              ctx.print(\"<\");\n              this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');\n              ctx.print(\">\");\n          }\n      };\n      return _TsEmitterVisitor;\n  }(AbstractEmitterVisitor));\n\n  function interpretStatements(statements, resultVar) {\n      var stmtsWithReturn = statements.concat([new ReturnStatement(variable(resultVar))]);\n      var ctx = new _ExecutionContext(null, null, null, new Map());\n      var visitor = new StatementInterpreter();\n      var result = visitor.visitAllStatements(stmtsWithReturn, ctx);\n      return isPresent(result) ? result.value : null;\n  }\n  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n      var childCtx = ctx.createChildWihtLocalVars();\n      for (var i = 0; i < varNames.length; i++) {\n          childCtx.vars.set(varNames[i], varValues[i]);\n      }\n      var result = visitor.visitAllStatements(statements, childCtx);\n      return isPresent(result) ? result.value : null;\n  }\n  var _ExecutionContext = (function () {\n      function _ExecutionContext(parent, instance, className, vars) {\n          this.parent = parent;\n          this.instance = instance;\n          this.className = className;\n          this.vars = vars;\n      }\n      _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n          return new _ExecutionContext(this, this.instance, this.className, new Map());\n      };\n      return _ExecutionContext;\n  }());\n  var ReturnValue = (function () {\n      function ReturnValue(value) {\n          this.value = value;\n      }\n      return ReturnValue;\n  }());\n  function createDynamicClass(_classStmt, _ctx, _visitor) {\n      var propertyDescriptors = {};\n      _classStmt.getters.forEach(function (getter) {\n          // Note: use `function` instead of arrow function to capture `this`\n          propertyDescriptors[getter.name] = {\n              configurable: false,\n              get: function () {\n                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                  return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n              }\n          };\n      });\n      _classStmt.methods.forEach(function (method) {\n          var paramNames = method.params.map(function (param) { return param.name; });\n          // Note: use `function` instead of arrow function to capture `this`\n          propertyDescriptors[method.name] = {\n              writable: false,\n              configurable: false,\n              value: function () {\n                  var args = [];\n                  for (var _i = 0; _i < arguments.length; _i++) {\n                      args[_i - 0] = arguments[_i];\n                  }\n                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                  return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n              }\n          };\n      });\n      var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });\n      // Note: use `function` instead of arrow function to capture `this`\n      var ctor = function () {\n          var _this = this;\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i - 0] = arguments[_i];\n          }\n          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n          _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });\n          _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n      };\n      var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n      ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n      return ctor;\n  }\n  var StatementInterpreter = (function () {\n      function StatementInterpreter() {\n      }\n      StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };\n      StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n          ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));\n          return null;\n      };\n      StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n          var value = expr.value.visitExpression(this, ctx);\n          var currCtx = ctx;\n          while (currCtx != null) {\n              if (currCtx.vars.has(expr.name)) {\n                  currCtx.vars.set(expr.name, value);\n                  return value;\n              }\n              currCtx = currCtx.parent;\n          }\n          throw new Error(\"Not declared variable \" + expr.name);\n      };\n      StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n          var varName = ast.name;\n          if (isPresent(ast.builtin)) {\n              switch (ast.builtin) {\n                  case BuiltinVar.Super:\n                      return ctx.instance.__proto__;\n                  case BuiltinVar.This:\n                      return ctx.instance;\n                  case BuiltinVar.CatchError:\n                      varName = CATCH_ERROR_VAR$1;\n                      break;\n                  case BuiltinVar.CatchStack:\n                      varName = CATCH_STACK_VAR$1;\n                      break;\n                  default:\n                      throw new Error(\"Unknown builtin variable \" + ast.builtin);\n              }\n          }\n          var currCtx = ctx;\n          while (currCtx != null) {\n              if (currCtx.vars.has(varName)) {\n                  return currCtx.vars.get(varName);\n              }\n              currCtx = currCtx.parent;\n          }\n          throw new Error(\"Not declared variable \" + varName);\n      };\n      StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n          var receiver = expr.receiver.visitExpression(this, ctx);\n          var index = expr.index.visitExpression(this, ctx);\n          var value = expr.value.visitExpression(this, ctx);\n          receiver[index] = value;\n          return value;\n      };\n      StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n          var receiver = expr.receiver.visitExpression(this, ctx);\n          var value = expr.value.visitExpression(this, ctx);\n          receiver[expr.name] = value;\n          return value;\n      };\n      StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n          var receiver = expr.receiver.visitExpression(this, ctx);\n          var args = this.visitAllExpressions(expr.args, ctx);\n          var result;\n          if (isPresent(expr.builtin)) {\n              switch (expr.builtin) {\n                  case BuiltinMethod.ConcatArray:\n                      result = receiver.concat.apply(receiver, args);\n                      break;\n                  case BuiltinMethod.SubscribeObservable:\n                      result = receiver.subscribe({ next: args[0] });\n                      break;\n                  case BuiltinMethod.Bind:\n                      result = receiver.bind.apply(receiver, args);\n                      break;\n                  default:\n                      throw new Error(\"Unknown builtin method \" + expr.builtin);\n              }\n          }\n          else {\n              result = receiver[expr.name].apply(receiver, args);\n          }\n          return result;\n      };\n      StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n          var args = this.visitAllExpressions(stmt.args, ctx);\n          var fnExpr = stmt.fn;\n          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n              ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n              return null;\n          }\n          else {\n              var fn = stmt.fn.visitExpression(this, ctx);\n              return fn.apply(null, args);\n          }\n      };\n      StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n          return new ReturnValue(stmt.value.visitExpression(this, ctx));\n      };\n      StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n          var clazz = createDynamicClass(stmt, ctx, this);\n          ctx.vars.set(stmt.name, clazz);\n          return null;\n      };\n      StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n          return stmt.expr.visitExpression(this, ctx);\n      };\n      StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n          var condition = stmt.condition.visitExpression(this, ctx);\n          if (condition) {\n              return this.visitAllStatements(stmt.trueCase, ctx);\n          }\n          else if (isPresent(stmt.falseCase)) {\n              return this.visitAllStatements(stmt.falseCase, ctx);\n          }\n          return null;\n      };\n      StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n          try {\n              return this.visitAllStatements(stmt.bodyStmts, ctx);\n          }\n          catch (e) {\n              var childCtx = ctx.createChildWihtLocalVars();\n              childCtx.vars.set(CATCH_ERROR_VAR$1, e);\n              childCtx.vars.set(CATCH_STACK_VAR$1, e.stack);\n              return this.visitAllStatements(stmt.catchStmts, childCtx);\n          }\n      };\n      StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n          throw stmt.error.visitExpression(this, ctx);\n      };\n      StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };\n      StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n          var args = this.visitAllExpressions(ast.args, ctx);\n          var clazz = ast.classExpr.visitExpression(this, ctx);\n          return new (clazz.bind.apply(clazz, [void 0].concat(args)))();\n      };\n      StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };\n      StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {\n          return ast.value.reference;\n      };\n      StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n          if (ast.condition.visitExpression(this, ctx)) {\n              return ast.trueCase.visitExpression(this, ctx);\n          }\n          else if (isPresent(ast.falseCase)) {\n              return ast.falseCase.visitExpression(this, ctx);\n          }\n          return null;\n      };\n      StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n          return !ast.condition.visitExpression(this, ctx);\n      };\n      StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n          return ast.value.visitExpression(this, ctx);\n      };\n      StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n          var paramNames = ast.params.map(function (param) { return param.name; });\n          return _declareFn(paramNames, ast.statements, ctx, this);\n      };\n      StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n          var paramNames = stmt.params.map(function (param) { return param.name; });\n          ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n          return null;\n      };\n      StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n          var _this = this;\n          var lhs = function () { return ast.lhs.visitExpression(_this, ctx); };\n          var rhs = function () { return ast.rhs.visitExpression(_this, ctx); };\n          switch (ast.operator) {\n              case BinaryOperator.Equals:\n                  return lhs() == rhs();\n              case BinaryOperator.Identical:\n                  return lhs() === rhs();\n              case BinaryOperator.NotEquals:\n                  return lhs() != rhs();\n              case BinaryOperator.NotIdentical:\n                  return lhs() !== rhs();\n              case BinaryOperator.And:\n                  return lhs() && rhs();\n              case BinaryOperator.Or:\n                  return lhs() || rhs();\n              case BinaryOperator.Plus:\n                  return lhs() + rhs();\n              case BinaryOperator.Minus:\n                  return lhs() - rhs();\n              case BinaryOperator.Divide:\n                  return lhs() / rhs();\n              case BinaryOperator.Multiply:\n                  return lhs() * rhs();\n              case BinaryOperator.Modulo:\n                  return lhs() % rhs();\n              case BinaryOperator.Lower:\n                  return lhs() < rhs();\n              case BinaryOperator.LowerEquals:\n                  return lhs() <= rhs();\n              case BinaryOperator.Bigger:\n                  return lhs() > rhs();\n              case BinaryOperator.BiggerEquals:\n                  return lhs() >= rhs();\n              default:\n                  throw new Error(\"Unknown operator \" + ast.operator);\n          }\n      };\n      StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n          var result;\n          var receiver = ast.receiver.visitExpression(this, ctx);\n          result = receiver[ast.name];\n          return result;\n      };\n      StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n          var receiver = ast.receiver.visitExpression(this, ctx);\n          var prop = ast.index.visitExpression(this, ctx);\n          return receiver[prop];\n      };\n      StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n          return this.visitAllExpressions(ast.entries, ctx);\n      };\n      StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n          var _this = this;\n          var result = {};\n          ast.entries.forEach(function (entry) { return result[entry[0]] =\n              entry[1].visitExpression(_this, ctx); });\n          return result;\n      };\n      StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n          var _this = this;\n          return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });\n      };\n      StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n          for (var i = 0; i < statements.length; i++) {\n              var stmt = statements[i];\n              var val = stmt.visitStatement(this, ctx);\n              if (val instanceof ReturnValue) {\n                  return val;\n              }\n          }\n          return null;\n      };\n      return StatementInterpreter;\n  }());\n  function _declareFn(varNames, statements, ctx, visitor) {\n      return function () {\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i - 0] = arguments[_i];\n          }\n          return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n      };\n  }\n  var CATCH_ERROR_VAR$1 = 'error';\n  var CATCH_STACK_VAR$1 = 'stack';\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$20 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var AbstractJsEmitterVisitor = (function (_super) {\n      __extends$20(AbstractJsEmitterVisitor, _super);\n      function AbstractJsEmitterVisitor() {\n          _super.call(this, false);\n      }\n      AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n          var _this = this;\n          ctx.pushClass(stmt);\n          this._visitClassConstructor(stmt, ctx);\n          if (isPresent(stmt.parent)) {\n              ctx.print(stmt.name + \".prototype = Object.create(\");\n              stmt.parent.visitExpression(this, ctx);\n              ctx.println(\".prototype);\");\n          }\n          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });\n          stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });\n          ctx.popClass();\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n          ctx.print(\"function \" + stmt.name + \"(\");\n          if (isPresent(stmt.constructorMethod)) {\n              this._visitParams(stmt.constructorMethod.params, ctx);\n          }\n          ctx.println(\") {\");\n          ctx.incIndent();\n          if (isPresent(stmt.constructorMethod)) {\n              if (stmt.constructorMethod.body.length > 0) {\n                  ctx.println(\"var self = this;\");\n                  this.visitAllStatements(stmt.constructorMethod.body, ctx);\n              }\n          }\n          ctx.decIndent();\n          ctx.println(\"}\");\n      };\n      AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {\n          ctx.println(\"Object.defineProperty(\" + stmt.name + \".prototype, '\" + getter.name + \"', { get: function() {\");\n          ctx.incIndent();\n          if (getter.body.length > 0) {\n              ctx.println(\"var self = this;\");\n              this.visitAllStatements(getter.body, ctx);\n          }\n          ctx.decIndent();\n          ctx.println(\"}});\");\n      };\n      AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {\n          ctx.print(stmt.name + \".prototype.\" + method.name + \" = function(\");\n          this._visitParams(method.params, ctx);\n          ctx.println(\") {\");\n          ctx.incIndent();\n          if (method.body.length > 0) {\n              ctx.println(\"var self = this;\");\n              this.visitAllStatements(method.body, ctx);\n          }\n          ctx.decIndent();\n          ctx.println(\"};\");\n      };\n      AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n          if (ast.builtin === BuiltinVar.This) {\n              ctx.print('self');\n          }\n          else if (ast.builtin === BuiltinVar.Super) {\n              throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n          }\n          else {\n              _super.prototype.visitReadVarExpr.call(this, ast, ctx);\n          }\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n          ctx.print(\"var \" + stmt.name + \" = \");\n          stmt.value.visitExpression(this, ctx);\n          ctx.println(\";\");\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n          ast.value.visitExpression(this, ctx);\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n          var fnExpr = expr.fn;\n          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n              ctx.currentClass.parent.visitExpression(this, ctx);\n              ctx.print(\".call(this\");\n              if (expr.args.length > 0) {\n                  ctx.print(\", \");\n                  this.visitAllExpressions(expr.args, ctx, ',');\n              }\n              ctx.print(\")\");\n          }\n          else {\n              _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);\n          }\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n          ctx.print(\"function(\");\n          this._visitParams(ast.params, ctx);\n          ctx.println(\") {\");\n          ctx.incIndent();\n          this.visitAllStatements(ast.statements, ctx);\n          ctx.decIndent();\n          ctx.print(\"}\");\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n          ctx.print(\"function \" + stmt.name + \"(\");\n          this._visitParams(stmt.params, ctx);\n          ctx.println(\") {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.statements, ctx);\n          ctx.decIndent();\n          ctx.println(\"}\");\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n          ctx.println(\"try {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.bodyStmts, ctx);\n          ctx.decIndent();\n          ctx.println(\"} catch (\" + CATCH_ERROR_VAR$2.name + \") {\");\n          ctx.incIndent();\n          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [\n                  StmtModifier.Final\n              ])].concat(stmt.catchStmts);\n          this.visitAllStatements(catchStmts, ctx);\n          ctx.decIndent();\n          ctx.println(\"}\");\n          return null;\n      };\n      AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n          this.visitAllObjects(function (param) { return ctx.print(param.name); }, params, ctx, ',');\n      };\n      AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n          var name;\n          switch (method) {\n              case BuiltinMethod.ConcatArray:\n                  name = 'concat';\n                  break;\n              case BuiltinMethod.SubscribeObservable:\n                  name = 'subscribe';\n                  break;\n              case BuiltinMethod.Bind:\n                  name = 'bind';\n                  break;\n              default:\n                  throw new Error(\"Unknown builtin method: \" + method);\n          }\n          return name;\n      };\n      return AbstractJsEmitterVisitor;\n  }(AbstractEmitterVisitor));\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$19 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  function evalExpression(sourceUrl, expr, declarations, vars) {\n      var fnBody = declarations + \"\\nreturn \" + expr + \"\\n//# sourceURL=\" + sourceUrl;\n      var fnArgNames = [];\n      var fnArgValues = [];\n      for (var argName in vars) {\n          fnArgNames.push(argName);\n          fnArgValues.push(vars[argName]);\n      }\n      return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);\n  }\n  function jitStatements(sourceUrl, statements, resultVar) {\n      var converter = new JitEmitterVisitor();\n      var ctx = EmitterVisitorContext.createRoot([resultVar]);\n      converter.visitAllStatements(statements, ctx);\n      return evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());\n  }\n  var JitEmitterVisitor = (function (_super) {\n      __extends$19(JitEmitterVisitor, _super);\n      function JitEmitterVisitor() {\n          _super.apply(this, arguments);\n          this._evalArgNames = [];\n          this._evalArgValues = [];\n      }\n      JitEmitterVisitor.prototype.getArgs = function () {\n          var result = {};\n          for (var i = 0; i < this._evalArgNames.length; i++) {\n              result[this._evalArgNames[i]] = this._evalArgValues[i];\n          }\n          return result;\n      };\n      JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n          var value = ast.value.reference;\n          var id = this._evalArgValues.indexOf(value);\n          if (id === -1) {\n              id = this._evalArgValues.length;\n              this._evalArgValues.push(value);\n              var name_1 = isPresent(ast.value.name) ? sanitizeIdentifier(ast.value.name) : 'val';\n              this._evalArgNames.push(sanitizeIdentifier(\"jit_\" + name_1 + id));\n          }\n          ctx.print(this._evalArgNames[id]);\n          return null;\n      };\n      return JitEmitterVisitor;\n  }(AbstractJsEmitterVisitor));\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  /**\n   * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n   *\n   * Please make sure to keep to edits in sync with the source file.\n   *\n   * Source:\n   * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n   *\n   * The original file level comment is reproduced below\n   */\n  /*\n    This is a limited shim for ShadowDOM css styling.\n    https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n    The intention here is to support only the styling features which can be\n    relatively simply implemented. The goal is to allow users to avoid the\n    most obvious pitfalls and do so without compromising performance significantly.\n    For ShadowDOM styling that's not covered here, a set of best practices\n    can be provided that should allow users to accomplish more complex styling.\n\n    The following is a list of specific ShadowDOM styling features and a brief\n    discussion of the approach used to shim.\n\n    Shimmed features:\n\n    * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n    element using the :host rule. To shim this feature, the :host styles are\n    reformatted and prefixed with a given scope name and promoted to a\n    document level stylesheet.\n    For example, given a scope name of .foo, a rule like this:\n\n      :host {\n          background: red;\n        }\n      }\n\n    becomes:\n\n      .foo {\n        background: red;\n      }\n\n    * encapsulation: Styles defined within ShadowDOM, apply only to\n    dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n    this feature.\n\n    By default, rules are prefixed with the host element tag name\n    as a descendant selector. This ensures styling does not leak out of the 'top'\n    of the element's ShadowDOM. For example,\n\n    div {\n        font-weight: bold;\n      }\n\n    becomes:\n\n    x-foo div {\n        font-weight: bold;\n      }\n\n    becomes:\n\n\n    Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n    selectors are scoped by adding an attribute selector suffix to each\n    simple selector that contains the host element tag name. Each element\n    in the element's ShadowDOM template is also given the scope attribute.\n    Thus, these rules match only elements that have the scope attribute.\n    For example, given a scope name of x-foo, a rule like this:\n\n      div {\n        font-weight: bold;\n      }\n\n    becomes:\n\n      div[x-foo] {\n        font-weight: bold;\n      }\n\n    Note that elements that are dynamically added to a scope must have the scope\n    selector added to them manually.\n\n    * upper/lower bound encapsulation: Styles which are defined outside a\n    shadowRoot should not cross the ShadowDOM boundary and should not apply\n    inside a shadowRoot.\n\n    This styling behavior is not emulated. Some possible ways to do this that\n    were rejected due to complexity and/or performance concerns include: (1) reset\n    every possible property for every possible selector for a given scope name;\n    (2) re-implement css in javascript.\n\n    As an alternative, users should make sure to use selectors\n    specific to the scope in which they are working.\n\n    * ::distributed: This behavior is not emulated. It's often not necessary\n    to style the contents of a specific insertion point and instead, descendants\n    of the host element can be styled selectively. Users can also create an\n    extra node around an insertion point and style that node's contents\n    via descendent selectors. For example, with a shadowRoot like this:\n\n      <style>\n        ::content(div) {\n          background: red;\n        }\n      </style>\n      <content></content>\n\n    could become:\n\n      <style>\n        / *@polyfill .content-container div * /\n        ::content(div) {\n          background: red;\n        }\n      </style>\n      <div class=\"content-container\">\n        <content></content>\n      </div>\n\n    Note the use of @polyfill in the comment above a ShadowDOM specific style\n    declaration. This is a directive to the styling shim to use the selector\n    in comments in lieu of the next selector when running under polyfill.\n  */\n  var ShadowCss = (function () {\n      function ShadowCss() {\n          this.strictStyling = true;\n      }\n      /*\n      * Shim some cssText with the given selector. Returns cssText that can\n      * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n      *\n      * When strictStyling is true:\n      * - selector is the attribute added to all elements inside the host,\n      * - hostSelector is the attribute added to the host itself.\n      */\n      ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\n          if (hostSelector === void 0) { hostSelector = ''; }\n          var sourceMappingUrl = extractSourceMappingUrl(cssText);\n          cssText = stripComments(cssText);\n          cssText = this._insertDirectives(cssText);\n          return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;\n      };\n      ShadowCss.prototype._insertDirectives = function (cssText) {\n          cssText = this._insertPolyfillDirectivesInCssText(cssText);\n          return this._insertPolyfillRulesInCssText(cssText);\n      };\n      /*\n       * Process styles to convert native ShadowDOM rules that will trip\n       * up the css parser; we rely on decorating the stylesheet with inert rules.\n       *\n       * For example, we convert this rule:\n       *\n       * polyfill-next-selector { content: ':host menu-item'; }\n       * ::content menu-item {\n       *\n       * to this:\n       *\n       * scopeName menu-item {\n       *\n      **/\n      ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\n          // Difference with webcomponents.js: does not handle comments\n          return cssText.replace(_cssContentNextSelectorRe, function () {\n              var m = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                  m[_i - 0] = arguments[_i];\n              }\n              return m[2] + '{';\n          });\n      };\n      /*\n       * Process styles to add rules which will only apply under the polyfill\n       *\n       * For example, we convert this rule:\n       *\n       * polyfill-rule {\n       *   content: ':host menu-item';\n       * ...\n       * }\n       *\n       * to this:\n       *\n       * scopeName menu-item {...}\n       *\n      **/\n      ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\n          // Difference with webcomponents.js: does not handle comments\n          return cssText.replace(_cssContentRuleRe, function () {\n              var m = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                  m[_i - 0] = arguments[_i];\n              }\n              var rule = m[0].replace(m[1], '').replace(m[2], '');\n              return m[4] + rule;\n          });\n      };\n      /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n       *\n       *  .foo {... }\n       *\n       *  and converts this to\n       *\n       *  scopeName .foo { ... }\n      */\n      ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\n          var unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n          // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n          cssText = this._insertPolyfillHostInCssText(cssText);\n          cssText = this._convertColonHost(cssText);\n          cssText = this._convertColonHostContext(cssText);\n          cssText = this._convertShadowDOMSelectors(cssText);\n          if (scopeSelector) {\n              cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n          }\n          cssText = cssText + '\\n' + unscopedRules;\n          return cssText.trim();\n      };\n      /*\n       * Process styles to add rules which will only apply under the polyfill\n       * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n       * occasions, e.g. -webkit-calc on Safari.)\n       * For example, we convert this rule:\n       *\n       * @polyfill-unscoped-rule {\n       *   content: 'menu-item';\n       * ... }\n       *\n       * to this:\n       *\n       * menu-item {...}\n       *\n      **/\n      ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\n          // Difference with webcomponents.js: does not handle comments\n          var r = '';\n          var m;\n          _cssContentUnscopedRuleRe.lastIndex = 0;\n          while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n              var rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n              r += rule + '\\n\\n';\n          }\n          return r;\n      };\n      /*\n       * convert a rule like :host(.foo) > .bar { }\n       *\n       * to\n       *\n       * .foo<scopeName> > .bar\n      */\n      ShadowCss.prototype._convertColonHost = function (cssText) {\n          return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n      };\n      /*\n       * convert a rule like :host-context(.foo) > .bar { }\n       *\n       * to\n       *\n       * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n       *\n       * and\n       *\n       * :host-context(.foo:host) .bar { ... }\n       *\n       * to\n       *\n       * .foo<scopeName> .bar { ... }\n      */\n      ShadowCss.prototype._convertColonHostContext = function (cssText) {\n          return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n      };\n      ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n          // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n          return cssText.replace(regExp, function () {\n              var m = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                  m[_i - 0] = arguments[_i];\n              }\n              if (m[2]) {\n                  var parts = m[2].split(',');\n                  var r = [];\n                  for (var i = 0; i < parts.length; i++) {\n                      var p = parts[i].trim();\n                      if (!p)\n                          break;\n                      r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                  }\n                  return r.join(',');\n              }\n              else {\n                  return _polyfillHostNoCombinator + m[3];\n              }\n          });\n      };\n      ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n          if (part.indexOf(_polyfillHost) > -1) {\n              return this._colonHostPartReplacer(host, part, suffix);\n          }\n          else {\n              return host + part + suffix + ', ' + part + ' ' + host + suffix;\n          }\n      };\n      ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n          return host + part.replace(_polyfillHost, '') + suffix;\n      };\n      /*\n       * Convert combinators like ::shadow and pseudo-elements like ::content\n       * by replacing with space.\n      */\n      ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n          return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n      };\n      // change a selector like 'div' to 'name div'\n      ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\n          var _this = this;\n          return processRules(cssText, function (rule) {\n              var selector = rule.selector;\n              var content = rule.content;\n              if (rule.selector[0] != '@') {\n                  selector =\n                      _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\n              }\n              else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                  rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                  content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n              }\n              return new CssRule(selector, content);\n          });\n      };\n      ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\n          var _this = this;\n          return selector.split(',')\n              .map(function (part) { return part.trim().split(_shadowDeepSelectors); })\n              .map(function (deepParts) {\n              var shallowPart = deepParts[0], otherParts = deepParts.slice(1);\n              var applyScope = function (shallowPart) {\n                  if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                      return strict ?\n                          _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                          _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                  }\n                  else {\n                      return shallowPart;\n                  }\n              };\n              return [applyScope(shallowPart)].concat(otherParts).join(' ');\n          })\n              .join(', ');\n      };\n      ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n          var re = this._makeScopeMatcher(scopeSelector);\n          return !re.test(selector);\n      };\n      ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n          var lre = /\\[/g;\n          var rre = /\\]/g;\n          scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n          return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n      };\n      ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n          // Difference from webcomponents.js: scopeSelector could not be an array\n          return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n      };\n      // scope via name and [is=name]\n      ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n          // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n          _polyfillHostRe.lastIndex = 0;\n          if (_polyfillHostRe.test(selector)) {\n              var replaceBy_1 = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\n              return selector\n                  .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n                  return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                      return before + replaceBy_1 + colon + after;\n                  });\n              })\n                  .replace(_polyfillHostRe, replaceBy_1 + ' ');\n          }\n          return scopeSelector + ' ' + selector;\n      };\n      // return a selector with [name] suffix on each simple selector\n      // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n      ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n          var _this = this;\n          var isRe = /\\[is=([^\\]]*)\\]/g;\n          scopeSelector = scopeSelector.replace(isRe, function (_) {\n              var parts = [];\n              for (var _i = 1; _i < arguments.length; _i++) {\n                  parts[_i - 1] = arguments[_i];\n              }\n              return parts[0];\n          });\n          var attrName = '[' + scopeSelector + ']';\n          var _scopeSelectorPart = function (p) {\n              var scopedP = p.trim();\n              if (!scopedP) {\n                  return '';\n              }\n              if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                  scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n              }\n              else {\n                  // remove :host since it should be unnecessary\n                  var t = p.replace(_polyfillHostRe, '');\n                  if (t.length > 0) {\n                      var matches = t.match(/([^:]*)(:*)(.*)/);\n                      if (matches) {\n                          scopedP = matches[1] + attrName + matches[2] + matches[3];\n                      }\n                  }\n              }\n              return scopedP;\n          };\n          var safeContent = new SafeSelector(selector);\n          selector = safeContent.content();\n          var scopedSelector = '';\n          var startIndex = 0;\n          var res;\n          var sep = /( |>|\\+|~(?!=))\\s*/g;\n          var scopeAfter = selector.indexOf(_polyfillHostNoCombinator);\n          while ((res = sep.exec(selector)) !== null) {\n              var separator = res[1];\n              var part = selector.slice(startIndex, res.index).trim();\n              // if a selector appears before :host-context it should not be shimmed as it\n              // matches on ancestor elements and not on elements in the host's shadow\n              var scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;\n              scopedSelector += scopedPart + \" \" + separator + \" \";\n              startIndex = sep.lastIndex;\n          }\n          scopedSelector += _scopeSelectorPart(selector.substring(startIndex));\n          // replace the placeholders with their original values\n          return safeContent.restore(scopedSelector);\n      };\n      ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n          return selector.replace(_colonHostContextRe, _polyfillHostContext)\n              .replace(_colonHostRe, _polyfillHost);\n      };\n      return ShadowCss;\n  }());\n  var SafeSelector = (function () {\n      function SafeSelector(selector) {\n          var _this = this;\n          this.placeholders = [];\n          this.index = 0;\n          // Replaces attribute selectors with placeholders.\n          // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n          selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n              var replaceBy = \"__ph-\" + _this.index + \"__\";\n              _this.placeholders.push(keep);\n              _this.index++;\n              return replaceBy;\n          });\n          // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n          // WS and \"+\" would otherwise be interpreted as selector separators.\n          this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n              var replaceBy = \"__ph-\" + _this.index + \"__\";\n              _this.placeholders.push(exp);\n              _this.index++;\n              return pseudo + replaceBy;\n          });\n      }\n      ;\n      SafeSelector.prototype.restore = function (content) {\n          var _this = this;\n          return content.replace(/__ph-(\\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });\n      };\n      SafeSelector.prototype.content = function () { return this._content; };\n      return SafeSelector;\n  }());\n  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\n  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\n  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\n  var _polyfillHost = '-shadowcsshost';\n  // note: :host-context pre-processed to -shadowcsshostcontext.\n  var _polyfillHostContext = '-shadowcsscontext';\n  var _parenSuffix = ')(?:\\\\((' +\n      '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n      ')\\\\))?([^,{]*)';\n  var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\n  var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\n  var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\n  var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\n  var _shadowDOMSelectorsRe = [\n      /::shadow/g,\n      /::content/g,\n      // Deprecated selectors\n      /\\/shadow-deep\\//g,\n      /\\/shadow\\//g,\n  ];\n  var _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)/g;\n  var _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\n  var _polyfillHostRe = /-shadowcsshost/gim;\n  var _colonHostRe = /:host/gim;\n  var _colonHostContextRe = /:host-context/gim;\n  var _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n  function stripComments(input) {\n      return input.replace(_commentRe, '');\n  }\n  // all comments except inline source mapping\n  var _sourceMappingUrlRe = /\\/\\*\\s*#\\s*sourceMappingURL=[\\s\\S]+?\\*\\//;\n  function extractSourceMappingUrl(input) {\n      var matcher = input.match(_sourceMappingUrlRe);\n      return matcher ? matcher[0] : '';\n  }\n  var _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\n  var _curlyRe = /([{}])/g;\n  var OPEN_CURLY = '{';\n  var CLOSE_CURLY = '}';\n  var BLOCK_PLACEHOLDER = '%BLOCK%';\n  var CssRule = (function () {\n      function CssRule(selector, content) {\n          this.selector = selector;\n          this.content = content;\n      }\n      return CssRule;\n  }());\n  function processRules(input, ruleCallback) {\n      var inputWithEscapedBlocks = escapeBlocks(input);\n      var nextBlockIndex = 0;\n      return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n          var m = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              m[_i - 0] = arguments[_i];\n          }\n          var selector = m[2];\n          var content = '';\n          var suffix = m[4];\n          var contentPrefix = '';\n          if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n              content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n              suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n              contentPrefix = '{';\n          }\n          var rule = ruleCallback(new CssRule(selector, content));\n          return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n      });\n  }\n  var StringWithEscapedBlocks = (function () {\n      function StringWithEscapedBlocks(escapedString, blocks) {\n          this.escapedString = escapedString;\n          this.blocks = blocks;\n      }\n      return StringWithEscapedBlocks;\n  }());\n  function escapeBlocks(input) {\n      var inputParts = input.split(_curlyRe);\n      var resultParts = [];\n      var escapedBlocks = [];\n      var bracketCount = 0;\n      var currentBlockParts = [];\n      for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {\n          var part = inputParts[partIndex];\n          if (part == CLOSE_CURLY) {\n              bracketCount--;\n          }\n          if (bracketCount > 0) {\n              currentBlockParts.push(part);\n          }\n          else {\n              if (currentBlockParts.length > 0) {\n                  escapedBlocks.push(currentBlockParts.join(''));\n                  resultParts.push(BLOCK_PLACEHOLDER);\n                  currentBlockParts = [];\n              }\n              resultParts.push(part);\n          }\n          if (part == OPEN_CURLY) {\n              bracketCount++;\n          }\n      }\n      if (currentBlockParts.length > 0) {\n          escapedBlocks.push(currentBlockParts.join(''));\n          resultParts.push(BLOCK_PLACEHOLDER);\n      }\n      return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n  }\n\n  var COMPONENT_VARIABLE = '%COMP%';\n  var HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\n  var CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\n  var StylesCompileDependency = (function () {\n      function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {\n          this.moduleUrl = moduleUrl;\n          this.isShimmed = isShimmed;\n          this.valuePlaceholder = valuePlaceholder;\n      }\n      return StylesCompileDependency;\n  }());\n  var StylesCompileResult = (function () {\n      function StylesCompileResult(componentStylesheet, externalStylesheets) {\n          this.componentStylesheet = componentStylesheet;\n          this.externalStylesheets = externalStylesheets;\n      }\n      return StylesCompileResult;\n  }());\n  var CompiledStylesheet = (function () {\n      function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {\n          this.statements = statements;\n          this.stylesVar = stylesVar;\n          this.dependencies = dependencies;\n          this.isShimmed = isShimmed;\n          this.meta = meta;\n      }\n      return CompiledStylesheet;\n  }());\n  var StyleCompiler = (function () {\n      function StyleCompiler(_urlResolver) {\n          this._urlResolver = _urlResolver;\n          this._shadowCss = new ShadowCss();\n      }\n      StyleCompiler.prototype.compileComponent = function (comp) {\n          var _this = this;\n          var externalStylesheets = [];\n          var componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({\n              styles: comp.template.styles,\n              styleUrls: comp.template.styleUrls,\n              moduleUrl: comp.type.moduleUrl\n          }), true);\n          comp.template.externalStylesheets.forEach(function (stylesheetMeta) {\n              var compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);\n              externalStylesheets.push(compiledStylesheet);\n          });\n          return new StylesCompileResult(componentStylesheet, externalStylesheets);\n      };\n      StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {\n          var _this = this;\n          var shim = comp.template.encapsulation === _angular_core.ViewEncapsulation.Emulated;\n          var styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });\n          var dependencies = [];\n          for (var i = 0; i < stylesheet.styleUrls.length; i++) {\n              var identifier = new CompileIdentifierMetadata({ name: getStylesVarName(null) });\n              dependencies.push(new StylesCompileDependency(stylesheet.styleUrls[i], shim, identifier));\n              styleExpressions.push(new ExternalExpr(identifier));\n          }\n          // styles variable contains plain strings and arrays of other styles arrays (recursive),\n          // so we set its type to dynamic.\n          var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n          var stmt = variable(stylesVar)\n              .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\n              .toDeclStmt(null, [StmtModifier.Final]);\n          return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);\n      };\n      StyleCompiler.prototype._shimIfNeeded = function (style, shim) {\n          return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n      };\n      StyleCompiler.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      StyleCompiler.ctorParameters = [\n          { type: UrlResolver, },\n      ];\n      return StyleCompiler;\n  }());\n  function getStylesVarName(component) {\n      var result = \"styles\";\n      if (component) {\n          result += \"_\" + component.type.name;\n      }\n      return result;\n  }\n\n  /**\n   * An internal module of the Angular compiler that begins with component types,\n   * extracts templates, and eventually produces a compiled version of the component\n   * ready for linking into an application.\n   *\n   * @security  When compiling templates at runtime, you must ensure that the entire template comes\n   * from a trusted source. Attacker-controlled data introduced by a template could expose your\n   * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n   */\n  var RuntimeCompiler = (function () {\n      function RuntimeCompiler(_injector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _directiveWrapperCompiler, _compilerConfig, _animationParser) {\n          this._injector = _injector;\n          this._metadataResolver = _metadataResolver;\n          this._templateParser = _templateParser;\n          this._styleCompiler = _styleCompiler;\n          this._viewCompiler = _viewCompiler;\n          this._ngModuleCompiler = _ngModuleCompiler;\n          this._directiveWrapperCompiler = _directiveWrapperCompiler;\n          this._compilerConfig = _compilerConfig;\n          this._animationParser = _animationParser;\n          this._compiledTemplateCache = new Map();\n          this._compiledHostTemplateCache = new Map();\n          this._compiledDirectiveWrapperCache = new Map();\n          this._compiledNgModuleCache = new Map();\n          this._animationCompiler = new AnimationCompiler();\n      }\n      Object.defineProperty(RuntimeCompiler.prototype, \"injector\", {\n          get: function () { return this._injector; },\n          enumerable: true,\n          configurable: true\n      });\n      RuntimeCompiler.prototype.compileModuleSync = function (moduleType) {\n          return this._compileModuleAndComponents(moduleType, true).syncResult;\n      };\n      RuntimeCompiler.prototype.compileModuleAsync = function (moduleType) {\n          return this._compileModuleAndComponents(moduleType, false).asyncResult;\n      };\n      RuntimeCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n          return this._compileModuleAndAllComponents(moduleType, true).syncResult;\n      };\n      RuntimeCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n          return this._compileModuleAndAllComponents(moduleType, false).asyncResult;\n      };\n      RuntimeCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n          var _this = this;\n          var loadingPromise = this._loadModules(moduleType, isSync);\n          var createResult = function () {\n              _this._compileComponents(moduleType, null);\n              return _this._compileModule(moduleType);\n          };\n          if (isSync) {\n              return new SyncAsyncResult(createResult());\n          }\n          else {\n              return new SyncAsyncResult(null, loadingPromise.then(createResult));\n          }\n      };\n      RuntimeCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n          var _this = this;\n          var loadingPromise = this._loadModules(moduleType, isSync);\n          var createResult = function () {\n              var componentFactories = [];\n              _this._compileComponents(moduleType, componentFactories);\n              return new _angular_core.ModuleWithComponentFactories(_this._compileModule(moduleType), componentFactories);\n          };\n          if (isSync) {\n              return new SyncAsyncResult(createResult());\n          }\n          else {\n              return new SyncAsyncResult(null, loadingPromise.then(createResult));\n          }\n      };\n      RuntimeCompiler.prototype._loadModules = function (mainModule, isSync) {\n          var _this = this;\n          var loadingPromises = [];\n          var _a = this._metadataResolver.loadNgModuleMetadata(mainModule, isSync), ngModule = _a.ngModule, loading = _a.loading;\n          loadingPromises.push(loading);\n          // Note: the loadingPromise for a module only includes the loading of the exported directives\n          // of imported modules.\n          // However, for runtime compilation, we want to transitively compile all modules,\n          // so we also need to call loadNgModuleMetadata for all nested modules.\n          ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {\n              loadingPromises.push(_this._metadataResolver.loadNgModuleMetadata(localModuleMeta.type.reference, isSync)\n                  .loading);\n          });\n          return Promise.all(loadingPromises);\n      };\n      RuntimeCompiler.prototype._compileModule = function (moduleType) {\n          var _this = this;\n          var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\n          if (!ngModuleFactory) {\n              var moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);\n              // Always provide a bound Compiler\n              var extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(_angular_core.Compiler, { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];\n              var compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);\n              compileResult.dependencies.forEach(function (dep) {\n                  dep.placeholder.reference =\n                      _this._assertComponentKnown(dep.comp.reference, true).proxyComponentFactory;\n                  dep.placeholder.name = \"compFactory_\" + dep.comp.name;\n              });\n              if (!this._compilerConfig.useJit) {\n                  ngModuleFactory =\n                      interpretStatements(compileResult.statements, compileResult.ngModuleFactoryVar);\n              }\n              else {\n                  ngModuleFactory = jitStatements(\"/\" + moduleMeta_1.type.name + \"/module.ngfactory.js\", compileResult.statements, compileResult.ngModuleFactoryVar);\n              }\n              this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);\n          }\n          return ngModuleFactory;\n      };\n      /**\n       * @internal\n       */\n      RuntimeCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n          var _this = this;\n          var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n          var moduleByDirective = new Map();\n          var templates = new Set();\n          ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n              var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.type.reference);\n              localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                  moduleByDirective.set(dirIdentifier.reference, localModuleMeta);\n                  var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                  _this._compileDirectiveWrapper(dirMeta, localModuleMeta);\n                  if (dirMeta.isComponent) {\n                      templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n                      if (allComponentFactories) {\n                          var template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                          templates.add(template);\n                          allComponentFactories.push(template.proxyComponentFactory);\n                      }\n                  }\n              });\n          });\n          ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n              var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.type.reference);\n              localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                  var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                  if (dirMeta.isComponent) {\n                      dirMeta.entryComponents.forEach(function (entryComponentType) {\n                          var moduleMeta = moduleByDirective.get(entryComponentType.reference);\n                          templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));\n                      });\n                  }\n              });\n              localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n                  var moduleMeta = moduleByDirective.get(entryComponentType.reference);\n                  templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));\n              });\n          });\n          templates.forEach(function (template) { return _this._compileTemplate(template); });\n      };\n      RuntimeCompiler.prototype.clearCacheFor = function (type) {\n          this._compiledNgModuleCache.delete(type);\n          this._metadataResolver.clearCacheFor(type);\n          this._compiledHostTemplateCache.delete(type);\n          var compiledTemplate = this._compiledTemplateCache.get(type);\n          if (compiledTemplate) {\n              this._compiledTemplateCache.delete(type);\n          }\n      };\n      RuntimeCompiler.prototype.clearCache = function () {\n          this._metadataResolver.clearCache();\n          this._compiledTemplateCache.clear();\n          this._compiledHostTemplateCache.clear();\n          this._compiledNgModuleCache.clear();\n      };\n      RuntimeCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n          if (!ngModule) {\n              throw new Error(\"Component \" + stringify(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n          }\n          var compiledTemplate = this._compiledHostTemplateCache.get(compType);\n          if (!compiledTemplate) {\n              var compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n              assertComponent(compMeta);\n              var hostMeta = createHostComponentMeta(compMeta);\n              compiledTemplate = new CompiledTemplate(true, compMeta.selector, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n              this._compiledHostTemplateCache.set(compType, compiledTemplate);\n          }\n          return compiledTemplate;\n      };\n      RuntimeCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n          var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n          if (!compiledTemplate) {\n              assertComponent(compMeta);\n              compiledTemplate = new CompiledTemplate(false, compMeta.selector, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n              this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n          }\n          return compiledTemplate;\n      };\n      RuntimeCompiler.prototype._assertComponentKnown = function (compType, isHost) {\n          var compiledTemplate = isHost ? this._compiledHostTemplateCache.get(compType) :\n              this._compiledTemplateCache.get(compType);\n          if (!compiledTemplate) {\n              throw new Error(\"Illegal state: Compiled view for component \" + stringify(compType) + \" (host: \" + isHost + \") does not exist!\");\n          }\n          return compiledTemplate;\n      };\n      RuntimeCompiler.prototype._assertDirectiveWrapper = function (dirType) {\n          var dirWrapper = this._compiledDirectiveWrapperCache.get(dirType);\n          if (!dirWrapper) {\n              throw new Error(\"Illegal state: Directive wrapper for \" + stringify(dirType) + \" has not been compiled!\");\n          }\n          return dirWrapper;\n      };\n      RuntimeCompiler.prototype._compileDirectiveWrapper = function (dirMeta, moduleMeta) {\n          var compileResult = this._directiveWrapperCompiler.compile(dirMeta);\n          var statements = compileResult.statements;\n          var directiveWrapperClass;\n          if (!this._compilerConfig.useJit) {\n              directiveWrapperClass = interpretStatements(statements, compileResult.dirWrapperClassVar);\n          }\n          else {\n              directiveWrapperClass = jitStatements(\"/\" + moduleMeta.type.name + \"/\" + dirMeta.type.name + \"/wrapper.ngfactory.js\", statements, compileResult.dirWrapperClassVar);\n          }\n          this._compiledDirectiveWrapperCache.set(dirMeta.type.reference, directiveWrapperClass);\n      };\n      RuntimeCompiler.prototype._compileTemplate = function (template) {\n          var _this = this;\n          if (template.isCompiled) {\n              return;\n          }\n          var compMeta = template.compMeta;\n          var externalStylesheetsByModuleUrl = new Map();\n          var stylesCompileResult = this._styleCompiler.compileComponent(compMeta);\n          stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r); });\n          this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);\n          var parsedAnimations = this._animationParser.parseComponent(compMeta);\n          var directives = template.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n          var pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, template.ngModule.schemas, compMeta.type.name);\n          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);\n          var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), pipes, compiledAnimations);\n          compileResult.dependencies.forEach(function (dep) {\n              var depTemplate;\n              if (dep instanceof ViewClassDependency) {\n                  var vfd = dep;\n                  depTemplate = _this._assertComponentKnown(vfd.comp.reference, false);\n                  vfd.placeholder.reference = depTemplate.proxyViewClass;\n                  vfd.placeholder.name = \"View_\" + vfd.comp.name;\n              }\n              else if (dep instanceof ComponentFactoryDependency) {\n                  var cfd = dep;\n                  depTemplate = _this._assertComponentKnown(cfd.comp.reference, true);\n                  cfd.placeholder.reference = depTemplate.proxyComponentFactory;\n                  cfd.placeholder.name = \"compFactory_\" + cfd.comp.name;\n              }\n              else if (dep instanceof DirectiveWrapperDependency) {\n                  var dwd = dep;\n                  dwd.placeholder.reference = _this._assertDirectiveWrapper(dwd.dir.reference);\n              }\n          });\n          var statements = (_a = stylesCompileResult.componentStylesheet.statements).concat.apply(_a, compiledAnimations.map(function (ca) { return ca.statements; }))\n              .concat(compileResult.statements);\n          var viewClass;\n          if (!this._compilerConfig.useJit) {\n              viewClass = interpretStatements(statements, compileResult.viewClassVar);\n          }\n          else {\n              viewClass = jitStatements(\"/\" + template.ngModule.type.name + \"/\" + template.compType.name + \"/\" + (template.isHost ? 'host' : 'component') + \".ngfactory.js\", statements, compileResult.viewClassVar);\n          }\n          template.compiled(viewClass);\n          var _a;\n      };\n      RuntimeCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n          var _this = this;\n          result.dependencies.forEach(function (dep, i) {\n              var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\n              var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n              dep.valuePlaceholder.reference = nestedStylesArr;\n              dep.valuePlaceholder.name = \"importedStyles\" + i;\n          });\n      };\n      RuntimeCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n          this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n          if (!this._compilerConfig.useJit) {\n              return interpretStatements(result.statements, result.stylesVar);\n          }\n          else {\n              return jitStatements(\"/\" + result.meta.moduleUrl + \".css.js\", result.statements, result.stylesVar);\n          }\n      };\n      RuntimeCompiler.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      RuntimeCompiler.ctorParameters = [\n          { type: _angular_core.Injector, },\n          { type: CompileMetadataResolver, },\n          { type: TemplateParser, },\n          { type: StyleCompiler, },\n          { type: ViewCompiler, },\n          { type: NgModuleCompiler, },\n          { type: DirectiveWrapperCompiler, },\n          { type: CompilerConfig, },\n          { type: AnimationParser, },\n      ];\n      return RuntimeCompiler;\n  }());\n  var CompiledTemplate = (function () {\n      function CompiledTemplate(isHost, selector, compType, compMeta, ngModule, directives) {\n          this.isHost = isHost;\n          this.compType = compType;\n          this.compMeta = compMeta;\n          this.ngModule = ngModule;\n          this.directives = directives;\n          this._viewClass = null;\n          this.isCompiled = false;\n          var self = this;\n          this.proxyViewClass = function () {\n              if (!self._viewClass) {\n                  throw new Error(\"Illegal state: CompiledTemplate for \" + stringify(self.compType) + \" is not compiled yet!\");\n              }\n              return self._viewClass.apply(this, arguments);\n          };\n          this.proxyComponentFactory = isHost ?\n              new _angular_core.ComponentFactory(selector, this.proxyViewClass, compType.reference) :\n              null;\n      }\n      CompiledTemplate.prototype.compiled = function (viewClass) {\n          this._viewClass = viewClass;\n          this.proxyViewClass.prototype = viewClass.prototype;\n          this.isCompiled = true;\n      };\n      return CompiledTemplate;\n  }());\n  function assertComponent(meta) {\n      if (!meta.isComponent) {\n          throw new Error(\"Could not compile '\" + meta.type.name + \"' because it is not a component.\");\n      }\n  }\n  /**\n   * Implements `Compiler` by delegating to the RuntimeCompiler using a known module.\n   */\n  var ModuleBoundCompiler = (function () {\n      function ModuleBoundCompiler(_delegate, _ngModule) {\n          this._delegate = _delegate;\n          this._ngModule = _ngModule;\n      }\n      Object.defineProperty(ModuleBoundCompiler.prototype, \"_injector\", {\n          get: function () { return this._delegate.injector; },\n          enumerable: true,\n          configurable: true\n      });\n      ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {\n          return this._delegate.compileModuleSync(moduleType);\n      };\n      ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {\n          return this._delegate.compileModuleAsync(moduleType);\n      };\n      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n          return this._delegate.compileModuleAndAllComponentsSync(moduleType);\n      };\n      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n          return this._delegate.compileModuleAndAllComponentsAsync(moduleType);\n      };\n      /**\n       * Clears all caches\n       */\n      ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };\n      /**\n       * Clears the cache for the given component/ngModule.\n       */\n      ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };\n      return ModuleBoundCompiler;\n  }());\n\n  // =================================================================================================\n  // =================================================================================================\n  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n  // =================================================================================================\n  // =================================================================================================\n  //\n  //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n  //                               Reach out to mprobst for details.\n  //\n  // =================================================================================================\n  /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */\n  var SECURITY_SCHEMA = {};\n  function registerContext(ctx, specs) {\n      for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n          var spec = specs_1[_i];\n          SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n      }\n  }\n  // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n  registerContext(_angular_core.SecurityContext.HTML, [\n      'iframe|srcdoc',\n      '*|innerHTML',\n      '*|outerHTML',\n  ]);\n  registerContext(_angular_core.SecurityContext.STYLE, ['*|style']);\n  // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n  registerContext(_angular_core.SecurityContext.URL, [\n      '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n      'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n      'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n      'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n  ]);\n  registerContext(_angular_core.SecurityContext.RESOURCE_URL, [\n      'applet|code',\n      'applet|codebase',\n      'base|href',\n      'embed|src',\n      'frame|src',\n      'head|profile',\n      'html|manifest',\n      'iframe|src',\n      'link|href',\n      'media|src',\n      'object|codebase',\n      'object|data',\n      'script|src',\n  ]);\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  var __extends$21 = (this && this.__extends) || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      function __() { this.constructor = d; }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  var BOOLEAN = 'boolean';\n  var NUMBER = 'number';\n  var STRING = 'string';\n  var OBJECT = 'object';\n  /**\n   * This array represents the DOM schema. It encodes inheritance, properties, and events.\n   *\n   * ## Overview\n   *\n   * Each line represents one kind of element. The `element_inheritance` and properties are joined\n   * using `element_inheritance|properties` syntax.\n   *\n   * ## Element Inheritance\n   *\n   * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n   * Here the individual elements are separated by `,` (commas). Every element in the list\n   * has identical properties.\n   *\n   * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n   * specified then `\"\"` (blank) element is assumed.\n   *\n   * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n   * elements.\n   *\n   * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n   *\n   * ## Properties\n   *\n   * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n   * by a special character designating its type:\n   *\n   * - (no prefix): property is a string.\n   * - `*`: property represents an event.\n   * - `!`: property is a boolean.\n   * - `#`: property is a number.\n   * - `%`: property is an object.\n   *\n   * ## Query\n   *\n   * The class creates an internal squas representation which allows to easily answer the query of\n   * if a given property exist on a given element.\n   *\n   * NOTE: We don't yet support querying for types or events.\n   * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n   *       see dom_element_schema_registry_spec.ts\n   */\n  // =================================================================================================\n  // =================================================================================================\n  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n  // =================================================================================================\n  // =================================================================================================\n  //\n  //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n  //\n  // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n  // dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n  //\n  // =================================================================================================\n  var SCHEMA = [\n      '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',\n      '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n      'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n      'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',\n      ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n      ':svg:graphics^:svg:|',\n      ':svg:animation^:svg:|*begin,*end,*repeat',\n      ':svg:geometry^:svg:|',\n      ':svg:componentTransferFunction^:svg:|',\n      ':svg:gradient^:svg:|',\n      ':svg:textContent^:svg:graphics|',\n      ':svg:textPositioning^:svg:textContent|',\n      'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n      'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',\n      'audio^media|',\n      'br^[HTMLElement]|clear',\n      'base^[HTMLElement]|href,target',\n      'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n      'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n      'canvas^[HTMLElement]|#height,#width',\n      'content^[HTMLElement]|select',\n      'dl^[HTMLElement]|!compact',\n      'datalist^[HTMLElement]|',\n      'details^[HTMLElement]|!open',\n      'dialog^[HTMLElement]|!open,returnValue',\n      'dir^[HTMLElement]|!compact',\n      'div^[HTMLElement]|align',\n      'embed^[HTMLElement]|align,height,name,src,type,width',\n      'fieldset^[HTMLElement]|!disabled,name',\n      'font^[HTMLElement]|color,face,size',\n      'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n      'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n      'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n      'hr^[HTMLElement]|align,color,!noShade,size,width',\n      'head^[HTMLElement]|',\n      'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n      'html^[HTMLElement]|version',\n      'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n      'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n      'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n      'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',\n      'li^[HTMLElement]|type,#value',\n      'label^[HTMLElement]|htmlFor',\n      'legend^[HTMLElement]|align',\n      'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',\n      'map^[HTMLElement]|name',\n      'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n      'menu^[HTMLElement]|!compact',\n      'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n      'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n      'ins,del^[HTMLElement]|cite,dateTime',\n      'ol^[HTMLElement]|!compact,!reversed,#start,type',\n      'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n      'optgroup^[HTMLElement]|!disabled,label',\n      'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n      'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n      'p^[HTMLElement]|align',\n      'param^[HTMLElement]|name,type,value,valueType',\n      'picture^[HTMLElement]|',\n      'pre^[HTMLElement]|#width',\n      'progress^[HTMLElement]|#max,#value',\n      'q,blockquote,cite^[HTMLElement]|',\n      'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n      'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n      'shadow^[HTMLElement]|',\n      'source^[HTMLElement]|media,sizes,src,srcset,type',\n      'span^[HTMLElement]|',\n      'style^[HTMLElement]|!disabled,media,type',\n      'caption^[HTMLElement]|align',\n      'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n      'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n      'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n      'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n      'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n      'template^[HTMLElement]|',\n      'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n      'title^[HTMLElement]|text',\n      'track^[HTMLElement]|!default,kind,label,src,srclang',\n      'ul^[HTMLElement]|!compact,type',\n      'unknown^[HTMLElement]|',\n      'video^media|#height,poster,#width',\n      ':svg:a^:svg:graphics|',\n      ':svg:animate^:svg:animation|',\n      ':svg:animateMotion^:svg:animation|',\n      ':svg:animateTransform^:svg:animation|',\n      ':svg:circle^:svg:geometry|',\n      ':svg:clipPath^:svg:graphics|',\n      ':svg:cursor^:svg:|',\n      ':svg:defs^:svg:graphics|',\n      ':svg:desc^:svg:|',\n      ':svg:discard^:svg:|',\n      ':svg:ellipse^:svg:geometry|',\n      ':svg:feBlend^:svg:|',\n      ':svg:feColorMatrix^:svg:|',\n      ':svg:feComponentTransfer^:svg:|',\n      ':svg:feComposite^:svg:|',\n      ':svg:feConvolveMatrix^:svg:|',\n      ':svg:feDiffuseLighting^:svg:|',\n      ':svg:feDisplacementMap^:svg:|',\n      ':svg:feDistantLight^:svg:|',\n      ':svg:feDropShadow^:svg:|',\n      ':svg:feFlood^:svg:|',\n      ':svg:feFuncA^:svg:componentTransferFunction|',\n      ':svg:feFuncB^:svg:componentTransferFunction|',\n      ':svg:feFuncG^:svg:componentTransferFunction|',\n      ':svg:feFuncR^:svg:componentTransferFunction|',\n      ':svg:feGaussianBlur^:svg:|',\n      ':svg:feImage^:svg:|',\n      ':svg:feMerge^:svg:|',\n      ':svg:feMergeNode^:svg:|',\n      ':svg:feMorphology^:svg:|',\n      ':svg:feOffset^:svg:|',\n      ':svg:fePointLight^:svg:|',\n      ':svg:feSpecularLighting^:svg:|',\n      ':svg:feSpotLight^:svg:|',\n      ':svg:feTile^:svg:|',\n      ':svg:feTurbulence^:svg:|',\n      ':svg:filter^:svg:|',\n      ':svg:foreignObject^:svg:graphics|',\n      ':svg:g^:svg:graphics|',\n      ':svg:image^:svg:graphics|',\n      ':svg:line^:svg:geometry|',\n      ':svg:linearGradient^:svg:gradient|',\n      ':svg:mpath^:svg:|',\n      ':svg:marker^:svg:|',\n      ':svg:mask^:svg:|',\n      ':svg:metadata^:svg:|',\n      ':svg:path^:svg:geometry|',\n      ':svg:pattern^:svg:|',\n      ':svg:polygon^:svg:geometry|',\n      ':svg:polyline^:svg:geometry|',\n      ':svg:radialGradient^:svg:gradient|',\n      ':svg:rect^:svg:geometry|',\n      ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n      ':svg:script^:svg:|type',\n      ':svg:set^:svg:animation|',\n      ':svg:stop^:svg:|',\n      ':svg:style^:svg:|!disabled,media,title,type',\n      ':svg:switch^:svg:graphics|',\n      ':svg:symbol^:svg:|',\n      ':svg:tspan^:svg:textPositioning|',\n      ':svg:text^:svg:textPositioning|',\n      ':svg:textPath^:svg:textContent|',\n      ':svg:title^:svg:|',\n      ':svg:use^:svg:graphics|',\n      ':svg:view^:svg:|#zoomAndPan',\n      'data^[HTMLElement]|value',\n      'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n      'summary^[HTMLElement]|',\n      'time^[HTMLElement]|dateTime',\n  ];\n  var _ATTR_TO_PROP = {\n      'class': 'className',\n      'for': 'htmlFor',\n      'formaction': 'formAction',\n      'innerHtml': 'innerHTML',\n      'readonly': 'readOnly',\n      'tabindex': 'tabIndex',\n  };\n  var DomElementSchemaRegistry = (function (_super) {\n      __extends$21(DomElementSchemaRegistry, _super);\n      function DomElementSchemaRegistry() {\n          var _this = this;\n          _super.call(this);\n          this._schema = {};\n          SCHEMA.forEach(function (encodedType) {\n              var type = {};\n              var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];\n              var properties = strProperties.split(',');\n              var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];\n              typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });\n              var superType = superName && _this._schema[superName.toLowerCase()];\n              if (superType) {\n                  Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });\n              }\n              properties.forEach(function (property) {\n                  if (property.length > 0) {\n                      switch (property[0]) {\n                          case '*':\n                              // We don't yet support events.\n                              // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                              // will\n                              // almost certainly introduce bad XSS vulnerabilities.\n                              // type[property.substring(1)] = EVENT;\n                              break;\n                          case '!':\n                              type[property.substring(1)] = BOOLEAN;\n                              break;\n                          case '#':\n                              type[property.substring(1)] = NUMBER;\n                              break;\n                          case '%':\n                              type[property.substring(1)] = OBJECT;\n                              break;\n                          default:\n                              type[property] = STRING;\n                      }\n                  }\n              });\n          });\n      }\n      DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {\n          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {\n              return true;\n          }\n          if (tagName.indexOf('-') > -1) {\n              if (tagName === 'ng-container' || tagName === 'ng-content') {\n                  return false;\n              }\n              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {\n                  // Can't tell now as we don't know which properties a custom element will get\n                  // once it is instantiated\n                  return true;\n              }\n          }\n          var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n          return !!elementProperties[propName];\n      };\n      DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {\n          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {\n              return true;\n          }\n          if (tagName.indexOf('-') > -1) {\n              if (tagName === 'ng-container' || tagName === 'ng-content') {\n                  return true;\n              }\n              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {\n                  // Allow any custom elements\n                  return true;\n              }\n          }\n          return !!this._schema[tagName.toLowerCase()];\n      };\n      /**\n       * securityContext returns the security context for the given property on the given DOM tag.\n       *\n       * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n       * possible to bind a value into a changing attribute or tag name.\n       *\n       * The filtering is white list based. All attributes in the schema above are assumed to have the\n       * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known\n       * attack vectors are assigned their appropriate context.\n       */\n      DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {\n          if (isAttribute) {\n              // NB: For security purposes, use the mapped property name, not the attribute name.\n              propName = this.getMappedPropName(propName);\n          }\n          // Make sure comparisons are case insensitive, so that case differences between attribute and\n          // property names do not have a security impact.\n          tagName = tagName.toLowerCase();\n          propName = propName.toLowerCase();\n          var ctx = SECURITY_SCHEMA[tagName + '|' + propName];\n          if (ctx) {\n              return ctx;\n          }\n          ctx = SECURITY_SCHEMA['*|' + propName];\n          return ctx ? ctx : _angular_core.SecurityContext.NONE;\n      };\n      DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };\n      DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };\n      DomElementSchemaRegistry.prototype.validateProperty = function (name) {\n          if (name.toLowerCase().startsWith('on')) {\n              var msg = (\"Binding to event property '\" + name + \"' is disallowed for security reasons, \") +\n                  (\"please use (\" + name.slice(2) + \")=...\") +\n                  (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\n                  \" current module.\";\n              return { error: true, msg: msg };\n          }\n          else {\n              return { error: false };\n          }\n      };\n      DomElementSchemaRegistry.prototype.validateAttribute = function (name) {\n          if (name.toLowerCase().startsWith('on')) {\n              var msg = (\"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \") +\n                  (\"please use (\" + name.slice(2) + \")=...\");\n              return { error: true, msg: msg };\n          }\n          else {\n              return { error: false };\n          }\n      };\n      DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };\n      DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {\n          return dashCaseToCamelCase(propName);\n      };\n      DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {\n          var unit = '';\n          var strVal = val.toString().trim();\n          var errorMsg = null;\n          if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n              if (typeof val === 'number') {\n                  unit = 'px';\n              }\n              else {\n                  var valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                  if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                      errorMsg = \"Please provide a CSS unit value for \" + userProvidedProp + \":\" + val;\n                  }\n              }\n          }\n          return { error: errorMsg, value: strVal + unit };\n      };\n      DomElementSchemaRegistry.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      DomElementSchemaRegistry.ctorParameters = [];\n      return DomElementSchemaRegistry;\n  }(ElementSchemaRegistry));\n  function _isPixelDimensionStyle(prop) {\n      switch (prop) {\n          case 'width':\n          case 'height':\n          case 'minWidth':\n          case 'minHeight':\n          case 'maxWidth':\n          case 'maxHeight':\n          case 'left':\n          case 'top':\n          case 'bottom':\n          case 'right':\n          case 'fontSize':\n          case 'outlineWidth':\n          case 'outlineOffset':\n          case 'paddingTop':\n          case 'paddingLeft':\n          case 'paddingBottom':\n          case 'paddingRight':\n          case 'marginTop':\n          case 'marginLeft':\n          case 'marginBottom':\n          case 'marginRight':\n          case 'borderRadius':\n          case 'borderWidth':\n          case 'borderTopWidth':\n          case 'borderLeftWidth':\n          case 'borderRightWidth':\n          case 'borderBottomWidth':\n          case 'textIndent':\n              return true;\n          default:\n              return false;\n      }\n  }\n\n  var _NO_RESOURCE_LOADER = {\n      get: function (url) {\n          throw new Error(\"No ResourceLoader implementation has been provided. Can't read the url \\\"\" + url + \"\\\"\");\n      }\n  };\n  /**\n   * A set of providers that provide `RuntimeCompiler` and its dependencies to use for\n   * template compilation.\n   */\n  var COMPILER_PROVIDERS = [\n      { provide: Reflector, useValue: reflector },\n      { provide: ReflectorReader, useExisting: Reflector },\n      { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },\n      Console,\n      Lexer,\n      Parser,\n      HtmlParser,\n      {\n          provide: I18NHtmlParser,\n          useFactory: function (parser, translations, format) {\n              return new I18NHtmlParser(parser, translations, format);\n          },\n          deps: [\n              HtmlParser,\n              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS)],\n              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS_FORMAT)],\n          ]\n      },\n      TemplateParser,\n      DirectiveNormalizer,\n      CompileMetadataResolver,\n      DEFAULT_PACKAGE_URL_PROVIDER,\n      StyleCompiler,\n      ViewCompiler,\n      NgModuleCompiler,\n      DirectiveWrapperCompiler,\n      { provide: CompilerConfig, useValue: new CompilerConfig() },\n      RuntimeCompiler,\n      { provide: _angular_core.Compiler, useExisting: RuntimeCompiler },\n      DomElementSchemaRegistry,\n      { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },\n      UrlResolver,\n      DirectiveResolver,\n      PipeResolver,\n      NgModuleResolver,\n      AnimationParser\n  ];\n  var RuntimeCompilerFactory = (function () {\n      function RuntimeCompilerFactory(defaultOptions) {\n          this._defaultOptions = [{\n                  useDebug: _angular_core.isDevMode(),\n                  useJit: true,\n                  defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated\n              }].concat(defaultOptions);\n      }\n      RuntimeCompilerFactory.prototype.createCompiler = function (options) {\n          if (options === void 0) { options = []; }\n          var mergedOptions = _mergeOptions(this._defaultOptions.concat(options));\n          var injector = _angular_core.ReflectiveInjector.resolveAndCreate([\n              COMPILER_PROVIDERS, {\n                  provide: CompilerConfig,\n                  useFactory: function () {\n                      return new CompilerConfig({\n                          // let explicit values from the compiler options overwrite options\n                          // from the app providers. E.g. important for the testing platform.\n                          genDebugInfo: mergedOptions.useDebug,\n                          // let explicit values from the compiler options overwrite options\n                          // from the app providers\n                          useJit: mergedOptions.useJit,\n                          // let explicit values from the compiler options overwrite options\n                          // from the app providers\n                          defaultEncapsulation: mergedOptions.defaultEncapsulation,\n                          logBindingUpdate: mergedOptions.useDebug\n                      });\n                  },\n                  deps: []\n              },\n              mergedOptions.providers\n          ]);\n          return injector.get(_angular_core.Compiler);\n      };\n      RuntimeCompilerFactory.decorators = [\n          { type: _angular_core.Injectable },\n      ];\n      /** @nocollapse */\n      RuntimeCompilerFactory.ctorParameters = [\n          { type: Array, decorators: [{ type: _angular_core.Inject, args: [_angular_core.COMPILER_OPTIONS,] },] },\n      ];\n      return RuntimeCompilerFactory;\n  }());\n  function _initReflector() {\n      reflector.reflectionCapabilities = new ReflectionCapabilities();\n  }\n  /**\n   * A platform that included corePlatform and the compiler.\n   *\n   * @experimental\n   */\n  var platformCoreDynamic = _angular_core.createPlatformFactory(_angular_core.platformCore, 'coreDynamic', [\n      { provide: _angular_core.COMPILER_OPTIONS, useValue: {}, multi: true },\n      { provide: _angular_core.CompilerFactory, useClass: RuntimeCompilerFactory },\n      { provide: _angular_core.PLATFORM_INITIALIZER, useValue: _initReflector, multi: true },\n  ]);\n  function _mergeOptions(optionsArr) {\n      return {\n          useDebug: _lastDefined(optionsArr.map(function (options) { return options.useDebug; })),\n          useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),\n          defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),\n          providers: _mergeArrays(optionsArr.map(function (options) { return options.providers; }))\n      };\n  }\n  function _lastDefined(args) {\n      for (var i = args.length - 1; i >= 0; i--) {\n          if (args[i] !== undefined) {\n              return args[i];\n          }\n      }\n      return undefined;\n  }\n  function _mergeArrays(parts) {\n      var result = [];\n      parts.forEach(function (part) { return part && result.push.apply(result, part); });\n      return result;\n  }\n\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n  // asset:<package-name>/<realm>/<path-to-module>\n  var _ASSET_URL_RE = /asset:([^\\/]+)\\/([^\\/]+)\\/(.+)/;\n  /**\n   * Interface that defines how import statements should be generated.\n   */\n  var ImportGenerator = (function () {\n      function ImportGenerator() {\n      }\n      ImportGenerator.parseAssetUrl = function (url) { return AssetUrl.parse(url); };\n      return ImportGenerator;\n  }());\n  var AssetUrl = (function () {\n      function AssetUrl(packageName, firstLevelDir, modulePath) {\n          this.packageName = packageName;\n          this.firstLevelDir = firstLevelDir;\n          this.modulePath = modulePath;\n      }\n      AssetUrl.parse = function (url, allowNonMatching) {\n          if (allowNonMatching === void 0) { allowNonMatching = true; }\n          var match = url.match(_ASSET_URL_RE);\n          if (match !== null) {\n              return new AssetUrl(match[1], match[2], match[3]);\n          }\n          if (allowNonMatching) {\n              return null;\n          }\n          throw new Error(\"Url \" + url + \" is not a valid asset: url\");\n      };\n      return AssetUrl;\n  }());\n\n  exports.TEMPLATE_TRANSFORMS = TEMPLATE_TRANSFORMS;\n  exports.CompilerConfig = CompilerConfig;\n  exports.RenderTypes = RenderTypes;\n  exports.RuntimeCompiler = RuntimeCompiler;\n  exports.DirectiveResolver = DirectiveResolver;\n  exports.PipeResolver = PipeResolver;\n  exports.NgModuleResolver = NgModuleResolver;\n  exports.DEFAULT_INTERPOLATION_CONFIG = DEFAULT_INTERPOLATION_CONFIG;\n  exports.InterpolationConfig = InterpolationConfig;\n  exports.NgModuleCompiler = NgModuleCompiler;\n  exports.DirectiveWrapperCompiler = DirectiveWrapperCompiler;\n  exports.ViewCompiler = ViewCompiler;\n  exports.AnimationParser = AnimationParser;\n  exports.TextAst = TextAst;\n  exports.BoundTextAst = BoundTextAst;\n  exports.AttrAst = AttrAst;\n  exports.BoundElementPropertyAst = BoundElementPropertyAst;\n  exports.BoundEventAst = BoundEventAst;\n  exports.ReferenceAst = ReferenceAst;\n  exports.VariableAst = VariableAst;\n  exports.ElementAst = ElementAst;\n  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;\n  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;\n  exports.DirectiveAst = DirectiveAst;\n  exports.ProviderAst = ProviderAst;\n  exports.NgContentAst = NgContentAst;\n  exports.templateVisitAll = templateVisitAll;\n  exports.CompileMetadataWithIdentifier = CompileMetadataWithIdentifier;\n  exports.CompileAnimationEntryMetadata = CompileAnimationEntryMetadata;\n  exports.CompileAnimationStateMetadata = CompileAnimationStateMetadata;\n  exports.CompileAnimationStateDeclarationMetadata = CompileAnimationStateDeclarationMetadata;\n  exports.CompileAnimationStateTransitionMetadata = CompileAnimationStateTransitionMetadata;\n  exports.CompileAnimationMetadata = CompileAnimationMetadata;\n  exports.CompileAnimationKeyframesSequenceMetadata = CompileAnimationKeyframesSequenceMetadata;\n  exports.CompileAnimationStyleMetadata = CompileAnimationStyleMetadata;\n  exports.CompileAnimationAnimateMetadata = CompileAnimationAnimateMetadata;\n  exports.CompileAnimationWithStepsMetadata = CompileAnimationWithStepsMetadata;\n  exports.CompileAnimationSequenceMetadata = CompileAnimationSequenceMetadata;\n  exports.CompileAnimationGroupMetadata = CompileAnimationGroupMetadata;\n  exports.CompileIdentifierMetadata = CompileIdentifierMetadata;\n  exports.CompileDiDependencyMetadata = CompileDiDependencyMetadata;\n  exports.CompileProviderMetadata = CompileProviderMetadata;\n  exports.CompileFactoryMetadata = CompileFactoryMetadata;\n  exports.CompileTokenMetadata = CompileTokenMetadata;\n  exports.CompileTypeMetadata = CompileTypeMetadata;\n  exports.CompileQueryMetadata = CompileQueryMetadata;\n  exports.CompileStylesheetMetadata = CompileStylesheetMetadata;\n  exports.CompileTemplateMetadata = CompileTemplateMetadata;\n  exports.CompileDirectiveMetadata = CompileDirectiveMetadata;\n  exports.createHostComponentMeta = createHostComponentMeta;\n  exports.CompilePipeMetadata = CompilePipeMetadata;\n  exports.CompileNgModuleMetadata = CompileNgModuleMetadata;\n  exports.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;\n  exports.removeIdentifierDuplicates = removeIdentifierDuplicates;\n  exports.isStaticSymbol = isStaticSymbol;\n  exports.ProviderMeta = ProviderMeta;\n  exports.SourceModule = SourceModule;\n  exports.analyzeNgModules = analyzeNgModules;\n  exports.OfflineCompiler = OfflineCompiler;\n  exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;\n  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;\n  exports.DEFAULT_PACKAGE_URL_PROVIDER = DEFAULT_PACKAGE_URL_PROVIDER;\n  exports.UrlResolver = UrlResolver;\n  exports.getUrlScheme = getUrlScheme;\n  exports.ResourceLoader = ResourceLoader;\n  exports.COMPILER_PROVIDERS = COMPILER_PROVIDERS;\n  exports.RuntimeCompilerFactory = RuntimeCompilerFactory;\n  exports.platformCoreDynamic = platformCoreDynamic;\n  exports.ElementSchemaRegistry = ElementSchemaRegistry;\n  exports.I18NHtmlParser = I18NHtmlParser;\n  exports.MessageBundle = MessageBundle;\n  exports.Xliff = Xliff;\n  exports.Xmb = Xmb;\n  exports.Xtb = Xtb;\n  exports.DirectiveNormalizer = DirectiveNormalizer;\n  exports.Lexer = Lexer;\n  exports.Token = Token;\n  exports.EOF = EOF;\n  exports.isIdentifier = isIdentifier;\n  exports.isQuote = isQuote;\n  exports.SplitInterpolation = SplitInterpolation;\n  exports.TemplateBindingParseResult = TemplateBindingParseResult;\n  exports.Parser = Parser;\n  exports._ParseAST = _ParseAST;\n  exports.CompileMetadataResolver = CompileMetadataResolver;\n  exports.HtmlParser = HtmlParser;\n  exports.ParseTreeResult = ParseTreeResult;\n  exports.TreeError = TreeError;\n  exports.ImportGenerator = ImportGenerator;\n  exports.AssetUrl = AssetUrl;\n  exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;\n  exports.TypeScriptEmitter = TypeScriptEmitter;\n  exports.ParseLocation = ParseLocation;\n  exports.ParseSourceFile = ParseSourceFile;\n  exports.ParseSourceSpan = ParseSourceSpan;\n  exports.ParseError = ParseError;\n  exports.DomElementSchemaRegistry = DomElementSchemaRegistry;\n  exports.CssSelector = CssSelector;\n  exports.SelectorMatcher = SelectorMatcher;\n  exports.SelectorListContext = SelectorListContext;\n  exports.SelectorContext = SelectorContext;\n  exports.StylesCompileDependency = StylesCompileDependency;\n  exports.StylesCompileResult = StylesCompileResult;\n  exports.CompiledStylesheet = CompiledStylesheet;\n  exports.StyleCompiler = StyleCompiler;\n  exports.TemplateParseError = TemplateParseError;\n  exports.TemplateParseResult = TemplateParseResult;\n  exports.TemplateParser = TemplateParser;\n  exports.splitClasses = splitClasses;\n  exports.removeSummaryDuplicates = removeSummaryDuplicates;\n\n}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2NvbXBpbGVyL2J1bmRsZXMvY29tcGlsZXIudW1kLmpzPzlkZjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQ0FBK0M7QUFDdEYsQ0FBQyx5Q0FBeUM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHlDQUF5QztBQUN0RztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQseUNBQXlDO0FBQ3RHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBNEQsRUFBRTtBQUMxRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1RUFBdUUsRUFBRTtBQUNyRztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsNEJBQTRCLHFCQUFxQixFQUFFO0FBQ25EO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBEQUEwRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0VBQWtFO0FBQ3JFO0FBQ0Esb0NBQW9DLGtCQUFrQixrQkFB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Q0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQSxzREFBc0QsNkNBQTZDO0FBQ25HO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGdEQUFnRDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixhQUFhO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsMkNBQTJDO0FBQzFILHFGQUFxRixhQUFhO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQ0FBa0MsRUFBRTtBQUMzRTtBQUNBO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOENBQThDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhDQUE4QztBQUM1Riw4Q0FBOEMsOENBQThDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrREFBa0Q7QUFDcEcsK0NBQStDLCtDQUErQztBQUM5RixrREFBa0QseUVBQXlFO0FBQzNILG1EQUFtRCwwRUFBMEU7QUFDN0g7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBFQUEwRTtBQUM3SCxvREFBb0QsMkVBQTJFO0FBQy9ILG1EQUFtRCwwRUFBMEU7QUFDN0gsNkNBQTZDLDZDQUE2QztBQUMxRiw4Q0FBOEMsbUVBQW1FO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdDQUFnQyxFQUFFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsZ0NBQWdDLEVBQUU7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZCQUE2QjtBQUM1RSwrQ0FBK0Msb0RBQW9EO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlIO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx1RkFBdUY7QUFDbEcsV0FBVyx5RkFBeUY7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0VBQWtFLDBFQUEwRSxFQUFFO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxH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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGlEQUFpRCxFQUFFO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0JBQStCLEVBQUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYSxFQUFFO0FBQzFELDBDQUEwQyxhQUFhLEVBQUU7QUFDekQsZ0RBQWdELGFBQWEsRUFBRTtBQUMvRCxpREFBaUQsYUFBYSxFQUFFO0FBQ2hFLHFEQUFxRCxhQUFhLEVBQUU7QUFDcEUsa0RBQWtELGFBQWEsRUFBRTtBQUNqRSw4Q0FBOEMsNkJBQTZCLEVBQUU7QUFDN0UsK0NBQStDLGFBQWEsRUFBRTtBQUM5RCxpREFBaUQsYUFBYSxFQUFFO0FBQ2hFLCtDQUErQyxhQUFhLEVBQUU7QUFDOUQscURBQXFELGFBQWEsRUFBRTtBQUNwRSwrQ0FBK0Msa0NBQWtDLEVBQUU7QUFDbkYseUNBQXlDLGFBQWEsRUFBRTtBQUN4RCw4Q0FBOEMsYUFBYSxFQUFFO0FBQzdELGlEQUFpRCxrQ0FBa0MsRUFBRTtBQUNyRixrREFBa0QsYUFBYSxFQUFFO0FBQ2pFLDBDQUEwQyxhQUFhLEVBQUU7QUFDekQsbURBQW1ELHlDQUF5QyxFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0QkFBNEIsRUFBRTtBQUM1RTtBQUNBO0FBQ0EsMkNBQTJDLHdEQUF3RCxFQUFFO0FBQ3JHLDBDQUEwQyxjQUFjLEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGlEQUFpRCxhQUFhLEVBQUU7QUFDaEUscURBQXFELGNBQWMsRUFBRTtBQUNyRSxrREFBa0QseUNBQXlDLEVBQUU7QUFDN0YsOENBQThDLGNBQWMsRUFBRTtBQUM5RCwrQ0FBK0MsY0FBYyxFQUFFO0FBQy9ELGlEQUFpRCxhQUFhLEVBQUU7QUFDaEUsK0NBQStDLGFBQWEsRUFBRTtBQUM5RCxxREFBcUQsY0FBYyxFQUFFO0FBQ3JFLCtDQUErQyxhQUFhLEVBQUU7QUFDOUQseUNBQXlDLGFBQWEsRUFBRTtBQUN4RCw4Q0FBOEMsb0NBQW9DLEVBQUU7QUFDcEYsaURBQWlELGNBQWMsRUFBRTtBQUNqRSxrREFBa0QsY0FBYyxFQUFFO0FBQ2xFLDBDQUEwQyxjQUFjLEVBQUU7QUFDMUQsbURBQW1ELGFBQWEsRUFBRTtBQUNsRSxxREFBcUQsY0FBYztBQUNuRSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdDQUF3Qyx5Q0FBeUMsRUFBRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxhQUFhO0FBQzFGLGdFQUFnRSxhQUFhO0FBQzdFO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2QkFBNkIsRUFBRTtBQUM3RywrRUFBK0UsOEJBQThCLEVBQUU7QUFDL0csK0VBQStFLDhCQUE4QixFQUFFO0FBQy9HLGlGQUFpRixnQ0FBZ0MsRUFBRTtBQUNuSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw2QkFBNkI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDRCQUE0QixFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw2Q0FBNkMsRUFBRTtBQUNwSCwwQkFBMEIseURBQXlEO0FBQ25GLFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3RUFBd0U7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdEQUF3RCxFQUFFO0FBQ3BILHdEQUF3RCxzREFBc0QsRUFBRTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLEVBQUU7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsa0VBQWtFO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwREFBMEQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx1QkFBdUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsNkRBQTZELHNFQUFzRSxFQUFFO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0MsMkVBQTJFLEVBQUUsRUFBRSxFQUFFO0FBQ2xLO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUNBQXVDLEVBQUU7QUFDckY7QUFDQSxzREFBc0QsdUNBQXVDLEVBQUU7QUFDL0YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdFQUF3RSxpREFBaUQscUNBQXFDLEVBQUUsRUFBRSxFQUFFO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZGQUE2Riw4Q0FBOEMsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0VBQXdFLEVBQUU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LHNEQUFzRCwwREFBMEQsRUFBRTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHdCQUF3QixFQUFFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDJFQUEyRSxvREFBb0QsOERBQThELEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMxUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyRUFBMkUsRUFBRTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQyxzRUFBc0UsSUFBSTtBQUNySDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRUFBaUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBDQUEwQztBQUM3QztBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQkFBMkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0VBQWdFLEVBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkJBQTJCLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4yLjBcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuY29tcGlsZXIgPSBnbG9iYWwubmcuY29tcGlsZXIgfHwge30pLGdsb2JhbC5uZy5jb3JlKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgLyoqXG4gICAqIEEgc2VnbWVudCBvZiB0ZXh0IHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgVGV4dEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIFRleHRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGJvdW5kIGV4cHJlc3Npb24gd2l0aGluIHRoZSB0ZXh0IG9mIGEgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgQm91bmRUZXh0QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJvdW5kVGV4dEFzdCh2YWx1ZSwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBCb3VuZFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJvdW5kVGV4dCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQm91bmRUZXh0QXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSBwbGFpbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAgICovXG4gIHZhciBBdHRyQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEF0dHJBc3QobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQXR0ckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHIodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gQXR0ckFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBwcm9wZXJ0eSAoZS5nLiBgW3Byb3BlcnR5XT1cImV4cHJlc3Npb25cImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIChlLmcuXG4gICAqIGBbQHRyaWdnZXJdPVwic3RhdGVFeHBcImApXG4gICAqL1xuICB2YXIgQm91bmRFbGVtZW50UHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQm91bmRFbGVtZW50UHJvcGVydHlBc3QobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCBuZWVkc1J1bnRpbWVTZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICAgIHRoaXMubmVlZHNSdW50aW1lU2VjdXJpdHlDb250ZXh0ID0gbmVlZHNSdW50aW1lU2VjdXJpdHlDb250ZXh0O1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBldmVudCAoZS5nLiBgKGV2ZW50KT1cImhhbmRsZXIoKVwiYCkgb3IgYW4gYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgKGUuZy5cbiAgICogYChAdHJpZ2dlci5waGFzZSk9XCJjYWxsYmFjaygkZXZlbnQpXCJgKS5cbiAgICovXG4gIHZhciBCb3VuZEV2ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJvdW5kRXZlbnRBc3QobmFtZSwgdGFyZ2V0LCBwaGFzZSwgaGFuZGxlciwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEJvdW5kRXZlbnRBc3QuY2FsY0Z1bGxOYW1lID0gZnVuY3Rpb24gKG5hbWUsIHRhcmdldCwgcGhhc2UpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQgKyBcIjpcIiArIG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHBoYXNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIkBcIiArIG5hbWUgKyBcIi5cIiArIHBoYXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEV2ZW50QXN0LnByb3RvdHlwZSwgXCJmdWxsTmFtZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCb3VuZEV2ZW50QXN0LmNhbGNGdWxsTmFtZSh0aGlzLm5hbWUsIHRoaXMudGFyZ2V0LCB0aGlzLnBoYXNlKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRFdmVudEFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLnBoYXNlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBCb3VuZEV2ZW50QXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSByZWZlcmVuY2UgZGVjbGFyYXRpb24gb24gYW4gZWxlbWVudCAoZS5nLiBgbGV0IHNvbWVOYW1lPVwiZXhwcmVzc2lvblwiYCkuXG4gICAqL1xuICB2YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBvbiBhIDx0ZW1wbGF0ZT4gKGUuZy4gYHZhci1zb21lTmFtZT1cInNvbWVMb2NhbE5hbWVcImApLlxuICAgKi9cbiAgdmFyIFZhcmlhYmxlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZhcmlhYmxlQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFZhcmlhYmxlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVmFyaWFibGVBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBbiBlbGVtZW50IGRlY2xhcmF0aW9uIGluIGEgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgRWxlbWVudEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbGVtZW50QXN0KG5hbWUsIGF0dHJzLCBpbnB1dHMsIG91dHB1dHMsIHJlZmVyZW5jZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEVsZW1lbnRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGA8dGVtcGxhdGU+YCBlbGVtZW50IGluY2x1ZGVkIGluIGFuIEFuZ3VsYXIgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRW1iZWRkZWRUZW1wbGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgZGlyZWN0aXZlIHByb3BlcnR5IHdpdGggYSBib3VuZCB2YWx1ZSAoZS5nLiBgKm5nSWY9XCJjb25kaXRpb25cIikuXG4gICAqL1xuICB2YXIgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0KGRpcmVjdGl2ZU5hbWUsIHRlbXBsYXRlTmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGRpcmVjdGl2ZSBkZWNsYXJlZCBvbiBhbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIERpcmVjdGl2ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuaG9zdEV2ZW50cyA9IGhvc3RFdmVudHM7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIHByb3ZpZGVyIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnRcbiAgICovXG4gIHZhciBQcm92aWRlckFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlckFzdCh0b2tlbiwgbXVsdGlQcm92aWRlciwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXJUeXBlLCBsaWZlY3ljbGVIb29rcywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xuICAgICAgICAgIHRoaXMuZWFnZXIgPSBlYWdlcjtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVyVHlwZSA9IHByb3ZpZGVyVHlwZTtcbiAgICAgICAgICB0aGlzLmxpZmVjeWNsZUhvb2tzID0gbGlmZWN5Y2xlSG9va3M7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFByb3ZpZGVyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gTm8gdmlzaXQgbWV0aG9kIGluIHRoZSB2aXNpdG9yIGZvciBub3cuLi5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvdmlkZXJBc3Q7XG4gIH0oKSk7XG4gIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlO1xuICAoZnVuY3Rpb24gKFByb3ZpZGVyQXN0VHlwZSkge1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlB1YmxpY1NlcnZpY2VcIl0gPSAwXSA9IFwiUHVibGljU2VydmljZVwiO1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlByaXZhdGVTZXJ2aWNlXCJdID0gMV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG4gICAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiQ29tcG9uZW50XCJdID0gMl0gPSBcIkNvbXBvbmVudFwiO1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIkRpcmVjdGl2ZVwiXSA9IDNdID0gXCJEaXJlY3RpdmVcIjtcbiAgICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJCdWlsdGluXCJdID0gNF0gPSBcIkJ1aWx0aW5cIjtcbiAgfSkoZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUgfHwgKGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlID0ge30pKTtcbiAgLyoqXG4gICAqIFBvc2l0aW9uIHdoZXJlIGNvbnRlbnQgaXMgdG8gYmUgcHJvamVjdGVkIChpbnN0YW5jZSBvZiBgPG5nLWNvbnRlbnQ+YCBpbiBhIHRlbXBsYXRlKS5cbiAgICovXG4gIHZhciBOZ0NvbnRlbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTmdDb250ZW50QXN0KGluZGV4LCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBFbnVtZXJhdGlvbiBvZiB0eXBlcyBvZiBwcm9wZXJ0eSBiaW5kaW5ncy5cbiAgICovXG4gIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZTtcbiAgKGZ1bmN0aW9uIChQcm9wZXJ0eUJpbmRpbmdUeXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbm9ybWFsIGJpbmRpbmcgdG8gYSBwcm9wZXJ0eSAoZS5nLiBgW3Byb3BlcnR5XT1cImV4cHJlc3Npb25cImApLlxuICAgICAgICovXG4gICAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJQcm9wZXJ0eVwiXSA9IDBdID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgLyoqXG4gICAgICAgKiBBIGJpbmRpbmcgdG8gYW4gZWxlbWVudCBhdHRyaWJ1dGUgKGUuZy4gYFthdHRyLm5hbWVdPVwiZXhwcmVzc2lvblwiYCkuXG4gICAgICAgKi9cbiAgICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIkF0dHJpYnV0ZVwiXSA9IDFdID0gXCJBdHRyaWJ1dGVcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGEgQ1NTIGNsYXNzIChlLmcuIGBbY2xhc3MubmFtZV09XCJjb25kaXRpb25cImApLlxuICAgICAgICovXG4gICAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJDbGFzc1wiXSA9IDJdID0gXCJDbGFzc1wiO1xuICAgICAgLyoqXG4gICAgICAgKiBBIGJpbmRpbmcgdG8gYSBzdHlsZSBydWxlIChlLmcuIGBbc3R5bGUucnVsZV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiU3R5bGVcIl0gPSAzXSA9IFwiU3R5bGVcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGFuIGFuaW1hdGlvbiByZWZlcmVuY2UgKGUuZy4gYFthbmltYXRlLmtleV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiQW5pbWF0aW9uXCJdID0gNF0gPSBcIkFuaW1hdGlvblwiO1xuICB9KShleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUgfHwgKGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZSA9IHt9KSk7XG4gIC8qKlxuICAgKiBWaXNpdCBldmVyeSBub2RlIGluIGEgbGlzdCBvZiB7QGxpbmsgVGVtcGxhdGVBc3R9cyB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgVGVtcGxhdGVBc3RWaXNpdG9yfS5cbiAgICovXG4gIGZ1bmN0aW9uIHRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgYXN0cywgY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXRvci52aXNpdChhc3QsIGNvbnRleHQpIHx8IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfSA6XG4gICAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgYXN0UmVzdWx0ID0gdmlzaXQoYXN0KTtcbiAgICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFzdFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgJEVPRiA9IDA7XG4gIHZhciAkVEFCID0gOTtcbiAgdmFyICRMRiA9IDEwO1xuICB2YXIgJFZUQUIgPSAxMTtcbiAgdmFyICRGRiA9IDEyO1xuICB2YXIgJENSID0gMTM7XG4gIHZhciAkU1BBQ0UgPSAzMjtcbiAgdmFyICRCQU5HID0gMzM7XG4gIHZhciAkRFEgPSAzNDtcbiAgdmFyICRIQVNIID0gMzU7XG4gIHZhciAkJCA9IDM2O1xuICB2YXIgJFBFUkNFTlQgPSAzNztcbiAgdmFyICRBTVBFUlNBTkQgPSAzODtcbiAgdmFyICRTUSA9IDM5O1xuICB2YXIgJExQQVJFTiA9IDQwO1xuICB2YXIgJFJQQVJFTiA9IDQxO1xuICB2YXIgJFNUQVIgPSA0MjtcbiAgdmFyICRQTFVTID0gNDM7XG4gIHZhciAkQ09NTUEgPSA0NDtcbiAgdmFyICRNSU5VUyA9IDQ1O1xuICB2YXIgJFBFUklPRCA9IDQ2O1xuICB2YXIgJFNMQVNIID0gNDc7XG4gIHZhciAkQ09MT04gPSA1ODtcbiAgdmFyICRTRU1JQ09MT04gPSA1OTtcbiAgdmFyICRMVCA9IDYwO1xuICB2YXIgJEVRID0gNjE7XG4gIHZhciAkR1QgPSA2MjtcbiAgdmFyICRRVUVTVElPTiA9IDYzO1xuICB2YXIgJDAgPSA0ODtcbiAgdmFyICQ5ID0gNTc7XG4gIHZhciAkQSA9IDY1O1xuICB2YXIgJEUgPSA2OTtcbiAgdmFyICRGID0gNzA7XG4gIHZhciAkWCA9IDg4O1xuICB2YXIgJFogPSA5MDtcbiAgdmFyICRMQlJBQ0tFVCA9IDkxO1xuICB2YXIgJEJBQ0tTTEFTSCA9IDkyO1xuICB2YXIgJFJCUkFDS0VUID0gOTM7XG4gIHZhciAkQ0FSRVQgPSA5NDtcbiAgdmFyICRfID0gOTU7XG4gIHZhciAkYSA9IDk3O1xuICB2YXIgJGUgPSAxMDE7XG4gIHZhciAkZiA9IDEwMjtcbiAgdmFyICRuID0gMTEwO1xuICB2YXIgJHIgPSAxMTQ7XG4gIHZhciAkdCA9IDExNjtcbiAgdmFyICR1ID0gMTE3O1xuICB2YXIgJHYgPSAxMTg7XG4gIHZhciAkeCA9IDEyMDtcbiAgdmFyICR6ID0gMTIyO1xuICB2YXIgJExCUkFDRSA9IDEyMztcbiAgdmFyICRCQVIgPSAxMjQ7XG4gIHZhciAkUkJSQUNFID0gMTI1O1xuICB2YXIgJE5CU1AgPSAxNjA7XG4gIHZhciAkQlQgPSA5NjtcbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgICAgIHJldHVybiAoY29kZSA+PSAkVEFCICYmIGNvZGUgPD0gJFNQQUNFKSB8fCAoY29kZSA9PSAkTkJTUCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gICAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xuICB9XG4gIGZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJFo7XG4gIH1cbiAgZnVuY3Rpb24gaXNBc2NpaUhleERpZ2l0KGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJGYgfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRGIHx8IGlzRGlnaXQoY29kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgfVxuICB2YXIgU1RSSU5HX01BUF9QUk9UTyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG4gIGZ1bmN0aW9uIGlzU3RyaWN0U3RyaW5nTWFwKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gU1RSSU5HX01BUF9QUk9UTztcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLm5hbWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbiAgfVxuICB2YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBOdW1iZXJXcmFwcGVyLmlzTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIWlzTmFOKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgICByZXR1cm4gIWlzSnNPYmplY3Qob2JqKTtcbiAgfVxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAocykge1xuICAgICAgcmV0dXJuIHMucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0QXJyYXlPZlN0cmluZ3MoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICAgIGlmICghX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSB8fCBpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIHZhciBJTlRFUlBPTEFUSU9OX0JMQUNLTElTVF9SRUdFWFBTID0gW1xuICAgICAgL15cXHMqJC8sXG4gICAgICAvWzw+XS8sXG4gICAgICAvXlt7fV0kLyxcbiAgICAgIC8mKCN8W2Etel0pL2ksXG4gICAgICAvXlxcL1xcLy8sXG4gIF07XG4gIGZ1bmN0aW9uIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PSAyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXksIFtzdGFydCwgZW5kXS5cIik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBzdGFydF8xID0gdmFsdWVbMF07XG4gICAgICAgICAgdmFyIGVuZF8xID0gdmFsdWVbMV07XG4gICAgICAgICAgLy8gYmxhY2sgbGlzdCBjaGVja2luZ1xuICAgICAgICAgIElOVEVSUE9MQVRJT05fQkxBQ0tMSVNUX1JFR0VYUFMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChzdGFydF8xKSB8fCByZWdleHAudGVzdChlbmRfMSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlsnXCIgKyBzdGFydF8xICsgXCInLCAnXCIgKyBlbmRfMSArIFwiJ10gY29udGFpbnMgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2wuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH1cblxuICB2YXIgSW50ZXJwb2xhdGlvbkNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uQ29uZmlnKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXJzKSB7XG4gICAgICAgICAgaWYgKCFtYXJrZXJzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIG1hcmtlcnMpO1xuICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZyhtYXJrZXJzWzBdLCBtYXJrZXJzWzFdKTtcbiAgICAgIH07XG4gICAgICA7XG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgfSgpKTtcbiAgdmFyIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZygne3snLCAnfX0nKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIFBhcnNlckVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgdGhpcy5lcnJMb2NhdGlvbiA9IGVyckxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlBhcnNlciBFcnJvcjogXCIgKyBtZXNzYWdlICsgXCIgXCIgKyBlcnJMb2NhdGlvbiArIFwiIFtcIiArIGlucHV0ICsgXCJdIGluIFwiICsgY3R4TG9jYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG4gIH0oKSk7XG4gIHZhciBQYXJzZVNwYW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VTcGFuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VTcGFuO1xuICB9KCkpO1xuICB2YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFTVChzcGFuKSB7XG4gICAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgIH1cbiAgICAgIEFTVC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBU1QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0FTVCc7IH07XG4gICAgICByZXR1cm4gQVNUO1xuICB9KCkpO1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHF1b3RlZCBleHByZXNzaW9uIG9mIHRoZSBmb3JtOlxuICAgKlxuICAgKiBxdW90ZSA9IHByZWZpeCBgOmAgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25cbiAgICogcHJlZml4ID0gaWRlbnRpZmllclxuICAgKiB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGFyYml0cmFyeSBzdHJpbmdcbiAgICpcbiAgICogQSBxdW90ZWQgZXhwcmVzc2lvbiBpcyBtZWFudCB0byBiZSBwcmUtcHJvY2Vzc2VkIGJ5IGFuIEFTVCB0cmFuc2Zvcm1lciB0aGF0XG4gICAqIGNvbnZlcnRzIGl0IGludG8gYW5vdGhlciBBU1QgdGhhdCBubyBsb25nZXIgY29udGFpbnMgcXVvdGVkIGV4cHJlc3Npb25zLlxuICAgKiBJdCBpcyBtZWFudCB0byBhbGxvdyB0aGlyZC1wYXJ0eSBkZXZlbG9wZXJzIHRvIGV4dGVuZCBBbmd1bGFyIHRlbXBsYXRlXG4gICAqIGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFRoZSBgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25gIHBhcnQgb2YgdGhlIHF1b3RlIGlzXG4gICAqIHRoZXJlZm9yZSBub3QgaW50ZXJwcmV0ZWQgYnkgdGhlIEFuZ3VsYXIncyBvd24gZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAqL1xuICB2YXIgUXVvdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoUXVvdGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBRdW90ZShzcGFuLCBwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICAgIHRoaXMudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSB1bmludGVycHJldGVkRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB9XG4gICAgICBRdW90ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFF1b3RlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFF1b3RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdRdW90ZSc7IH07XG4gICAgICByZXR1cm4gUXVvdGU7XG4gIH0oQVNUKSk7XG4gIHZhciBFbXB0eUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoRW1wdHlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRW1wdHlFeHByKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgRW1wdHlFeHByLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1wdHlFeHByO1xuICB9KEFTVCkpO1xuICB2YXIgSW1wbGljaXRSZWNlaXZlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShJbXBsaWNpdFJlY2VpdmVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW1wbGljaXRSZWNlaXZlcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbXBsaWNpdFJlY2VpdmVyKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbXBsaWNpdFJlY2VpdmVyO1xuICB9KEFTVCkpO1xuICAvKipcbiAgICogTXVsdGlwbGUgZXhwcmVzc2lvbnMgc2VwYXJhdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICAgKi9cbiAgdmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENoYWluLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2hhaW4oc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICBDaGFpbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoYWluKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDaGFpbjtcbiAgfShBU1QpKTtcbiAgdmFyIENvbmRpdGlvbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWwoc3BhbiwgY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICAgIHRoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XG4gICAgICAgICAgdGhpcy5mYWxzZUV4cCA9IGZhbHNlRXhwO1xuICAgICAgfVxuICAgICAgQ29uZGl0aW9uYWwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29uZGl0aW9uYWw7XG4gIH0oQVNUKSk7XG4gIHZhciBQcm9wZXJ0eVJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbiAgfShBU1QpKTtcbiAgdmFyIFByb3BlcnR5V3JpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoUHJvcGVydHlXcml0ZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByb3BlcnR5V3JpdGUoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgUHJvcGVydHlXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5V3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XG4gIH0oQVNUKSk7XG4gIHZhciBTYWZlUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKFNhZmVQcm9wZXJ0eVJlYWQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBTYWZlUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZVByb3BlcnR5UmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbiAgfShBU1QpKTtcbiAgdmFyIEtleWVkUmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShLZXllZFJlYWQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIH1cbiAgICAgIEtleWVkUmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkUmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gS2V5ZWRSZWFkO1xuICB9KEFTVCkpO1xuICB2YXIgS2V5ZWRXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShLZXllZFdyaXRlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gS2V5ZWRXcml0ZShzcGFuLCBvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBLZXllZFdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZWRXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gS2V5ZWRXcml0ZTtcbiAgfShBU1QpKTtcbiAgdmFyIEJpbmRpbmdQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKEJpbmRpbmdQaXBlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQmluZGluZ1BpcGUoc3BhbiwgZXhwLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHAgPSBleHA7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgQmluZGluZ1BpcGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQaXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5kaW5nUGlwZTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxQcmltaXRpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoTGl0ZXJhbFByaW1pdGl2ZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUoc3BhbiwgdmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGl0ZXJhbFByaW1pdGl2ZTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShMaXRlcmFsQXJyYXksIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXkoc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICBMaXRlcmFsQXJyYXkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxBcnJheTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoTGl0ZXJhbE1hcCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIH1cbiAgICAgIExpdGVyYWxNYXAucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsTWFwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsTWFwO1xuICB9KEFTVCkpO1xuICB2YXIgSW50ZXJwb2xhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShJbnRlcnBvbGF0aW9uLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihzcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgfVxuICAgICAgSW50ZXJwb2xhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludGVycG9sYXRpb24odGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEludGVycG9sYXRpb247XG4gIH0oQVNUKSk7XG4gIHZhciBCaW5hcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQmluYXJ5LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQmluYXJ5KHNwYW4sIG9wZXJhdGlvbiwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgIH1cbiAgICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQmluYXJ5O1xuICB9KEFTVCkpO1xuICB2YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKFByZWZpeE5vdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByZWZpeE5vdChzcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIFByZWZpeE5vdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByZWZpeE5vdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJlZml4Tm90O1xuICB9KEFTVCkpO1xuICB2YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgbmFtZSwgYXJncykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTWV0aG9kQ2FsbDtcbiAgfShBU1QpKTtcbiAgdmFyIFNhZmVNZXRob2RDYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKFNhZmVNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgU2FmZU1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2FmZU1ldGhvZENhbGw7XG4gIH0oQVNUKSk7XG4gIHZhciBGdW5jdGlvbkNhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBGdW5jdGlvbkNhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbiAgfShBU1QpKTtcbiAgdmFyIEFTVFdpdGhTb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQVNUV2l0aFNvdXJjZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uLCBlcnJvcnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoc291cmNlKSA/IDAgOiBzb3VyY2UubGVuZ3RoKSk7XG4gICAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNvdXJjZSArIFwiIGluIFwiICsgdGhpcy5sb2NhdGlvbjsgfTtcbiAgICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xuICB9KEFTVCkpO1xuICB2YXIgVGVtcGxhdGVCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhzcGFuLCBrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLmtleUlzVmFyID0ga2V5SXNWYXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZztcbiAgfSgpKTtcbiAgdmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVjdXJzaXZlQXN0VmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5sZWZ0LnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC5yaWdodC52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpOyB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QudGFyZ2V0LnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5vYmoudmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMsIGNvbnRleHQpOyB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICByZXR1cm4gUmVjdXJzaXZlQXN0VmlzaXRvcjtcbiAgfSgpKTtcblxuICBleHBvcnRzLlRva2VuVHlwZTtcbiAgKGZ1bmN0aW9uIChUb2tlblR5cGUpIHtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDaGFyYWN0ZXJcIl0gPSAwXSA9IFwiQ2hhcmFjdGVyXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiSWRlbnRpZmllclwiXSA9IDFdID0gXCJJZGVudGlmaWVyXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiS2V5d29yZFwiXSA9IDJdID0gXCJLZXl3b3JkXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiU3RyaW5nXCJdID0gM10gPSBcIlN0cmluZ1wiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk9wZXJhdG9yXCJdID0gNF0gPSBcIk9wZXJhdG9yXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiTnVtYmVyXCJdID0gNV0gPSBcIk51bWJlclwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVycm9yXCJdID0gNl0gPSBcIkVycm9yXCI7XG4gIH0pKGV4cG9ydHMuVG9rZW5UeXBlIHx8IChleHBvcnRzLlRva2VuVHlwZSA9IHt9KSk7XG4gIHZhciBLRVlXT1JEUyA9IFsndmFyJywgJ2xldCcsICdudWxsJywgJ3VuZGVmaW5lZCcsICd0cnVlJywgJ2ZhbHNlJywgJ2lmJywgJ2Vsc2UnLCAndGhpcyddO1xuICB2YXIgTGV4ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTGV4ZXIoKSB7XG4gICAgICB9XG4gICAgICBMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgIHZhciBzY2FubmVyID0gbmV3IF9TY2FubmVyKHRleHQpO1xuICAgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICAgIHdoaWxlICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgfTtcbiAgICAgIExleGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIExleGVyLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICByZXR1cm4gTGV4ZXI7XG4gIH0oKSk7XG4gIHZhciBUb2tlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUb2tlbihpbmRleCwgdHlwZSwgbnVtVmFsdWUsIHN0clZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5udW1WYWx1ZSA9IG51bVZhbHVlO1xuICAgICAgICAgIHRoaXMuc3RyVmFsdWUgPSBzdHJWYWx1ZTtcbiAgICAgIH1cbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0NoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlO1xuICAgICAgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc051bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5OdW1iZXI7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuU3RyaW5nOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzT3BlcmF0b3IgPSBmdW5jdGlvbiAob3BlcmF0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yICYmIHRoaXMuc3RyVmFsdWUgPT0gb3BlcmF0ZXI7XG4gICAgICB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5JZGVudGlmaWVyOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2xldCc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkTnVsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ251bGwnOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICAgIH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVHJ1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RydWUnOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZEZhbHNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnZmFsc2UnOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd0aGlzJzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0Vycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLkVycm9yOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk51bWJlciA/IHRoaXMubnVtVmFsdWUgOiAtMTsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLkNoYXJhY3RlcjpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5JZGVudGlmaWVyOlxuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQ6XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3I6XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLkVycm9yOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gVG9rZW47XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIG5ld0NoYXJhY3RlclRva2VuKGluZGV4LCBjb2RlKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBleHBvcnRzLlRva2VuVHlwZS5DaGFyYWN0ZXIsIGNvZGUsIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld0lkZW50aWZpZXJUb2tlbihpbmRleCwgdGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZXhwb3J0cy5Ub2tlblR5cGUuSWRlbnRpZmllciwgMCwgdGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3S2V5d29yZFRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkLCAwLCB0ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBuZXdPcGVyYXRvclRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvciwgMCwgdGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3U3RyaW5nVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGV4cG9ydHMuVG9rZW5UeXBlLlN0cmluZywgMCwgdGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3TnVtYmVyVG9rZW4oaW5kZXgsIG4pIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGV4cG9ydHMuVG9rZW5UeXBlLk51bWJlciwgbiwgJycpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld0Vycm9yVG9rZW4oaW5kZXgsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGV4cG9ydHMuVG9rZW5UeXBlLkVycm9yLCAwLCBtZXNzYWdlKTtcbiAgfVxuICB2YXIgRU9GID0gbmV3IFRva2VuKC0xLCBleHBvcnRzLlRva2VuVHlwZS5DaGFyYWN0ZXIsIDAsICcnKTtcbiAgdmFyIF9TY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9TY2FubmVyKGlucHV0KSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICAgIHRoaXMucGVlayA9IDA7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgfVxuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5wZWVrID0gKyt0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoID8gJEVPRiA6IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQsIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgIHZhciBwZWVrID0gdGhpcy5wZWVrLCBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICAgIHdoaWxlIChwZWVrIDw9ICRTUEFDRSkge1xuICAgICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHBlZWsgPSAkRU9GO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWVrID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wZWVrID0gcGVlaztcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSGFuZGxlIGlkZW50aWZpZXJzIGFuZCBudW1iZXJzLlxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChwZWVrKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoaXNEaWdpdChwZWVrKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWJlcihpbmRleCk7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgc3dpdGNoIChwZWVrKSB7XG4gICAgICAgICAgICAgIGNhc2UgJFBFUklPRDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRGlnaXQodGhpcy5wZWVrKSA/IHRoaXMuc2Nhbk51bWJlcihzdGFydCkgOlxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCAkUEVSSU9EKTtcbiAgICAgICAgICAgICAgY2FzZSAkTFBBUkVOOlxuICAgICAgICAgICAgICBjYXNlICRSUEFSRU46XG4gICAgICAgICAgICAgIGNhc2UgJExCUkFDRTpcbiAgICAgICAgICAgICAgY2FzZSAkUkJSQUNFOlxuICAgICAgICAgICAgICBjYXNlICRMQlJBQ0tFVDpcbiAgICAgICAgICAgICAgY2FzZSAkUkJSQUNLRVQ6XG4gICAgICAgICAgICAgIGNhc2UgJENPTU1BOlxuICAgICAgICAgICAgICBjYXNlICRDT0xPTjpcbiAgICAgICAgICAgICAgY2FzZSAkU0VNSUNPTE9OOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNoYXJhY3RlcihzdGFydCwgcGVlayk7XG4gICAgICAgICAgICAgIGNhc2UgJFNROlxuICAgICAgICAgICAgICBjYXNlICREUTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgICAgY2FzZSAkSEFTSDpcbiAgICAgICAgICAgICAgY2FzZSAkUExVUzpcbiAgICAgICAgICAgICAgY2FzZSAkTUlOVVM6XG4gICAgICAgICAgICAgIGNhc2UgJFNUQVI6XG4gICAgICAgICAgICAgIGNhc2UgJFNMQVNIOlxuICAgICAgICAgICAgICBjYXNlICRQRVJDRU5UOlxuICAgICAgICAgICAgICBjYXNlICRDQVJFVDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSk7XG4gICAgICAgICAgICAgIGNhc2UgJFFVRVNUSU9OOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJz8nLCAkUEVSSU9ELCAnLicpO1xuICAgICAgICAgICAgICBjYXNlICRMVDpcbiAgICAgICAgICAgICAgY2FzZSAkR1Q6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICAgIGNhc2UgJEJBTkc6XG4gICAgICAgICAgICAgIGNhc2UgJEVROlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSwgJEVRLCAnPScsICRFUSwgJz0nKTtcbiAgICAgICAgICAgICAgY2FzZSAkQU1QRVJTQU5EOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJyYnLCAkQU1QRVJTQU5ELCAnJicpO1xuICAgICAgICAgICAgICBjYXNlICRCQVI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnfCcsICRCQVIsICd8Jyk7XG4gICAgICAgICAgICAgIGNhc2UgJE5CU1A6XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoaXNXaGl0ZXNwYWNlKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuVG9rZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBbXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspICsgXCJdXCIsIDApO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuQ2hhcmFjdGVyID0gZnVuY3Rpb24gKHN0YXJ0LCBjb2RlKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgcmV0dXJuIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCBjb2RlKTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBzdHIpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgc3RyKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFRva2VuaXplIGEgMi8zIGNoYXIgbG9uZyBvcGVyYXRvclxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBpbmRleCBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAgICogQHBhcmFtIG9uZSBmaXJzdCBzeW1ib2wgKGFsd2F5cyBwYXJ0IG9mIHRoZSBvcGVyYXRvcilcbiAgICAgICAqIEBwYXJhbSB0d29Db2RlIGNvZGUgcG9pbnQgZm9yIHRoZSBzZWNvbmQgc3ltYm9sXG4gICAgICAgKiBAcGFyYW0gdHdvIHNlY29uZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gdGhlIHNlY29uZCBjb2RlIHBvaW50IG1hdGNoZXMpXG4gICAgICAgKiBAcGFyYW0gdGhyZWVDb2RlIGNvZGUgcG9pbnQgZm9yIHRoZSB0aGlyZCBzeW1ib2xcbiAgICAgICAqIEBwYXJhbSB0aHJlZSB0aGlyZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gcHJvdmlkZWQgYW5kIG1hdGNoZXMgc291cmNlIGV4cHJlc3Npb24pXG4gICAgICAgKiBAcmV0dXJucyB7VG9rZW59XG4gICAgICAgKi9cbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuQ29tcGxleE9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBvbmUsIHR3b0NvZGUsIHR3bywgdGhyZWVDb2RlLCB0aHJlZSkge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBzdHIgPSBvbmU7XG4gICAgICAgICAgaWYgKHRoaXMucGVlayA9PSB0d29Db2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBzdHIgKz0gdHdvO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRocmVlQ29kZSkgJiYgdGhpcy5wZWVrID09IHRocmVlQ29kZSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgc3RyICs9IHRocmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgc3RyKTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbklkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBLRVlXT1JEUy5pbmRleE9mKHN0cikgPiAtMSA/IG5ld0tleXdvcmRUb2tlbihzdGFydCwgc3RyKSA6XG4gICAgICAgICAgICAgIG5ld0lkZW50aWZpZXJUb2tlbihzdGFydCwgc3RyKTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk51bWJlciA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICAgIHZhciBzaW1wbGUgPSAodGhpcy5pbmRleCA9PT0gc3RhcnQpO1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgZGlnaXQuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzRGlnaXQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PSAkUEVSSU9EKSB7XG4gICAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9uZW50U3RhcnQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNFeHBvbmVudFNpZ24odGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNEaWdpdCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIGV4cG9uZW50JywgLTEpO1xuICAgICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzaW1wbGUgPyBOdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4KHN0cikgOiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgICAgcmV0dXJuIG5ld051bWJlclRva2VuKHN0YXJ0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnBlZWs7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBxdW90ZS5cbiAgICAgICAgICB2YXIgYnVmZmVyID0gJyc7XG4gICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9IHF1b3RlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkQ29kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyA0IGNoYXJhY3RlciBoZXggY29kZSBmb3IgdW5pY29kZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhleCA9IGlucHV0LnN1YnN0cmluZyh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgvXlswLTlhLWZdKyQvaS50ZXN0KGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFtcXFxcdVwiICsgaGV4ICsgXCJdXCIsIDApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gdW5lc2NhcGUodGhpcy5wZWVrKTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlZENvZGUpO1xuICAgICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gJEVPRikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1VudGVybWluYXRlZCBxdW90ZScsIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxhc3QgPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCB0ZXJtaW5hdGluZyBxdW90ZS5cbiAgICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIGJ1ZmZlciArIGxhc3QpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBuZXdFcnJvclRva2VuKHBvc2l0aW9uLCBcIkxleGVyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBhdCBjb2x1bW4gXCIgKyBwb3NpdGlvbiArIFwiIGluIGV4cHJlc3Npb24gW1wiICsgdGhpcy5pbnB1dCArIFwiXVwiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1NjYW5uZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fFxuICAgICAgICAgIChjb2RlID09ICRfKSB8fCAoY29kZSA9PSAkJCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIoaW5wdXQpO1xuICAgICAgaWYgKCFpc0lkZW50aWZpZXJTdGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgICAgd2hpbGUgKHNjYW5uZXIucGVlayAhPT0gJEVPRikge1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgc2Nhbm5lci5hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiBpc0FzY2lpTGV0dGVyKGNvZGUpIHx8IGlzRGlnaXQoY29kZSkgfHwgKGNvZGUgPT0gJF8pIHx8XG4gICAgICAgICAgKGNvZGUgPT0gJCQpO1xuICB9XG4gIGZ1bmN0aW9uIGlzRXhwb25lbnRTdGFydChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PSAkZSB8fCBjb2RlID09ICRFO1xuICB9XG4gIGZ1bmN0aW9uIGlzRXhwb25lbnRTaWduKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID09ICRNSU5VUyB8fCBjb2RlID09ICRQTFVTO1xuICB9XG4gIGZ1bmN0aW9uIGlzUXVvdGUoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPT09ICRTUSB8fCBjb2RlID09PSAkRFEgfHwgY29kZSA9PT0gJEJUO1xuICB9XG4gIGZ1bmN0aW9uIHVuZXNjYXBlKGNvZGUpIHtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgJG46XG4gICAgICAgICAgICAgIHJldHVybiAkTEY7XG4gICAgICAgICAgY2FzZSAkZjpcbiAgICAgICAgICAgICAgcmV0dXJuICRGRjtcbiAgICAgICAgICBjYXNlICRyOlxuICAgICAgICAgICAgICByZXR1cm4gJENSO1xuICAgICAgICAgIGNhc2UgJHQ6XG4gICAgICAgICAgICAgIHJldHVybiAkVEFCO1xuICAgICAgICAgIGNhc2UgJHY6XG4gICAgICAgICAgICAgIHJldHVybiAkVlRBQjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBTcGxpdEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBTcGxpdEludGVycG9sYXRpb247XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCh0ZW1wbGF0ZUJpbmRpbmdzLCB3YXJuaW5ncywgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChjb25maWcpIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gZXNjYXBlUmVnRXhwKGNvbmZpZy5zdGFydCkgKyAnKFtcXFxcc1xcXFxTXSo/KScgKyBlc2NhcGVSZWdFeHAoY29uZmlnLmVuZCk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpO1xuICB9XG4gIHZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VyKF9sZXhlcikge1xuICAgICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWN0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpO1xuICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KSk7XG4gICAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgdHJ1ZSwgdGhpcy5lcnJvcnMsIGlucHV0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aClcbiAgICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTaW1wbGVCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrKGFzdCk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiSG9zdCBiaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gXCIgKyBlcnJvcnMuam9pbignICcpLCBpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZ0FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICAvLyBRdW90ZXMgZXhwcmVzc2lvbnMgdXNlIDNyZC1wYXJ0eSBleHByZXNzaW9uIGxhbmd1YWdlLiBXZSBkb24ndCB3YW50IHRvIHVzZVxuICAgICAgICAgIC8vIG91ciBsZXhlciBvciBwYXJzZXIgZm9yIHRoYXQsIHNvIHdlIGNoZWNrIGZvciB0aGF0IGFoZWFkIG9mIHRpbWUuXG4gICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5fcGFyc2VRdW90ZShpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVvdGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBxdW90ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgaW5wdXQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKVxuICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlUXVvdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgICAgaWYgKGlzQmxhbmsoaW5wdXQpKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgcHJlZml4U2VwYXJhdG9ySW5kZXggPSBpbnB1dC5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgaWYgKHByZWZpeFNlcGFyYXRvckluZGV4ID09IC0xKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gaW5wdXQuc3Vic3RyaW5nKDAsIHByZWZpeFNlcGFyYXRvckluZGV4KS50cmltKCk7XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXIocHJlZml4KSlcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gaW5wdXQuc3Vic3RyaW5nKHByZWZpeFNlcGFyYXRvckluZGV4ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCksIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChwcmVmaXhUb2tlbiwgaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKGlucHV0KTtcbiAgICAgICAgICBpZiAocHJlZml4VG9rZW4pIHtcbiAgICAgICAgICAgICAgLy8gUHJlZml4IHRoZSB0b2tlbnMgd2l0aCB0aGUgdG9rZW5zIGZyb20gcHJlZml4VG9rZW4gYnV0IGhhdmUgdGhlbSB0YWtlIG5vIHNwYWNlICgwIGluZGV4KS5cbiAgICAgICAgICAgICAgdmFyIHByZWZpeFRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHByZWZpeFRva2VuKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHQuaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0b2tlbnMudW5zaGlmdC5hcHBseSh0b2tlbnMsIHByZWZpeFRva2Vucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBpbnB1dC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgMClcbiAgICAgICAgICAgICAgLnBhcnNlVGVtcGxhdGVCaW5kaW5ncygpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLnNwbGl0SW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChzcGxpdCA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0LmV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBleHByZXNzaW9uVGV4dCA9IHNwbGl0LmV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgICB2YXIgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGV4cHJlc3Npb25UZXh0KTtcbiAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHRoaXMuX3N0cmlwQ29tbWVudHMoc3BsaXQuZXhwcmVzc2lvbnNbaV0pKTtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCBzcGxpdC5vZmZzZXRzW2ldICsgKGV4cHJlc3Npb25UZXh0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgSW50ZXJwb2xhdGlvbihuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoaW5wdXQpID8gMCA6IGlucHV0Lmxlbmd0aCksIHNwbGl0LnN0cmluZ3MsIGV4cHJlc3Npb25zKSwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5zcGxpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gaW5wdXQuc3BsaXQocmVnZXhwKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gZml4ZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGludGVycG9sYXRpb25Db25maWcuc3RhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHBhcnQubGVuZ3RoICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoJ0JsYW5rIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBpbnRlcnBvbGF0ZWQgc3RyaW5ncycsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIGksIGludGVycG9sYXRpb25Db25maWcpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgnJGltcGxpY3QnKTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLndyYXBMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoaW5wdXQpID8gMCA6IGlucHV0Lmxlbmd0aCksIGlucHV0KSwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fc3RyaXBDb21tZW50cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fY29tbWVudFN0YXJ0KGlucHV0KTtcbiAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGkpID8gaW5wdXQuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKSA6IGlucHV0O1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX2NvbW1lbnRTdGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJFNMQVNIICYmIG5leHRDaGFyID09ICRTTEFTSCAmJiBpc0JsYW5rKG91dGVyUXVvdGUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIGlmIChvdXRlclF1b3RlID09PSBjaGFyKSB7XG4gICAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc0JsYW5rKG91dGVyUXVvdGUpICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBjaGFyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX2NoZWNrTm9JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gaW5wdXQuc3BsaXQocmVnZXhwKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkdvdCBpbnRlcnBvbGF0aW9uIChcIiArIGludGVycG9sYXRpb25Db25maWcuc3RhcnQgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCArIFwiKSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZFwiLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCAxLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbiA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydEluRXJySWR4LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIGVyckxvY2F0aW9uID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0SW5FcnJJZHg7IGorKykge1xuICAgICAgICAgICAgICBlcnJMb2NhdGlvbiArPSBqICUgMiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICBwYXJ0c1tqXSA6XG4gICAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCArIHBhcnRzW2pdICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlcnJMb2NhdGlvbi5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IExleGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKSk7XG4gIHZhciBfUGFyc2VBU1QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBpbnB1dExlbmd0aCwgcGFyc2VBY3Rpb24sIGVycm9ycywgb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgICB0aGlzLmlucHV0TGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgICAgICAgdGhpcy5wYXJzZUFjdGlvbiA9IHBhcnNlQWN0aW9uO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkID0gMDtcbiAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkID0gMDtcbiAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCA9IDA7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBpIDwgdGhpcy50b2tlbnMubGVuZ3RoID8gdGhpcy50b2tlbnNbaV0gOiBFT0Y7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwibmV4dFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBlZWsoMCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwiaW5wdXRJbmRleFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyB0aGlzLm5leHQuaW5kZXggKyB0aGlzLm9mZnNldCA6XG4gICAgICAgICAgICAgICAgICB0aGlzLmlucHV0TGVuZ3RoICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNwYW4gPSBmdW5jdGlvbiAoc3RhcnQpIHsgcmV0dXJuIG5ldyBQYXJzZVNwYW4oc3RhcnQsIHRoaXMuaW5wdXRJbmRleCk7IH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5kZXgrKzsgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoY29kZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWtLZXl3b3JkTGV0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZExldCgpOyB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGNvZGUpKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsT3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICBpZiAodGhpcy5uZXh0LmlzT3BlcmF0b3Iob3ApKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3Iob3BlcmF0b3IpKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgXCIgKyBvcGVyYXRvcik7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xuICAgICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSkge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciBvciBrZXl3b3JkXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpICYmICFuLmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBuICsgXCIsIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIGNoYWluZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgIH0gLy8gcmVhZCBhbGwgc2VtaWNvbG9uc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHRoaXMubmV4dCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cHJzWzBdO1xuICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW4odGhpcy5zcGFuKHN0YXJ0KSwgZXhwcnMpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQaXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3wnKSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQ2Fubm90IGhhdmUgYSBwaXBlIGluIGFuIGFjdGlvbiBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0IC0gdGhpcy5vZmZzZXQpLCByZXN1bHQsIG5hbWVfMSwgYXJncyk7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbCgpOyB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxPcigpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz8nKSkge1xuICAgICAgICAgICAgICB2YXIgeWVzID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgdmFyIG5vID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiBcIiArIGV4cHJlc3Npb24gKyBcIiByZXF1aXJlcyBhbGwgMyBleHByZXNzaW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgIG5vID0gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5vID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKHRoaXMuc3BhbihzdGFydCksIHJlc3VsdCwgeWVzLCBubyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbE9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICd8fCdcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCd8fCcpKSB7XG4gICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgJ3x8JywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJyYmJ1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcmJicpKSB7XG4gICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksICcmJicsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFcXVhbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnPT0nLCchPScsJz09PScsJyE9PSdcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VSZWxhdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICc8JywgJz4nLCAnPD0nLCAnPj0nXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUFkZGl0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICcrJywgJy0nXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZU11bHRpcGxpY2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICcqJywgJyUnLCAnLydcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5uZXh0LnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIG5ldyBMaXRlcmFsUHJpbWl0aXZlKG5ldyBQYXJzZVNwYW4oc3RhcnQsIHN0YXJ0KSwgMCksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QodGhpcy5zcGFuKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGxDaGFpbigpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDYWxsQ2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFBFUklPRCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/LicpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgS2V5ZWRXcml0ZSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCByZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEtleWVkUmVhZCh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCByZXN1bHQsIGtleSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGdW5jdGlvbkNhbGwodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBhcmdzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByaW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZE51bGwoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVW5kZWZpbmVkKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVHJ1ZSgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRGYWxzZSgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVGhpcygpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucGFyc2VFeHByZXNzaW9uTGlzdCgkUkJSQUNLRVQpO1xuICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KHRoaXMuc3BhbihzdGFydCksIGVsZW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKCRMQlJBQ0UpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwobmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSksIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzTnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgICB2YXIgbGl0ZXJhbFZhbHVlID0gdGhpcy5uZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgbGl0ZXJhbFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb246IFwiICsgdGhpcy5pbnB1dCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyB0aGlzLm5leHQpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24gKHRlcm1pbmF0b3IpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgaWYgKCF0aGlzLm5leHQuaXNDaGFyYWN0ZXIodGVybWluYXRvcikpIHtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxpdGVyYWxNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRMQlJBQ0UpO1xuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkUkJSQUNFKSkge1xuICAgICAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwKHRoaXMuc3BhbihzdGFydCksIGtleXMsIHZhbHVlcyk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgaXNTYWZlKSB7XG4gICAgICAgICAgaWYgKGlzU2FmZSA9PT0gdm9pZCAwKSB7IGlzU2FmZSA9IGZhbHNlOyB9XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gcmVjZWl2ZXIuc3Bhbi5zdGFydDtcbiAgICAgICAgICB2YXIgaWQgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuc3BhbihzdGFydCk7XG4gICAgICAgICAgICAgIHJldHVybiBpc1NhZmUgPyBuZXcgU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIGlkLCBhcmdzKSA6XG4gICAgICAgICAgICAgICAgICBuZXcgTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgaWQsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVGhlIFxcJz8uXFwnIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluIHRoZSBhc3NpZ25tZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5ncyBjYW5ub3QgY29udGFpbiBhc3NpZ25tZW50cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVdyaXRlKHRoaXMuc3BhbihzdGFydCksIHJlY2VpdmVyLCBpZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbEFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKCRSUEFSRU4pKVxuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgdmFyIHBvc2l0aW9uYWxzID0gW107XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBwb3NpdGlvbmFscy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uYWxzO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQW4gaWRlbnRpZmllciwgYSBrZXl3b3JkLCBhIHN0cmluZyB3aXRoIGFuIG9wdGlvbmFsIGAtYCBpbmJldHdlZW4uXG4gICAgICAgKi9cbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgICB2YXIgb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XG4gICAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJy0nKTtcbiAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChvcGVyYXRvckZvdW5kKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGJpbmRpbmdzID0gW107XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG51bGw7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICB2YXIga2V5SXNWYXIgPSB0aGlzLnBlZWtLZXl3b3JkTGV0KCk7XG4gICAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICAgIGlmICgha2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IGtleTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCArIGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTik7XG4gICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZV8yID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWVfMiA9ICdcXCRpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0ICE9PSBFT0YgJiYgIXRoaXMucGVla0tleXdvcmRMZXQoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0XzEgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydF8xIC0gdGhpcy5vZmZzZXQsIHRoaXMuaW5wdXRJbmRleCAtIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgdGhpcy5sb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyh0aGlzLnNwYW4oc3RhcnQpLCBrZXksIGtleUlzVmFyLCBuYW1lXzIsIGV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdChiaW5kaW5ncywgd2FybmluZ3MsIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IobWVzc2FnZSwgdGhpcy5pbnB1dCwgdGhpcy5sb2NhdGlvblRleHQoaW5kZXgpLCB0aGlzLmxvY2F0aW9uKSk7XG4gICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5sb2NhdGlvblRleHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IG51bGw7IH1cbiAgICAgICAgICBpZiAoaXNCbGFuayhpbmRleCkpXG4gICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICByZXR1cm4gKGluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IFwiYXQgY29sdW1uIFwiICsgKHRoaXMudG9rZW5zW2luZGV4XS5pbmRleCArIDEpICsgXCIgaW5cIiA6XG4gICAgICAgICAgICAgIFwiYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvblwiO1xuICAgICAgfTtcbiAgICAgIC8vIEVycm9yIHJlY292ZXJ5IHNob3VsZCBza2lwIHRva2VucyB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgcmVjb3ZlcnkgcG9pbnQuIHNraXAoKSB0cmVhdHNcbiAgICAgIC8vIHRoZSBlbmQgb2YgaW5wdXQgYW5kIGEgJzsnIGFzIHVuY29uZGl0aW9uYWxseSBhIHJlY292ZXJ5IHBvaW50LiBJdCBhbHNvIHRyZWF0cyAnKScsXG4gICAgICAvLyAnfScgYW5kICddJyBhcyBjb25kaXRpb25hbCByZWNvdmVyeSBwb2ludHMgaWYgb25lIG9mIGNhbGxpbmcgcHJvZHVjdGlvbnMgaXMgZXhwZWN0aW5nXG4gICAgICAvLyBvbmUgb2YgdGhlc2Ugc3ltYm9scy4gVGhpcyBhbGxvd3Mgc2tpcCgpIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMgc3VjaCBhcyAnKGEuKSArIDEnIGFsbG93aW5nXG4gICAgICAvLyBtb3JlIG9mIHRoZSBBU1QgdG8gYmUgcmV0YWluZWQgKGl0IGRvZXNuJ3Qgc2tpcCBhbnkgdG9rZW5zIGFzIHRoZSAnKScgaXMgcmV0YWluZWQgYmVjYXVzZVxuICAgICAgLy8gb2YgdGhlICcoJyBiZWdpbnMgYW4gJygnIDxleHByPiAnKScgcHJvZHVjdGlvbikuIFRoZSByZWNvdmVyeSBwb2ludHMgb2YgZ3JvdXBpbmcgc3ltYm9sc1xuICAgICAgLy8gbXVzdCBiZSBjb25kaXRpb25hbCBhcyB0aGV5IG11c3QgYmUgc2tpcHBlZCBpZiBub25lIG9mIHRoZSBjYWxsaW5nIHByb2R1Y3Rpb25zIGFyZSBub3RcbiAgICAgIC8vIGV4cGVjdGluZyB0aGUgY2xvc2luZyB0b2tlbiBlbHNlIHdlIHdpbGwgbmV2ZXIgbWFrZSBwcm9ncmVzcyBpbiB0aGUgY2FzZSBvZiBhblxuICAgICAgLy8gZXh0cmFuZW91cyBncm91cCBjbG9zaW5nIHN5bWJvbCAoc3VjaCBhcyBhIHN0cmF5ICcpJykuIFRoaXMgaXMgbm90IHRoZSBjYXNlIGZvciAnOycgYmVjYXVzZVxuICAgICAgLy8gcGFyc2VDaGFpbigpIGlzIGFsd2F5cyB0aGUgcm9vdCBwcm9kdWN0aW9uIGFuZCBpdCBleHBlY3RzIGEgJzsnLlxuICAgICAgLy8gSWYgYSBwcm9kdWN0aW9uIGV4cGVjdHMgb25lIG9mIHRoZXNlIHRva2VuIGl0IGluY3JlbWVudHMgdGhlIGNvcnJlc3BvbmRpbmcgbmVzdGluZyBjb3VudCxcbiAgICAgIC8vIGFuZCB0aGVuIGRlY3JlbWVudHMgaXQganVzdCBwcmlvciB0byBjaGVja2luZyBpZiB0aGUgdG9rZW4gaXMgaW4gdGhlIGlucHV0LlxuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xuICAgICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoICYmICFuLmlzQ2hhcmFjdGVyKCRTRU1JQ09MT04pICYmXG4gICAgICAgICAgICAgICh0aGlzLnJwYXJlbnNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSUEFSRU4pKSAmJlxuICAgICAgICAgICAgICAodGhpcy5yYnJhY2VzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNFKSkgJiZcbiAgICAgICAgICAgICAgKHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNLRVQpKSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0LmlzRXJyb3IoKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IodGhpcy5uZXh0LnRvU3RyaW5nKCksIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9QYXJzZUFTVDtcbiAgfSgpKTtcbiAgdmFyIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyKCkge1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5jaGVjayA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgcyA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICAgIGFzdC52aXNpdChzKTtcbiAgICAgICAgICByZXR1cm4gcy5lcnJvcnM7XG4gICAgICB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcyk7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuZXJyb3JzLnB1c2goJ3BpcGVzJyk7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG4gIH0oKSk7XG5cbiAgdmFyIFBhcnNlTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VMb2NhdGlvbihmaWxlLCBvZmZzZXQsIGxpbmUsIGNvbCkge1xuICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICAgIH1cbiAgICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5vZmZzZXQpID8gdGhpcy5maWxlLnVybCArIFwiQFwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbCA6IHRoaXMuZmlsZS51cmw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlTG9jYXRpb247XG4gIH0oKSk7XG4gIHZhciBQYXJzZVNvdXJjZUZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VGaWxlKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VTb3VyY2VGaWxlO1xuICB9KCkpO1xuICB2YXIgUGFyc2VTb3VyY2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kLCBkZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkgeyBkZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgfVxuICAgICAgUGFyc2VTb3VyY2VTcGFuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5maWxlLmNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuc3RhcnQub2Zmc2V0LCB0aGlzLmVuZC5vZmZzZXQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQYXJzZVNvdXJjZVNwYW47XG4gIH0oKSk7XG4gIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsO1xuICAoZnVuY3Rpb24gKFBhcnNlRXJyb3JMZXZlbCkge1xuICAgICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIldBUk5JTkdcIl0gPSAwXSA9IFwiV0FSTklOR1wiO1xuICAgICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIkZBVEFMXCJdID0gMV0gPSBcIkZBVEFMXCI7XG4gIH0pKGV4cG9ydHMuUGFyc2VFcnJvckxldmVsIHx8IChleHBvcnRzLlBhcnNlRXJyb3JMZXZlbCA9IHt9KSk7XG4gIHZhciBQYXJzZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlRXJyb3Ioc3BhbiwgbXNnLCBsZXZlbCkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRkFUQUw7IH1cbiAgICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIH1cbiAgICAgIFBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNwYW4uc3RhcnQuZmlsZS5jb250ZW50O1xuICAgICAgICAgIHZhciBjdHhTdGFydCA9IHRoaXMuc3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgdmFyIGNvbnRleHRTdHIgPSAnJztcbiAgICAgICAgICB2YXIgZGV0YWlscyA9ICcnO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoY3R4U3RhcnQpKSB7XG4gICAgICAgICAgICAgIGlmIChjdHhTdGFydCA+IHNvdXJjZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBjdHhTdGFydCA9IHNvdXJjZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjdHhFbmQgPSBjdHhTdGFydDtcbiAgICAgICAgICAgICAgdmFyIGN0eExlbiA9IDA7XG4gICAgICAgICAgICAgIHZhciBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChjdHhMZW4gPCAxMDAgJiYgY3R4U3RhcnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjdHhTdGFydC0tO1xuICAgICAgICAgICAgICAgICAgY3R4TGVuKys7XG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2N0eFN0YXJ0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eExlbiA9IDA7XG4gICAgICAgICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGN0eExlbiA8IDEwMCAmJiBjdHhFbmQgPCBzb3VyY2UubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgY3R4RW5kKys7XG4gICAgICAgICAgICAgICAgICBjdHhMZW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbY3R4RW5kXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gc291cmNlLnN1YnN0cmluZyhjdHhTdGFydCwgdGhpcy5zcGFuLnN0YXJ0Lm9mZnNldCkgKyAnW0VSUk9SIC0+XScgK1xuICAgICAgICAgICAgICAgICAgc291cmNlLnN1YnN0cmluZyh0aGlzLnNwYW4uc3RhcnQub2Zmc2V0LCBjdHhFbmQgKyAxKTtcbiAgICAgICAgICAgICAgY29udGV4dFN0ciA9IFwiIChcXFwiXCIgKyBjb250ZXh0ICsgXCJcXFwiKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zcGFuLmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgZGV0YWlscyA9IFwiLCBcIiArIHRoaXMuc3Bhbi5kZXRhaWxzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMubXNnICsgY29udGV4dFN0ciArIFwiOiBcIiArIHRoaXMuc3Bhbi5zdGFydCArIGRldGFpbHM7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlRXJyb3I7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZXh0KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBUZXh0O1xuICB9KCkpO1xuICB2YXIgRXhwYW5zaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cGFuc2lvbihzd2l0Y2hWYWx1ZSwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlU291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuc3dpdGNoVmFsdWUgPSBzd2l0Y2hWYWx1ZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuc3dpdGNoVmFsdWVTb3VyY2VTcGFuID0gc3dpdGNoVmFsdWVTb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRXhwYW5zaW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEV4cGFuc2lvbjtcbiAgfSgpKTtcbiAgdmFyIEV4cGFuc2lvbkNhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXhwYW5zaW9uQ2FzZSh2YWx1ZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdmFsdWVTb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLnZhbHVlU291cmNlU3BhbiA9IHZhbHVlU291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmV4cFNvdXJjZVNwYW4gPSBleHBTb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRXhwYW5zaW9uQ2FzZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEV4cGFuc2lvbkNhc2UodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gRXhwYW5zaW9uQ2FzZTtcbiAgfSgpKTtcbiAgdmFyIEF0dHJpYnV0ZSQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICAgIH1cbiAgICAgIEF0dHJpYnV0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHJpYnV0ZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBBdHRyaWJ1dGU7XG4gIH0oKSk7XG4gIHZhciBFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEVsZW1lbnQobmFtZSwgYXR0cnMsIGNoaWxkcmVuLCBzb3VyY2VTcGFuLCBzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRWxlbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gRWxlbWVudDtcbiAgfSgpKTtcbiAgdmFyIENvbW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tbWVudCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQ29tbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gQ29tbWVudDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gdmlzaXRBbGwodmlzaXRvciwgbm9kZXMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXQoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICAgIGlmIChhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBUYWdDb250ZW50VHlwZTtcbiAgKGZ1bmN0aW9uIChUYWdDb250ZW50VHlwZSkge1xuICAgICAgVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGVbXCJSQVdfVEVYVFwiXSA9IDBdID0gXCJSQVdfVEVYVFwiO1xuICAgICAgVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGVbXCJFU0NBUEFCTEVfUkFXX1RFWFRcIl0gPSAxXSA9IFwiRVNDQVBBQkxFX1JBV19URVhUXCI7XG4gICAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIlBBUlNBQkxFX0RBVEFcIl0gPSAyXSA9IFwiUEFSU0FCTEVfREFUQVwiO1xuICB9KShUYWdDb250ZW50VHlwZSB8fCAoVGFnQ29udGVudFR5cGUgPSB7fSkpO1xuICBmdW5jdGlvbiBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSkge1xuICAgICAgaWYgKGVsZW1lbnROYW1lWzBdICE9ICc6Jykge1xuICAgICAgICAgIHJldHVybiBbbnVsbCwgZWxlbWVudE5hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGNvbG9uSW5kZXggPSBlbGVtZW50TmFtZS5pbmRleE9mKCc6JywgMSk7XG4gICAgICBpZiAoY29sb25JbmRleCA9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGZvcm1hdCBcXFwiXCIgKyBlbGVtZW50TmFtZSArIFwiXFxcIiBleHBlY3RpbmcgXFxcIjpuYW1lc3BhY2U6bmFtZVxcXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2VsZW1lbnROYW1lLnNsaWNlKDEsIGNvbG9uSW5kZXgpLCBlbGVtZW50TmFtZS5zbGljZShjb2xvbkluZGV4ICsgMSldO1xuICB9XG4gIGZ1bmN0aW9uIGdldE5zUHJlZml4KGZ1bGxOYW1lKSB7XG4gICAgICByZXR1cm4gZnVsbE5hbWUgPT09IG51bGwgPyBudWxsIDogc3BsaXROc05hbWUoZnVsbE5hbWUpWzBdO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKSB7XG4gICAgICByZXR1cm4gcHJlZml4ID8gXCI6XCIgKyBwcmVmaXggKyBcIjpcIiArIGxvY2FsTmFtZSA6IGxvY2FsTmFtZTtcbiAgfVxuICAvLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI25hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2VzXG4gIC8vIHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbnRpdGllcy5qc29uXG4gIC8vIFRoaXMgbGlzdCBpcyBub3QgZXhoYXVzdGl2ZSB0byBrZWVwIHRoZSBjb21waWxlciBmb290cHJpbnQgbG93LlxuICAvLyBUaGUgYCYjMTIzO2AgLyBgJiN4MWFiO2Agc3ludGF4IHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuXG4gIHZhciBOQU1FRF9FTlRJVElFUyA9IHtcbiAgICAgICdBYWN1dGUnOiAnXFx1MDBDMScsXG4gICAgICAnYWFjdXRlJzogJ1xcdTAwRTEnLFxuICAgICAgJ0FjaXJjJzogJ1xcdTAwQzInLFxuICAgICAgJ2FjaXJjJzogJ1xcdTAwRTInLFxuICAgICAgJ2FjdXRlJzogJ1xcdTAwQjQnLFxuICAgICAgJ0FFbGlnJzogJ1xcdTAwQzYnLFxuICAgICAgJ2FlbGlnJzogJ1xcdTAwRTYnLFxuICAgICAgJ0FncmF2ZSc6ICdcXHUwMEMwJyxcbiAgICAgICdhZ3JhdmUnOiAnXFx1MDBFMCcsXG4gICAgICAnYWxlZnN5bSc6ICdcXHUyMTM1JyxcbiAgICAgICdBbHBoYSc6ICdcXHUwMzkxJyxcbiAgICAgICdhbHBoYSc6ICdcXHUwM0IxJyxcbiAgICAgICdhbXAnOiAnJicsXG4gICAgICAnYW5kJzogJ1xcdTIyMjcnLFxuICAgICAgJ2FuZyc6ICdcXHUyMjIwJyxcbiAgICAgICdhcG9zJzogJ1xcdTAwMjcnLFxuICAgICAgJ0FyaW5nJzogJ1xcdTAwQzUnLFxuICAgICAgJ2FyaW5nJzogJ1xcdTAwRTUnLFxuICAgICAgJ2FzeW1wJzogJ1xcdTIyNDgnLFxuICAgICAgJ0F0aWxkZSc6ICdcXHUwMEMzJyxcbiAgICAgICdhdGlsZGUnOiAnXFx1MDBFMycsXG4gICAgICAnQXVtbCc6ICdcXHUwMEM0JyxcbiAgICAgICdhdW1sJzogJ1xcdTAwRTQnLFxuICAgICAgJ2JkcXVvJzogJ1xcdTIwMUUnLFxuICAgICAgJ0JldGEnOiAnXFx1MDM5MicsXG4gICAgICAnYmV0YSc6ICdcXHUwM0IyJyxcbiAgICAgICdicnZiYXInOiAnXFx1MDBBNicsXG4gICAgICAnYnVsbCc6ICdcXHUyMDIyJyxcbiAgICAgICdjYXAnOiAnXFx1MjIyOScsXG4gICAgICAnQ2NlZGlsJzogJ1xcdTAwQzcnLFxuICAgICAgJ2NjZWRpbCc6ICdcXHUwMEU3JyxcbiAgICAgICdjZWRpbCc6ICdcXHUwMEI4JyxcbiAgICAgICdjZW50JzogJ1xcdTAwQTInLFxuICAgICAgJ0NoaSc6ICdcXHUwM0E3JyxcbiAgICAgICdjaGknOiAnXFx1MDNDNycsXG4gICAgICAnY2lyYyc6ICdcXHUwMkM2JyxcbiAgICAgICdjbHVicyc6ICdcXHUyNjYzJyxcbiAgICAgICdjb25nJzogJ1xcdTIyNDUnLFxuICAgICAgJ2NvcHknOiAnXFx1MDBBOScsXG4gICAgICAnY3JhcnInOiAnXFx1MjFCNScsXG4gICAgICAnY3VwJzogJ1xcdTIyMkEnLFxuICAgICAgJ2N1cnJlbic6ICdcXHUwMEE0JyxcbiAgICAgICdkYWdnZXInOiAnXFx1MjAyMCcsXG4gICAgICAnRGFnZ2VyJzogJ1xcdTIwMjEnLFxuICAgICAgJ2RhcnInOiAnXFx1MjE5MycsXG4gICAgICAnZEFycic6ICdcXHUyMUQzJyxcbiAgICAgICdkZWcnOiAnXFx1MDBCMCcsXG4gICAgICAnRGVsdGEnOiAnXFx1MDM5NCcsXG4gICAgICAnZGVsdGEnOiAnXFx1MDNCNCcsXG4gICAgICAnZGlhbXMnOiAnXFx1MjY2NicsXG4gICAgICAnZGl2aWRlJzogJ1xcdTAwRjcnLFxuICAgICAgJ0VhY3V0ZSc6ICdcXHUwMEM5JyxcbiAgICAgICdlYWN1dGUnOiAnXFx1MDBFOScsXG4gICAgICAnRWNpcmMnOiAnXFx1MDBDQScsXG4gICAgICAnZWNpcmMnOiAnXFx1MDBFQScsXG4gICAgICAnRWdyYXZlJzogJ1xcdTAwQzgnLFxuICAgICAgJ2VncmF2ZSc6ICdcXHUwMEU4JyxcbiAgICAgICdlbXB0eSc6ICdcXHUyMjA1JyxcbiAgICAgICdlbXNwJzogJ1xcdTIwMDMnLFxuICAgICAgJ2Vuc3AnOiAnXFx1MjAwMicsXG4gICAgICAnRXBzaWxvbic6ICdcXHUwMzk1JyxcbiAgICAgICdlcHNpbG9uJzogJ1xcdTAzQjUnLFxuICAgICAgJ2VxdWl2JzogJ1xcdTIyNjEnLFxuICAgICAgJ0V0YSc6ICdcXHUwMzk3JyxcbiAgICAgICdldGEnOiAnXFx1MDNCNycsXG4gICAgICAnRVRIJzogJ1xcdTAwRDAnLFxuICAgICAgJ2V0aCc6ICdcXHUwMEYwJyxcbiAgICAgICdFdW1sJzogJ1xcdTAwQ0InLFxuICAgICAgJ2V1bWwnOiAnXFx1MDBFQicsXG4gICAgICAnZXVybyc6ICdcXHUyMEFDJyxcbiAgICAgICdleGlzdCc6ICdcXHUyMjAzJyxcbiAgICAgICdmbm9mJzogJ1xcdTAxOTInLFxuICAgICAgJ2ZvcmFsbCc6ICdcXHUyMjAwJyxcbiAgICAgICdmcmFjMTInOiAnXFx1MDBCRCcsXG4gICAgICAnZnJhYzE0JzogJ1xcdTAwQkMnLFxuICAgICAgJ2ZyYWMzNCc6ICdcXHUwMEJFJyxcbiAgICAgICdmcmFzbCc6ICdcXHUyMDQ0JyxcbiAgICAgICdHYW1tYSc6ICdcXHUwMzkzJyxcbiAgICAgICdnYW1tYSc6ICdcXHUwM0IzJyxcbiAgICAgICdnZSc6ICdcXHUyMjY1JyxcbiAgICAgICdndCc6ICc+JyxcbiAgICAgICdoYXJyJzogJ1xcdTIxOTQnLFxuICAgICAgJ2hBcnInOiAnXFx1MjFENCcsXG4gICAgICAnaGVhcnRzJzogJ1xcdTI2NjUnLFxuICAgICAgJ2hlbGxpcCc6ICdcXHUyMDI2JyxcbiAgICAgICdJYWN1dGUnOiAnXFx1MDBDRCcsXG4gICAgICAnaWFjdXRlJzogJ1xcdTAwRUQnLFxuICAgICAgJ0ljaXJjJzogJ1xcdTAwQ0UnLFxuICAgICAgJ2ljaXJjJzogJ1xcdTAwRUUnLFxuICAgICAgJ2lleGNsJzogJ1xcdTAwQTEnLFxuICAgICAgJ0lncmF2ZSc6ICdcXHUwMENDJyxcbiAgICAgICdpZ3JhdmUnOiAnXFx1MDBFQycsXG4gICAgICAnaW1hZ2UnOiAnXFx1MjExMScsXG4gICAgICAnaW5maW4nOiAnXFx1MjIxRScsXG4gICAgICAnaW50JzogJ1xcdTIyMkInLFxuICAgICAgJ0lvdGEnOiAnXFx1MDM5OScsXG4gICAgICAnaW90YSc6ICdcXHUwM0I5JyxcbiAgICAgICdpcXVlc3QnOiAnXFx1MDBCRicsXG4gICAgICAnaXNpbic6ICdcXHUyMjA4JyxcbiAgICAgICdJdW1sJzogJ1xcdTAwQ0YnLFxuICAgICAgJ2l1bWwnOiAnXFx1MDBFRicsXG4gICAgICAnS2FwcGEnOiAnXFx1MDM5QScsXG4gICAgICAna2FwcGEnOiAnXFx1MDNCQScsXG4gICAgICAnTGFtYmRhJzogJ1xcdTAzOUInLFxuICAgICAgJ2xhbWJkYSc6ICdcXHUwM0JCJyxcbiAgICAgICdsYW5nJzogJ1xcdTI3RTgnLFxuICAgICAgJ2xhcXVvJzogJ1xcdTAwQUInLFxuICAgICAgJ2xhcnInOiAnXFx1MjE5MCcsXG4gICAgICAnbEFycic6ICdcXHUyMUQwJyxcbiAgICAgICdsY2VpbCc6ICdcXHUyMzA4JyxcbiAgICAgICdsZHF1byc6ICdcXHUyMDFDJyxcbiAgICAgICdsZSc6ICdcXHUyMjY0JyxcbiAgICAgICdsZmxvb3InOiAnXFx1MjMwQScsXG4gICAgICAnbG93YXN0JzogJ1xcdTIyMTcnLFxuICAgICAgJ2xveic6ICdcXHUyNUNBJyxcbiAgICAgICdscm0nOiAnXFx1MjAwRScsXG4gICAgICAnbHNhcXVvJzogJ1xcdTIwMzknLFxuICAgICAgJ2xzcXVvJzogJ1xcdTIwMTgnLFxuICAgICAgJ2x0JzogJzwnLFxuICAgICAgJ21hY3InOiAnXFx1MDBBRicsXG4gICAgICAnbWRhc2gnOiAnXFx1MjAxNCcsXG4gICAgICAnbWljcm8nOiAnXFx1MDBCNScsXG4gICAgICAnbWlkZG90JzogJ1xcdTAwQjcnLFxuICAgICAgJ21pbnVzJzogJ1xcdTIyMTInLFxuICAgICAgJ011JzogJ1xcdTAzOUMnLFxuICAgICAgJ211JzogJ1xcdTAzQkMnLFxuICAgICAgJ25hYmxhJzogJ1xcdTIyMDcnLFxuICAgICAgJ25ic3AnOiAnXFx1MDBBMCcsXG4gICAgICAnbmRhc2gnOiAnXFx1MjAxMycsXG4gICAgICAnbmUnOiAnXFx1MjI2MCcsXG4gICAgICAnbmknOiAnXFx1MjIwQicsXG4gICAgICAnbm90JzogJ1xcdTAwQUMnLFxuICAgICAgJ25vdGluJzogJ1xcdTIyMDknLFxuICAgICAgJ25zdWInOiAnXFx1MjI4NCcsXG4gICAgICAnTnRpbGRlJzogJ1xcdTAwRDEnLFxuICAgICAgJ250aWxkZSc6ICdcXHUwMEYxJyxcbiAgICAgICdOdSc6ICdcXHUwMzlEJyxcbiAgICAgICdudSc6ICdcXHUwM0JEJyxcbiAgICAgICdPYWN1dGUnOiAnXFx1MDBEMycsXG4gICAgICAnb2FjdXRlJzogJ1xcdTAwRjMnLFxuICAgICAgJ09jaXJjJzogJ1xcdTAwRDQnLFxuICAgICAgJ29jaXJjJzogJ1xcdTAwRjQnLFxuICAgICAgJ09FbGlnJzogJ1xcdTAxNTInLFxuICAgICAgJ29lbGlnJzogJ1xcdTAxNTMnLFxuICAgICAgJ09ncmF2ZSc6ICdcXHUwMEQyJyxcbiAgICAgICdvZ3JhdmUnOiAnXFx1MDBGMicsXG4gICAgICAnb2xpbmUnOiAnXFx1MjAzRScsXG4gICAgICAnT21lZ2EnOiAnXFx1MDNBOScsXG4gICAgICAnb21lZ2EnOiAnXFx1MDNDOScsXG4gICAgICAnT21pY3Jvbic6ICdcXHUwMzlGJyxcbiAgICAgICdvbWljcm9uJzogJ1xcdTAzQkYnLFxuICAgICAgJ29wbHVzJzogJ1xcdTIyOTUnLFxuICAgICAgJ29yJzogJ1xcdTIyMjgnLFxuICAgICAgJ29yZGYnOiAnXFx1MDBBQScsXG4gICAgICAnb3JkbSc6ICdcXHUwMEJBJyxcbiAgICAgICdPc2xhc2gnOiAnXFx1MDBEOCcsXG4gICAgICAnb3NsYXNoJzogJ1xcdTAwRjgnLFxuICAgICAgJ090aWxkZSc6ICdcXHUwMEQ1JyxcbiAgICAgICdvdGlsZGUnOiAnXFx1MDBGNScsXG4gICAgICAnb3RpbWVzJzogJ1xcdTIyOTcnLFxuICAgICAgJ091bWwnOiAnXFx1MDBENicsXG4gICAgICAnb3VtbCc6ICdcXHUwMEY2JyxcbiAgICAgICdwYXJhJzogJ1xcdTAwQjYnLFxuICAgICAgJ3Blcm1pbCc6ICdcXHUyMDMwJyxcbiAgICAgICdwZXJwJzogJ1xcdTIyQTUnLFxuICAgICAgJ1BoaSc6ICdcXHUwM0E2JyxcbiAgICAgICdwaGknOiAnXFx1MDNDNicsXG4gICAgICAnUGknOiAnXFx1MDNBMCcsXG4gICAgICAncGknOiAnXFx1MDNDMCcsXG4gICAgICAncGl2JzogJ1xcdTAzRDYnLFxuICAgICAgJ3BsdXNtbic6ICdcXHUwMEIxJyxcbiAgICAgICdwb3VuZCc6ICdcXHUwMEEzJyxcbiAgICAgICdwcmltZSc6ICdcXHUyMDMyJyxcbiAgICAgICdQcmltZSc6ICdcXHUyMDMzJyxcbiAgICAgICdwcm9kJzogJ1xcdTIyMEYnLFxuICAgICAgJ3Byb3AnOiAnXFx1MjIxRCcsXG4gICAgICAnUHNpJzogJ1xcdTAzQTgnLFxuICAgICAgJ3BzaSc6ICdcXHUwM0M4JyxcbiAgICAgICdxdW90JzogJ1xcdTAwMjInLFxuICAgICAgJ3JhZGljJzogJ1xcdTIyMUEnLFxuICAgICAgJ3JhbmcnOiAnXFx1MjdFOScsXG4gICAgICAncmFxdW8nOiAnXFx1MDBCQicsXG4gICAgICAncmFycic6ICdcXHUyMTkyJyxcbiAgICAgICdyQXJyJzogJ1xcdTIxRDInLFxuICAgICAgJ3JjZWlsJzogJ1xcdTIzMDknLFxuICAgICAgJ3JkcXVvJzogJ1xcdTIwMUQnLFxuICAgICAgJ3JlYWwnOiAnXFx1MjExQycsXG4gICAgICAncmVnJzogJ1xcdTAwQUUnLFxuICAgICAgJ3JmbG9vcic6ICdcXHUyMzBCJyxcbiAgICAgICdSaG8nOiAnXFx1MDNBMScsXG4gICAgICAncmhvJzogJ1xcdTAzQzEnLFxuICAgICAgJ3JsbSc6ICdcXHUyMDBGJyxcbiAgICAgICdyc2FxdW8nOiAnXFx1MjAzQScsXG4gICAgICAncnNxdW8nOiAnXFx1MjAxOScsXG4gICAgICAnc2JxdW8nOiAnXFx1MjAxQScsXG4gICAgICAnU2Nhcm9uJzogJ1xcdTAxNjAnLFxuICAgICAgJ3NjYXJvbic6ICdcXHUwMTYxJyxcbiAgICAgICdzZG90JzogJ1xcdTIyQzUnLFxuICAgICAgJ3NlY3QnOiAnXFx1MDBBNycsXG4gICAgICAnc2h5JzogJ1xcdTAwQUQnLFxuICAgICAgJ1NpZ21hJzogJ1xcdTAzQTMnLFxuICAgICAgJ3NpZ21hJzogJ1xcdTAzQzMnLFxuICAgICAgJ3NpZ21hZic6ICdcXHUwM0MyJyxcbiAgICAgICdzaW0nOiAnXFx1MjIzQycsXG4gICAgICAnc3BhZGVzJzogJ1xcdTI2NjAnLFxuICAgICAgJ3N1Yic6ICdcXHUyMjgyJyxcbiAgICAgICdzdWJlJzogJ1xcdTIyODYnLFxuICAgICAgJ3N1bSc6ICdcXHUyMjExJyxcbiAgICAgICdzdXAnOiAnXFx1MjI4MycsXG4gICAgICAnc3VwMSc6ICdcXHUwMEI5JyxcbiAgICAgICdzdXAyJzogJ1xcdTAwQjInLFxuICAgICAgJ3N1cDMnOiAnXFx1MDBCMycsXG4gICAgICAnc3VwZSc6ICdcXHUyMjg3JyxcbiAgICAgICdzemxpZyc6ICdcXHUwMERGJyxcbiAgICAgICdUYXUnOiAnXFx1MDNBNCcsXG4gICAgICAndGF1JzogJ1xcdTAzQzQnLFxuICAgICAgJ3RoZXJlNCc6ICdcXHUyMjM0JyxcbiAgICAgICdUaGV0YSc6ICdcXHUwMzk4JyxcbiAgICAgICd0aGV0YSc6ICdcXHUwM0I4JyxcbiAgICAgICd0aGV0YXN5bSc6ICdcXHUwM0QxJyxcbiAgICAgICd0aGluc3AnOiAnXFx1MjAwOScsXG4gICAgICAnVEhPUk4nOiAnXFx1MDBERScsXG4gICAgICAndGhvcm4nOiAnXFx1MDBGRScsXG4gICAgICAndGlsZGUnOiAnXFx1MDJEQycsXG4gICAgICAndGltZXMnOiAnXFx1MDBENycsXG4gICAgICAndHJhZGUnOiAnXFx1MjEyMicsXG4gICAgICAnVWFjdXRlJzogJ1xcdTAwREEnLFxuICAgICAgJ3VhY3V0ZSc6ICdcXHUwMEZBJyxcbiAgICAgICd1YXJyJzogJ1xcdTIxOTEnLFxuICAgICAgJ3VBcnInOiAnXFx1MjFEMScsXG4gICAgICAnVWNpcmMnOiAnXFx1MDBEQicsXG4gICAgICAndWNpcmMnOiAnXFx1MDBGQicsXG4gICAgICAnVWdyYXZlJzogJ1xcdTAwRDknLFxuICAgICAgJ3VncmF2ZSc6ICdcXHUwMEY5JyxcbiAgICAgICd1bWwnOiAnXFx1MDBBOCcsXG4gICAgICAndXBzaWgnOiAnXFx1MDNEMicsXG4gICAgICAnVXBzaWxvbic6ICdcXHUwM0E1JyxcbiAgICAgICd1cHNpbG9uJzogJ1xcdTAzQzUnLFxuICAgICAgJ1V1bWwnOiAnXFx1MDBEQycsXG4gICAgICAndXVtbCc6ICdcXHUwMEZDJyxcbiAgICAgICd3ZWllcnAnOiAnXFx1MjExOCcsXG4gICAgICAnWGknOiAnXFx1MDM5RScsXG4gICAgICAneGknOiAnXFx1MDNCRScsXG4gICAgICAnWWFjdXRlJzogJ1xcdTAwREQnLFxuICAgICAgJ3lhY3V0ZSc6ICdcXHUwMEZEJyxcbiAgICAgICd5ZW4nOiAnXFx1MDBBNScsXG4gICAgICAneXVtbCc6ICdcXHUwMEZGJyxcbiAgICAgICdZdW1sJzogJ1xcdTAxNzgnLFxuICAgICAgJ1pldGEnOiAnXFx1MDM5NicsXG4gICAgICAnemV0YSc6ICdcXHUwM0I2JyxcbiAgICAgICd6d2onOiAnXFx1MjAwRCcsXG4gICAgICAnenduaic6ICdcXHUyMDBDJyxcbiAgfTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIFRva2VuVHlwZSQxO1xuICAoZnVuY3Rpb24gKFRva2VuVHlwZSkge1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRBR19PUEVOX1NUQVJUXCJdID0gMF0gPSBcIlRBR19PUEVOX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fRU5EXCJdID0gMV0gPSBcIlRBR19PUEVOX0VORFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRBR19PUEVOX0VORF9WT0lEXCJdID0gMl0gPSBcIlRBR19PUEVOX0VORF9WT0lEXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX0NMT1NFXCJdID0gM10gPSBcIlRBR19DTE9TRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRFWFRcIl0gPSA0XSA9IFwiVEVYVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDVdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJSQVdfVEVYVFwiXSA9IDZdID0gXCJSQVdfVEVYVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNPTU1FTlRfU1RBUlRcIl0gPSA3XSA9IFwiQ09NTUVOVF9TVEFSVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNPTU1FTlRfRU5EXCJdID0gOF0gPSBcIkNPTU1FTlRfRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ0RBVEFfU1RBUlRcIl0gPSA5XSA9IFwiQ0RBVEFfU1RBUlRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDREFUQV9FTkRcIl0gPSAxMF0gPSBcIkNEQVRBX0VORFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkFUVFJfTkFNRVwiXSA9IDExXSA9IFwiQVRUUl9OQU1FXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQVRUUl9WQUxVRVwiXSA9IDEyXSA9IFwiQVRUUl9WQUxVRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkRPQ19UWVBFXCJdID0gMTNdID0gXCJET0NfVFlQRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCJdID0gMTRdID0gXCJFWFBBTlNJT05fRk9STV9TVEFSVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9DQVNFX1ZBTFVFXCJdID0gMTVdID0gXCJFWFBBTlNJT05fQ0FTRV9WQUxVRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVFwiXSA9IDE2XSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiXSA9IDE3XSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9GT1JNX0VORFwiXSA9IDE4XSA9IFwiRVhQQU5TSU9OX0ZPUk1fRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRU9GXCJdID0gMTldID0gXCJFT0ZcIjtcbiAgfSkoVG9rZW5UeXBlJDEgfHwgKFRva2VuVHlwZSQxID0ge30pKTtcbiAgdmFyIFRva2VuJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVG9rZW4odHlwZSwgcGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuO1xuICB9KCkpO1xuICB2YXIgVG9rZW5FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhUb2tlbkVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gVG9rZW5FcnJvcihlcnJvck1zZywgdG9rZW5UeXBlLCBzcGFuKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgZXJyb3JNc2cpO1xuICAgICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICB2YXIgVG9rZW5pemVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVG9rZW5pemVSZXN1bHQodG9rZW5zLCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBUb2tlbml6ZVJlc3VsdDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgIGlmICh0b2tlbml6ZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICByZXR1cm4gbmV3IF9Ub2tlbml6ZXIobmV3IFBhcnNlU291cmNlRmlsZShzb3VyY2UsIHVybCksIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpXG4gICAgICAgICAgLnRva2VuaXplKCk7XG4gIH1cbiAgdmFyIF9DUl9PUl9DUkxGX1JFR0VYUCA9IC9cXHJcXG4/L2c7XG4gIGZ1bmN0aW9uIF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coY2hhckNvZGUpIHtcbiAgICAgIHZhciBjaGFyID0gY2hhckNvZGUgPT09ICRFT0YgPyAnRU9GJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgcmV0dXJuIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgXFxcIlwiICsgY2hhciArIFwiXFxcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIF91bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5U3JjKSB7XG4gICAgICByZXR1cm4gXCJVbmtub3duIGVudGl0eSBcXFwiXCIgKyBlbnRpdHlTcmMgKyBcIlxcXCIgLSB1c2UgdGhlIFxcXCImIzxkZWNpbWFsPjtcXFwiIG9yICBcXFwiJiN4PGhleD47XFxcIiBzeW50YXhcIjtcbiAgfVxuICB2YXIgX0NvbnRyb2xGbG93RXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gX0NvbnRyb2xGbG93RXJyb3I7XG4gIH0oKSk7XG4gIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjd3JpdGluZ1xuICB2YXIgX1Rva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSBfZmlsZSBUaGUgaHRtbCBzb3VyY2VcbiAgICAgICAqIEBwYXJhbSBfZ2V0VGFnRGVmaW5pdGlvblxuICAgICAgICogQHBhcmFtIF90b2tlbml6ZUljdSBXaGV0aGVyIHRvIHRva2VuaXplIElDVSBtZXNzYWdlcyAoY29uc2lkZXJlZCBhcyB0ZXh0IG5vZGVzIHdoZW4gZmFsc2UpXG4gICAgICAgKiBAcGFyYW0gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gX1Rva2VuaXplcihfZmlsZSwgX2dldFRhZ0RlZmluaXRpb24sIF90b2tlbml6ZUljdSwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoX2ludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBfaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB0aGlzLl9maWxlID0gX2ZpbGU7XG4gICAgICAgICAgdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbiA9IF9nZXRUYWdEZWZpbml0aW9uO1xuICAgICAgICAgIHRoaXMuX3Rva2VuaXplSWN1ID0gX3Rva2VuaXplSWN1O1xuICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgICAvLyBOb3RlOiB0aGlzIGlzIGFsd2F5cyBsb3dlcmNhc2UhXG4gICAgICAgICAgdGhpcy5fcGVlayA9IC0xO1xuICAgICAgICAgIHRoaXMuX25leHRQZWVrID0gLTE7XG4gICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgICB0aGlzLl9jb2x1bW4gPSAtMTtcbiAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sgPSBbXTtcbiAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgICAgdGhpcy5faW5wdXQgPSBfZmlsZS5jb250ZW50O1xuICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IF9maWxlLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgICAvLyBJbiBvcmRlciB0byBrZWVwIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpbiB0aGUgc291cmNlLCB3ZSBjYW4gbm90XG4gICAgICAgICAgLy8gcHJlLXByb2Nlc3MgaXQuXG4gICAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoX0NSX09SX0NSTEZfUkVHRVhQLCAnXFxuJyk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJE1JTlVTKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZURvY1R5cGUoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3Rva2VuaXplSWN1IHx8ICF0aGlzLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVPRik7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICAgIHJldHVybiBuZXcgVG9rZW5pemVSZXN1bHQobWVyZ2VUZXh0VG9rZW5zKHRoaXMudG9rZW5zKSwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgYW4gSUNVIHRva2VuIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICovXG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fdG9rZW5pemVFeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc0V4cGFuc2lvbkZvcm1TdGFydCh0aGlzLl9pbnB1dCwgdGhpcy5faW5kZXgsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtU3RhcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0V4cGFuc2lvbkNhc2VTdGFydCh0aGlzLl9wZWVrKSAmJiB0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2dldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLl9maWxlLCB0aGlzLl9pbmRleCwgdGhpcy5fbGluZSwgdGhpcy5fY29sdW1uKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U3BhbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpOyB9XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYmVnaW5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IHR5cGU7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2VuZFRva2VuID0gZnVuY3Rpb24gKHBhcnRzLCBlbmQpIHtcbiAgICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbiQxKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHBhcnRzLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChtc2csIHNwYW4pIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICBtc2cgKz0gXCIgKERvIHlvdSBoYXZlIGFuIHVuZXNjYXBlZCBcXFwie1xcXCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFxcXCJ7eyAneycgfX1cXFwiKSB0byBlc2NhcGUgaXQuKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgVG9rZW5FcnJvcihtc2csIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbmV3IF9Db250cm9sRmxvd0Vycm9yKGVycm9yKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coJEVPRiksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkTEYpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGluZSsrO1xuICAgICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrICE9PSAkTEYgJiYgdGhpcy5fcGVlayAhPT0gJENSKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbHVtbisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICAgIHRoaXMuX3BlZWsgPSB0aGlzLl9pbmRleCA+PSB0aGlzLl9sZW5ndGggPyAkRU9GIDogdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCk7XG4gICAgICAgICAgdGhpcy5fbmV4dFBlZWsgPVxuICAgICAgICAgICAgICB0aGlzLl9pbmRleCArIDEgPj0gdGhpcy5fbGVuZ3RoID8gJEVPRiA6IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5faW5kZXggKyAxKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZSh0aGlzLl9wZWVrLCBjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlQ2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKGxvY2F0aW9uLCBsb2NhdGlvbikpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgIHZhciBsZW4gPSBjaGFycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZGV4ICsgbGVuID4gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIGF0dGVtcHRpbmcgdG8gcGFyc2UgdGhlIHN0cmluZyBmYWlscywgd2Ugd2FudCB0byByZXNldCB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgICAvLyB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZVN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0U3RyKGNoYXJzKSkge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgIHdoaWxlICghcHJlZGljYXRlKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlLCBsZW4pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKTtcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggLSBzdGFydC5vZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbihzdGFydCwgc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRVbnRpbENoYXIgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBjaGFyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRDaGFyID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgICAgaWYgKGRlY29kZUVudGl0aWVzICYmIHRoaXMuX3BlZWsgPT09ICRBTVBFUlNBTkQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUVudGl0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0W2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2RlY29kZUVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRIQVNIKSkge1xuICAgICAgICAgICAgICB2YXIgaXNIZXggPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJHgpIHx8IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkWCk7XG4gICAgICAgICAgICAgIHZhciBudW1iZXJTdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCkub2Zmc2V0O1xuICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzRGlnaXRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlayAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdmFyIHN0ck51bSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhudW1iZXJTdGFydCwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ck51bSwgaXNIZXggPyAxNiA6IDEwKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydC5vZmZzZXQgKyAxLCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3Vua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHkpLCB0aGlzLl9nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOYW1lZEVudGl0eUVuZCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICAgIHZhciBjaGFyID0gTkFNRURfRU5USVRJRVNbbmFtZV8xXTtcbiAgICAgICAgICAgICAgaWYgKCFjaGFyKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKG5hbWVfMSksIHRoaXMuX2dldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0ID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzLCBmaXJzdENoYXJPZkVuZCwgYXR0ZW1wdEVuZFJlc3QpIHtcbiAgICAgICAgICB2YXIgdGFnQ2xvc2VTdGFydDtcbiAgICAgICAgICB2YXIgdGV4dFN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKGRlY29kZUVudGl0aWVzID8gVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUIDogVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRleHRTdGFydCk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgdGFnQ2xvc2VTdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoZmlyc3RDaGFyT2ZFbmQpICYmIGF0dGVtcHRFbmRSZXN0KCkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+IHRhZ0Nsb3NlU3RhcnQub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNoYXJhY3RlcnMgY29uc3VtZWQgYnkgdGhlIHByZXZpb3VzIGlmIHN0YXRlbWVudCB0byB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0YWdDbG9zZVN0YXJ0Lm9mZnNldCwgdGhpcy5faW5kZXgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gZmlyc3RDaGFyT2ZFbmQpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoZGVjb2RlRW50aXRpZXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSwgdGFnQ2xvc2VTdGFydCk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVDb21tZW50ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJE1JTlVTKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdmFyIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGZhbHNlLCAkTUlOVVMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hdHRlbXB0U3RyKCctPicpOyB9KTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfRU5ELCB0ZXh0VG9rZW4uc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNkYXRhID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNEQVRBX1NUQVJULCBzdGFydCk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignQ0RBVEFbJyk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICAgIHZhciB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgJFJCUkFDS0VULCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYXR0ZW1wdFN0cignXT4nKTsgfSk7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5DREFUQV9FTkQsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRG9jVHlwZSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRE9DX1RZUEUsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKCRHVCk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMiwgdGhpcy5faW5kZXggLSAxKV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUHJlZml4QW5kTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbmFtZU9yUHJlZml4U3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gbnVsbDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gJENPTE9OICYmICFpc1ByZWZpeEVuZCh0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lU3RhcnQ7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRDT0xPTikge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lT3JQcmVmaXhTdGFydCwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgbmFtZVN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lU3RhcnQgPSBuYW1lT3JQcmVmaXhTdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihpc05hbWVFbmQsIHRoaXMuX2luZGV4ID09PSBuYW1lU3RhcnQgPyAxIDogMCk7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZVN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgcmV0dXJuIFtwcmVmaXgsIG5hbWVdO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlbiA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICAgIHZhciBzYXZlZFBvcyA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICAgIHZhciB0YWdOYW1lO1xuICAgICAgICAgIHZhciBsb3dlcmNhc2VUYWdOYW1lO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghaXNBc2NpaUxldHRlcih0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmFtZVN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgICB0YWdOYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICAgICAgICBsb3dlcmNhc2VUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkU0xBU0ggJiYgdGhpcy5fcGVlayAhPT0gJEdUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQXR0cmlidXRlTmFtZSgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkRVEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHN0YXJ0IHRhZyBpcyBpbnZhbGlkLCBhc3N1bWUgd2Ugd2FudCBhIFwiPFwiXG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oc2F2ZWRQb3MpO1xuICAgICAgICAgICAgICAgICAgLy8gQmFjayB0byBiYWNrIHRleHQgdG9rZW5zIGFyZSBtZXJnZWQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5URVhULCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJzwnXSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbnRlbnRUb2tlblR5cGUgPSB0aGlzLl9nZXRUYWdEZWZpbml0aW9uKHRhZ05hbWUpLmNvbnRlbnRUeXBlO1xuICAgICAgICAgIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBUYWdDb250ZW50VHlwZS5SQVdfVEVYVCkge1xuICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlID0gZnVuY3Rpb24gKGxvd2VyY2FzZVRhZ05hbWUsIGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZGVjb2RlRW50aXRpZXMsICRMVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZShsb3dlcmNhc2VUYWdOYW1lKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEdUKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19DTE9TRSwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbbnVsbCwgbG93ZXJjYXNlVGFnTmFtZV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlblN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVCwgc3RhcnQpO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkFUVFJfTkFNRSk7XG4gICAgICAgICAgdmFyIHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5BVFRSX1ZBTFVFKTtcbiAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRTUSB8fCB0aGlzLl9wZWVrID09PSAkRFEpIHtcbiAgICAgICAgICAgICAgdmFyIHF1b3RlQ2hhciA9IHRoaXMuX3BlZWs7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gcGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCAxKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodmFsdWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuVHlwZSA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpID8gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSUQgOiBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkQ7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbih0b2tlblR5cGUpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ0Nsb3NlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfQ0xPU0UsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgdmFyIHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJEdUKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihwcmVmaXhBbmROYW1lKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUKTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0eXBlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUUsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3JlYWRVbnRpbCgkTEJSQUNFKS50cmltKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3ZhbHVlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnBvcCgpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEVYVCwgc3RhcnQpO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyAmJiB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKSAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlICghdGhpcy5faXNUZXh0RW5kKCkpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc1RleHRFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMVCB8fCB0aGlzLl9wZWVrID09PSAkRU9GKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVJY3UgJiYgIXRoaXMuX2luSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICBpZiAoaXNFeHBhbnNpb25Gb3JtU3RhcnQodGhpcy5faW5wdXQsIHRoaXMuX2luZGV4LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgYW4gZXhwYW5zaW9uIGZvcm1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkUkJSQUNFICYmIHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBhbmQgZXhwYW5zaW9uIGNhc2VcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fc2F2ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbdGhpcy5fcGVlaywgdGhpcy5faW5kZXgsIHRoaXMuX2NvbHVtbiwgdGhpcy5fbGluZSwgdGhpcy50b2tlbnMubGVuZ3RoXTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZFVudGlsID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKGNoYXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzdG9yZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fcGVlayA9IHBvc2l0aW9uWzBdO1xuICAgICAgICAgIHRoaXMuX2luZGV4ID0gcG9zaXRpb25bMV07XG4gICAgICAgICAgdGhpcy5fY29sdW1uID0gcG9zaXRpb25bMl07XG4gICAgICAgICAgdGhpcy5fbGluZSA9IHBvc2l0aW9uWzNdO1xuICAgICAgICAgIHZhciBuYlRva2VucyA9IHBvc2l0aW9uWzRdO1xuICAgICAgICAgIGlmIChuYlRva2VucyA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgYW55IGV4dHJhIHRva2Vuc1xuICAgICAgICAgICAgICB0aGlzLnRva2VucyA9IHRoaXMudG9rZW5zLnNsaWNlKDAsIG5iVG9rZW5zKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzSW5FeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgICAgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uRm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICAgIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVG9rZW5pemVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBpc05vdFdoaXRlc3BhY2UoY29kZSkge1xuICAgICAgcmV0dXJuICFpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEVPRjtcbiAgfVxuICBmdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgICAgcmV0dXJuIGlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkR1QgfHwgY29kZSA9PT0gJFNMQVNIIHx8XG4gICAgICAgICAgY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkRVE7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmVmaXhFbmQoY29kZSkge1xuICAgICAgcmV0dXJuIChjb2RlIDwgJGEgfHwgJHogPCBjb2RlKSAmJiAoY29kZSA8ICRBIHx8ICRaIDwgY29kZSkgJiZcbiAgICAgICAgICAoY29kZSA8ICQwIHx8IGNvZGUgPiAkOSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNEaWdpdEVudGl0eUVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT0gJEVPRiB8fCAhaXNBc2NpaUhleERpZ2l0KGNvZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGlzTmFtZWRFbnRpdHlFbmQoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNFeHBhbnNpb25Gb3JtU3RhcnQoaW5wdXQsIG9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgdmFyIGlzSW50ZXJwb2xhdGlvblN0YXJ0ID0gaW50ZXJwb2xhdGlvbkNvbmZpZyA/IGlucHV0LmluZGV4T2YoaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCwgb2Zmc2V0KSA9PSBvZmZzZXQgOiBmYWxzZTtcbiAgICAgIHJldHVybiBpbnB1dC5jaGFyQ29kZUF0KG9mZnNldCkgPT0gJExCUkFDRSAmJiAhaXNJbnRlcnBvbGF0aW9uU3RhcnQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNFeHBhbnNpb25DYXNlU3RhcnQocGVlaykge1xuICAgICAgcmV0dXJuIHBlZWsgPT09ICRFUSB8fCBpc0FzY2lpTGV0dGVyKHBlZWspO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjb2RlMSwgY29kZTIpIHtcbiAgICAgIHJldHVybiB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUxKSA9PSB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUyKTtcbiAgfVxuICBmdW5jdGlvbiB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogPyBjb2RlIC0gJGEgKyAkQSA6IGNvZGU7XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VUZXh0VG9rZW5zKHNyY1Rva2Vucykge1xuICAgICAgdmFyIGRzdFRva2VucyA9IFtdO1xuICAgICAgdmFyIGxhc3REc3RUb2tlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gc3JjVG9rZW5zW2ldO1xuICAgICAgICAgIGlmIChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCAmJiB0b2tlbi50eXBlID09IFRva2VuVHlwZSQxLlRFWFQpIHtcbiAgICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgICBsYXN0RHN0VG9rZW4uc291cmNlU3Bhbi5lbmQgPSB0b2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3REc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICBkc3RUb2tlbnMucHVzaChsYXN0RHN0VG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkc3RUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIFRyZWVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihUcmVlRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZyk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lO1xuICAgICAgfVxuICAgICAgVHJlZUVycm9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyZWVFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBQYXJzZVRyZWVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VUcmVlUmVzdWx0KHJvb3ROb2RlcywgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy5yb290Tm9kZXMgPSByb290Tm9kZXM7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VUcmVlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgUGFyc2VyJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VyKGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24gPSBnZXRUYWdEZWZpbml0aW9uO1xuICAgICAgfVxuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciB0b2tlbnNBbmRFcnJvcnMgPSB0b2tlbml6ZShzb3VyY2UsIHVybCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgdHJlZUFuZEVycm9ycyA9IG5ldyBfVHJlZUJ1aWxkZXIodG9rZW5zQW5kRXJyb3JzLnRva2VucywgdGhpcy5nZXRUYWdEZWZpbml0aW9uKS5idWlsZCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyZWVBbmRFcnJvcnMucm9vdE5vZGVzLCB0b2tlbnNBbmRFcnJvcnMuZXJyb3JzLmNvbmNhdCh0cmVlQW5kRXJyb3JzLmVycm9ycykpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKSk7XG4gIHZhciBfVHJlZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1RyZWVCdWlsZGVyKHRva2VucywgZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICB0aGlzLl9yb290Tm9kZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVPRikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfQ0xPU0UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbmRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkNEQVRBX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDb21tZW50KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5URVhUIHx8IHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuUkFXX1RFWFQgfHxcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb24odGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNraXAgYWxsIG90aGVyIHRva2Vucy4uLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRoaXMuX3Jvb3ROb2RlcywgdGhpcy5fZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5fcGVlaztcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFsd2F5cyBhbiBFT0YgdG9rZW4gYXQgdGhlIGVuZFxuICAgICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wZWVrID0gdGhpcy50b2tlbnNbdGhpcy5faW5kZXhdO1xuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2VJZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnRUb2tlbikge1xuICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLkNEQVRBX0VORCk7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2FkdmFuY2VJZihUb2tlblR5cGUkMS5SQVdfVEVYVCk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLkNPTU1FTlRfRU5EKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpc1ByZXNlbnQodGV4dCkgPyB0ZXh0LnBhcnRzWzBdLnRyaW0oKSA6IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IENvbW1lbnQodmFsdWUsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdmFyIHN3aXRjaFZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBjYXNlcyA9IFtdO1xuICAgICAgICAgIC8vIHJlYWQgPVxuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX1ZBTFVFKSB7XG4gICAgICAgICAgICAgIHZhciBleHBDYXNlID0gdGhpcy5fcGFyc2VFeHBhbnNpb25DYXNlKCk7XG4gICAgICAgICAgICAgIGlmICghZXhwQ2FzZSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgY2FzZXMucHVzaChleHBDYXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVhZCB0aGUgZmluYWwgfVxuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih0b2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgRXhwYW5zaW9uKHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWUuc291cmNlU3BhbikpO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wYXJzZUV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIC8vIHJlYWQge1xuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd7Jy5cIikpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVhZCB1bnRpbCB9XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBleHAgPSB0aGlzLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KTtcbiAgICAgICAgICBpZiAoIWV4cClcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICBleHAucHVzaChuZXcgVG9rZW4kMShUb2tlblR5cGUkMS5FT0YsIFtdLCBlbmQuc291cmNlU3BhbikpO1xuICAgICAgICAgIC8vIHBhcnNlIGV2ZXJ5dGhpbmcgaW4gYmV0d2VlbiB7IGFuZCB9XG4gICAgICAgICAgdmFyIHBhcnNlZEV4cCA9IG5ldyBfVHJlZUJ1aWxkZXIoZXhwLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgICAgaWYgKHBhcnNlZEV4cC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLl9lcnJvcnMuY29uY2F0KHBhcnNlZEV4cC5lcnJvcnMpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHZhbHVlLnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgdmFyIGV4cFNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKHZhbHVlLnBhcnRzWzBdLCBwYXJzZWRFeHAucm9vdE5vZGVzLCBzb3VyY2VTcGFuLCB2YWx1ZS5zb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIGV4cCA9IFtdO1xuICAgICAgICAgIHZhciBleHBhbnNpb25Gb3JtU3RhY2sgPSBbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wdXNoKHRoaXMuX3BlZWsudHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5zaW9uRm9ybVN0YWNrLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FT0YpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhwLnB1c2godGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVRleHQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDAgJiYgdGV4dFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50XzEpICYmIHBhcmVudF8xLmNoaWxkcmVuLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50XzEubmFtZSkuaWdub3JlRmlyc3RMZikge1xuICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IFRleHQodGV4dCwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jbG9zZVZvaWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9lbGVtZW50U3RhY2tbdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVTdGFydFRhZyA9IGZ1bmN0aW9uIChzdGFydFRhZ1Rva2VuKSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgdmFyIG5hbWUgPSBzdGFydFRhZ1Rva2VuLnBhcnRzWzFdO1xuICAgICAgICAgIHZhciBhdHRycyA9IFtdO1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfTkFNRSkge1xuICAgICAgICAgICAgICBhdHRycy5wdXNoKHRoaXMuX2NvbnN1bWVBdHRyKHRoaXMuX2FkdmFuY2UoKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUocHJlZml4LCBuYW1lLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgIC8vIE5vdGU6IFRoZXJlIGNvdWxkIGhhdmUgYmVlbiBhIHRva2VuaXplciBlcnJvclxuICAgICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IGEgdG9rZW4gZm9yIHRoZSBlbmQgdGFnLi4uXG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSUQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBzZWxmQ2xvc2luZyA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciB0YWdEZWYgPSB0aGlzLmdldFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpO1xuICAgICAgICAgICAgICBpZiAoISh0YWdEZWYuY2FuU2VsZkNsb3NlIHx8IGdldE5zUHJlZml4KGZ1bGxOYW1lKSAhPT0gbnVsbCB8fCB0YWdEZWYuaXNWb2lkKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLCBcIk9ubHkgdm9pZCBhbmQgZm9yZWlnbiBlbGVtZW50cyBjYW4gYmUgc2VsZiBjbG9zZWQgXFxcIlwiICsgc3RhcnRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuLnN0YXJ0O1xuICAgICAgICAgIHZhciBzcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCk7XG4gICAgICAgICAgdmFyIGVsID0gbmV3IEVsZW1lbnQoZnVsbE5hbWUsIGF0dHJzLCBbXSwgc3Bhbiwgc3BhbiwgbnVsbCk7XG4gICAgICAgICAgdGhpcy5fcHVzaEVsZW1lbnQoZWwpO1xuICAgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgICB0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lKTtcbiAgICAgICAgICAgICAgZWwuZW5kU291cmNlU3BhbiA9IHNwYW47XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRFbCA9IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50RWwubmFtZSkuaXNDbG9zZWRCeUNoaWxkKGVsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50U2tpcHBpbmdDb250YWluZXJzKCksIHBhcmVudCA9IF9hLnBhcmVudCwgY29udGFpbmVyID0gX2EuY29udGFpbmVyO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSAmJiB0YWdEZWYucmVxdWlyZUV4dHJhUGFyZW50KHBhcmVudC5uYW1lKSkge1xuICAgICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3IEVsZW1lbnQodGFnRGVmLnBhcmVudFRvQWRkLCBbXSwgW10sIGVsLnNvdXJjZVNwYW4sIGVsLnN0YXJ0U291cmNlU3BhbiwgZWwuZW5kU291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMuX2luc2VydEJlZm9yZUNvbnRhaW5lcihwYXJlbnQsIGNvbnRhaW5lciwgbmV3UGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQoZWwpO1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKGVsKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lRW5kVGFnID0gZnVuY3Rpb24gKGVuZFRhZ1Rva2VuKSB7XG4gICAgICAgICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5fZ2V0RWxlbWVudEZ1bGxOYW1lKGVuZFRhZ1Rva2VuLnBhcnRzWzBdLCBlbmRUYWdUb2tlbi5wYXJ0c1sxXSwgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgICBpZiAodGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKS5lbmRTb3VyY2VTcGFuID0gZW5kVGFnVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVm9pZCBlbGVtZW50cyBkbyBub3QgaGF2ZSBlbmQgdGFncyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lKSkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuLCBcIlVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXFxcIlwiICsgZW5kVGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wb3BFbGVtZW50ID0gZnVuY3Rpb24gKGZ1bGxOYW1lKSB7XG4gICAgICAgICAgZm9yICh2YXIgc3RhY2tJbmRleCA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBzdGFja0luZGV4ID49IDA7IHN0YWNrSW5kZXgtLSkge1xuICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9lbGVtZW50U3RhY2tbc3RhY2tJbmRleF07XG4gICAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGZ1bGxOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHN0YWNrSW5kZXgsIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSBzdGFja0luZGV4KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmNsb3NlZEJ5UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgdmFyIGZ1bGxOYW1lID0gbWVyZ2VOc0FuZE5hbWUoYXR0ck5hbWUucGFydHNbMF0sIGF0dHJOYW1lLnBhcnRzWzFdKTtcbiAgICAgICAgICB2YXIgZW5kID0gYXR0ck5hbWUuc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgICAgdmFyIHZhbHVlU3BhbjtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5BVFRSX1ZBTFVFKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZVRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlVG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICAgIGVuZCA9IHZhbHVlVG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgICAgICAgIHZhbHVlU3BhbiA9IHZhbHVlVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUkMShmdWxsTmFtZSwgdmFsdWUsIG5ldyBQYXJzZVNvdXJjZVNwYW4oYXR0ck5hbWUuc291cmNlU3Bhbi5zdGFydCwgZW5kKSwgdmFsdWVTcGFuKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRQYXJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCA/IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgcGFyZW50IGluIHRoZSBET00gYW5kIHRoZSBjb250YWluZXIuXG4gICAgICAgKlxuICAgICAgICogYDxuZy1jb250YWluZXI+YCBlbGVtZW50cyBhcmUgc2tpcHBlZCBhcyB0aGV5IGFyZSBub3QgcmVuZGVyZWQgYXMgRE9NIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFN0YWNrW2ldLm5hbWUgIT09ICduZy1jb250YWluZXInKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBwYXJlbnQ6IHRoaXMuX2VsZW1lbnRTdGFja1tpXSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50U3RhY2tbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZGRUb1BhcmVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSBub2RlIGJldHdlZW4gdGhlIHBhcmVudCBhbmQgdGhlIGNvbnRhaW5lci5cbiAgICAgICAqIFdoZW4gbm8gY29udGFpbmVyIGlzIGdpdmVuLCB0aGUgbm9kZSBpcyBhcHBlbmRlZCBhcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQuXG4gICAgICAgKiBBbHNvIHVwZGF0ZXMgdGhlIGVsZW1lbnQgc3RhY2sgYWNjb3JkaW5nbHkuXG4gICAgICAgKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2luc2VydEJlZm9yZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnQsIGNvbnRhaW5lciwgbm9kZSkge1xuICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5vZGUpO1xuICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGNvbnRhaW5lciB3aXRoIHRoZSBuZXcgbm9kZSBpbiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChjb250YWluZXIpO1xuICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHRoaXMuX2VsZW1lbnRTdGFjay5pbmRleE9mKGNvbnRhaW5lciksIDAsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRFbGVtZW50RnVsbE5hbWUgPSBmdW5jdGlvbiAocHJlZml4LCBsb2NhbE5hbWUsIHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoaXNCbGFuayhwcmVmaXgpKSB7XG4gICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihsb2NhbE5hbWUpLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4O1xuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhwcmVmaXgpICYmIGlzUHJlc2VudChwYXJlbnRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgcHJlZml4ID0gZ2V0TnNQcmVmaXgocGFyZW50RWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVHJlZUJ1aWxkZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGxhc3RPblN0YWNrKHN0YWNrLCBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlnZXN0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gc2hhMShzZXJpYWxpemVOb2RlcyhtZXNzYWdlLm5vZGVzKS5qb2luKCcnKSArIChcIltcIiArIG1lc3NhZ2UubWVhbmluZyArIFwiXVwiKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAgICpcbiAgICogVGhlIHZpc2l0b3IgaXMgYWxzbyB1c2VkIGluIHRoZSBpMThuIHBhcnNlciB0ZXN0c1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhciBfU2VyaWFsaXplclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJWaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcsICcpICsgXCJdXCI7XG4gICAgICB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiAoayArIFwiIHtcIiArIGljdS5jYXNlc1trXS52aXNpdChfdGhpcykgKyBcIn1cIik7IH0pO1xuICAgICAgICAgIHJldHVybiBcIntcIiArIGljdS5leHByZXNzaW9uICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIgKyBzdHJDYXNlcy5qb2luKCcsICcpICsgXCJ9XCI7XG4gICAgICB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gcGguaXNWb2lkID9cbiAgICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiLz5cIiA6XG4gICAgICAgICAgICAgIFwiPHBoIHRhZyBuYW1lPVxcXCJcIiArIHBoLnN0YXJ0TmFtZSArIFwiXFxcIj5cIiArIHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignLCAnKSArIFwiPC9waCBuYW1lPVxcXCJcIiArIHBoLmNsb3NlTmFtZSArIFwiXFxcIj5cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gXCI8cGggbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiPlwiICsgcGgudmFsdWUgKyBcIjwvcGg+XCI7XG4gICAgICB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwiPHBoIGljdSBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZS52aXNpdCh0aGlzKSArIFwiPC9waD5cIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1NlcmlhbGl6ZXJWaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJWaXNpdG9yKCk7XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVzKG5vZGVzKSB7XG4gICAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2l0KHNlcmlhbGl6ZXJWaXNpdG9yLCBudWxsKTsgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICAgKlxuICAgKiBzZWUgaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC00L2ZpcHMtMTgwLTQucGRmXG4gICAqXG4gICAqIFdBUk5JTkc6IHRoaXMgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGRlc2lnbmVkIG5vdCB0ZXN0ZWQgd2l0aCBzZWN1cml0eSBpbiBtaW5kLlxuICAgKiAgICAgICAgICBETyBOT1QgVVNFIElUIElOIEEgU0VDVVJJVFkgU0VOU0lUSVZFIENPTlRFWFQuXG4gICAqL1xuICBmdW5jdGlvbiBzaGExKHN0cikge1xuICAgICAgdmFyIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgICB2YXIgd29yZHMzMiA9IHN0cmluZ1RvV29yZHMzMih1dGY4KTtcbiAgICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCAqIDg7XG4gICAgICB2YXIgdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgICB2YXIgX2EgPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF0sIGEgPSBfYVswXSwgYiA9IF9hWzFdLCBjID0gX2FbMl0sIGQgPSBfYVszXSwgZSA9IF9hWzRdO1xuICAgICAgd29yZHMzMltsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gICAgICB3b3JkczMyWygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgdmFyIF9iID0gW2EsIGIsIGMsIGQsIGVdLCBoMCA9IF9iWzBdLCBoMSA9IF9iWzFdLCBoMiA9IF9iWzJdLCBoMyA9IF9iWzNdLCBoNCA9IF9iWzRdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICB3W2pdID0gd29yZHMzMltpICsgal07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB3W2pdID0gcm9sMzIod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9jID0gZmsoaiwgYiwgYywgZCksIGYgPSBfY1swXSwgayA9IF9jWzFdO1xuICAgICAgICAgICAgICB2YXIgdGVtcCA9IFtyb2wzMihhLCA1KSwgZiwgZSwgaywgd1tqXV0ucmVkdWNlKGFkZDMyKTtcbiAgICAgICAgICAgICAgX2QgPSBbZCwgYywgcm9sMzIoYiwgMzApLCBhLCB0ZW1wXSwgZSA9IF9kWzBdLCBkID0gX2RbMV0sIGMgPSBfZFsyXSwgYiA9IF9kWzNdLCBhID0gX2RbNF07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lID0gW2FkZDMyKGEsIGgwKSwgYWRkMzIoYiwgaDEpLCBhZGQzMihjLCBoMiksIGFkZDMyKGQsIGgzKSwgYWRkMzIoZSwgaDQpXSwgYSA9IF9lWzBdLCBiID0gX2VbMV0sIGMgPSBfZVsyXSwgZCA9IF9lWzNdLCBlID0gX2VbNF07XG4gICAgICB9XG4gICAgICB2YXIgc2hhMSA9IHdvcmRzMzJUb1N0cmluZyhbYSwgYiwgYywgZCwgZV0pO1xuICAgICAgdmFyIGhleCA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGExLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGJfMSA9IHNoYTEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBoZXggKz0gKGJfMSA+Pj4gNCAmIDB4MGYpLnRvU3RyaW5nKDE2KSArIChiXzEgJiAweDBmKS50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgX2QsIF9lO1xuICB9XG4gIGZ1bmN0aW9uIHV0ZjhFbmNvZGUoc3RyKSB7XG4gICAgICB2YXIgZW5jb2RlZCA9ICcnO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY29kZVBvaW50ID0gZGVjb2RlU3Vycm9nYXRlUGFpcnMoc3RyLCBpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweDdmKSB7XG4gICAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCBjb2RlUG9pbnQgPj4+IDYsIDB4ODAgfCBjb2RlUG9pbnQgJiAweDNmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IGNvZGVQb2ludCA+Pj4gMTIsIDB4ODAgfCBjb2RlUG9pbnQgPj4+IDYgJiAweDNmLCAweDgwIHwgY29kZVBvaW50ICYgMHgzZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDFmZmZmZikge1xuICAgICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IGNvZGVQb2ludCA+Pj4gMTgsIDB4ODAgfCBjb2RlUG9pbnQgPj4+IDEyICYgMHgzZiwgMHg4MCB8IGNvZGVQb2ludCA+Pj4gNiAmIDB4M2YsIDB4ODAgfCBjb2RlUG9pbnQgJiAweDNmKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlZDtcbiAgfVxuICAvLyBzZWUgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gIGZ1bmN0aW9uIGRlY29kZVN1cnJvZ2F0ZVBhaXJzKHN0ciwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4PVwiICsgaW5kZXggKyBcIiBpcyBvdXQgb2YgcmFuZ2UgaW4gXFxcIlwiICsgc3RyICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGhpZ2ggPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICB2YXIgbG93O1xuICAgICAgaWYgKGhpZ2ggPj0gMHhkODAwICYmIGhpZ2ggPD0gMHhkZmZmICYmIHN0ci5sZW5ndGggPiBpbmRleCArIDEpIHtcbiAgICAgICAgICBsb3cgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgIGlmIChsb3cgPj0gMHhkYzAwICYmIGxvdyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChoaWdoIC0gMHhkODAwKSAqIDB4NDAwICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGlnaDtcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmdUb1dvcmRzMzIoc3RyKSB7XG4gICAgICB2YXIgd29yZHMzMiA9IEFycmF5KHN0ci5sZW5ndGggPj4+IDIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkczMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd29yZHMzMltpXSA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdvcmRzMzJbaSA+Pj4gMl0gfD0gKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgOCAqICgzIC0gaSAmIDB4Myk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29yZHMzMjtcbiAgfVxuICBmdW5jdGlvbiB3b3JkczMyVG9TdHJpbmcod29yZHMzMikge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkczMyLmxlbmd0aCAqIDQ7IGkrKykge1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh3b3JkczMyW2kgPj4+IDJdID4+PiA4ICogKDMgLSBpICYgMHgzKSkgJiAweGZmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZnVuY3Rpb24gZmsoaW5kZXgsIGIsIGMsIGQpIHtcbiAgICAgIGlmIChpbmRleCA8IDIwKSB7XG4gICAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4IDwgNDApIHtcbiAgICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCA2MCkge1xuICAgICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYiBeIGMgXiBkLCAweGNhNjJjMWQ2XTtcbiAgfVxuICBmdW5jdGlvbiBhZGQzMihhLCBiKSB7XG4gICAgICB2YXIgbG93ID0gKGEgJiAweGZmZmYpICsgKGIgJiAweGZmZmYpO1xuICAgICAgdmFyIGhpZ2ggPSAoYSA+PiAxNikgKyAoYiA+PiAxNikgKyAobG93ID4+IDE2KTtcbiAgICAgIHJldHVybiAoaGlnaCA8PCAxNikgfCAobG93ICYgMHhmZmZmKTtcbiAgfVxuICBmdW5jdGlvbiByb2wzMihhLCBjb3VudCkge1xuICAgICAgcmV0dXJuIChhIDw8IGNvdW50KSB8IChhID4+PiAoMzIgLSBjb3VudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSBub2RlcyBtZXNzYWdlIEFTVFxuICAgICAgICogQHBhcmFtIHBsYWNlaG9sZGVycyBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHN0YXRpYyBjb250ZW50XG4gICAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJUb01zZ0lkcyBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHRyYW5zbGF0YWJsZSBtZXNzYWdlIElEcyAodXNlZCBmb3IgSUNVXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcylcbiAgICAgICAqIEBwYXJhbSBtZWFuaW5nXG4gICAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gTWVzc2FnZShub2RlcywgcGxhY2Vob2xkZXJzLCBwbGFjZWhvbGRlclRvTXNnSWRzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVycztcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyVG9Nc2dJZHMgPSBwbGFjZWhvbGRlclRvTXNnSWRzO1xuICAgICAgICAgIHRoaXMubWVhbmluZyA9IG1lYW5pbmc7XG4gICAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lc3NhZ2U7XG4gIH0oKSk7XG4gIHZhciBUZXh0JDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGV4dCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gVGV4dDtcbiAgfSgpKTtcbiAgdmFyIENvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb250YWluZXIoY2hpbGRyZW4sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIENvbnRhaW5lci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbnRhaW5lcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBDb250YWluZXI7XG4gIH0oKSk7XG4gIHZhciBJY3UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSWN1KGV4cHJlc3Npb24sIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgSWN1LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEljdTtcbiAgfSgpKTtcbiAgdmFyIFRhZ1BsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRhZ1BsYWNlaG9sZGVyKHRhZywgYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICAgIHRoaXMuY2xvc2VOYW1lID0gY2xvc2VOYW1lO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgVGFnUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBUYWdQbGFjZWhvbGRlcjtcbiAgfSgpKTtcbiAgdmFyIFBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gJyc7IH1cbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBQbGFjZWhvbGRlcjtcbiAgfSgpKTtcbiAgdmFyIEljdVBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEljdVBsYWNlaG9sZGVyKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gJyc7IH1cbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgSWN1UGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3VQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBJY3VQbGFjZWhvbGRlcjtcbiAgfSgpKTtcblxuICB2YXIgSHRtbFRhZ0RlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSHRtbFRhZ0RlZmluaXRpb24oX2EpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBjbG9zZWRCeUNoaWxkcmVuID0gX2IuY2xvc2VkQnlDaGlsZHJlbiwgcmVxdWlyZWRQYXJlbnRzID0gX2IucmVxdWlyZWRQYXJlbnRzLCBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeCA9IF9iLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4LCBfYyA9IF9iLmNvbnRlbnRUeXBlLCBjb250ZW50VHlwZSA9IF9jID09PSB2b2lkIDAgPyBUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBIDogX2MsIF9kID0gX2IuY2xvc2VkQnlQYXJlbnQsIGNsb3NlZEJ5UGFyZW50ID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIF9lID0gX2IuaXNWb2lkLCBpc1ZvaWQgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgX2YgPSBfYi5pZ25vcmVGaXJzdExmLCBpZ25vcmVGaXJzdExmID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Y7XG4gICAgICAgICAgdGhpcy5jbG9zZWRCeUNoaWxkcmVuID0ge307XG4gICAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY2FuU2VsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGNsb3NlZEJ5Q2hpbGRyZW4gJiYgY2xvc2VkQnlDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkgeyByZXR1cm4gX3RoaXMuY2xvc2VkQnlDaGlsZHJlblt0YWdOYW1lXSA9IHRydWU7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gY2xvc2VkQnlQYXJlbnQgfHwgaXNWb2lkO1xuICAgICAgICAgIGlmIChyZXF1aXJlZFBhcmVudHMgJiYgcmVxdWlyZWRQYXJlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXF1aXJlZFBhcmVudHMgPSB7fTtcbiAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmVudCBpcyB0aGUgbGlzdCBpcyBhdXRvbWF0aWNhbGx5IHdoZW4gbm9uZSBvZiB0aGUgbGlzdGVkIHBhcmVudHMgYXJlIHByZXNlbnRcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnRUb0FkZCA9IHJlcXVpcmVkUGFyZW50c1swXTtcbiAgICAgICAgICAgICAgcmVxdWlyZWRQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLnJlcXVpcmVkUGFyZW50c1t0YWdOYW1lXSA9IHRydWU7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gaW1wbGljaXROYW1lc3BhY2VQcmVmaXg7XG4gICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGlnbm9yZUZpcnN0TGY7XG4gICAgICB9XG4gICAgICBIdG1sVGFnRGVmaW5pdGlvbi5wcm90b3R5cGUucmVxdWlyZUV4dHJhUGFyZW50ID0gZnVuY3Rpb24gKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMucmVxdWlyZWRQYXJlbnRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGNQYXJlbnQgPSBjdXJyZW50UGFyZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZWRQYXJlbnRzW2xjUGFyZW50XSAhPSB0cnVlICYmIGxjUGFyZW50ICE9ICd0ZW1wbGF0ZSc7XG4gICAgICB9O1xuICAgICAgSHRtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNWb2lkIHx8IG5hbWUudG9Mb3dlckNhc2UoKSBpbiB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW47XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEh0bWxUYWdEZWZpbml0aW9uO1xuICB9KCkpO1xuICAvLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3NcbiAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBmdWxseSBjb25mb3JtIHRvIHRoZSBIVE1MNSBzcGVjLlxuICB2YXIgVEFHX0RFRklOSVRJT05TID0ge1xuICAgICAgJ2Jhc2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnbWV0YSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdhcmVhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2VtYmVkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2xpbmsnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnaW1nJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2lucHV0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3BhcmFtJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2hyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3NvdXJjZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICd0cmFjayc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICd3YnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAncCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7XG4gICAgICAgICAgY2xvc2VkQnlDaGlsZHJlbjogW1xuICAgICAgICAgICAgICAnYWRkcmVzcycsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jsb2NrcXVvdGUnLCAnZGl2JywgJ2RsJywgJ2ZpZWxkc2V0JywgJ2Zvb3RlcicsICdmb3JtJyxcbiAgICAgICAgICAgICAgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLFxuICAgICAgICAgICAgICAnbWFpbicsICduYXYnLCAnb2wnLCAncCcsICdwcmUnLCAnc2VjdGlvbicsICd0YWJsZScsICd1bCdcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgICB9KSxcbiAgICAgICd0aGVhZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSB9KSxcbiAgICAgICd0Ym9keSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAndGZvb3QnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5J10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3RyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RyJ10sXG4gICAgICAgICAgcmVxdWlyZWRQYXJlbnRzOiBbJ3Rib2R5JywgJ3Rmb290JywgJ3RoZWFkJ10sXG4gICAgICAgICAgY2xvc2VkQnlQYXJlbnQ6IHRydWVcbiAgICAgIH0pLFxuICAgICAgJ3RkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICd0aCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAnY29sJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgcmVxdWlyZWRQYXJlbnRzOiBbJ2NvbGdyb3VwJ10sIGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdzdmcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ3N2ZycgfSksXG4gICAgICAnbWF0aCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4OiAnbWF0aCcgfSksXG4gICAgICAnbGknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2xpJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ2R0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydkdCcsICdkZCddIH0pLFxuICAgICAgJ2RkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydkdCcsICdkZCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdyYic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3J0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAncnRjJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAncnAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdvcHRncm91cCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0Z3JvdXAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAnb3B0aW9uJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydvcHRpb24nLCAnb3B0Z3JvdXAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAncHJlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAgICdsaXN0aW5nJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAgICdzdHlsZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5SQVdfVEVYVCB9KSxcbiAgICAgICdzY3JpcHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAndGl0bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUIH0pLFxuICAgICAgJ3RleHRhcmVhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCwgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgfTtcbiAgdmFyIF9ERUZBVUxUX1RBR19ERUZJTklUSU9OID0gbmV3IEh0bWxUYWdEZWZpbml0aW9uKCk7XG4gIGZ1bmN0aW9uIGdldEh0bWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBUQUdfREVGSU5JVElPTlNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBfREVGQVVMVF9UQUdfREVGSU5JVElPTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIFRBR19UT19QTEFDRUhPTERFUl9OQU1FUyA9IHtcbiAgICAgICdBJzogJ0xJTksnLFxuICAgICAgJ0InOiAnQk9MRF9URVhUJyxcbiAgICAgICdCUic6ICdMSU5FX0JSRUFLJyxcbiAgICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICAgJ0gxJzogJ0hFQURJTkdfTEVWRUwxJyxcbiAgICAgICdIMic6ICdIRUFESU5HX0xFVkVMMicsXG4gICAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICAgJ0g0JzogJ0hFQURJTkdfTEVWRUw0JyxcbiAgICAgICdINSc6ICdIRUFESU5HX0xFVkVMNScsXG4gICAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICAgJ0hSJzogJ0hPUklaT05UQUxfUlVMRScsXG4gICAgICAnSSc6ICdJVEFMSUNfVEVYVCcsXG4gICAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAgICdMSU5LJzogJ01FRElBX0xJTksnLFxuICAgICAgJ09MJzogJ09SREVSRURfTElTVCcsXG4gICAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICAgJ1EnOiAnUVVPVEFUSU9OJyxcbiAgICAgICdTJzogJ1NUUklLRVRIUk9VR0hfVEVYVCcsXG4gICAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgICAnU1VCJzogJ1NVQlNUUklQVCcsXG4gICAgICAnU1VQJzogJ1NVUEVSU0NSSVBUJyxcbiAgICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAgICdURCc6ICdUQUJMRV9DRUxMJyxcbiAgICAgICdURk9PVCc6ICdUQUJMRV9GT09URVInLFxuICAgICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAgICdUSEVBRCc6ICdUQUJMRV9IRUFERVInLFxuICAgICAgJ1RSJzogJ1RBQkxFX1JPVycsXG4gICAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAgICdVJzogJ1VOREVSTElORURfVEVYVCcsXG4gICAgICAnVUwnOiAnVU5PUkRFUkVEX0xJU1QnLFxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyB1bmlxdWUgbmFtZXMgZm9yIHBsYWNlaG9sZGVyIHdpdGggZGlmZmVyZW50IGNvbnRlbnRcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgUGxhY2Vob2xkZXJSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQbGFjZWhvbGRlclJlZ2lzdHJ5KCkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBvY2N1cnJlbmNlIG9mIHRoZSBiYXNlIG5hbWUgdG9wIGdlbmVyYXRlIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMgPSB7fTtcbiAgICAgICAgICAvLyBNYXBzIHNpZ25hdHVyZSB0byBwbGFjZWhvbGRlciBuYW1lc1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZSA9IHt9O1xuICAgICAgfVxuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgaXNWb2lkKSB7XG4gICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hUYWcodGFnLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoaXNWb2lkID8gYmFzZU5hbWUgOiBcIlNUQVJUX1wiICsgYmFzZU5hbWUpO1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH07XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5faGFzaENsb3NpbmdUYWcodGFnKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoXCJDTE9TRV9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IG5hbWU7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgICB2YXIgdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBcIlBIOiBcIiArIHVwcGVyTmFtZSArIFwiPVwiICsgY29udGVudDtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gdW5pcXVlTmFtZTtcbiAgICAgICAgICByZXR1cm4gdW5pcXVlTmFtZTtcbiAgICAgIH07XG4gICAgICAvLyBHZW5lcmF0ZSBhIGhhc2ggZm9yIGEgdGFnIC0gZG9lcyBub3QgdGFrZSBhdHRyaWJ1dGUgb3JkZXIgaW50byBhY2NvdW50XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBcIjxcIiArIHRhZztcbiAgICAgICAgICB2YXIgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKFwiIFwiICsgbmFtZSArIFwiPVwiICsgYXR0cnNbbmFtZV0pOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICB2YXIgZW5kID0gaXNWb2lkID8gJy8+JyA6IFwiPjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgKyBzdHJBdHRycyArIGVuZDtcbiAgICAgIH07XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaENsb3NpbmdUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0aGlzLl9oYXNoVGFnKFwiL1wiICsgdGFnLCB7fSwgZmFsc2UpOyB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuX2dlbmVyYXRlVW5pcXVlTmFtZSA9IGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBiYXNlO1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW25hbWVdO1xuICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICBuZXh0ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgKz0gXCJfXCIgKyBuZXh0O1xuICAgICAgICAgICAgICBuZXh0Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBsYWNlaG9sZGVyUmVnaXN0cnk7XG4gIH0oKSk7XG5cbiAgdmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiBjb252ZXJ0aW5nIGh0bWwgbm9kZXMgdG8gYW4gaTE4biBNZXNzYWdlIGdpdmVuIGFuIGludGVycG9sYXRpb25Db25maWdcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfSTE4blZpc2l0b3IoX2V4cFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnRvSTE4bk1lc3NhZ2Uobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH07XG4gIH1cbiAgdmFyIF9JMThuVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fZXhwcmVzc2lvblBhcnNlciA9IF9leHByZXNzaW9uUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgIH1cbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICB0aGlzLl9pc0ljdSA9IG5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGVzWzBdIGluc3RhbmNlb2YgRXhwYW5zaW9uO1xuICAgICAgICAgIHRoaXMuX2ljdURlcHRoID0gMDtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5ID0gbmV3IFBsYWNlaG9sZGVyUmVnaXN0cnkoKTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCA9IHt9O1xuICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMgPSB7fTtcbiAgICAgICAgICB2YXIgaTE4bm9kZXMgPSB2aXNpdEFsbCh0aGlzLCBub2Rlcywge30pO1xuICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShpMThub2RlcywgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnQsIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCB2aXNpdCB0aGUgYXR0cmlidXRlcywgdHJhbnNsYXRhYmxlIG9uZXMgYXJlIHRvcC1sZXZlbCBBU1RzXG4gICAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpc1ZvaWQgPSBnZXRIdG1sVGFnRGVmaW5pdGlvbihlbC5uYW1lKS5pc1ZvaWQ7XG4gICAgICAgICAgdmFyIHN0YXJ0UGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtzdGFydFBoTmFtZV0gPSBlbC5zb3VyY2VTcGFuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgdmFyIGNsb3NlUGhOYW1lID0gJyc7XG4gICAgICAgICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgICAgICAgICAgY2xvc2VQaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKGVsLm5hbWUpO1xuICAgICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtjbG9zZVBoTmFtZV0gPSBcIjwvXCIgKyBlbC5uYW1lICsgXCI+XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIoZWwubmFtZSwgYXR0cnMsIHN0YXJ0UGhOYW1lLCBjbG9zZVBoTmFtZSwgY2hpbGRyZW4sIGlzVm9pZCwgZWwuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24oYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5faWN1RGVwdGgrKztcbiAgICAgICAgICB2YXIgaTE4bkljdUNhc2VzID0ge307XG4gICAgICAgICAgdmFyIGkxOG5JY3UgPSBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGkxOG5JY3VDYXNlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIGljdS5jYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXplKSB7XG4gICAgICAgICAgICAgIGkxOG5JY3VDYXNlc1tjYXplLnZhbHVlXSA9IG5ldyBDb250YWluZXIoY2F6ZS5leHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywge30pOyB9KSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9pY3VEZXB0aC0tO1xuICAgICAgICAgIGlmICh0aGlzLl9pc0ljdSB8fCB0aGlzLl9pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UgcmV0dXJucyBpdFxuICAgICAgICAgICAgICByZXR1cm4gaTE4bkljdTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRWxzZSByZXR1cm5zIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAgIC8vIHRyYW5zbGF0aW9ucy4gV2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgdmlzaXRvciAodGhleSBhcmUgbm90IHJlLWVudHJhbnQpIHRvIGNvbXB1dGUgdGhlXG4gICAgICAgICAgLy8gbWVzc2FnZSBpZC5cbiAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBhZGQgYSBodG1sLk5vZGUgLT4gaTE4bi5NZXNzYWdlIGNhY2hlIHRvIGF2b2lkIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIG1zZ1xuICAgICAgICAgIHZhciBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZSgnSUNVJywgaWN1LnNvdXJjZVNwYW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKHRoaXMuX2V4cHJlc3Npb25QYXJzZXIsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHNbcGhOYW1lXSA9IGRpZ2VzdE1lc3NhZ2UodmlzaXRvci50b0kxOG5NZXNzYWdlKFtpY3VdLCAnJywgJycpKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKGkxOG5JY3UsIHBoTmFtZSwgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh0ZXh0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNwbGl0SW50ZXJwb2xhdGlvbiA9IHRoaXMuX2V4cHJlc3Npb25QYXJzZXIuc3BsaXRJbnRlcnBvbGF0aW9uKHRleHQsIHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKSwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKCFzcGxpdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gTm8gZXhwcmVzc2lvbiwgcmV0dXJuIGEgc2luZ2xlIHRleHRcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDEodGV4dCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiBhIGdyb3VwIG9mIHRleHQgKyBleHByZXNzaW9uc1xuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKG5vZGVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLCBzRGVsaW1pdGVyID0gX2Euc3RhcnQsIGVEZWxpbWl0ZXIgPSBfYS5lbmQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdEludGVycG9sYXRpb24uc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBzcGxpdEludGVycG9sYXRpb24uZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICAgIHZhciBiYXNlTmFtZSA9IF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGV4cHJlc3Npb24pIHx8ICdJTlRFUlBPTEFUSU9OJztcbiAgICAgICAgICAgICAgdmFyIHBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0UGxhY2Vob2xkZXJOYW1lKGJhc2VOYW1lLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3BoTmFtZV0gPSBzRGVsaW1pdGVyICsgZXhwcmVzc2lvbiArIGVEZWxpbWl0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBsYXN0IGluZGV4IGNvbnRhaW5zIG5vIGV4cHJlc3Npb25cbiAgICAgICAgICB2YXIgbGFzdFN0cmluZ0lkeCA9IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2xhc3RTdHJpbmdJZHhdLmxlbmd0aCkge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbbGFzdFN0cmluZ0lkeF0sIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0kxOG5WaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKlwiKFtcXHNcXFNdKj8pXCJbXFxzXFxTXSpcXCkvZztcbiAgZnVuY3Rpb24gX2V4dHJhY3RQbGFjZWhvbGRlck5hbWUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMV07XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFuIGkxOG4gZXJyb3IuXG4gICAqL1xuICB2YXIgSTE4bkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ0KEkxOG5FcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEkxOG5FcnJvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEkxOG5FcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG5cbiAgdmFyIF9JMThOX0FUVFIgPSAnaTE4bic7XG4gIHZhciBfSTE4Tl9BVFRSX1BSRUZJWCA9ICdpMThuLSc7XG4gIHZhciBfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAgPSAvXmkxOG46Py87XG4gIC8qKlxuICAgKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gICAqL1xuICBmdW5jdGlvbiBleHRyYWN0TWVzc2FnZXMobm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlVHJhbnNsYXRpb25zKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICAgIHJldHVybiB2aXNpdG9yLm1lcmdlKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpO1xuICB9XG4gIHZhciBFeHRyYWN0aW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4dHJhY3Rpb25SZXN1bHQobWVzc2FnZXMsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBFeHRyYWN0aW9uUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgX1Zpc2l0b3JNb2RlO1xuICAoZnVuY3Rpb24gKF9WaXNpdG9yTW9kZSkge1xuICAgICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIkV4dHJhY3RcIl0gPSAwXSA9IFwiRXh0cmFjdFwiO1xuICAgICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIk1lcmdlXCJdID0gMV0gPSBcIk1lcmdlXCI7XG4gIH0pKF9WaXNpdG9yTW9kZSB8fCAoX1Zpc2l0b3JNb2RlID0ge30pKTtcbiAgLyoqXG4gICAqIFRoaXMgVmlzaXRvciBpcyB1c2VkOlxuICAgKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAgICogMi4gdG8gcmVwbGFjZSB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3Mgd2l0aCB0aGUgYWN0dWFsIHRyYW5zbGF0aW9ucyAoc2VlIGBtZXJnZSgpYClcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgX1Zpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1Zpc2l0b3IoX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRXh0cmFjdHMgdGhlIG1lc3NhZ2VzIGZyb20gdGhlIHRyZWVcbiAgICAgICAqL1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLkV4dHJhY3QsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMsIG51bGwpOyB9KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQodGhpcy5fbWVzc2FnZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgdHJlZSB3aGVyZSBhbGwgdHJhbnNsYXRhYmxlIG5vZGVzIGFyZSB0cmFuc2xhdGVkXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdChfVmlzaXRvck1vZGUuTWVyZ2UsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9ucztcbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBFbGVtZW50KCd3cmFwcGVyJywgW10sIG5vZGVzLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyYW5zbGF0ZWROb2RlLmNoaWxkcmVuLCB0aGlzLl9lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICAgIC8vIFBhcnNlIGNhc2VzIGZvciB0cmFuc2xhdGFibGUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKGljdUNhc2UudmFsdWUsIGV4cHJlc3Npb24sIGljdUNhc2Uuc291cmNlU3BhbiwgaWN1Q2FzZS52YWx1ZVNvdXJjZVNwYW4sIGljdUNhc2UuZXhwU291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oaWN1KTtcbiAgICAgICAgICB2YXIgd2FzSW5JY3UgPSB0aGlzLl9pbkljdTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBleHRyYWN0ZWQgYnV0IHRvcC1sZXZlbCB0cmFuc2xhdGVkIGFzIGEgd2hvbGVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFtpY3VdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9pbkljdSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjYXNlcyA9IHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcywgY29udGV4dCk7XG4gICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgICBpY3UgPSBuZXcgRXhwYW5zaW9uKGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3BhbiwgaWN1LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2luSWN1ID0gd2FzSW5JY3U7XG4gICAgICAgICAgcmV0dXJuIGljdTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgaXNPcGVuaW5nID0gX2lzT3BlbmluZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnQ291bGQgbm90IHN0YXJ0IGEgYmxvY2sgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNDbG9zaW5nID0gX2lzQ2xvc2luZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgaWYgKGlzQ2xvc2luZyAmJiAhdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ1RyeWluZyB0byBjbG9zZSBhbiB1bm9wZW5lZCBibG9jaycpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5faW5JMThuTm9kZSAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzT3BlbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyA9IGNvbW1lbnQudmFsdWUucmVwbGFjZShfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCwgdGhpcy5fYmxvY2tDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZSh0aGlzLl9ibG9ja0NoaWxkcmVuLCB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYXR0cmlidXRlcyBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGNvbW1lbnQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwodGhpcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0kxOE4gYmxvY2tzIHNob3VsZCBub3QgY3Jvc3MgZWxlbWVudCBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbih0ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGVsKTtcbiAgICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICAgIHZhciB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgICB2YXIgd2FzSW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlcztcbiAgICAgICAgICAvLyBFeHRyYWN0IG9ubHkgdG9wIGxldmVsIG5vZGVzIHdpdGggdGhlIChpbXBsaWNpdCkgXCJpMThuXCIgYXR0cmlidXRlIGlmIG5vdCBpbiBhIGJsb2NrIG9yIGFuIElDVVxuICAgICAgICAgIC8vIG1lc3NhZ2VcbiAgICAgICAgICB2YXIgaTE4bkF0dHIgPSBfZ2V0STE4bkF0dHIoZWwpO1xuICAgICAgICAgIHZhciBpc0ltcGxpY2l0ID0gdGhpcy5faW1wbGljaXRUYWdzLnNvbWUoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gZWwubmFtZSA9PT0gdGFnOyB9KSAmJlxuICAgICAgICAgICAgICAhdGhpcy5faW5JY3UgJiYgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICAgIHZhciBpc1RvcExldmVsSW1wbGljaXQgPSAhd2FzSW5JbXBsaWNpdE5vZGUgJiYgaXNJbXBsaWNpdDtcbiAgICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IHRoaXMuX2luSW1wbGljaXROb2RlIHx8IGlzSW1wbGljaXQ7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbiAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgICAgaWYgKGkxOG5BdHRyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UoZWwuY2hpbGRyZW4sIGkxOG5BdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGltcGxpY2l0IHRyYW5zbGF0aW9uXG4gICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZShlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1RyYW5zbGF0YWJsZSA9IGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdDtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGVsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihlbCwgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UgJiYgIWkxOG5BdHRyICYmICFpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBjbG9zZSAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCAnQ291bGQgbm90IG1hcmsgYW4gZWxlbWVudCBhcyB0cmFuc2xhdGFibGUgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgICAgLy8gRGVzY2VuZCBpbnRvIGNoaWxkIG5vZGVzIGZvciBleHRyYWN0aW9uXG4gICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgYXR0cmlidXRlcyBpbiBJQ1UgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBjbG9zZSAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdmlzaXRBdHRyaWJ1dGVzT2YoZWwpO1xuICAgICAgICAgIHRoaXMuX2RlcHRoLS07XG4gICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHdhc0luSTE4bk5vZGU7XG4gICAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBjaGlsZE5vZGVzIGluIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAtIHRob3NlIG5vZGVzIHdpbGwgYmUgcmVwbGFjZSBhbnl3YXlcbiAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBdHRycyA9IHRoaXMuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMoZWwpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWwubmFtZSwgdHJhbnNsYXRlZEF0dHJzLCBjaGlsZE5vZGVzLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG1vZGUsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9kZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5faW5JY3UgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZSA9IGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgIH07XG4gICAgICAvLyBsb29rcyBmb3IgdHJhbnNsYXRhYmxlIGF0dHJpYnV0ZXNcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRBdHRyaWJ1dGVzT2YgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZSA9IHt9O1xuICAgICAgICAgIHZhciBpbXBsaWNpdEF0dHJOYW1lcyA9IHRoaXMuX2ltcGxpY2l0QXR0cnNbZWwubmFtZV0gfHwgW107XG4gICAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCk7IH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICBhdHRyLnZhbHVlOyB9KTtcbiAgICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgaW4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRNZXNzYWdlKFthdHRyXSwgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wbGljaXRBdHRyTmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXR0ci5uYW1lID09PSBuYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8vIGFkZCBhIHRyYW5zbGF0YWJsZSBtZXNzYWdlXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX2FkZE1lc3NhZ2UgPSBmdW5jdGlvbiAoYXN0LCBtZWFuaW5nQW5kRGVzYykge1xuICAgICAgICAgIGlmIChhc3QubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgICAgYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSQxICYmICFhc3RbMF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGNyZWF0ZSBlbXB0eSBtZXNzYWdlc1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfYSA9IF9zcGxpdE1lYW5pbmdBbmREZXNjKG1lYW5pbmdBbmREZXNjKSwgbWVhbmluZyA9IF9hWzBdLCBkZXNjcmlwdGlvbiA9IF9hWzFdO1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoYXN0LCBtZWFuaW5nLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG4gICAgICAvLyBUcmFuc2xhdGVzIHRoZSBnaXZlbiBtZXNzYWdlIGdpdmVuIHRoZSBgVHJhbnNsYXRpb25CdW5kbGVgXG4gICAgICAvLyBuby1vcCB3aGVuIGNhbGxlZCBpbiBleHRyYWN0aW9uIG1vZGUgKHJldHVybnMgW10pXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAobWVzc2FnZSAmJiB0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gZGlnZXN0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRpb25zLmdldChpZCk7XG4gICAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBtZXNzYWdlIGlkPVxcXCJcIiArIGlkICsgXCJcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICB9O1xuICAgICAgLy8gdHJhbnNsYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnQgYW5kIHJlbW92ZSBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdHJhbnNsYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBlbC5hdHRycztcbiAgICAgICAgICB2YXIgaTE4bkF0dHJpYnV0ZU1lYW5pbmdzID0ge307XG4gICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAgIGkxOG5BdHRyaWJ1dGVNZWFuaW5nc1thdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICAgICAgICAgIF9zcGxpdE1lYW5pbmdBbmREZXNjKGF0dHIudmFsdWUpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IF9JMThOX0FUVFIgfHwgYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdHJpcCBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXR0ci52YWx1ZSAmJiBhdHRyLnZhbHVlICE9ICcnICYmIGkxOG5BdHRyaWJ1dGVNZWFuaW5ncy5oYXNPd25Qcm9wZXJ0eShhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVhbmluZyA9IGkxOG5BdHRyaWJ1dGVNZWFuaW5nc1thdHRyLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBfdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBtZWFuaW5nLCAnJyk7XG4gICAgICAgICAgICAgICAgICB2YXIgaWQgPSBkaWdlc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gX3RoaXMuX3RyYW5zbGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzWzBdIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2Rlc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlJDEoYXR0ci5uYW1lLCB2YWx1ZSwgYXR0ci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0cmFuc2xhdGlvbiBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkQXR0cmlidXRlcztcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEFkZCB0aGUgbm9kZSBhcyBhIGNoaWxkIG9mIHRoZSBibG9jayB3aGVuOlxuICAgICAgICogLSB3ZSBhcmUgaW4gYSBibG9jayxcbiAgICAgICAqIC0gd2UgYXJlIG5vdCBpbnNpZGUgYSBJQ1UgbWVzc2FnZSAodGhvc2UgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSksXG4gICAgICAgKiAtIHRoZSBub2RlIGlzIGEgXCJkaXJlY3QgY2hpbGRcIiBvZiB0aGUgYmxvY2tcbiAgICAgICAqL1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jayAmJiAhdGhpcy5faW5JY3UgJiYgdGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBNYXJrcyB0aGUgc3RhcnQgb2YgYSBzZWN0aW9uLCBzZWUgYF9lbmRTZWN0aW9uYFxuICAgICAgICovXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBzdGFydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9WaXNpdG9yLnByb3RvdHlwZSwgXCJfaXNJblRyYW5zbGF0YWJsZVNlY3Rpb25cIiwge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgdHJhbnNsYXRhYmxlIHNlY3Rpb24gY291bGQgYmU6XG4gICAgICAgICAgICogLSBhIHRyYW5zbGF0YWJsZSBlbGVtZW50LFxuICAgICAgICAgICAqIC0gbm9kZXMgYmV0d2VlbiBgPCEtLSBpMThuIC0tPmAgYW5kIGA8IS0tIC9pMThuIC0tPmAgY29tbWVudHNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgIT09IHZvaWQgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogVGVybWluYXRlcyBhIHNlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogSWYgYSBzZWN0aW9uIGhhcyBvbmx5IG9uZSBzaWduaWZpY2FudCBjaGlsZHJlbiAoY29tbWVudHMgbm90IHNpZ25pZmljYW50KSB0aGVuIHdlIHNob3VsZCBub3RcbiAgICAgICAqIGtlZXAgdGhlIG1lc3NhZ2UgZnJvbSB0aGlzIGNoaWxkcmVuOlxuICAgICAgICpcbiAgICAgICAqIGA8cCBpMThuPVwibWVhbmluZ3xkZXNjcmlwdGlvblwiPntJQ1UgbWVzc2FnZX08L3A+YCB3b3VsZCBwcm9kdWNlIHR3byBtZXNzYWdlczpcbiAgICAgICAqIC0gb25lIGZvciB0aGUgPHA+IGNvbnRlbnQgd2l0aCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbixcbiAgICAgICAqIC0gYW5vdGhlciBvbmUgZm9yIHRoZSBJQ1UgbWVzc2FnZS5cbiAgICAgICAqXG4gICAgICAgKiBJbiB0aGlzIGNhc2UgdGhlIGxhc3QgbWVzc2FnZSBpcyBkaXNjYXJkZWQgYXMgaXQgY29udGFpbnMgbGVzcyBpbmZvcm1hdGlvbiAodGhlIEFTVCBpc1xuICAgICAgICogb3RoZXJ3aXNlIGlkZW50aWNhbCkuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHdlIHNob3VsZCBzdGlsbCBrZWVwIG1lc3NhZ2VzIGV4dHJhY3RlZCBmcm9tIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBzZWN0aW9uIChpZSBpbiB0aGVcbiAgICAgICAqIElDVSBtZXNzYWdlIGhlcmUpXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGRpcmVjdENoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIGVuZCcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydDtcbiAgICAgICAgICB2YXIgc2lnbmlmaWNhbnRDaGlsZHJlbiA9IGRpcmVjdENoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIG5vZGUpIHsgcmV0dXJuIGNvdW50ICsgKG5vZGUgaW5zdGFuY2VvZiBDb21tZW50ID8gMCA6IDEpOyB9LCAwKTtcbiAgICAgICAgICBpZiAoc2lnbmlmaWNhbnRDaGlsZHJlbiA9PSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX21lc3NhZ2VzW2ldLm5vZGVzO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIFRleHQkMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1zZykge1xuICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1Zpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9pc09wZW5pbmdDb21tZW50KG4pIHtcbiAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUuc3RhcnRzV2l0aCgnaTE4bicpO1xuICB9XG4gIGZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUgPT09ICcvaTE4bic7XG4gIH1cbiAgZnVuY3Rpb24gX2dldEkxOG5BdHRyKHApIHtcbiAgICAgIHJldHVybiBwLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUjsgfSkgfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBfc3BsaXRNZWFuaW5nQW5kRGVzYyhpMThuKSB7XG4gICAgICBpZiAoIWkxOG4pXG4gICAgICAgICAgcmV0dXJuIFsnJywgJyddO1xuICAgICAgdmFyIHBpcGVJbmRleCA9IGkxOG4uaW5kZXhPZignfCcpO1xuICAgICAgcmV0dXJuIHBpcGVJbmRleCA9PSAtMSA/IFsnJywgaTE4bl0gOiBbaTE4bi5zbGljZSgwLCBwaXBlSW5kZXgpLCBpMThuLnNsaWNlKHBpcGVJbmRleCArIDEpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBmb3IgbWVzc2FnZSBleHRyYWN0ZWQgZnJvbSB0aGUgdGVtcGxhdGVzLlxuICAgKi9cbiAgdmFyIE1lc3NhZ2VCdW5kbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTWVzc2FnZUJ1bmRsZShfaHRtbFBhcnNlciwgX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU1hcCA9IHt9O1xuICAgICAgfVxuICAgICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUudXBkYXRlRnJvbVRlbXBsYXRlID0gZnVuY3Rpb24gKGh0bWwsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGh0bWxQYXJzZXJSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKGh0bWwsIHVybCwgdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gaHRtbFBhcnNlclJlc3VsdC5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpMThuUGFyc2VyUmVzdWx0ID0gZXh0cmFjdE1lc3NhZ2VzKGh0bWxQYXJzZXJSZXN1bHQucm9vdE5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCB0aGlzLl9pbXBsaWNpdFRhZ3MsIHRoaXMuX2ltcGxpY2l0QXR0cnMpO1xuICAgICAgICAgIGlmIChpMThuUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpMThuUGFyc2VyUmVzdWx0Lm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgX3RoaXMuX21lc3NhZ2VNYXBbZGlnZXN0TWVzc2FnZShtZXNzYWdlKV0gPSBtZXNzYWdlOyB9KTtcbiAgICAgIH07XG4gICAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS5nZXRNZXNzYWdlTWFwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZU1hcDsgfTtcbiAgICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXIpIHsgcmV0dXJuIHNlcmlhbGl6ZXIud3JpdGUodGhpcy5fbWVzc2FnZU1hcCk7IH07XG4gICAgICByZXR1cm4gTWVzc2FnZUJ1bmRsZTtcbiAgfSgpKTtcblxuICAvKipcbiAgICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXG4gICAqL1xuICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICBtW2tdID0gbTFba107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gX2NbX2JdO1xuICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgfTtcbiAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgIHZhciBrMSA9IE9iamVjdC5rZXlzKG0xKTtcbiAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBrMVtpXTtcbiAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgfSgpKTtcbiAgdmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGZsYXQsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgdmFyIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IExpc3RXcmFwcGVyLmZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICAgICAgICByZXR1cm4gZmxhdC5jb25jYXQoZmxhdEl0ZW0pO1xuICAgICAgICAgIH0sIFtdKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gIH0oKSk7XG5cbiAgdmFyIFhtbFRhZ0RlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gWG1sVGFnRGVmaW5pdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEE7XG4gICAgICAgICAgdGhpcy5pc1ZvaWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5pc0Nsb3NlZEJ5Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICByZXR1cm4gWG1sVGFnRGVmaW5pdGlvbjtcbiAgfSgpKTtcbiAgdmFyIF9UQUdfREVGSU5JVElPTiA9IG5ldyBYbWxUYWdEZWZpbml0aW9uKCk7XG4gIGZ1bmN0aW9uIGdldFhtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgICAgcmV0dXJuIF9UQUdfREVGSU5JVElPTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgWG1sUGFyc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ1KFhtbFBhcnNlciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFhtbFBhcnNlcigpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBnZXRYbWxUYWdEZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgICAgIFhtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMpIHtcbiAgICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIG51bGwpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBYbWxQYXJzZXI7XG4gIH0oUGFyc2VyJDEpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8vIEdlbmVyYXRlIGEgbWFwIG9mIHBsYWNlaG9sZGVyIHRvIGNvbnRlbnQgaW5kZXhlZCBieSBtZXNzYWdlIGlkc1xuICBmdW5jdGlvbiBleHRyYWN0UGxhY2Vob2xkZXJzKG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgIHZhciBtZXNzYWdlTWFwID0gbWVzc2FnZUJ1bmRsZS5nZXRNZXNzYWdlTWFwKCk7XG4gICAgICB2YXIgcGxhY2Vob2xkZXJzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhtZXNzYWdlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgIHBsYWNlaG9sZGVyc1ttc2dJZF0gPSBtZXNzYWdlTWFwW21zZ0lkXS5wbGFjZWhvbGRlcnM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcnM7XG4gIH1cbiAgLy8gR2VuZXJhdGUgYSBtYXAgb2YgcGxhY2Vob2xkZXIgdG8gbWVzc2FnZSBpZHMgaW5kZXhlZCBieSBtZXNzYWdlIGlkc1xuICBmdW5jdGlvbiBleHRyYWN0UGxhY2Vob2xkZXJUb0lkcyhtZXNzYWdlQnVuZGxlKSB7XG4gICAgICB2YXIgbWVzc2FnZU1hcCA9IG1lc3NhZ2VCdW5kbGUuZ2V0TWVzc2FnZU1hcCgpO1xuICAgICAgdmFyIHBsYWNlaG9sZGVyVG9JZHMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VNYXApLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgcGxhY2Vob2xkZXJUb0lkc1ttc2dJZF0gPSBtZXNzYWdlTWFwW21zZ0lkXS5wbGFjZWhvbGRlclRvTXNnSWRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXJUb0lkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgX1Zpc2l0b3IkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJBdHRycyA9IHRoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXModGFnLmF0dHJzKTtcbiAgICAgICAgICBpZiAodGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZy5uYW1lICsgc3RyQXR0cnMgKyBcIi8+XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHJDaGlsZHJlbiA9IHRhZy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCI+XCIgKyBzdHJDaGlsZHJlbi5qb2luKCcnKSArIFwiPC9cIiArIHRhZy5uYW1lICsgXCI+XCI7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoZGVjbCkge1xuICAgICAgICAgIHJldHVybiBcIjw/eG1sXCIgKyB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKGRlY2wuYXR0cnMpICsgXCIgPz5cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgICB2YXIgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAobmFtZSArIFwiPVxcXCJcIiArIGF0dHJzW25hbWVdICsgXCJcXFwiXCIpOyB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgcmV0dXJuIHN0ckF0dHJzLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJBdHRycyA6ICcnO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkge1xuICAgICAgICAgIHJldHVybiBcIjwhRE9DVFlQRSBcIiArIGRvY3R5cGUucm9vdFRhZyArIFwiIFtcXG5cIiArIGRvY3R5cGUuZHRkICsgXCJcXG5dPlwiO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmlzaXRvcjtcbiAgfSgpKTtcbiAgdmFyIF92aXNpdG9yID0gbmV3IF9WaXNpdG9yJDEoKTtcbiAgZnVuY3Rpb24gc2VyaWFsaXplKG5vZGVzKSB7XG4gICAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF92aXNpdG9yKTsgfSkuam9pbignJyk7XG4gIH1cbiAgdmFyIERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKHVuZXNjYXBlZEF0dHJzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgX3RoaXMuYXR0cnNba10gPSBfZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIERlY2xhcmF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb24odGhpcyk7IH07XG4gICAgICByZXR1cm4gRGVjbGFyYXRpb247XG4gIH0oKSk7XG4gIHZhciBEb2N0eXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERvY3R5cGUocm9vdFRhZywgZHRkKSB7XG4gICAgICAgICAgdGhpcy5yb290VGFnID0gcm9vdFRhZztcbiAgICAgICAgICB0aGlzLmR0ZCA9IGR0ZDtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIERvY3R5cGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXREb2N0eXBlKHRoaXMpOyB9O1xuICAgICAgcmV0dXJuIERvY3R5cGU7XG4gIH0oKSk7XG4gIHZhciBUYWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGFnKG5hbWUsIHVuZXNjYXBlZEF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHVuZXNjYXBlZEF0dHJzID09PSB2b2lkIDApIHsgdW5lc2NhcGVkQXR0cnMgPSB7fTsgfVxuICAgICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgX3RoaXMuYXR0cnNba10gPSBfZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFRhZy5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFRhZyh0aGlzKTsgfTtcbiAgICAgIHJldHVybiBUYWc7XG4gIH0oKSk7XG4gIHZhciBUZXh0JDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGV4dCh1bmVzY2FwZWRWYWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBfZXNjYXBlWG1sKHVuZXNjYXBlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMpOyB9O1xuICAgICAgcmV0dXJuIFRleHQ7XG4gIH0oKSk7XG4gIHZhciBDUiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNihDUiwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENSKHdzKSB7XG4gICAgICAgICAgaWYgKHdzID09PSB2b2lkIDApIHsgd3MgPSAwOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJcXG5cIiArIG5ldyBBcnJheSh3cyArIDEpLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ1I7XG4gIH0oVGV4dCQyKSk7XG4gIHZhciBfRVNDQVBFRF9DSEFSUyA9IFtcbiAgICAgIFsvJi9nLCAnJmFtcDsnXSxcbiAgICAgIFsvXCIvZywgJyZxdW90OyddLFxuICAgICAgWy8nL2csICcmYXBvczsnXSxcbiAgICAgIFsvPC9nLCAnJmx0OyddLFxuICAgICAgWy8+L2csICcmZ3Q7J10sXG4gIF07XG4gIGZ1bmN0aW9uIF9lc2NhcGVYbWwodGV4dCkge1xuICAgICAgcmV0dXJuIF9FU0NBUEVEX0NIQVJTLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgZW50cnkpIHsgcmV0dXJuIHRleHQucmVwbGFjZShlbnRyeVswXSwgZW50cnlbMV0pOyB9LCB0ZXh0KTtcbiAgfVxuXG4gIHZhciBfVkVSU0lPTiA9ICcxLjInO1xuICB2YXIgX1hNTE5TID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoxLjInO1xuICAvLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxuICB2YXIgX1NPVVJDRV9MQU5HID0gJ2VuJztcbiAgdmFyIF9QTEFDRUhPTERFUl9UQUcgPSAneCc7XG4gIHZhciBfU09VUkNFX1RBRyA9ICdzb3VyY2UnO1xuICB2YXIgX1RBUkdFVF9UQUcgPSAndGFyZ2V0JztcbiAgdmFyIF9VTklUX1RBRyA9ICd0cmFucy11bml0JztcbiAgLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi9vcy94bGlmZi1jb3JlLmh0bWxcbiAgLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi94bGlmZi1wcm9maWxlLWh0bWwveGxpZmYtcHJvZmlsZS1odG1sLTEuMi5odG1sXG4gIHZhciBYbGlmZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYbGlmZihfaHRtbFBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgfVxuICAgICAgWGxpZmYucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VNYXApIHtcbiAgICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yKCk7XG4gICAgICAgICAgdmFyIHRyYW5zVW5pdHMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VNYXBbaWRdO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUcsIHsgaWQ6IGlkLCBkYXRhdHlwZTogJ2h0bWwnIH0pO1xuICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoX1NPVVJDRV9UQUcsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSksIG5ldyBDUig4KSwgbmV3IFRhZyhfVEFSR0VUX1RBRykpO1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgcHJpb3JpdHk6ICcxJywgZnJvbTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgICAgdHJhbnNVbml0cy5wdXNoKG5ldyBDUig2KSwgdHJhbnNVbml0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYm9keSA9IG5ldyBUYWcoJ2JvZHknLCB7fSwgdHJhbnNVbml0cy5jb25jYXQoW25ldyBDUig0KV0pKTtcbiAgICAgICAgICB2YXIgZmlsZSA9IG5ldyBUYWcoJ2ZpbGUnLCB7ICdzb3VyY2UtbGFuZ3VhZ2UnOiBfU09VUkNFX0xBTkcsIGRhdGF0eXBlOiAncGxhaW50ZXh0Jywgb3JpZ2luYWw6ICduZzIudGVtcGxhdGUnIH0sIFtuZXcgQ1IoNCksIGJvZHksIG5ldyBDUigyKV0pO1xuICAgICAgICAgIHZhciB4bGlmZiA9IG5ldyBUYWcoJ3hsaWZmJywgeyB2ZXJzaW9uOiBfVkVSU0lPTiwgeG1sbnM6IF9YTUxOUyB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgICBdKTtcbiAgICAgIH07XG4gICAgICBYbGlmZi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSB4dGIgZmlsZSBpbnRvIHhtbCBub2Rlc1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoY29udGVudCwgdXJsKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIHJlc3VsdC5lcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBwbGFjZWhvbGRlcnMsIG1lc3NhZ2VzIGFyZSBub3cgc3RyaW5nXG4gICAgICAgICAgdmFyIF9hID0gbmV3IF9Mb2FkVmlzaXRvcigpLnBhcnNlKHJlc3VsdC5yb290Tm9kZXMsIG1lc3NhZ2VCdW5kbGUpLCBtZXNzYWdlcyA9IF9hLm1lc3NhZ2VzLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyBtZXNzYWdlcyB0byBodG1sIGFzdFxuICAgICAgICAgIC8vIFRPRE8odmljYik6IG1hcCBlcnJvciBtZXNzYWdlIGJhY2sgdG8gdGhlIG9yaWdpbmFsIG1lc3NhZ2UgaW4geHRiXG4gICAgICAgICAgdmFyIG1lc3NhZ2VNYXAgPSB7fTtcbiAgICAgICAgICB2YXIgcGFyc2VFcnJvcnMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLl9odG1sUGFyc2VyLnBhcnNlKG1lc3NhZ2VzW2lkXSwgdXJsLCB0cnVlLCBfdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgIHBhcnNlRXJyb3JzLnB1c2guYXBwbHkocGFyc2VFcnJvcnMsIHJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICBtZXNzYWdlTWFwW2lkXSA9IHJlcy5yb290Tm9kZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHBhcnNlRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgcGFyc2VFcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZU1hcDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gWGxpZmY7XG4gIH0oKSk7XG4gIHZhciBfV3JpdGVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9Xcml0ZVZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2Rlcywgbm9kZS52aXNpdChfdGhpcykpOyB9KTtcbiAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzSW5JY3UpIHtcbiAgICAgICAgICAgICAgLy8gbmVzdGVkIElDVSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneGxpZmYgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgSUNVIG1lc3NhZ2VzJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2lzSW5JY3UgPSB0cnVlO1xuICAgICAgICAgIC8vIFRPRE8odmljYik6IHN1cHBvcnQgSUNVIG1lc3NhZ2VzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9saXN0cy5vYXNpcy1vcGVuLm9yZy9hcmNoaXZlcy94bGlmZi8yMDEyMDEvbXNnMDAwMjguaHRtbFxuICAgICAgICAgIC8vIGh0dHA6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3YxLjIveGxpZmYtcHJvZmlsZS1wby94bGlmZi1wcm9maWxlLXBvLTEuMi1jZDAyLmh0bWxcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9pc0luSWN1ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfTtcbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgY3R5cGUgPSBnZXRDdHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICAgIHZhciBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAgIC8vIHZvaWQgdGFncyBoYXZlIG5vIGNoaWxkcmVuIG5vciBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNsb3NlVGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLmNsb3NlTmFtZSwgY3R5cGU6IGN0eXBlIH0pO1xuICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICAgIH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgICAgfTtcbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9pc0luSWN1ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZsYXR0ZW4obm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfV3JpdGVWaXNpdG9yO1xuICB9KCkpO1xuICAvLyBUT0RPKHZpY2IpOiBhZGQgZXJyb3IgbWFuYWdlbWVudCAoc3RydWN0dXJlKVxuICAvLyBUT0RPKHZpY2IpOiBmYWN0b3JpemUgKHh0YikgP1xuICB2YXIgX0xvYWRWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9Mb2FkVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAobm9kZXMsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcyA9IHt9O1xuICAgICAgICAgIHRoaXMuX21zZ0lkID0gJyc7XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gW107XG4gICAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgICAgLy8gRmluZCBhbGwgbWVzc2FnZXNcbiAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBub2RlcywgbnVsbCk7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VNYXAgPSBtZXNzYWdlQnVuZGxlLmdldE1lc3NhZ2VNYXAoKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJzID0gZXh0cmFjdFBsYWNlaG9sZGVycyhtZXNzYWdlQnVuZGxlKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJUb0lkcyA9IGV4dHJhY3RQbGFjZWhvbGRlclRvSWRzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2Rlc1xuICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgbWVzc2FnZXMgdGhhdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgc291cmNlIG1lc3NhZ2UgYnVuZGxlLlxuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZU1hcC5oYXNPd25Qcm9wZXJ0eShtZXNzYWdlWzBdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG5vIElDVSBwbGFjZWhvbGRlcnMgaW5zaWRlIGFuIElDVSBtZXNzYWdlLFxuICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgYHBsYWNlaG9sZGVyVG9Nc2dJZHNgIG9mIHRoZSByZWZlcmVuY2VkXG4gICAgICAgICAgICAgIC8vIG1lc3NhZ2VzLCB0aG9zZSB3b3VsZCBhbHdheXMgYmUgZW1wdHlcbiAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogb3ZlcmtpbGwgLSBjcmVhdGUgMiBidWNrZXRzIGFuZCBbLi4ud29EZXBzLCAuLi53RGVwc10ucHJvY2VzcygpXG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNzYWdlTWFwW2FbMF1dLnBsYWNlaG9sZGVyVG9Nc2dJZHMpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYlswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IG1lc3NhZ2VbMF07XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICBfdGhpcy5fcGxhY2Vob2xkZXJUb0lkcyA9IHBsYWNlaG9sZGVyVG9JZHNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gYF9UUkFOU0xBVElPTlNfVEFHYCBub3IgYF9UUkFOU0xBVElPTl9UQUdgXG4gICAgICAgICAgICAgIF90aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbaWRdID0gdmlzaXRBbGwoX3RoaXMsIG1lc3NhZ2VbMV0pLmpvaW4oJycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2VzOiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMsIGVycm9yczogdGhpcy5fZXJyb3JzIH07XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgX1VOSVRfVEFHOlxuICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHZhciBtc2dJZCA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbXNnSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9VTklUX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWQgPSBtc2dJZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzLnB1c2goW3RoaXMuX21zZ0lkLCB0aGlzLl90YXJnZXRdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9TT1VSQ0VfVEFHOlxuICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfVEFSR0VUX1RBRzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfVEFHOlxuICAgICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICghaWRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlclRvSWRzLmhhc093blByb3BlcnR5KGlkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMuaGFzT3duUHJvcGVydHkodGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tpZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbdGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tpZF1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBiZXR0ZXIgZXJyb3IgbWVzc2FnZSBmb3Igd2hlblxuICAgICAgICAgICAgICAgICAgICAgIC8vICF0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMuaGFzT3duUHJvcGVydHkodGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tpZF0pXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJUaGUgcGxhY2Vob2xkZXIgXFxcIlwiICsgaWQgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3RzIGluIHRoZSBzb3VyY2UgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuICcnOyB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Mb2FkVmlzaXRvcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZ2V0Q3R5cGVGb3JUYWcodGFnKSB7XG4gICAgICBzd2l0Y2ggKHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICAgICAgICByZXR1cm4gJ2xiJztcbiAgICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gXCJ4LVwiICsgdGFnO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIF9NRVNTQUdFU19UQUcgPSAnbWVzc2FnZWJ1bmRsZSc7XG4gIHZhciBfTUVTU0FHRV9UQUcgPSAnbXNnJztcbiAgdmFyIF9QTEFDRUhPTERFUl9UQUckMSA9ICdwaCc7XG4gIHZhciBfRVhFTVBMRV9UQUcgPSAnZXgnO1xuICB2YXIgX0RPQ1RZUEUgPSBcIjwhRUxFTUVOVCBtZXNzYWdlYnVuZGxlIChtc2cpKj5cXG48IUFUVExJU1QgbWVzc2FnZWJ1bmRsZSBjbGFzcyBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgbXNnICgjUENEQVRBfHBofHNvdXJjZSkqPlxcbjwhQVRUTElTVCBtc2cgaWQgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBzZXEgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBuYW1lIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgZGVzYyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG1lYW5pbmcgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBvYnNvbGV0ZSAob2Jzb2xldGUpICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgeG1sOnNwYWNlIChkZWZhdWx0fHByZXNlcnZlKSBcXFwiZGVmYXVsdFxcXCI+XFxuPCFBVFRMSVNUIG1zZyBpc19oaWRkZW4gQ0RBVEEgI0lNUExJRUQ+XFxuXFxuPCFFTEVNRU5UIHNvdXJjZSAoI1BDREFUQSk+XFxuXFxuPCFFTEVNRU5UIHBoICgjUENEQVRBfGV4KSo+XFxuPCFBVFRMSVNUIHBoIG5hbWUgQ0RBVEEgI1JFUVVJUkVEPlxcblxcbjwhRUxFTUVOVCBleCAoI1BDREFUQSk+XCI7XG4gIHZhciBYbWIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gWG1iKCkge1xuICAgICAgfVxuICAgICAgWG1iLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlTWFwKSB7XG4gICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMigpO1xuICAgICAgICAgIHZhciByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlTWFwW2lkXTtcbiAgICAgICAgICAgICAgdmFyIGF0dHJzID0geyBpZDogaWQgfTtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzWydkZXNjJ10gPSBtZXNzYWdlLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzWydtZWFuaW5nJ10gPSBtZXNzYWdlLm1lYW5pbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMiksIG5ldyBUYWcoX01FU1NBR0VfVEFHLCBhdHRycywgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigpKTtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLFxuICAgICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgICAgbmV3IERvY3R5cGUoX01FU1NBR0VTX1RBRywgX0RPQ1RZUEUpLFxuICAgICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIFhtYi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFhtYjtcbiAgfSgpKTtcbiAgdmFyIF9WaXNpdG9yJDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1Zpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBub2RlLnZpc2l0KF90aGlzKSk7IH0pO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbbmV3IFRleHQkMihcIntcIiArIGljdS5leHByZXNzaW9uICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgW25ldyBUZXh0JDIoYyArIFwiIHtcIildLmNvbmNhdChpY3UuY2FzZXNbY10udmlzaXQoX3RoaXMpLCBbbmV3IFRleHQkMihcIn0gXCIpXSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMihcIn1cIikpO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBzdGFydEV4ID0gbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbbmV3IFRleHQkMihcIjxcIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICAgIHZhciBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGguc3RhcnROYW1lIH0sIFtzdGFydEV4XSk7XG4gICAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjbG9zZUV4ID0gbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbbmV3IFRleHQkMihcIjwvXCIgKyBwaC50YWcgKyBcIj5cIildKTtcbiAgICAgICAgICB2YXIgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IG5hbWU6IHBoLmNsb3NlTmFtZSB9LCBbY2xvc2VFeF0pO1xuICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IG5hbWU6IHBoLm5hbWUgfSldO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5mbGF0dGVuKG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1Zpc2l0b3I7XG4gIH0oKSk7XG5cbiAgdmFyIF9UUkFOU0xBVElPTlNfVEFHID0gJ3RyYW5zbGF0aW9uYnVuZGxlJztcbiAgdmFyIF9UUkFOU0xBVElPTl9UQUcgPSAndHJhbnNsYXRpb24nO1xuICB2YXIgX1BMQUNFSE9MREVSX1RBRyQyID0gJ3BoJztcbiAgdmFyIFh0YiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYdGIoX2h0bWxQYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgIH1cbiAgICAgIFh0Yi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZU1hcCkgeyB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7IH07XG4gICAgICBYdGIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsLCBtZXNzYWdlQnVuZGxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAvLyBQYXJzZSB0aGUgeHRiIGZpbGUgaW50byB4bWwgbm9kZXNcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKGNvbnRlbnQsIHVybCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyByZXN1bHQuZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzLCBtZXNzYWdlcyBhcmUgbm93IHN0cmluZ1xuICAgICAgICAgIHZhciBfYSA9IG5ldyBfVmlzaXRvciQzKCkucGFyc2UocmVzdWx0LnJvb3ROb2RlcywgbWVzc2FnZUJ1bmRsZSksIG1lc3NhZ2VzID0gX2EubWVzc2FnZXMsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIG1lc3NhZ2VzIHRvIGh0bWwgYXN0XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogbWFwIGVycm9yIG1lc3NhZ2UgYmFjayB0byB0aGUgb3JpZ2luYWwgbWVzc2FnZSBpbiB4dGJcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IHt9O1xuICAgICAgICAgIHZhciBwYXJzZUVycm9ycyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuX2h0bWxQYXJzZXIucGFyc2UobWVzc2FnZXNbaWRdLCB1cmwsIHRydWUsIF90aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgcGFyc2VFcnJvcnMucHVzaC5hcHBseShwYXJzZUVycm9ycywgcmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VNYXBbaWRdID0gcmVzLnJvb3ROb2RlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGFyc2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBwYXJzZUVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBYdGI7XG4gIH0oKSk7XG4gIHZhciBfVmlzaXRvciQzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9WaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG5vZGVzLCBtZXNzYWdlQnVuZGxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9tZXNzYWdlTm9kZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMgPSB7fTtcbiAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25EZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgICAgLy8gRmluZCBhbGwgbWVzc2FnZXNcbiAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBub2RlcywgbnVsbCk7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VNYXAgPSBtZXNzYWdlQnVuZGxlLmdldE1lc3NhZ2VNYXAoKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJzID0gZXh0cmFjdFBsYWNlaG9sZGVycyhtZXNzYWdlQnVuZGxlKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJUb0lkcyA9IGV4dHJhY3RQbGFjZWhvbGRlclRvSWRzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2Rlc1xuICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgbWVzc2FnZXMgdGhhdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgc291cmNlIG1lc3NhZ2UgYnVuZGxlLlxuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZU1hcC5oYXNPd25Qcm9wZXJ0eShtZXNzYWdlWzBdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG5vIElDVSBwbGFjZWhvbGRlcnMgaW5zaWRlIGFuIElDVSBtZXNzYWdlLFxuICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgYHBsYWNlaG9sZGVyVG9Nc2dJZHNgIG9mIHRoZSByZWZlcmVuY2VkXG4gICAgICAgICAgICAgIC8vIG1lc3NhZ2VzLCB0aG9zZSB3b3VsZCBhbHdheXMgYmUgZW1wdHlcbiAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogb3ZlcmtpbGwgLSBjcmVhdGUgMiBidWNrZXRzIGFuZCBbLi4ud29EZXBzLCAuLi53RGVwc10ucHJvY2VzcygpXG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNzYWdlTWFwW2FbMF1dLnBsYWNlaG9sZGVyVG9Nc2dJZHMpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYlswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IG1lc3NhZ2VbMF07XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICBfdGhpcy5fcGxhY2Vob2xkZXJUb0lkcyA9IHBsYWNlaG9sZGVyVG9JZHNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gYF9UUkFOU0xBVElPTlNfVEFHYCBub3IgYF9UUkFOU0xBVElPTl9UQUdgXG4gICAgICAgICAgICAgIF90aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbaWRdID0gdmlzaXRBbGwoX3RoaXMsIG1lc3NhZ2VbMV0pLmpvaW4oJycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2VzOiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMsIGVycm9yczogdGhpcy5fZXJyb3JzIH07XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBfVFJBTlNMQVRJT05TX1RBRzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoKys7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYnVuZGxlRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVFJBTlNMQVRJT05TX1RBRyArIFwiPiBlbGVtZW50cyBjYW4gbm90IGJlIG5lc3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTl9UQUc6XG4gICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkRlcHRoKys7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNsYXRpb25EZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTl9UQUcgKyBcIj4gZWxlbWVudHMgY2FuIG5vdCBiZSBuZXN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElDVSBwbGFjZWhvbGRlcnMgYXJlIHJlZmVyZW5jZSB0byBvdGhlciBtZXNzYWdlcy5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVmZXJlbmNlZCBtZXNzYWdlIG1pZ2h0IG5vdCBoYXZlIGJlZW4gZGVjb2RlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBoYXZlIGFsbCBtZXNzYWdlcyBhdmFpbGFibGUgdG8gbWFrZSBzdXJlIGRlcHMgYXJlIGRlY29kZWQgZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogcmVwb3J0IGFuIGVycm9yIG9uIGR1cGxpY2F0ZSBpZFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2Rlcy5wdXNoKFtpZEF0dHIudmFsdWUsIGVsZW1lbnQuY2hpbGRyZW5dKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uRGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUckMjpcbiAgICAgICAgICAgICAgICAgIHZhciBuYW1lQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbmFtZSc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lQXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQyICsgXCI+IG1pc3NlcyB0aGUgXFxcIm5hbWVcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBuYW1lQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyc1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJUb0lkcy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9wbGFjZWhvbGRlclRvSWRzW25hbWVfMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbdGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tuYW1lXzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogYmV0dGVyIGVycm9yIG1lc3NhZ2UgZm9yIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAvLyAhdGhpcy5fdHJhbnNsYXRlZE1lc3NhZ2VzLmhhc093blByb3BlcnR5KHRoaXMuX3BsYWNlaG9sZGVyVG9JZHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJUaGUgcGxhY2Vob2xkZXIgXFxcIlwiICsgbmFtZV8xICsgXCJcXFwiIGRvZXMgbm90IGV4aXN0cyBpbiB0aGUgc291cmNlIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsICdVbmV4cGVjdGVkIHRhZycpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiAnJzsgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJDYXNlcyA9IGV4cGFuc2lvbi5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmlzaXQoX3RoaXMsIG51bGwpOyB9KTtcbiAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBleHBhbnNpb24uc3dpdGNoVmFsdWUgKyBcIiwgXCIgKyBleHBhbnNpb24udHlwZSArIFwiLCBzdHJDYXNlcy5qb2luKCcgJyl9XCI7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGFuc2lvbkNhc2UudmFsdWUgKyBcIiB7XCIgKyB2aXNpdEFsbCh0aGlzLCBleHBhbnNpb25DYXNlLmV4cHJlc3Npb24sIG51bGwpICsgXCJ9XCI7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1Zpc2l0b3I7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogQSBjb250YWluZXIgZm9yIHRyYW5zbGF0ZWQgbWVzc2FnZXNcbiAgICovXG4gIHZhciBUcmFuc2xhdGlvbkJ1bmRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUcmFuc2xhdGlvbkJ1bmRsZShfbWVzc2FnZU1hcCkge1xuICAgICAgICAgIGlmIChfbWVzc2FnZU1hcCA9PT0gdm9pZCAwKSB7IF9tZXNzYWdlTWFwID0ge307IH1cbiAgICAgICAgICB0aGlzLl9tZXNzYWdlTWFwID0gX21lc3NhZ2VNYXA7XG4gICAgICB9XG4gICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSwgc2VyaWFsaXplcikge1xuICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25CdW5kbGUoc2VyaWFsaXplci5sb2FkKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSkpO1xuICAgICAgfTtcbiAgICAgIFRyYW5zbGF0aW9uQnVuZGxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VNYXBbaWRdOyB9O1xuICAgICAgVHJhbnNsYXRpb25CdW5kbGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgaW4gdGhpcy5fbWVzc2FnZU1hcDsgfTtcbiAgICAgIHJldHVybiBUcmFuc2xhdGlvbkJ1bmRsZTtcbiAgfSgpKTtcblxuICB2YXIgSTE4Tkh0bWxQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETyh2aWNiKTogdHJhbnNCLmxvYWQoKSBzaG91bGQgbm90IG5lZWQgYSBtc2dCICYgYWRkIHRyYW5zQi5yZXNvbHZlKG1zZ0IsXG4gICAgICAvLyBpbnRlcnBvbGF0aW9uQ29uZmlnKVxuICAgICAgLy8gVE9ETyh2aWNiKTogcmVtb3ZlIHRoZSBpbnRlcnBvbGF0aW9uQ29uZmlnIGZyb20gdGhlIFh0YiBzZXJpYWxpemVyXG4gICAgICBmdW5jdGlvbiBJMThOSHRtbFBhcnNlcihfaHRtbFBhcnNlciwgX3RyYW5zbGF0aW9ucywgX3RyYW5zbGF0aW9uc0Zvcm1hdCkge1xuICAgICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbnMgPSBfdHJhbnNsYXRpb25zO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uc0Zvcm1hdCA9IF90cmFuc2xhdGlvbnNGb3JtYXQ7XG4gICAgICB9XG4gICAgICBJMThOSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zbGF0aW9ucyB8fCB0aGlzLl90cmFuc2xhdGlvbnMgPT09ICcnKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBlbmFibGUgaTE4biB3aGVuIG5vIHRyYW5zbGF0aW9uIGJ1bmRsZSBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8odmljYik6IGFkZCBzdXBwb3J0IGZvciBpbXBsaWNpdCB0YWdzIC8gYXR0cmlidXRlc1xuICAgICAgICAgIHZhciBtZXNzYWdlQnVuZGxlID0gbmV3IE1lc3NhZ2VCdW5kbGUodGhpcy5faHRtbFBhcnNlciwgW10sIHt9KTtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gbWVzc2FnZUJ1bmRsZS51cGRhdGVGcm9tVGVtcGxhdGUoc291cmNlLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycy5jb25jYXQoZXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gdGhpcy5fY3JlYXRlU2VyaWFsaXplcihpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRpb25CdW5kbGUgPSBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRoaXMuX3RyYW5zbGF0aW9ucywgdXJsLCBtZXNzYWdlQnVuZGxlLCBzZXJpYWxpemVyKTtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VUcmFuc2xhdGlvbnMocGFyc2VSZXN1bHQucm9vdE5vZGVzLCB0cmFuc2xhdGlvbkJ1bmRsZSwgaW50ZXJwb2xhdGlvbkNvbmZpZywgW10sIHt9KTtcbiAgICAgIH07XG4gICAgICBJMThOSHRtbFBhcnNlci5wcm90b3R5cGUuX2NyZWF0ZVNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciBmb3JtYXQgPSAodGhpcy5fdHJhbnNsYXRpb25zRm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIodGhpcy5faHRtbFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgIGNhc2UgJ3hsaWZmJzpcbiAgICAgICAgICAgICAgY2FzZSAneGxmJzpcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWGxpZmYodGhpcy5faHRtbFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBJMThOSHRtbFBhcnNlcjtcbiAgfSgpKTtcblxuICB2YXIgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICtcbiAgICAgICcoWy1cXFxcd10rKXwnICtcbiAgICAgICcoPzpcXFxcLihbLVxcXFx3XSspKXwnICtcbiAgICAgICcoPzpcXFxcWyhbLVxcXFx3Kl0rKSg/Oj0oW15cXFxcXV0qKSk/XFxcXF0pfCcgK1xuICAgICAgJyhcXFxcKSl8JyArXG4gICAgICAnKFxcXFxzKixcXFxccyopJywgLy8gXCIsXCJcbiAgJ2cnKTtcbiAgLyoqXG4gICAqIEEgY3NzIHNlbGVjdG9yIGNvbnRhaW5zIGFuIGVsZW1lbnQgbmFtZSxcbiAgICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gICAqIG9mIHNlbGVjdGluZyBzdWJzZXRzIG91dCBvZiB0aGVtLlxuICAgKi9cbiAgdmFyIENzc1NlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENzc1NlbGVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzID0gW107XG4gICAgICB9XG4gICAgICBDc3NTZWxlY3Rvci5wYXJzZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgdmFyIF9hZGRSZXN1bHQgPSBmdW5jdGlvbiAocmVzLCBjc3NTZWwpIHtcbiAgICAgICAgICAgICAgaWYgKGNzc1NlbC5ub3RTZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAhY3NzU2VsLmVsZW1lbnQgJiYgY3NzU2VsLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgIGNzc1NlbC5hdHRycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgY3NzU2VsLmVsZW1lbnQgPSAnKic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgIHZhciBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgIF9TRUxFQ1RPUl9SRUdFWFAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBfU0VMRUNUT1JfUkVHRVhQLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0aW5nIDpub3QgaXMgbm90IGFsbG93ZWQgaW4gYSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5Ob3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgICAgY3NzU2VsZWN0b3Iubm90U2VsZWN0b3JzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50LnNldEVsZW1lbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5hZGRDbGFzc05hbWUobWF0Y2hbM10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5hZGRBdHRyaWJ1dGUobWF0Y2hbNF0sIG1hdGNoWzVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbNl0pIHtcbiAgICAgICAgICAgICAgICAgIGluTm90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3NzU2VsZWN0b3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzddKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfYWRkUmVzdWx0KHJlc3VsdHMsIGNzc1NlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5pc0VsZW1lbnRTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNFbGVtZW50U2VsZWN0b3IoKSAmJiB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiYgdGhpcy5hdHRycy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gICAgICB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmhhc0VsZW1lbnRTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5lbGVtZW50OyB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHsgZWxlbWVudCA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfTtcbiAgICAgIC8qKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuICovXG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRhZ05hbWUgPSB0aGlzLmVsZW1lbnQgfHwgJ2Rpdic7XG4gICAgICAgICAgdmFyIGNsYXNzQXR0ciA9IHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPiAwID8gXCIgY2xhc3M9XFxcIlwiICsgdGhpcy5jbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgdmFyIGF0dHJzID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBcIj1cXFwiXCIgKyB0aGlzLmF0dHJzW2kgKyAxXSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgIGF0dHJzICs9IFwiIFwiICsgYXR0ck5hbWUgKyBhdHRyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiLz5cIiA6XG4gICAgICAgICAgICAgIFwiPFwiICsgdGFnTmFtZSArIGNsYXNzQXR0ciArIGF0dHJzICsgXCI+PC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgICAgIH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICAgIHRoaXMuYXR0cnMucHVzaChuYW1lLCB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpIHx8ICcnKTtcbiAgICAgIH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5jbGFzc05hbWVzLnB1c2gobmFtZS50b0xvd2VyQ2FzZSgpKTsgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzID0gdGhpcy5lbGVtZW50IHx8ICcnO1xuICAgICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiByZXMgKz0gXCIuXCIgKyBrbGFzczsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIHJlcyArPSBcIltcIiArIG5hbWVfMSArICh2YWx1ZSA/ICc9JyArIHZhbHVlIDogJycpICsgXCJdXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAobm90U2VsZWN0b3IpIHsgcmV0dXJuIHJlcyArPSBcIjpub3QoXCIgKyBub3RTZWxlY3RvciArIFwiKVwiOyB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDc3NTZWxlY3RvcjtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIFJlYWRzIGEgbGlzdCBvZiBDc3NTZWxlY3RvcnMgYW5kIGFsbG93cyB0byBjYWxjdWxhdGUgd2hpY2ggb25lc1xuICAgKiBhcmUgY29udGFpbmVkIGluIGEgZ2l2ZW4gQ3NzU2VsZWN0b3IuXG4gICAqL1xuICB2YXIgU2VsZWN0b3JNYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNlbGVjdG9yTWF0Y2hlcigpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NsYXNzUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hdHRyVmFsdWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyID0gZnVuY3Rpb24gKG5vdFNlbGVjdG9ycykge1xuICAgICAgICAgIHZhciBub3RNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICAgIG5vdE1hdGNoZXIuYWRkU2VsZWN0YWJsZXMobm90U2VsZWN0b3JzLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gbm90TWF0Y2hlcjtcbiAgICAgIH07XG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgICAgdmFyIGxpc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoY3NzU2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgbGlzdENvbnRleHQgPSBuZXcgU2VsZWN0b3JMaXN0Q29udGV4dChjc3NTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMucHVzaChsaXN0Q29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFNlbGVjdGFibGUoY3NzU2VsZWN0b3JzW2ldLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGZvdW5kIGxhdGVyIG9uIGJ5IGNhbGxpbmcgYG1hdGNoYC5cbiAgICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrQ3R4dCBBbiBvcGFxdWUgb2JqZWN0IHRoYXQgd2lsbCBiZSBnaXZlbiB0byB0aGUgY2FsbGJhY2sgb2YgdGhlIGBtYXRjaGAgZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICAgIHZhciBtYXRjaGVyID0gdGhpcztcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XG4gICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICAgIHZhciBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICAgIHZhciBzZWxlY3RhYmxlID0gbmV3IFNlbGVjdG9yQ29udGV4dChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9jbGFzc01hcCwgY2xhc3NOYW1lLCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2NsYXNzUGFydGlhbE1hcCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBpID09PSBhdHRycy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsVmFsdWVzTWFwID0gdGVybWluYWxNYXAuZ2V0KG5hbWVfMik7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxNYXAuc2V0KG5hbWVfMiwgdGVybWluYWxWYWx1ZXNNYXApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVQYXJ0aWFsTWFwO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsVmFsdWVzTWFwID0gcGFydGlhbE1hcC5nZXQobmFtZV8yKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnRpYWxWYWx1ZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcC5zZXQobmFtZV8yLCBwYXJ0aWFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHZhciB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgIGlmICghdGVybWluYWxMaXN0KSB7XG4gICAgICAgICAgICAgIHRlcm1pbmFsTGlzdCA9IFtdO1xuICAgICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlcm1pbmFsTGlzdC5wdXNoKHNlbGVjdGFibGUpO1xuICAgICAgfTtcbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFBhcnRpYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXIgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgICBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICAgICAgICBtYXAuc2V0KG5hbWUsIG1hdGNoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcjtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdmlhIGBhZGRTZWxlY3RhYmxlYFxuICAgICAgICogd2hvc2UgY3NzIHNlbGVjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICAgICAgICogQHBhcmFtIGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICAgKiBAcGFyYW0gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgYSBtYXRjaCB3YXMgZm91bmRcbiAgICAgICovXG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHNbaV0uYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9lbGVtZW50TWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9jbGFzc01hcCwgY2xhc3NOYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFtZV8zID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVNYXAuZ2V0KG5hbWVfMyk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwLmdldChuYW1lXzMpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hUZXJtaW5hbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIW1hcCB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2VsZWN0YWJsZXMgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgIHZhciBzdGFyU2VsZWN0YWJsZXMgPSBtYXAuZ2V0KCcqJyk7XG4gICAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgICBzZWxlY3RhYmxlcyA9IHNlbGVjdGFibGVzLmNvbmNhdChzdGFyU2VsZWN0YWJsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGVjdGFibGVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlbGVjdGFibGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgICByZXN1bHQgPSBzZWxlY3RhYmxlLmZpbmFsaXplKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICAvKiogQGludGVybmFsICovXG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFBhcnRpYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5lc3RlZFNlbGVjdG9yID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgICBpZiAoIW5lc3RlZFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyhwZXJmKTogZ2V0IHJpZCBvZiByZWN1cnNpb24gYW5kIG1lYXN1cmUgYWdhaW5cbiAgICAgICAgICAvLyBUT0RPKHBlcmYpOiBkb24ndCBwYXNzIHRoZSB3aG9sZSBzZWxlY3RvciBpbnRvIHRoZSByZWN1cnNpb24sXG4gICAgICAgICAgLy8gYnV0IG9ubHkgdGhlIG5vdCBwcm9jZXNzZWQgcGFydHNcbiAgICAgICAgICByZXR1cm4gbmVzdGVkU2VsZWN0b3IubWF0Y2goY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjayk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNlbGVjdG9yTWF0Y2hlcjtcbiAgfSgpKTtcbiAgdmFyIFNlbGVjdG9yTGlzdENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU2VsZWN0b3JMaXN0Q29udGV4dChzZWxlY3RvcnMpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgICB0aGlzLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gU2VsZWN0b3JMaXN0Q29udGV4dDtcbiAgfSgpKTtcbiAgLy8gU3RvcmUgY29udGV4dCB0byBwYXNzIGJhY2sgc2VsZWN0b3IgYW5kIGNvbnRleHQgd2hlbiBhIHNlbGVjdG9yIGlzIG1hdGNoZWRcbiAgdmFyIFNlbGVjdG9yQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTZWxlY3RvckNvbnRleHQoc2VsZWN0b3IsIGNiQ29udGV4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgdGhpcy5jYkNvbnRleHQgPSBjYkNvbnRleHQ7XG4gICAgICAgICAgdGhpcy5saXN0Q29udGV4dCA9IGxpc3RDb250ZXh0O1xuICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzID0gc2VsZWN0b3Iubm90U2VsZWN0b3JzO1xuICAgICAgfVxuICAgICAgU2VsZWN0b3JDb250ZXh0LnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAoIXRoaXMubGlzdENvbnRleHQgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgIHZhciBub3RNYXRjaGVyID0gU2VsZWN0b3JNYXRjaGVyLmNyZWF0ZU5vdE1hdGNoZXIodGhpcy5ub3RTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICByZXN1bHQgPSAhbm90TWF0Y2hlci5tYXRjaChjc3NTZWxlY3RvciwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgJiYgY2FsbGJhY2sgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5saXN0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5zZWxlY3RvciwgdGhpcy5jYkNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTZWxlY3RvckNvbnRleHQ7XG4gIH0oKSk7XG5cbiAgdmFyIE1PRFVMRV9TVUZGSVggPSAnJztcbiAgdmFyIERBU0hfQ0FTRV9SRUdFWFAgPSAvLSsoW2EtejAtOV0pL2c7XG4gIGZ1bmN0aW9uIGRhc2hDYXNlVG9DYW1lbENhc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKERBU0hfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIG1bX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzcGxpdEF0Q29sb24oaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJzonLCBkZWZhdWx0VmFsdWVzKTtcbiAgfVxuICBmdW5jdGlvbiBzcGxpdEF0UGVyaW9kKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICcuJywgZGVmYXVsdFZhbHVlcyk7XG4gIH1cbiAgZnVuY3Rpb24gX3NwbGl0QXQoaW5wdXQsIGNoYXJhY3RlciwgZGVmYXVsdFZhbHVlcykge1xuICAgICAgdmFyIGNoYXJhY3RlckluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyYWN0ZXIpO1xuICAgICAgaWYgKGNoYXJhY3RlckluZGV4ID09IC0xKVxuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVzO1xuICAgICAgcmV0dXJuIFtpbnB1dC5zbGljZSgwLCBjaGFyYWN0ZXJJbmRleCkudHJpbSgpLCBpbnB1dC5zbGljZShjaGFyYWN0ZXJJbmRleCArIDEpLnRyaW0oKV07XG4gIH1cbiAgZnVuY3Rpb24gc2FuaXRpemVJZGVudGlmaWVyKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL1xcVy9nLCAnXycpO1xuICB9XG4gIGZ1bmN0aW9uIHZpc2l0VmFsdWUodmFsdWUsIHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXkodmFsdWUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaWN0U3RyaW5nTWFwKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RyaW5nTWFwKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSB8fCBpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByaW1pdGl2ZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmlzaXRvci52aXNpdE90aGVyKHZhbHVlLCBjb250ZXh0KTtcbiAgfVxuICB2YXIgVmFsdWVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWYWx1ZVRyYW5zZm9ybWVyKCkge1xuICAgICAgfVxuICAgICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBcnJheSA9IGZ1bmN0aW9uIChhcnIsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgIH07XG4gICAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXN1bHRba2V5XSA9IHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAgIHJldHVybiBWYWx1ZVRyYW5zZm9ybWVyO1xuICB9KCkpO1xuICB2YXIgU3luY0FzeW5jUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN5bmNBc3luY1Jlc3VsdChzeW5jUmVzdWx0LCBhc3luY1Jlc3VsdCkge1xuICAgICAgICAgIGlmIChhc3luY1Jlc3VsdCA9PT0gdm9pZCAwKSB7IGFzeW5jUmVzdWx0ID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMuc3luY1Jlc3VsdCA9IHN5bmNSZXN1bHQ7XG4gICAgICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IGFzeW5jUmVzdWx0O1xuICAgICAgICAgIGlmICghYXN5bmNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IFByb21pc2UucmVzb2x2ZShzeW5jUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU3luY0FzeW5jUmVzdWx0O1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICBmdW5jdGlvbiB1bmltcGxlbWVudGVkKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkJyk7XG4gIH1cbiAgLy8gZ3JvdXAgMDogXCJbcHJvcF0gb3IgKGV2ZW50KSBvciBAdHJpZ2dlclwiXG4gIC8vIGdyb3VwIDE6IFwicHJvcFwiIGZyb20gXCJbcHJvcF1cIlxuICAvLyBncm91cCAyOiBcImV2ZW50XCIgZnJvbSBcIihldmVudClcIlxuICAvLyBncm91cCAzOiBcIkB0cmlnZ2VyXCIgZnJvbSBcIkB0cmlnZ2VyXCJcbiAgdmFyIEhPU1RfUkVHX0VYUCA9IC9eKD86KD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpKXwoXFxAWy1cXHddKykkLztcbiAgdmFyIENvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyKCkge1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyLnByb3RvdHlwZSwgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXI7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBkZWZpbml0aW9ucykge1xuICAgICAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAoZGVmaW5pdGlvbnMgPT09IHZvaWQgMCkgeyBkZWZpbml0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNyhDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0YXRlTmFtZUV4cHIgPSBzdGF0ZU5hbWVFeHByO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNyhDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEoc3RhdGVDaGFuZ2VFeHByLCBzdGVwcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFeHByID0gc3RhdGVDaGFuZ2VFeHByO1xuICAgICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEoKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDcoQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gW107IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNyhDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKG9mZnNldCwgc3R5bGVzKSB7XG4gICAgICAgICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDcoQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEodGltaW5ncywgc3R5bGVzKSB7XG4gICAgICAgICAgaWYgKHRpbWluZ3MgPT09IHZvaWQgMCkgeyB0aW1pbmdzID0gMDsgfVxuICAgICAgICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ3KENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YShzdGVwcykge1xuICAgICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNyhDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDcoQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShzdGVwcykge1xuICAgICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHN0ZXBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCByZWZlcmVuY2UgPSBfYi5yZWZlcmVuY2UsIG5hbWUgPSBfYi5uYW1lLCBtb2R1bGVVcmwgPSBfYi5tb2R1bGVVcmwsIHByZWZpeCA9IF9iLnByZWZpeCwgdmFsdWUgPSBfYi52YWx1ZTtcbiAgICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlSWRlbnRpZmllck1ldGFkYXRhLnByb3RvdHlwZSwgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGlzQXR0cmlidXRlID0gX2IuaXNBdHRyaWJ1dGUsIGlzU2VsZiA9IF9iLmlzU2VsZiwgaXNIb3N0ID0gX2IuaXNIb3N0LCBpc1NraXBTZWxmID0gX2IuaXNTa2lwU2VsZiwgaXNPcHRpb25hbCA9IF9iLmlzT3B0aW9uYWwsIGlzVmFsdWUgPSBfYi5pc1ZhbHVlLCB0b2tlbiA9IF9iLnRva2VuLCB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICAgIHRoaXMuaXNBdHRyaWJ1dGUgPSAhIWlzQXR0cmlidXRlO1xuICAgICAgICAgIHRoaXMuaXNTZWxmID0gISFpc1NlbGY7XG4gICAgICAgICAgdGhpcy5pc0hvc3QgPSAhIWlzSG9zdDtcbiAgICAgICAgICB0aGlzLmlzU2tpcFNlbGYgPSAhIWlzU2tpcFNlbGY7XG4gICAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gISFpc09wdGlvbmFsO1xuICAgICAgICAgIHRoaXMuaXNWYWx1ZSA9ICEhaXNWYWx1ZTtcbiAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVQcm92aWRlck1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVQcm92aWRlck1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gX2EudG9rZW4sIHVzZUNsYXNzID0gX2EudXNlQ2xhc3MsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZUZhY3RvcnkgPSBfYS51c2VGYWN0b3J5LCBkZXBzID0gX2EuZGVwcywgbXVsdGkgPSBfYS5tdWx0aTtcbiAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgdGhpcy51c2VDbGFzcyA9IHVzZUNsYXNzO1xuICAgICAgICAgIHRoaXMudXNlVmFsdWUgPSB1c2VWYWx1ZTtcbiAgICAgICAgICB0aGlzLnVzZUV4aXN0aW5nID0gdXNlRXhpc3Rpbmc7XG4gICAgICAgICAgdGhpcy51c2VGYWN0b3J5ID0gdXNlRmFjdG9yeTtcbiAgICAgICAgICB0aGlzLmRlcHMgPSBkZXBzIHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5tdWx0aSA9ICEhbXVsdGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlRmFjdG9yeU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ3KENvbXBpbGVGYWN0b3J5TWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlRmFjdG9yeU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIHJlZmVyZW5jZSA9IF9hLnJlZmVyZW5jZSwgbmFtZSA9IF9hLm5hbWUsIG1vZHVsZVVybCA9IF9hLm1vZHVsZVVybCwgcHJlZml4ID0gX2EucHJlZml4LCBkaURlcHMgPSBfYS5kaURlcHMsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeyByZWZlcmVuY2U6IHJlZmVyZW5jZSwgbmFtZTogbmFtZSwgcHJlZml4OiBwcmVmaXgsIG1vZHVsZVVybDogbW9kdWxlVXJsLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgdGhpcy5kaURlcHMgPSBfbm9ybWFsaXplQXJyYXkoZGlEZXBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlRmFjdG9yeU1ldGFkYXRhO1xuICB9KENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVUb2tlbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVUb2tlbk1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIGlkZW50aWZpZXIgPSBfYS5pZGVudGlmaWVyLCBpZGVudGlmaWVySXNJbnN0YW5jZSA9IF9hLmlkZW50aWZpZXJJc0luc3RhbmNlO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgICAgICAgIHRoaXMuaWRlbnRpZmllcklzSW5zdGFuY2UgPSAhIWlkZW50aWZpZXJJc0luc3RhbmNlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVUb2tlbk1ldGFkYXRhLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlVG9rZW5NZXRhZGF0YS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy52YWx1ZSkgPyBzYW5pdGl6ZUlkZW50aWZpZXIodGhpcy52YWx1ZSkgOiB0aGlzLmlkZW50aWZpZXIubmFtZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlVG9rZW5NZXRhZGF0YTtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIHR5cGUuXG4gICAqL1xuICB2YXIgQ29tcGlsZVR5cGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNyhDb21waWxlVHlwZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVR5cGVNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCByZWZlcmVuY2UgPSBfYi5yZWZlcmVuY2UsIG5hbWUgPSBfYi5uYW1lLCBtb2R1bGVVcmwgPSBfYi5tb2R1bGVVcmwsIHByZWZpeCA9IF9iLnByZWZpeCwgaXNIb3N0ID0gX2IuaXNIb3N0LCB2YWx1ZSA9IF9iLnZhbHVlLCBkaURlcHMgPSBfYi5kaURlcHMsIGxpZmVjeWNsZUhvb2tzID0gX2IubGlmZWN5Y2xlSG9va3M7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeyByZWZlcmVuY2U6IHJlZmVyZW5jZSwgbmFtZTogbmFtZSwgbW9kdWxlVXJsOiBtb2R1bGVVcmwsIHByZWZpeDogcHJlZml4LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgdGhpcy5pc0hvc3QgPSAhIWlzSG9zdDtcbiAgICAgICAgICB0aGlzLmRpRGVwcyA9IF9ub3JtYWxpemVBcnJheShkaURlcHMpO1xuICAgICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBfbm9ybWFsaXplQXJyYXkobGlmZWN5Y2xlSG9va3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVUeXBlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZVF1ZXJ5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVF1ZXJ5TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgc2VsZWN0b3JzID0gX2Iuc2VsZWN0b3JzLCBkZXNjZW5kYW50cyA9IF9iLmRlc2NlbmRhbnRzLCBmaXJzdCA9IF9iLmZpcnN0LCBwcm9wZXJ0eU5hbWUgPSBfYi5wcm9wZXJ0eU5hbWUsIHJlYWQgPSBfYi5yZWFkO1xuICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgICAgICAgIHRoaXMuZGVzY2VuZGFudHMgPSAhIWRlc2NlbmRhbnRzO1xuICAgICAgICAgIHRoaXMuZmlyc3QgPSAhIWZpcnN0O1xuICAgICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICAgIHRoaXMucmVhZCA9IHJlYWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZVF1ZXJ5TWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBNZXRhZGF0YSBhYm91dCBhIHN0eWxlc2hlZXRcbiAgICovXG4gIHZhciBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscztcbiAgICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IF9ub3JtYWxpemVBcnJheShzdHlsZXMpO1xuICAgICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YTtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIHRlbXBsYXRlLlxuICAgKi9cbiAgdmFyIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IF9iLmV4dGVybmFsU3R5bGVzaGVldHMsIGFuaW1hdGlvbnMgPSBfYi5hbmltYXRpb25zLCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBfYi5uZ0NvbnRlbnRTZWxlY3RvcnMsIGludGVycG9sYXRpb24gPSBfYi5pbnRlcnBvbGF0aW9uO1xuICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IF9ub3JtYWxpemVBcnJheShzdHlsZXMpO1xuICAgICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgICAgICAgdGhpcy5leHRlcm5hbFN0eWxlc2hlZXRzID0gX25vcm1hbGl6ZUFycmF5KGV4dGVybmFsU3R5bGVzaGVldHMpO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMgPyBMaXN0V3JhcHBlci5mbGF0dGVuKGFuaW1hdGlvbnMpIDogW107XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMgPSBuZ0NvbnRlbnRTZWxlY3RvcnMgfHwgW107XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb24gJiYgaW50ZXJwb2xhdGlvbi5sZW5ndGggIT0gMikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaW50ZXJwb2xhdGlvbicgc2hvdWxkIGhhdmUgYSBzdGFydCBhbmQgYW4gZW5kIHN5bWJvbC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICB9XG4gICAgICBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlzU3VtbWFyeTogdHJ1ZSxcbiAgICAgICAgICAgICAgYW5pbWF0aW9uczogdGhpcy5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS5uYW1lOyB9KSxcbiAgICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdGhpcy5lbmNhcHN1bGF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBNZXRhZGF0YSByZWdhcmRpbmcgY29tcGlsYXRpb24gb2YgYSBkaXJlY3RpdmUuXG4gICAqL1xuICB2YXIgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0TGlzdGVuZXJzID0gX2IuaG9zdExpc3RlbmVycywgaG9zdFByb3BlcnRpZXMgPSBfYi5ob3N0UHJvcGVydGllcywgaG9zdEF0dHJpYnV0ZXMgPSBfYi5ob3N0QXR0cmlidXRlcywgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Iudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuaXNDb21wb25lbnQgPSBpc0NvbXBvbmVudDtcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgdGhpcy5leHBvcnRBcyA9IGV4cG9ydEFzO1xuICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uID0gY2hhbmdlRGV0ZWN0aW9uO1xuICAgICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgICAgdGhpcy5ob3N0TGlzdGVuZXJzID0gaG9zdExpc3RlbmVycztcbiAgICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0aWVzID0gaG9zdFByb3BlcnRpZXM7XG4gICAgICAgICAgdGhpcy5ob3N0QXR0cmlidXRlcyA9IGhvc3RBdHRyaWJ1dGVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHByb3ZpZGVycyk7XG4gICAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdQcm92aWRlcnMpO1xuICAgICAgICAgIHRoaXMucXVlcmllcyA9IF9ub3JtYWxpemVBcnJheShxdWVyaWVzKTtcbiAgICAgICAgICB0aGlzLnZpZXdRdWVyaWVzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdRdWVyaWVzKTtcbiAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShlbnRyeUNvbXBvbmVudHMpO1xuICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgIH1cbiAgICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIGlzQ29tcG9uZW50ID0gX2IuaXNDb21wb25lbnQsIHNlbGVjdG9yID0gX2Iuc2VsZWN0b3IsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9iLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgaG9zdCA9IF9iLmhvc3QsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgdmlld1Byb3ZpZGVycyA9IF9iLnZpZXdQcm92aWRlcnMsIHF1ZXJpZXMgPSBfYi5xdWVyaWVzLCB2aWV3UXVlcmllcyA9IF9iLnZpZXdRdWVyaWVzLCBlbnRyeUNvbXBvbmVudHMgPSBfYi5lbnRyeUNvbXBvbmVudHMsIHRlbXBsYXRlID0gX2IudGVtcGxhdGU7XG4gICAgICAgICAgdmFyIGhvc3RMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICB2YXIgaG9zdFByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICB2YXIgaG9zdEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGhvc3QpKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGhvc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaG9zdFtrZXldO1xuICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBrZXkubWF0Y2goSE9TVF9SRUdfRVhQKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KG1hdGNoZXNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXNbbWF0Y2hlc1sxXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChtYXRjaGVzWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnNbbWF0Y2hlc1syXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnB1dHNNYXAgPSB7fTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGlucHV0cykpIHtcbiAgICAgICAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBgOmAsIHVzZSBkaXJQcm9wID0gZWxQcm9wXG4gICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcbiAgICAgICAgICAgICAgICAgIGlucHV0c01hcFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvdXRwdXRzTWFwID0ge307XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChvdXRwdXRzKSkge1xuICAgICAgICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBgOmAsIHVzZSBkaXJQcm9wID0gZWxQcm9wXG4gICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcbiAgICAgICAgICAgICAgICAgIG91dHB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIGlzQ29tcG9uZW50OiAhIWlzQ29tcG9uZW50LCBzZWxlY3Rvcjogc2VsZWN0b3IsIGV4cG9ydEFzOiBleHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uOiBjaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgIGlucHV0czogaW5wdXRzTWFwLFxuICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzTWFwLFxuICAgICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBob3N0TGlzdGVuZXJzLFxuICAgICAgICAgICAgICBob3N0UHJvcGVydGllczogaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IHZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICAgIHZpZXdRdWVyaWVzOiB2aWV3UXVlcmllcyxcbiAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpc1N1bW1hcnk6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgaXNDb21wb25lbnQ6IHRoaXMuaXNDb21wb25lbnQsXG4gICAgICAgICAgICAgIHNlbGVjdG9yOiB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgICBleHBvcnRBczogdGhpcy5leHBvcnRBcyxcbiAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cyxcbiAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgICBob3N0TGlzdGVuZXJzOiB0aGlzLmhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiB0aGlzLmhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBob3N0QXR0cmlidXRlczogdGhpcy5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgcHJvdmlkZXJzOiB0aGlzLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdGhpcy52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICBxdWVyaWVzOiB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogdGhpcy5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogdGhpcy5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlICYmIHRoaXMudGVtcGxhdGUudG9TdW1tYXJ5KClcbiAgICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Qge0BsaW5rIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YX0gZnJvbSB7QGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBDc3NTZWxlY3Rvci5wYXJzZShjb21wTWV0YS5zZWxlY3RvcilbMF0uZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUoKTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICB0eXBlOiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogT2JqZWN0LFxuICAgICAgICAgICAgICBuYW1lOiBjb21wTWV0YS50eXBlLm5hbWUgKyBcIl9Ib3N0XCIsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogY29tcE1ldGEudHlwZS5tb2R1bGVVcmwsXG4gICAgICAgICAgICAgIGlzSG9zdDogdHJ1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcnLFxuICAgICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgICAgaG9zdDoge30sXG4gICAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgICAgc2VsZWN0b3I6ICcqJyxcbiAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHF1ZXJpZXM6IFtdLFxuICAgICAgICAgIHZpZXdRdWVyaWVzOiBbXVxuICAgICAgfSk7XG4gIH1cbiAgdmFyIENvbXBpbGVQaXBlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVBpcGVNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgbmFtZSA9IF9iLm5hbWUsIHB1cmUgPSBfYi5wdXJlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnB1cmUgPSAhIXB1cmU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVBpcGVNZXRhZGF0YS5wcm90b3R5cGUsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGU7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgQ29tcGlsZVBpcGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGlzU3VtbWFyeTogdHJ1ZSwgdHlwZTogdGhpcy50eXBlLCBuYW1lOiB0aGlzLm5hbWUsIHB1cmU6IHRoaXMucHVyZSB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlUGlwZU1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgbW9kdWxlLlxuICAgKi9cbiAgdmFyIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHR5cGUgPSBfYi50eXBlLCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIGRlY2xhcmVkRGlyZWN0aXZlcyA9IF9iLmRlY2xhcmVkRGlyZWN0aXZlcywgZXhwb3J0ZWREaXJlY3RpdmVzID0gX2IuZXhwb3J0ZWREaXJlY3RpdmVzLCBkZWNsYXJlZFBpcGVzID0gX2IuZGVjbGFyZWRQaXBlcywgZXhwb3J0ZWRQaXBlcyA9IF9iLmV4cG9ydGVkUGlwZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9iLmJvb3RzdHJhcENvbXBvbmVudHMsIGltcG9ydGVkTW9kdWxlcyA9IF9iLmltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzID0gX2IuZXhwb3J0ZWRNb2R1bGVzLCBzY2hlbWFzID0gX2Iuc2NoZW1hcywgdHJhbnNpdGl2ZU1vZHVsZSA9IF9iLnRyYW5zaXRpdmVNb2R1bGUsIGlkID0gX2IuaWQ7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmRlY2xhcmVkRGlyZWN0aXZlcyA9IF9ub3JtYWxpemVBcnJheShkZWNsYXJlZERpcmVjdGl2ZXMpO1xuICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzID0gX25vcm1hbGl6ZUFycmF5KGV4cG9ydGVkRGlyZWN0aXZlcyk7XG4gICAgICAgICAgdGhpcy5kZWNsYXJlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkUGlwZXMpO1xuICAgICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcyA9IF9ub3JtYWxpemVBcnJheShleHBvcnRlZFBpcGVzKTtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgICAgdGhpcy5ib290c3RyYXBDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGJvb3RzdHJhcENvbXBvbmVudHMpO1xuICAgICAgICAgIHRoaXMuaW1wb3J0ZWRNb2R1bGVzID0gX25vcm1hbGl6ZUFycmF5KGltcG9ydGVkTW9kdWxlcyk7XG4gICAgICAgICAgdGhpcy5leHBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgICB0aGlzLnNjaGVtYXMgPSBfbm9ybWFsaXplQXJyYXkoc2NoZW1hcyk7XG4gICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGl2ZU1vZHVsZSA9IHRyYW5zaXRpdmVNb2R1bGU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS50b1N1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaXNTdW1tYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogdGhpcy5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgIHByb3ZpZGVyczogdGhpcy5wcm92aWRlcnMsXG4gICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlczogdGhpcy5pbXBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICAgIGV4cG9ydGVkTW9kdWxlczogdGhpcy5leHBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlczogdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICAgIGV4cG9ydGVkUGlwZXM6IHRoaXMuZXhwb3J0ZWRQaXBlcyxcbiAgICAgICAgICAgICAgbG9hZGluZ1Byb21pc2VzOiB0aGlzLnRyYW5zaXRpdmVNb2R1bGUubG9hZGluZ1Byb21pc2VzXG4gICAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUudG9JbmplY3RvclN1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaXNTdW1tYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogdGhpcy5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgIHByb3ZpZGVyczogdGhpcy5wcm92aWRlcnMsXG4gICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlczogdGhpcy5pbXBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICAgIGV4cG9ydGVkTW9kdWxlczogdGhpcy5leHBvcnRlZE1vZHVsZXNcbiAgICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLnByb3RvdHlwZS50b0RpcmVjdGl2ZVN1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaXNTdW1tYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlczogdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICAgIGV4cG9ydGVkUGlwZXM6IHRoaXMuZXhwb3J0ZWRQaXBlcyxcbiAgICAgICAgICAgICAgZXhwb3J0ZWRNb2R1bGVzOiB0aGlzLmV4cG9ydGVkTW9kdWxlcyxcbiAgICAgICAgICAgICAgbG9hZGluZ1Byb21pc2VzOiB0aGlzLnRyYW5zaXRpdmVNb2R1bGUubG9hZGluZ1Byb21pc2VzXG4gICAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKG1vZHVsZXMsIHByb3ZpZGVycywgZW50cnlDb21wb25lbnRzLCBkaXJlY3RpdmVzLCBwaXBlcywgbG9hZGluZ1Byb21pc2VzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gZW50cnlDb21wb25lbnRzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xuICAgICAgICAgIHRoaXMubG9hZGluZ1Byb21pc2VzID0gbG9hZGluZ1Byb21pc2VzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnBpcGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBfdGhpcy5kaXJlY3RpdmVzU2V0LmFkZChkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgICAgcGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMucGlwZXNTZXQuYWRkKHBpcGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhO1xuICB9KCkpO1xuICBmdW5jdGlvbiByZW1vdmVJZGVudGlmaWVyRHVwbGljYXRlcyhpdGVtcykge1xuICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoIW1hcC5nZXQoaXRlbS5pZGVudGlmaWVyLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgbWFwLnNldChpdGVtLmlkZW50aWZpZXIucmVmZXJlbmNlLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSk7XG4gIH1cbiAgZnVuY3Rpb24gX25vcm1hbGl6ZUFycmF5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiB8fCBbXTtcbiAgfVxuICBmdW5jdGlvbiBpc1N0YXRpY1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWVbJ25hbWUnXSAmJiB2YWx1ZVsnZmlsZVBhdGgnXTtcbiAgfVxuICB2YXIgUHJvdmlkZXJNZXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFByb3ZpZGVyTWV0YSh0b2tlbiwgX2EpIHtcbiAgICAgICAgICB2YXIgdXNlQ2xhc3MgPSBfYS51c2VDbGFzcywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlRmFjdG9yeSA9IF9hLnVzZUZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3M7XG4gICAgICAgICAgdGhpcy51c2VWYWx1ZSA9IHVzZVZhbHVlO1xuICAgICAgICAgIHRoaXMudXNlRXhpc3RpbmcgPSB1c2VFeGlzdGluZztcbiAgICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5O1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwcztcbiAgICAgICAgICB0aGlzLm11bHRpID0gISFtdWx0aTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm92aWRlck1ldGE7XG4gIH0oKSk7XG5cbiAgdmFyIGlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuICB2YXIgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQ2hhbmdlRGV0ZWN0b3JTdGF0dXM7XG4gIHZhciBMaWZlY3ljbGVIb29rcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5MaWZlY3ljbGVIb29rcztcbiAgdmFyIExJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUztcbiAgdmFyIFJlZmxlY3RvclJlYWRlciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5SZWZsZWN0b3JSZWFkZXI7XG4gIHZhciBWaWV3Q29udGFpbmVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlZpZXdDb250YWluZXI7XG4gIHZhciBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gIHZhciBDb21wb25lbnRSZWZfID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkNvbXBvbmVudFJlZl87XG4gIHZhciBBcHBWaWV3ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFwcFZpZXc7XG4gIHZhciBEZWJ1Z0FwcFZpZXcgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uRGVidWdBcHBWaWV3O1xuICB2YXIgTmdNb2R1bGVJbmplY3RvciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5OZ01vZHVsZUluamVjdG9yO1xuICB2YXIgcmVnaXN0ZXJNb2R1bGVGYWN0b3J5ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnJlZ2lzdGVyTW9kdWxlRmFjdG9yeTtcbiAgdmFyIFZpZXdUeXBlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlZpZXdUeXBlO1xuICB2YXIgdmlld191dGlscyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy52aWV3X3V0aWxzO1xuICB2YXIgRGVidWdDb250ZXh0ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkRlYnVnQ29udGV4dDtcbiAgdmFyIFN0YXRpY05vZGVEZWJ1Z0luZm8gPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uU3RhdGljTm9kZURlYnVnSW5mbztcbiAgdmFyIGRldk1vZGVFcXVhbCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5kZXZNb2RlRXF1YWw7XG4gIHZhciBVTklOSVRJQUxJWkVEID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlVOSU5JVElBTElaRUQ7XG4gIHZhciBWYWx1ZVVud3JhcHBlciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5WYWx1ZVVud3JhcHBlcjtcbiAgdmFyIFRlbXBsYXRlUmVmXyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5UZW1wbGF0ZVJlZl87XG4gIHZhciBDb25zb2xlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkNvbnNvbGU7XG4gIHZhciByZWZsZWN0b3IgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18ucmVmbGVjdG9yO1xuICB2YXIgUmVmbGVjdG9yID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlJlZmxlY3RvcjtcbiAgdmFyIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uUmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbiAgdmFyIE5vT3BBbmltYXRpb25QbGF5ZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTm9PcEFuaW1hdGlvblBsYXllcjtcbiAgdmFyIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFuaW1hdGlvblNlcXVlbmNlUGxheWVyO1xuICB2YXIgQW5pbWF0aW9uR3JvdXBQbGF5ZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQW5pbWF0aW9uR3JvdXBQbGF5ZXI7XG4gIHZhciBBbmltYXRpb25LZXlmcmFtZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BbmltYXRpb25LZXlmcmFtZTtcbiAgdmFyIEFuaW1hdGlvblN0eWxlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BbmltYXRpb25TdHlsZXM7XG4gIHZhciBBTllfU1RBVEUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQU5ZX1NUQVRFO1xuICB2YXIgREVGQVVMVF9TVEFURSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5ERUZBVUxUX1NUQVRFO1xuICB2YXIgRU1QVFlfQU5JTUFUSU9OX1NUQVRFID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkVNUFRZX1NUQVRFO1xuICB2YXIgRklMTF9TVFlMRV9GTEFHID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkZJTExfU1RZTEVfRkxBRztcbiAgdmFyIHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5wcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXM7XG4gIHZhciBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXM7XG4gIHZhciBjbGVhclN0eWxlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5jbGVhclN0eWxlcztcbiAgdmFyIGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzO1xuICB2YXIgcmVuZGVyU3R5bGVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnJlbmRlclN0eWxlcztcbiAgdmFyIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkNvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yO1xuICB2YXIgQW5pbWF0aW9uVHJhbnNpdGlvbiA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BbmltYXRpb25UcmFuc2l0aW9uO1xuXG4gIHZhciBBUFBfVklFV19NT0RVTEVfVVJMID0gYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXcnKTtcbiAgdmFyIFZJRVdfVVRJTFNfTU9EVUxFX1VSTCA9IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3X3V0aWxzJyk7XG4gIHZhciBDRF9NT0RVTEVfVVJMID0gYXNzZXRVcmwoJ2NvcmUnLCAnY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XG4gIHZhciBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwgPSBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX3N0eWxlX3V0aWwnKTtcbiAgdmFyIElkZW50aWZpZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIElkZW50aWZpZXJzKCkge1xuICAgICAgfVxuICAgICAgSWRlbnRpZmllcnMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyA9IHtcbiAgICAgICAgICBuYW1lOiAnQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdtZXRhZGF0YS9kaScpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UU1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlZpZXdVdGlscyA9IHtcbiAgICAgICAgICBuYW1lOiAnVmlld1V0aWxzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3X3V0aWxzJyksXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5WaWV3VXRpbHNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5BcHBWaWV3ID0geyBuYW1lOiAnQXBwVmlldycsIG1vZHVsZVVybDogQVBQX1ZJRVdfTU9EVUxFX1VSTCwgcnVudGltZTogQXBwVmlldyB9O1xuICAgICAgSWRlbnRpZmllcnMuRGVidWdBcHBWaWV3ID0ge1xuICAgICAgICAgIG5hbWU6ICdEZWJ1Z0FwcFZpZXcnLFxuICAgICAgICAgIG1vZHVsZVVybDogQVBQX1ZJRVdfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBEZWJ1Z0FwcFZpZXdcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyID0ge1xuICAgICAgICAgIG5hbWU6ICdWaWV3Q29udGFpbmVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3X2NvbnRhaW5lcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IFZpZXdDb250YWluZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5FbGVtZW50UmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdFbGVtZW50UmVmJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9lbGVtZW50X3JlZicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYgPSB7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdDb250YWluZXJSZWYnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdDaGFuZ2VEZXRlY3RvclJlZicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdjaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rvcl9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdG9yUmVmXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuUmVuZGVyQ29tcG9uZW50VHlwZSA9IHtcbiAgICAgICAgICBuYW1lOiAnUmVuZGVyQ29tcG9uZW50VHlwZScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdyZW5kZXIvYXBpJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJDb21wb25lbnRUeXBlXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuUXVlcnlMaXN0ID0ge1xuICAgICAgICAgIG5hbWU6ICdRdWVyeUxpc3QnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3F1ZXJ5X2xpc3QnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdUZW1wbGF0ZVJlZicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdGVtcGxhdGVfcmVmJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmXyA9IHtcbiAgICAgICAgICBuYW1lOiAnVGVtcGxhdGVSZWZfJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci90ZW1wbGF0ZV9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBUZW1wbGF0ZVJlZl9cbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgICAgICAgIG5hbWU6ICdDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9jb21wb25lbnRfZmFjdG9yeV9yZXNvbHZlcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSB7XG4gICAgICAgICAgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvY29tcG9uZW50X2ZhY3RvcnlfcmVzb2x2ZXInKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkgPSB7XG4gICAgICAgICAgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnknLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9jb21wb25lbnRfZmFjdG9yeScpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ29tcG9uZW50UmVmXyA9IHtcbiAgICAgICAgICBuYW1lOiAnQ29tcG9uZW50UmVmXycsXG4gICAgICAgICAgcnVudGltZTogQ29tcG9uZW50UmVmXyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9jb21wb25lbnRfZmFjdG9yeScpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ29tcG9uZW50UmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdDb21wb25lbnRSZWYnLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50UmVmLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2NvbXBvbmVudF9mYWN0b3J5JylcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkgPSB7XG4gICAgICAgICAgbmFtZTogJ05nTW9kdWxlRmFjdG9yeScsXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZUZhY3RvcnksXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvbmdfbW9kdWxlX2ZhY3RvcnknKVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLk5nTW9kdWxlSW5qZWN0b3IgPSB7XG4gICAgICAgICAgbmFtZTogJ05nTW9kdWxlSW5qZWN0b3InLFxuICAgICAgICAgIHJ1bnRpbWU6IE5nTW9kdWxlSW5qZWN0b3IsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvbmdfbW9kdWxlX2ZhY3RvcnknKVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlJlZ2lzdGVyTW9kdWxlRmFjdG9yeUZuID0ge1xuICAgICAgICAgIG5hbWU6ICdyZWdpc3Rlck1vZHVsZUZhY3RvcnknLFxuICAgICAgICAgIHJ1bnRpbWU6IHJlZ2lzdGVyTW9kdWxlRmFjdG9yeSxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9uZ19tb2R1bGVfZmFjdG9yeV9sb2FkZXInKVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlZhbHVlVW53cmFwcGVyID0geyBuYW1lOiAnVmFsdWVVbndyYXBwZXInLCBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsIHJ1bnRpbWU6IFZhbHVlVW53cmFwcGVyIH07XG4gICAgICBJZGVudGlmaWVycy5JbmplY3RvciA9IHtcbiAgICAgICAgICBuYW1lOiAnSW5qZWN0b3InLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnZGkvaW5qZWN0b3InKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkluamVjdG9yXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuVmlld0VuY2Fwc3VsYXRpb24gPSB7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdFbmNhcHN1bGF0aW9uJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ21ldGFkYXRhL3ZpZXcnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuVmlld1R5cGUgPSB7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdUeXBlJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3X3R5cGUnKSxcbiAgICAgICAgICBydW50aW1lOiBWaWV3VHlwZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0ge1xuICAgICAgICAgIG5hbWU6ICdDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvID0ge1xuICAgICAgICAgIG5hbWU6ICdTdGF0aWNOb2RlRGVidWdJbmZvJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9kZWJ1Z19jb250ZXh0JyksXG4gICAgICAgICAgcnVudGltZTogU3RhdGljTm9kZURlYnVnSW5mb1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkRlYnVnQ29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiAnRGVidWdDb250ZXh0JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9kZWJ1Z19jb250ZXh0JyksXG4gICAgICAgICAgcnVudGltZTogRGVidWdDb250ZXh0XG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuUmVuZGVyZXIgPSB7XG4gICAgICAgICAgbmFtZTogJ1JlbmRlcmVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ3JlbmRlci9hcGknKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuU2ltcGxlQ2hhbmdlID0geyBuYW1lOiAnU2ltcGxlQ2hhbmdlJywgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLCBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlNpbXBsZUNoYW5nZSB9O1xuICAgICAgSWRlbnRpZmllcnMuVU5JTklUSUFMSVpFRCA9IHsgbmFtZTogJ1VOSU5JVElBTElaRUQnLCBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsIHJ1bnRpbWU6IFVOSU5JVElBTElaRUQgfTtcbiAgICAgIElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yU3RhdHVzID0ge1xuICAgICAgICAgIG5hbWU6ICdDaGFuZ2VEZXRlY3RvclN0YXR1cycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IENoYW5nZURldGVjdG9yU3RhdHVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuY2hlY2tCaW5kaW5nID0ge1xuICAgICAgICAgIG5hbWU6ICdjaGVja0JpbmRpbmcnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuY2hlY2tCaW5kaW5nXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuZGV2TW9kZUVxdWFsID0geyBuYW1lOiAnZGV2TW9kZUVxdWFsJywgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLCBydW50aW1lOiBkZXZNb2RlRXF1YWwgfTtcbiAgICAgIElkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlID0ge1xuICAgICAgICAgIG5hbWU6ICdpbmxpbmVJbnRlcnBvbGF0ZScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5pbmxpbmVJbnRlcnBvbGF0ZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmludGVycG9sYXRlID0ge1xuICAgICAgICAgIG5hbWU6ICdpbnRlcnBvbGF0ZScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5pbnRlcnBvbGF0ZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmNhc3RCeVZhbHVlID0ge1xuICAgICAgICAgIG5hbWU6ICdjYXN0QnlWYWx1ZScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5jYXN0QnlWYWx1ZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkVNUFRZX0FSUkFZID0ge1xuICAgICAgICAgIG5hbWU6ICdFTVBUWV9BUlJBWScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5FTVBUWV9BUlJBWVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkVNUFRZX01BUCA9IHtcbiAgICAgICAgICBuYW1lOiAnRU1QVFlfTUFQJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLkVNUFRZX01BUFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmNyZWF0ZVJlbmRlckVsZW1lbnQgPSB7XG4gICAgICAgICAgbmFtZTogJ2NyZWF0ZVJlbmRlckVsZW1lbnQnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuY3JlYXRlUmVuZGVyRWxlbWVudFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLnNlbGVjdE9yQ3JlYXRlUmVuZGVySG9zdEVsZW1lbnQgPSB7XG4gICAgICAgICAgbmFtZTogJ3NlbGVjdE9yQ3JlYXRlUmVuZGVySG9zdEVsZW1lbnQnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuc2VsZWN0T3JDcmVhdGVSZW5kZXJIb3N0RWxlbWVudFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLnB1cmVQcm94aWVzID0gW1xuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5MScsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTEgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHkyJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5MiB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTMnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHkzIH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5NCcsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTQgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHk1JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5NSB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTYnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHk2IH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5NycsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTcgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHk4JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5OCB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTknLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHk5IH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5MTAnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHkxMCB9LFxuICAgICAgXTtcbiAgICAgIElkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiAnU2VjdXJpdHlDb250ZXh0JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ3NlY3VyaXR5JyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQsXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQW5pbWF0aW9uS2V5ZnJhbWUgPSB7XG4gICAgICAgICAgbmFtZTogJ0FuaW1hdGlvbktleWZyYW1lJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fa2V5ZnJhbWUnKSxcbiAgICAgICAgICBydW50aW1lOiBBbmltYXRpb25LZXlmcmFtZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFuaW1hdGlvblN0eWxlcyA9IHtcbiAgICAgICAgICBuYW1lOiAnQW5pbWF0aW9uU3R5bGVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fc3R5bGVzJyksXG4gICAgICAgICAgcnVudGltZTogQW5pbWF0aW9uU3R5bGVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuTm9PcEFuaW1hdGlvblBsYXllciA9IHtcbiAgICAgICAgICBuYW1lOiAnTm9PcEFuaW1hdGlvblBsYXllcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX3BsYXllcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IE5vT3BBbmltYXRpb25QbGF5ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5BbmltYXRpb25Hcm91cFBsYXllciA9IHtcbiAgICAgICAgICBuYW1lOiAnQW5pbWF0aW9uR3JvdXBQbGF5ZXInLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9ncm91cF9wbGF5ZXInKSxcbiAgICAgICAgICBydW50aW1lOiBBbmltYXRpb25Hcm91cFBsYXllclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFuaW1hdGlvblNlcXVlbmNlUGxheWVyID0ge1xuICAgICAgICAgIG5hbWU6ICdBbmltYXRpb25TZXF1ZW5jZVBsYXllcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX3NlcXVlbmNlX3BsYXllcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFuaW1hdGlvblNlcXVlbmNlUGxheWVyXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMucHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogQU5JTUFUSU9OX1NUWUxFX1VUSUxfQVNTRVRfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ2JhbGFuY2VBbmltYXRpb25LZXlmcmFtZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogQU5JTUFUSU9OX1NUWUxFX1VUSUxfQVNTRVRfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IGJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5jbGVhclN0eWxlcyA9IHtcbiAgICAgICAgICBuYW1lOiAnY2xlYXJTdHlsZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogQU5JTUFUSU9OX1NUWUxFX1VUSUxfQVNTRVRfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IGNsZWFyU3R5bGVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMucmVuZGVyU3R5bGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdyZW5kZXJTdHlsZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogQU5JTUFUSU9OX1NUWUxFX1VUSUxfQVNTRVRfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHJlbmRlclN0eWxlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogY29sbGVjdEFuZFJlc29sdmVTdHlsZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5MT0NBTEVfSUQgPSB7XG4gICAgICAgICAgbmFtZTogJ0xPQ0FMRV9JRCcsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdpMThuL3Rva2VucycpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuTE9DQUxFX0lEXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IHtcbiAgICAgICAgICBuYW1lOiAnVFJBTlNMQVRJT05TX0ZPUk1BVCcsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdpMThuL3Rva2VucycpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuVFJBTlNMQVRJT05TX0ZPUk1BVFxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgbmFtZTogJ3NldEJpbmRpbmdEZWJ1Z0luZm8nLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuc2V0QmluZGluZ0RlYnVnSW5mb1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLnNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzID0ge1xuICAgICAgICAgIG5hbWU6ICdzZXRCaW5kaW5nRGVidWdJbmZvRm9yQ2hhbmdlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5zZXRCaW5kaW5nRGVidWdJbmZvRm9yQ2hhbmdlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFuaW1hdGlvblRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgbmFtZTogJ0FuaW1hdGlvblRyYW5zaXRpb24nLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl90cmFuc2l0aW9uJyksXG4gICAgICAgICAgcnVudGltZTogQW5pbWF0aW9uVHJhbnNpdGlvblxuICAgICAgfTtcbiAgICAgIC8vIFRoaXMgaXMganVzdCB0aGUgaW50ZXJmYWNlIVxuICAgICAgSWRlbnRpZmllcnMuSW5saW5lQXJyYXkgPSB7IG5hbWU6ICdJbmxpbmVBcnJheScsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiBudWxsIH07XG4gICAgICBJZGVudGlmaWVycy5pbmxpbmVBcnJheXMgPSBbXG4gICAgICAgICAgeyBuYW1lOiAnSW5saW5lQXJyYXkyJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMuSW5saW5lQXJyYXkyIH0sXG4gICAgICAgICAgeyBuYW1lOiAnSW5saW5lQXJyYXkyJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMuSW5saW5lQXJyYXkyIH0sXG4gICAgICAgICAgeyBuYW1lOiAnSW5saW5lQXJyYXk0JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMuSW5saW5lQXJyYXk0IH0sXG4gICAgICAgICAgeyBuYW1lOiAnSW5saW5lQXJyYXk4JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMuSW5saW5lQXJyYXk4IH0sXG4gICAgICAgICAgeyBuYW1lOiAnSW5saW5lQXJyYXkxNicsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLklubGluZUFycmF5MTYgfSxcbiAgICAgIF07XG4gICAgICBJZGVudGlmaWVycy5FTVBUWV9JTkxJTkVfQVJSQVkgPSB7XG4gICAgICAgICAgbmFtZTogJ0VNUFRZX0lOTElORV9BUlJBWScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5FTVBUWV9JTkxJTkVfQVJSQVlcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5JbmxpbmVBcnJheUR5bmFtaWMgPSB7XG4gICAgICAgICAgbmFtZTogJ0lubGluZUFycmF5RHluYW1pYycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5JbmxpbmVBcnJheUR5bmFtaWNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5zdWJzY3JpYmVUb1JlbmRlckVsZW1lbnQgPSB7XG4gICAgICAgICAgbmFtZTogJ3N1YnNjcmliZVRvUmVuZGVyRWxlbWVudCcsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5zdWJzY3JpYmVUb1JlbmRlckVsZW1lbnRcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5jcmVhdGVSZW5kZXJDb21wb25lbnRUeXBlID0ge1xuICAgICAgICAgIG5hbWU6ICdjcmVhdGVSZW5kZXJDb21wb25lbnRUeXBlJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLmNyZWF0ZVJlbmRlckNvbXBvbmVudFR5cGVcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5ub29wID0geyBuYW1lOiAnbm9vcCcsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLm5vb3AgfTtcbiAgICAgIHJldHVybiBJZGVudGlmaWVycztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gYXNzZXRVcmwocGtnLCBwYXRoLCB0eXBlKSB7XG4gICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSAnc3JjJzsgfVxuICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcImFzc2V0OkBhbmd1bGFyL2xpYi9cIiArIHBrZyArIFwiL2luZGV4XCI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJhc3NldDpAYW5ndWxhci9saWIvXCIgKyBwa2cgKyBcIi9zcmMvXCIgKyBwYXRoO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7XG4gICAgICAgICAgbmFtZTogaWRlbnRpZmllci5uYW1lLFxuICAgICAgICAgIG1vZHVsZVVybDogaWRlbnRpZmllci5tb2R1bGVVcmwsXG4gICAgICAgICAgcmVmZXJlbmNlOiByZWZsZWN0b3IucmVzb2x2ZUlkZW50aWZpZXIoaWRlbnRpZmllci5uYW1lLCBpZGVudGlmaWVyLm1vZHVsZVVybCwgaWRlbnRpZmllci5ydW50aW1lKVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyBpZGVudGlmaWVyOiBpZGVudGlmaWVyIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVJZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIGlkZW50aWZpZXJUb2tlbihyZXNvbHZlSWRlbnRpZmllcihpZGVudGlmaWVyKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZUVudW1JZGVudGlmaWVyKGVudW1UeXBlLCBuYW1lKSB7XG4gICAgICB2YXIgcmVzb2x2ZWRFbnVtID0gcmVmbGVjdG9yLnJlc29sdmVFbnVtKGVudW1UeXBlLnJlZmVyZW5jZSwgbmFtZSk7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiBlbnVtVHlwZS5uYW1lICsgXCIuXCIgKyBuYW1lLCBtb2R1bGVVcmw6IGVudW1UeXBlLm1vZHVsZVVybCwgcmVmZXJlbmNlOiByZXNvbHZlZEVudW0gfSk7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIEh0bWxQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDgoSHRtbFBhcnNlciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEh0bWxQYXJzZXIoKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZ2V0SHRtbFRhZ0RlZmluaXRpb24pO1xuICAgICAgfVxuICAgICAgSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgIH07XG4gICAgICBIdG1sUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIEh0bWxQYXJzZXIuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgIHJldHVybiBIdG1sUGFyc2VyO1xuICB9KFBhcnNlciQxKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIC8vIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbiAgdmFyIFBMVVJBTF9DQVNFUyA9IFsnemVybycsICdvbmUnLCAndHdvJywgJ2ZldycsICdtYW55JywgJ290aGVyJ107XG4gIC8qKlxuICAgKiBFeHBhbmRzIHNwZWNpYWwgZm9ybXMgaW50byBlbGVtZW50cy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsXG4gICAqXG4gICAqIGBgYFxuICAgKiB7IG1lc3NhZ2VzLmxlbmd0aCwgcGx1cmFsLFxuICAgKiAgID0wIHt6ZXJvfVxuICAgKiAgID0xIHtvbmV9XG4gICAqICAgb3RoZXIge21vcmUgdGhhbiBvbmV9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIHdpbGwgYmUgZXhwYW5kZWQgaW50b1xuICAgKlxuICAgKiBgYGBcbiAgICogPG5nLWNvbnRhaW5lciBbbmdQbHVyYWxdPVwibWVzc2FnZXMubGVuZ3RoXCI+XG4gICAqICAgPHRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIj0wXCI+emVybzwvbmctY29udGFpbmVyPlxuICAgKiAgIDx0ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MVwiPm9uZTwvbmctY29udGFpbmVyPlxuICAgKiAgIDx0ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCJvdGhlclwiPm1vcmUgdGhhbiBvbmU8L25nLWNvbnRhaW5lcj5cbiAgICogPC9uZy1jb250YWluZXI+XG4gICAqIGBgYFxuICAgKi9cbiAgZnVuY3Rpb24gZXhwYW5kTm9kZXMobm9kZXMpIHtcbiAgICAgIHZhciBleHBhbmRlciA9IG5ldyBfRXhwYW5kZXIoKTtcbiAgICAgIHJldHVybiBuZXcgRXhwYW5zaW9uUmVzdWx0KHZpc2l0QWxsKGV4cGFuZGVyLCBub2RlcyksIGV4cGFuZGVyLmlzRXhwYW5kZWQsIGV4cGFuZGVyLmVycm9ycyk7XG4gIH1cbiAgdmFyIEV4cGFuc2lvblJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHBhbnNpb25SZXN1bHQobm9kZXMsIGV4cGFuZGVkLCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEV4cGFuc2lvblJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIEV4cGFuc2lvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ5KEV4cGFuc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRXhwYW5zaW9uRXJyb3Ioc3BhbiwgZXJyb3JNc2cpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRXhwYW5zaW9uRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICAvKipcbiAgICogRXhwYW5kIGV4cGFuc2lvbiBmb3JtcyAocGx1cmFsLCBzZWxlY3QpIHRvIGRpcmVjdGl2ZXNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgX0V4cGFuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9FeHBhbmRlcigpIHtcbiAgICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgfVxuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChlbGVtZW50Lm5hbWUsIGVsZW1lbnQuYXR0cnMsIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IHJldHVybiBhdHRyaWJ1dGU7IH07XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0OyB9O1xuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gY29tbWVudDsgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaWN1LnR5cGUgPT0gJ3BsdXJhbCcgPyBfZXhwYW5kUGx1cmFsRm9ybShpY3UsIHRoaXMuZXJyb3JzKSA6XG4gICAgICAgICAgICAgIF9leHBhbmREZWZhdWx0Rm9ybShpY3UsIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGJlIHJlYWNoZWQnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0V4cGFuZGVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfZXhwYW5kUGx1cmFsRm9ybShhc3QsIGVycm9ycykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gYXN0LmNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmIChQTFVSQUxfQ0FTRVMuaW5kZXhPZihjLnZhbHVlKSA9PSAtMSAmJiAhYy52YWx1ZS5tYXRjaCgvXj1cXGQrJC8pKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBFeHBhbnNpb25FcnJvcihjLnZhbHVlU291cmNlU3BhbiwgXCJQbHVyYWwgY2FzZXMgc2hvdWxkIGJlIFxcXCI9PG51bWJlcj5cXFwiIG9yIG9uZSBvZiBcIiArIFBMVVJBTF9DQVNFUy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV4cGFuc2lvblJlc3VsdCA9IGV4cGFuZE5vZGVzKGMuZXhwcmVzc2lvbik7XG4gICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbnNpb25SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoXCJ0ZW1wbGF0ZVwiLCBbbmV3IEF0dHJpYnV0ZSQxKCduZ1BsdXJhbENhc2UnLCBcIlwiICsgYy52YWx1ZSwgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN3aXRjaEF0dHIgPSBuZXcgQXR0cmlidXRlJDEoJ1tuZ1BsdXJhbF0nLCBhc3Quc3dpdGNoVmFsdWUsIGFzdC5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbiAgfVxuICBmdW5jdGlvbiBfZXhwYW5kRGVmYXVsdEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgIGlmIChjLnZhbHVlID09PSAnb3RoZXInKSB7XG4gICAgICAgICAgICAgIC8vIG90aGVyIGlzIHRoZSBkZWZhdWx0IGNhc2Ugd2hlbiBubyB2YWx1ZXMgbWF0Y2hcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwidGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdTd2l0Y2hEZWZhdWx0JywgJycsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcInRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nU3dpdGNoQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nU3dpdGNoXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICByZXR1cm4gbmV3IEVsZW1lbnQoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDEwID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTAoUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByb3ZpZGVyRXJyb3IobWVzc2FnZSwgc3Bhbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb3ZpZGVyRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICB2YXIgUHJvdmlkZXJWaWV3Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgICB0aGlzLnZpZXdQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhjb21wb25lbnQudmlld1Byb3ZpZGVycywgc291cmNlU3BhbiwgdGhpcy5lcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy52aWV3UHJvdmlkZXJzLnNldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbiAgfSgpKTtcbiAgdmFyIFByb3ZpZGVyRWxlbWVudENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUHJvdmlkZXJFbGVtZW50Q29udGV4dCh2aWV3Q29udGV4dCwgX3BhcmVudCwgX2lzVmlld1Jvb3QsIF9kaXJlY3RpdmVBc3RzLCBhdHRycywgcmVmcywgX3NvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMudmlld0NvbnRleHQgPSB2aWV3Q29udGV4dDtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVBc3RzID0gX2RpcmVjdGl2ZUFzdHM7XG4gICAgICAgICAgdGhpcy5fc291cmNlU3BhbiA9IF9zb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5faGFzVmlld0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0ckFzdCkgeyByZXR1cm4gX3RoaXMuX2F0dHJzW2F0dHJBc3QubmFtZV0gPSBhdHRyQXN0LnZhbHVlOyB9KTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlc01ldGEgPSBfZGlyZWN0aXZlQXN0cy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID1cbiAgICAgICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzTWV0YSwgX3NvdXJjZVNwYW4sIHZpZXdDb250ZXh0LmVycm9ycyk7XG4gICAgICAgICAgdGhpcy5fY29udGVudFF1ZXJpZXMgPSBfZ2V0Q29udGVudFF1ZXJpZXMoZGlyZWN0aXZlc01ldGEpO1xuICAgICAgICAgIHZhciBxdWVyaWVkVG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKHByb3ZpZGVyLnRva2VuLCBxdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZkFzdCkge1xuICAgICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKG5ldyBDb21waWxlVG9rZW5NZXRhZGF0YSh7IHZhbHVlOiByZWZBc3QubmFtZSB9KSwgcXVlcmllZFRva2Vucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChxdWVyaWVkVG9rZW5zLmdldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXdDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjcmVhdGUgdGhlIHByb3ZpZGVycyB0aGF0IHdlIGtub3cgYXJlIGVhZ2VyIGZpcnN0XG4gICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHZhciBlYWdlciA9IHByb3ZpZGVyLmVhZ2VyIHx8IGlzUHJlc2VudChxdWVyaWVkVG9rZW5zLmdldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgaWYgKGVhZ2VyKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIudG9rZW4sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5hZnRlckVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAvLyBjb2xsZWN0IGxhenkgcHJvdmlkZXJzXG4gICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHNvcnRlZFByb3ZpZGVyVHlwZXMgPSB0aGlzLnRyYW5zZm9ybVByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyOyB9KTtcbiAgICAgICAgICAgICAgdmFyIHNvcnRlZERpcmVjdGl2ZXMgPSB0aGlzLl9kaXJlY3RpdmVBc3RzLnNsaWNlKCk7XG4gICAgICAgICAgICAgIHNvcnRlZERpcmVjdGl2ZXMuc29ydChmdW5jdGlvbiAoZGlyMSwgZGlyMikgeyByZXR1cm4gc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjEuZGlyZWN0aXZlLnR5cGUpIC1cbiAgICAgICAgICAgICAgICAgIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIyLmRpcmVjdGl2ZS50eXBlKTsgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBzb3J0ZWREaXJlY3RpdmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLCBcInRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oYXNWaWV3Q29udGFpbmVyOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9hZGRRdWVyeVJlYWRzVG8gPSBmdW5jdGlvbiAodG9rZW4sIHF1ZXJ5UmVhZFRva2Vucykge1xuICAgICAgICAgIHRoaXMuX2dldFF1ZXJpZXNGb3IodG9rZW4pLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgIHZhciBxdWVyeVJlYWRUb2tlbiA9IHF1ZXJ5LnJlYWQgfHwgdG9rZW47XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHF1ZXJ5UmVhZFRva2Vucy5nZXQocXVlcnlSZWFkVG9rZW4ucmVmZXJlbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5UmVhZFRva2Vucy5zZXQocXVlcnlSZWFkVG9rZW4ucmVmZXJlbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXRRdWVyaWVzRm9yID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzO1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgICAgdmFyIHF1ZXJpZXM7XG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnRFbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBxdWVyaWVzID0gY3VycmVudEVsLl9jb250ZW50UXVlcmllcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChxdWVyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBxdWVyaWVzLmZpbHRlcihmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIHF1ZXJ5LmRlc2NlbmRhbnRzIHx8IGRpc3RhbmNlIDw9IDE7IH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY3VycmVudEVsLl9kaXJlY3RpdmVBc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLl9wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLnZpZXdDb250ZXh0LnZpZXdRdWVyaWVzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllcykpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBxdWVyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIHRva2VuLCBlYWdlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0aGlzLl9hbGxQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyIHx8ICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UpICYmXG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSkgfHxcbiAgICAgICAgICAgICAgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSB8fFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5CdWlsdGluKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPSB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NlZW5Qcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW4ubmFtZSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2VlblByb3ZpZGVycy5zZXQodG9rZW4ucmVmZXJlbmNlLCB0cnVlKTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQcm92aWRlcnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gcHJvdmlkZXIudXNlRXhpc3Rpbmc7XG4gICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZERlcHM7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdEaURlcCA9IF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pLCBlYWdlcik7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4aXN0aW5nRGlEZXAudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nLFxuICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRyYW5zZm9ybWVkVXNlVmFsdWUsXG4gICAgICAgICAgICAgICAgICBkZXBzOiB0cmFuc2Zvcm1lZERlcHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9XG4gICAgICAgICAgICAgIF90cmFuc2Zvcm1Qcm92aWRlckFzdChyZXNvbHZlZFByb3ZpZGVyLCB7IGVhZ2VyOiBlYWdlciwgcHJvdmlkZXJzOiB0cmFuc2Zvcm1lZFByb3ZpZGVycyB9KTtcbiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5zZXQodG9rZW4ucmVmZXJlbmNlLCB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgIH07XG4gICAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0TG9jYWxEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpIHtcbiAgICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IG51bGw7IH1cbiAgICAgICAgICBpZiAoZGVwLmlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0aGlzLl9hdHRyc1tkZXAudG9rZW4udmFsdWVdO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBhdHRyVmFsdWUgPT0gbnVsbCA/IG51bGwgOiBhdHRyVmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAvLyBhY2Nlc3MgYnVpbHRpbnRzXG4gICAgICAgICAgICAgIGlmICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5SZW5kZXJlcikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5FbGVtZW50UmVmKS5yZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKS5yZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkZXAudG9rZW4ucmVmZXJlbmNlID09PSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRlcC50b2tlbi5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkluamVjdG9yKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYWNjZXNzIHByb3ZpZGVyc1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAudG9rZW4sIGVhZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcikge1xuICAgICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICAgIHZhciBjdXJyRWxlbWVudCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGN1cnJFYWdlciA9IGVhZ2VyO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmICghZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWxEZXBlbmRlbmN5KHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVwLmlzU2VsZikge1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjaGVjayBwYXJlbnQgZWxlbWVudHNcbiAgICAgICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgaXNQcmVzZW50KGN1cnJFbGVtZW50Ll9wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJldkVsZW1lbnQgPSBjdXJyRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIGN1cnJFbGVtZW50ID0gY3VyckVsZW1lbnQuX3BhcmVudDtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2RWxlbWVudC5faXNWaWV3Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJFYWdlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyckVsZW1lbnQuX2dldExvY2FsRGVwZW5kZW5jeShleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBkZXAsIGN1cnJFYWdlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gY2hlY2sgQEhvc3QgcmVzdHJpY3Rpb25cbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZGVwLmlzSG9zdCB8fCB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC50eXBlLmlzSG9zdCB8fFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuY29tcG9uZW50LnR5cGUucmVmZXJlbmNlID09PSBkZXAudG9rZW4ucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgaXNQcmVzZW50KHRoaXMudmlld0NvbnRleHQudmlld1Byb3ZpZGVycy5nZXQoZGVwLnRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVwLmlzT3B0aW9uYWwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyBkZXAudG9rZW4ubmFtZSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQcm92aWRlckVsZW1lbnRDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcihuZ01vZHVsZSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZVR5cGVzID0gbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLm1hcChmdW5jdGlvbiAobW9kdWxlTWV0YSkgeyByZXR1cm4gbW9kdWxlTWV0YS50eXBlOyB9KTtcbiAgICAgICAgICBuZ01vZHVsZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICB2YXIgbmdNb2R1bGVQcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7IHRva2VuOiBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyBpZGVudGlmaWVyOiBuZ01vZHVsZVR5cGUgfSksIHVzZUNsYXNzOiBuZ01vZHVsZVR5cGUgfSk7XG4gICAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtuZ01vZHVsZVByb3ZpZGVyXSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgdHJ1ZSwgc291cmNlU3BhbiwgX3RoaXMuX2Vycm9ycywgX3RoaXMuX2FsbFByb3ZpZGVycyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoX25vcm1hbGl6ZVByb3ZpZGVycyhuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnByb3ZpZGVycy5jb25jYXQoZXh0cmFQcm92aWRlcnMpLCBzb3VyY2VTcGFuLCB0aGlzLl9lcnJvcnMpLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGhpcy5fZXJyb3JzLCB0aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgICAgfVxuICAgICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5lYWdlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IHRoaXMuX2Vycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgICB9O1xuICAgICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHRva2VuLCBlYWdlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0aGlzLl9hbGxQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9IHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodHJhbnNmb3JtZWRQcm92aWRlckFzdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW4ucmVmZXJlbmNlKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW4ubmFtZSwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzLnNldCh0b2tlbi5yZWZlcmVuY2UsIHRydWUpO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBwcm92aWRlci51c2VWYWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBwcm92aWRlci51c2VFeGlzdGluZztcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRGVwcztcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0RpRGVwID0gX3RoaXMuX2dldERlcGVuZGVuY3kobmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSwgZWFnZXIsIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4aXN0aW5nRGlEZXAudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdHJhbnNmb3JtZWRVc2VWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGRlcHM6IHRyYW5zZm9ybWVkRGVwc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID1cbiAgICAgICAgICAgICAgX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHJlc29sdmVkUHJvdmlkZXIsIHsgZWFnZXI6IGVhZ2VyLCBwcm92aWRlcnM6IHRyYW5zZm9ybWVkUHJvdmlkZXJzIH0pO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnNldCh0b2tlbi5yZWZlcmVuY2UsIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpO1xuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgfTtcbiAgICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwLCBlYWdlciwgcmVxdWVzdG9yU291cmNlU3Bhbikge1xuICAgICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICAgIHZhciBmb3VuZExvY2FsID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZiAmJiBpc1ByZXNlbnQoZGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkluamVjdG9yKS5yZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICAgIGRlcC50b2tlbi5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgZm91bmRMb2NhbCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihkZXAudG9rZW4sIGVhZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQgPSBkZXA7XG4gICAgICAgICAgaWYgKGRlcC5pc1NlbGYgJiYgIWZvdW5kTG9jYWwpIHtcbiAgICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk5vIHByb3ZpZGVyIGZvciBcIiArIGRlcC50b2tlbi5uYW1lLCByZXF1ZXN0b3JTb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTmdNb2R1bGVQcm92aWRlckFuYWx5emVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIF9hKSB7XG4gICAgICB2YXIgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgZGVwcyA9IF9hLmRlcHM7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICB0b2tlbjogcHJvdmlkZXIudG9rZW4sXG4gICAgICAgICAgdXNlQ2xhc3M6IHByb3ZpZGVyLnVzZUNsYXNzLFxuICAgICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcbiAgICAgICAgICB1c2VGYWN0b3J5OiBwcm92aWRlci51c2VGYWN0b3J5LFxuICAgICAgICAgIHVzZVZhbHVlOiB1c2VWYWx1ZSxcbiAgICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHByb3ZpZGVyLCBfYSkge1xuICAgICAgdmFyIGVhZ2VyID0gX2EuZWFnZXIsIHByb3ZpZGVycyA9IF9hLnByb3ZpZGVycztcbiAgICAgIHJldHVybiBuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIsIHByb3ZpZGVyLmVhZ2VyIHx8IGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIubGlmZWN5Y2xlSG9va3MsIHByb3ZpZGVyLnNvdXJjZVNwYW4pO1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHRhcmdldFByb3ZpZGVycykge1xuICAgICAgaWYgKHRhcmdldFByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IHRhcmdldFByb3ZpZGVycyA9IG51bGw7IH1cbiAgICAgIGlmICghdGFyZ2V0UHJvdmlkZXJzKSB7XG4gICAgICAgICAgdGFyZ2V0UHJvdmlkZXJzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVycykpIHtcbiAgICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVyLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHRhcmdldFByb3ZpZGVycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplUHJvdmlkZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIENvbXBpbGVUeXBlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVQcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7IHRva2VuOiBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyBpZGVudGlmaWVyOiBwcm92aWRlciB9KSwgdXNlQ2xhc3M6IHByb3ZpZGVyIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJVbmtub3duIHByb3ZpZGVyIHR5cGUgXCIgKyBwcm92aWRlciwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChub3JtYWxpemVQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcm92aWRlcnMucHVzaChub3JtYWxpemVQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRQcm92aWRlcnM7XG4gIH1cbiAgZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpIHtcbiAgICAgIHZhciBwcm92aWRlcnNCeVRva2VuID0gbmV3IE1hcCgpO1xuICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICB2YXIgZGlyUHJvdmlkZXIgPSBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoeyB0b2tlbjogbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgaWRlbnRpZmllcjogZGlyZWN0aXZlLnR5cGUgfSksIHVzZUNsYXNzOiBkaXJlY3RpdmUudHlwZSB9KTtcbiAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhbZGlyUHJvdmlkZXJdLCBkaXJlY3RpdmUuaXNDb21wb25lbnQgPyBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQgOiBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUsIHRydWUsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgICB9KTtcbiAgICAgIC8vIE5vdGU6IGRpcmVjdGl2ZXMgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJ3cml0ZSBwcm92aWRlcnMgb2YgYSBjb21wb25lbnQhXG4gICAgICB2YXIgZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdCA9IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5pc0NvbXBvbmVudDsgfSkuY29uY2F0KGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICFkaXIuaXNDb21wb25lbnQ7IH0pKTtcbiAgICAgIGRpcmVjdGl2ZXNXaXRoQ29tcG9uZW50Rmlyc3QuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoX25vcm1hbGl6ZVByb3ZpZGVycyhkaXJlY3RpdmUucHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhfbm9ybWFsaXplUHJvdmlkZXJzKGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm92aWRlcnNCeVRva2VuO1xuICB9XG4gIGZ1bmN0aW9uIF9yZXNvbHZlUHJvdmlkZXJzKHByb3ZpZGVycywgcHJvdmlkZXJUeXBlLCBlYWdlciwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCB0YXJnZXRQcm92aWRlcnNCeVRva2VuKSB7XG4gICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlciA9IHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uZ2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChyZXNvbHZlZFByb3ZpZGVyKSAmJiByZXNvbHZlZFByb3ZpZGVyLm11bHRpUHJvdmlkZXIgIT09IHByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgIHRhcmdldEVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTWl4aW5nIG11bHRpIGFuZCBub24gbXVsdGkgcHJvdmlkZXIgaXMgbm90IHBvc3NpYmxlIGZvciB0b2tlbiBcIiArIHJlc29sdmVkUHJvdmlkZXIudG9rZW4ubmFtZSwgc291cmNlU3BhbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGxpZmVjeWNsZUhvb2tzID0gcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllciAmJiBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyIGluc3RhbmNlb2YgQ29tcGlsZVR5cGVNZXRhZGF0YSA/XG4gICAgICAgICAgICAgICAgICBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyLmxpZmVjeWNsZUhvb2tzIDpcbiAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5tdWx0aSwgZWFnZXIgfHwgbGlmZWN5Y2xlSG9va3MubGVuZ3RoID4gMCwgW3Byb3ZpZGVyXSwgcHJvdmlkZXJUeXBlLCBsaWZlY3ljbGVIb29rcywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uc2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRWaWV3UXVlcmllcyhjb21wb25lbnQpIHtcbiAgICAgIHZhciB2aWV3UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgIGlmIChpc1ByZXNlbnQoY29tcG9uZW50LnZpZXdRdWVyaWVzKSkge1xuICAgICAgICAgIGNvbXBvbmVudC52aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgcXVlcnkpOyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aWV3UXVlcmllcztcbiAgfVxuICBmdW5jdGlvbiBfZ2V0Q29udGVudFF1ZXJpZXMoZGlyZWN0aXZlcykge1xuICAgICAgdmFyIGNvbnRlbnRRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRpcmVjdGl2ZS5xdWVyaWVzKSkge1xuICAgICAgICAgICAgICBkaXJlY3RpdmUucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcChjb250ZW50UXVlcmllcywgcXVlcnkpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50UXVlcmllcztcbiAgfVxuICBmdW5jdGlvbiBfYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICAgIHF1ZXJ5LnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciBlbnRyeSA9IG1hcC5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgIGVudHJ5ID0gW107XG4gICAgICAgICAgICAgIG1hcC5zZXQodG9rZW4ucmVmZXJlbmNlLCBlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgfSgpKTtcblxuICB2YXIgU3R5bGVXaXRoSW1wb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlLCBzdHlsZVVybHMpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3R5bGVXaXRoSW1wb3J0cztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgICBpZiAoaXNCbGFuayh1cmwpIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc2NoZW1lTWF0Y2ggPSB1cmwubWF0Y2goX3VybFdpdGhTY2hlbWFSZSk7XG4gICAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG4gIH1cbiAgLyoqXG4gICAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIEBpbXBvcnQgdXJscyB0aGF0XG4gICAqIGFyZSBlaXRoZXIgcmVsYXRpdmUgb3IgZG9uJ3QgaGF2ZSBhIGBwYWNrYWdlOmAgc2NoZW1lXG4gICAqL1xuICBmdW5jdGlvbiBleHRyYWN0U3R5bGVVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KSB7XG4gICAgICB2YXIgZm91bmRVcmxzID0gW107XG4gICAgICB2YXIgbW9kaWZpZWRDc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKF9jc3NJbXBvcnRSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgbVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVybCA9IG1bMV0gfHwgbVsyXTtcbiAgICAgICAgICBpZiAoIWlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJIHNjaGVtZVxuICAgICAgICAgICAgICByZXR1cm4gbVswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm91bmRVcmxzLnB1c2gocmVzb2x2ZXIucmVzb2x2ZShiYXNlVXJsLCB1cmwpKTtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgU3R5bGVXaXRoSW1wb3J0cyhtb2RpZmllZENzc1RleHQsIGZvdW5kVXJscyk7XG4gIH1cbiAgdmFyIF9jc3NJbXBvcnRSZSA9IC9AaW1wb3J0XFxzKyg/OnVybFxcKCk/XFxzKig/Oig/OlsnXCJdKFteJ1wiXSopKXwoW147XFwpXFxzXSopKVteO10qOz8vZztcbiAgdmFyIF91cmxXaXRoU2NoZW1hUmUgPSAvXihbXjovPyNdKyk6LztcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IgPSAnLic7XG4gIHZhciBBVFRSSUJVVEVfUFJFRklYID0gJ2F0dHInO1xuICB2YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbiAgdmFyIFNUWUxFX1BSRUZJWCA9ICdzdHlsZSc7XG4gIHZhciBBTklNQVRFX1BST1BfUFJFRklYID0gJ2FuaW1hdGUtJztcbiAgdmFyIEJvdW5kUHJvcGVydHlUeXBlO1xuICAoZnVuY3Rpb24gKEJvdW5kUHJvcGVydHlUeXBlKSB7XG4gICAgICBCb3VuZFByb3BlcnR5VHlwZVtCb3VuZFByb3BlcnR5VHlwZVtcIkRFRkFVTFRcIl0gPSAwXSA9IFwiREVGQVVMVFwiO1xuICAgICAgQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGVbXCJMSVRFUkFMX0FUVFJcIl0gPSAxXSA9IFwiTElURVJBTF9BVFRSXCI7XG4gICAgICBCb3VuZFByb3BlcnR5VHlwZVtCb3VuZFByb3BlcnR5VHlwZVtcIkFOSU1BVElPTlwiXSA9IDJdID0gXCJBTklNQVRJT05cIjtcbiAgfSkoQm91bmRQcm9wZXJ0eVR5cGUgfHwgKEJvdW5kUHJvcGVydHlUeXBlID0ge30pKTtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBwYXJzZWQgcHJvcGVydHkuXG4gICAqL1xuICB2YXIgQm91bmRQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZFByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzTGl0ZXJhbFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IEJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUjsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRQcm9wZXJ0eS5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBCb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT047IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEJvdW5kUHJvcGVydHk7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBQYXJzZXMgYmluZGluZ3MgaW4gdGVtcGxhdGVzIGFuZCBpbiB0aGUgZGlyZWN0aXZlIGhvc3QgYXJlYS5cbiAgICovXG4gIHZhciBCaW5kaW5nUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJpbmRpbmdQYXJzZXIoX2V4cHJQYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnLCBfc2NoZW1hUmVnaXN0cnksIHBpcGVzLCBfdGFyZ2V0RXJyb3JzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX3RhcmdldEVycm9ycyA9IF90YXJnZXRFcnJvcnM7XG4gICAgICAgICAgdGhpcy5waXBlc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBwaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5waXBlc0J5TmFtZS5zZXQocGlwZS5uYW1lLCBwaXBlKTsgfSk7XG4gICAgICB9XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGRpck1ldGEsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChkaXJNZXRhLmhvc3RQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIHZhciBib3VuZFByb3BzXzEgPSBbXTtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0UHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyc2VQcm9wZXJ0eUJpbmRpbmcocHJvcE5hbWUsIGV4cHJlc3Npb24sIHRydWUsIHNvdXJjZVNwYW4sIFtdLCBib3VuZFByb3BzXzEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZyBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBuZWVkcyB0byBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gZXhwcmVzc2lvbiBidXQgZ290IFxcXCJcIiArIGV4cHJlc3Npb24gKyBcIlxcXCIgKFwiICsgdHlwZW9mIGV4cHJlc3Npb24gKyBcIilcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gYm91bmRQcm9wc18xLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGRpck1ldGEuc2VsZWN0b3IsIHByb3ApOyB9KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXRFdmVudEFzdHNfMSA9IFtdO1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLmhvc3RMaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGRpck1ldGEuaG9zdExpc3RlbmVyc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyc2VFdmVudChwcm9wTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgW10sIHRhcmdldEV2ZW50QXN0c18xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlZhbHVlIG9mIHRoZSBob3N0IGxpc3RlbmVyIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXFxcIlwiICsgZXhwcmVzc2lvbiArIFwiXFxcIiAoXCIgKyB0eXBlb2YgZXhwcmVzc2lvbiArIFwiKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRFdmVudEFzdHNfMTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VJbmxpbmVUZW1wbGF0ZUJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSwgcHJlZml4VG9rZW4sIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgICB2YXIgYmluZGluZ3MgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQmluZGluZ3MocHJlZml4VG9rZW4sIHZhbHVlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgICAgIGlmIChiaW5kaW5nLmtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLm5hbWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQoYmluZGluZy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChiaW5kaW5nLmtleSwgYmluZGluZy5leHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbYmluZGluZy5rZXksICcnXSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGl0ZXJhbEF0dHIoYmluZGluZy5rZXksIG51bGwsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBiaW5kaW5nc1Jlc3VsdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHByZWZpeFRva2VuLCB2YWx1ZSwgc291cmNlSW5mbyk7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYmluZGluZ3NSZXN1bHQuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGJpbmRpbmcuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQaXBlcyhiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykgeyBfdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7IH0pO1xuICAgICAgICAgICAgICByZXR1cm4gYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlTGl0ZXJhbEF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIiBVc2UgcHJvcGVydHkgYmluZGluZ3MgKGUuZy4gW0Bwcm9wXT1cXFwiZXhwXFxcIikgb3IgdXNlIGFuIGF0dHJpYnV0ZSB3aXRob3V0IGEgdmFsdWUgKGUuZy4gQHByb3ApIGluc3RlYWQuXCIsIHNvdXJjZVNwYW4sIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kUHJvcGVydHkobmFtZSwgdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSwgJycpLCBCb3VuZFByb3BlcnR5VHlwZS5MSVRFUkFMX0FUVFIsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgaXNBbmltYXRpb25Qcm9wID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChBTklNQVRFX1BST1BfUFJFRklYKSkge1xuICAgICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoQU5JTUFURV9QUk9QX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FuaW1hdGlvblByb3ApIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24sIGlzSG9zdCwgc291cmNlU3BhbiksIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIGFzdCwgQm91bmRQcm9wZXJ0eVR5cGUuREVGQVVMVCwgc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgb2NjdXIgd2hlbiBhIEB0cmlnZ2VyIGlzIG5vdCBwYWlyZWQgd2l0aCBhbiBleHByZXNzaW9uLlxuICAgICAgICAgIC8vIEZvciBhbmltYXRpb25zIGl0IGlzIHZhbGlkIHRvIG5vdCBoYXZlIGFuIGV4cHJlc3Npb24gc2luY2UgKi92b2lkXG4gICAgICAgICAgLy8gc3RhdGVzIHdpbGwgYmUgYXBwbGllZCBieSBhbmd1bGFyIHdoZW4gdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQvZGV0YWNoZWRcbiAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24gfHwgJ251bGwnLCBmYWxzZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kUHJvcGVydHkobmFtZSwgYXN0LCBCb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT04sIHNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBpc0hvc3RCaW5kaW5nLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IGlzSG9zdEJpbmRpbmcgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwclBhcnNlci5wYXJzZVNpbXBsZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpIDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0ID0gZnVuY3Rpb24gKGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wKSB7XG4gICAgICAgICAgaWYgKGJvdW5kUHJvcC5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KGJvdW5kUHJvcC5uYW1lLCBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uLCBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FLCBmYWxzZSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIG51bGwsIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xuICAgICAgICAgIHZhciBiaW5kaW5nVHlwZTtcbiAgICAgICAgICB2YXIgYm91bmRQcm9wZXJ0eU5hbWU7XG4gICAgICAgICAgdmFyIHBhcnRzID0gYm91bmRQcm9wLm5hbWUuc3BsaXQoUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SKTtcbiAgICAgICAgICB2YXIgc2VjdXJpdHlDb250ZXh0cztcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0VmFsdWUgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShwYXJ0VmFsdWUpO1xuICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3BlcnR5TmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PSBBVFRSSUJVVEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wZXJ0eU5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgdmFyIG5zU2VwYXJhdG9ySWR4ID0gYm91bmRQcm9wZXJ0eU5hbWUuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5zU2VwYXJhdG9ySWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbnMgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMCwgbnNTZXBhcmF0b3JJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcobnNTZXBhcmF0b3JJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IG1lcmdlTnNBbmROYW1lKG5zLCBuYW1lXzEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IENMQVNTX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzO1xuICAgICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IFtfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBTVFlMRV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlO1xuICAgICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IFtfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TVFlMRV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkludmFsaWQgcHJvcGVydHkgbmFtZSAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJ1wiLCBib3VuZFByb3Auc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3BlcnR5TmFtZSwgYmluZGluZ1R5cGUsIHNlY3VyaXR5Q29udGV4dHMubGVuZ3RoID09PSAxID8gc2VjdXJpdHlDb250ZXh0c1swXSA6IG51bGwsIHNlY3VyaXR5Q29udGV4dHMubGVuZ3RoID4gMSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIHVuaXQsIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgICBpZiAoX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbkV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHNwbGl0QXRQZXJpb2QobmFtZSwgW25hbWUsICcnXSk7XG4gICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoZXNbMF07XG4gICAgICAgICAgdmFyIHBoYXNlID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RXZlbnRzLnB1c2gobmV3IEJvdW5kRXZlbnRBc3QoZXZlbnROYW1lLCBudWxsLCBwaGFzZSwgYXN0LCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiBvdXRwdXQgcGhhc2UgdmFsdWUgXFxcIlwiICsgcGhhc2UgKyBcIlxcXCIgZm9yIFxcXCJAXCIgKyBldmVudE5hbWUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZCAodXNlIHN0YXJ0IG9yIGRvbmUpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBvdXRwdXQgZXZlbnQgKEBcIiArIGV2ZW50TmFtZSArIFwiKSBpcyBtaXNzaW5nIGl0cyBwaGFzZSB2YWx1ZSBuYW1lIChzdGFydCBvciBkb25lIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXG4gICAgICAgICAgdmFyIF9hID0gc3BsaXRBdENvbG9uKG5hbWUsIFtudWxsLCBuYW1lXSksIHRhcmdldCA9IF9hWzBdLCBldmVudE5hbWUgPSBfYVsxXTtcbiAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgdGFyZ2V0LCBudWxsLCBhc3QsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAvLyBEb24ndCBkZXRlY3QgZGlyZWN0aXZlcyBmb3IgZXZlbnQgbmFtZXMgZm9yIG5vdyxcbiAgICAgICAgICAvLyBzbyBkb24ndCBhZGQgdGhlIGV2ZW50IG5hbWUgdG8gdGhlIG1hdGNoYWJsZUF0dHJzXG4gICAgICB9O1xuICAgICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VBY3Rpb24odmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghYXN0IHx8IGFzdC5hc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiRW1wdHkgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQaXBlcyhhc3QsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMOyB9XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFBhcnNlRXJyb3Ioc291cmNlU3BhbiwgbWVzc2FnZSwgbGV2ZWwpKTtcbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVycm9yc18xID0gZXJyb3JzOyBfaSA8IGVycm9yc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvcnNfMVtfaV07XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycm9yLm1lc3NhZ2UsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tQaXBlcyA9IGZ1bmN0aW9uIChhc3QsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0KSkge1xuICAgICAgICAgICAgICB2YXIgY29sbGVjdG9yID0gbmV3IFBpcGVDb2xsZWN0b3IoKTtcbiAgICAgICAgICAgICAgYXN0LnZpc2l0KGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgIGNvbGxlY3Rvci5waXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5waXBlc0J5TmFtZS5oYXMocGlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlIHBpcGUgJ1wiICsgcGlwZU5hbWUgKyBcIicgY291bGQgbm90IGJlIGZvdW5kXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0gcHJvcE5hbWUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IC8gYXR0cmlidXRlXG4gICAgICAgKiBAcGFyYW0gc291cmNlU3BhblxuICAgICAgICogQHBhcmFtIGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzb3VyY2VTcGFuLCBpc0F0dHIpIHtcbiAgICAgICAgICB2YXIgcmVwb3J0ID0gaXNBdHRyID8gdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVBdHRyaWJ1dGUocHJvcE5hbWUpIDpcbiAgICAgICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVQcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICAgICAgaWYgKHJlcG9ydC5lcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihyZXBvcnQubXNnLCBzb3VyY2VTcGFuLCBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5GQVRBTCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5kaW5nUGFyc2VyO1xuICB9KCkpO1xuICB2YXIgUGlwZUNvbGxlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTEoUGlwZUNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFBpcGVDb2xsZWN0b3IoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIFBpcGVDb2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnBpcGVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUGlwZUNvbGxlY3RvcjtcbiAgfShSZWN1cnNpdmVBc3RWaXNpdG9yKSk7XG4gIGZ1bmN0aW9uIF9pc0FuaW1hdGlvbkxhYmVsKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbiAgfVxuICBmdW5jdGlvbiBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHJlZ2lzdHJ5LCBzZWxlY3RvciwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7XG4gICAgICB2YXIgY3R4cyA9IFtdO1xuICAgICAgQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3IpLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnROYW1lcyA9IHNlbGVjdG9yLmVsZW1lbnQgPyBbc2VsZWN0b3IuZWxlbWVudF0gOiByZWdpc3RyeS5hbGxLbm93bkVsZW1lbnROYW1lcygpO1xuICAgICAgICAgIHZhciBub3RFbGVtZW50TmFtZXMgPSBuZXcgU2V0KHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5maWx0ZXIoZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5pc0VsZW1lbnRTZWxlY3RvcigpOyB9KVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuZWxlbWVudDsgfSkpO1xuICAgICAgICAgIHZhciBwb3NzaWJsZUVsZW1lbnROYW1lcyA9IGVsZW1lbnROYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7IHJldHVybiAhbm90RWxlbWVudE5hbWVzLmhhcyhlbGVtZW50TmFtZSk7IH0pO1xuICAgICAgICAgIGN0eHMucHVzaC5hcHBseShjdHhzLCBwb3NzaWJsZUVsZW1lbnROYW1lcy5tYXAoZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7IHJldHVybiByZWdpc3RyeS5zZWN1cml0eUNvbnRleHQoZWxlbWVudE5hbWUsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSk7IH0pKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGN0eHMubGVuZ3RoID09PSAwID8gW19hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkVdIDogQXJyYXkuZnJvbShuZXcgU2V0KGN0eHMpKS5zb3J0KCk7XG4gIH1cblxuICB2YXIgTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUiA9ICdzZWxlY3QnO1xuICB2YXIgTkdfQ09OVEVOVF9FTEVNRU5UID0gJ25nLWNvbnRlbnQnO1xuICB2YXIgTElOS19FTEVNRU5UID0gJ2xpbmsnO1xuICB2YXIgTElOS19TVFlMRV9SRUxfQVRUUiA9ICdyZWwnO1xuICB2YXIgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XG4gIHZhciBMSU5LX1NUWUxFX1JFTF9WQUxVRSA9ICdzdHlsZXNoZWV0JztcbiAgdmFyIFNUWUxFX0VMRU1FTlQgPSAnc3R5bGUnO1xuICB2YXIgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcbiAgdmFyIE5HX05PTl9CSU5EQUJMRV9BVFRSID0gJ25nTm9uQmluZGFibGUnO1xuICB2YXIgTkdfUFJPSkVDVF9BUyA9ICduZ1Byb2plY3RBcyc7XG4gIGZ1bmN0aW9uIHByZXBhcnNlRWxlbWVudChhc3QpIHtcbiAgICAgIHZhciBzZWxlY3RBdHRyID0gbnVsbDtcbiAgICAgIHZhciBocmVmQXR0ciA9IG51bGw7XG4gICAgICB2YXIgcmVsQXR0ciA9IG51bGw7XG4gICAgICB2YXIgbm9uQmluZGFibGUgPSBmYWxzZTtcbiAgICAgIHZhciBwcm9qZWN0QXMgPSBudWxsO1xuICAgICAgYXN0LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICB2YXIgbGNBdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChsY0F0dHJOYW1lID09IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIpIHtcbiAgICAgICAgICAgICAgc2VsZWN0QXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9IUkVGX0FUVFIpIHtcbiAgICAgICAgICAgICAgaHJlZkF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfUkVMX0FUVFIpIHtcbiAgICAgICAgICAgICAgcmVsQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19OT05fQklOREFCTEVfQVRUUikge1xuICAgICAgICAgICAgICBub25CaW5kYWJsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19QUk9KRUNUX0FTKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHByb2plY3RBcyA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEF0dHIgPSBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cik7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBhc3QubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5PVEhFUjtcbiAgICAgIGlmIChzcGxpdE5zTmFtZShub2RlTmFtZSlbMV0gPT0gTkdfQ09OVEVOVF9FTEVNRU5UKSB7XG4gICAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTVFlMRV9FTEVNRU5UKSB7XG4gICAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU0NSSVBUX0VMRU1FTlQpIHtcbiAgICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gTElOS19FTEVNRU5UICYmIHJlbEF0dHIgPT0gTElOS19TVFlMRV9SRUxfVkFMVUUpIHtcbiAgICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcyk7XG4gIH1cbiAgdmFyIFByZXBhcnNlZEVsZW1lbnRUeXBlO1xuICAoZnVuY3Rpb24gKFByZXBhcnNlZEVsZW1lbnRUeXBlKSB7XG4gICAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk5HX0NPTlRFTlRcIl0gPSAwXSA9IFwiTkdfQ09OVEVOVFwiO1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVwiXSA9IDFdID0gXCJTVFlMRVwiO1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVNIRUVUXCJdID0gMl0gPSBcIlNUWUxFU0hFRVRcIjtcbiAgICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJPVEhFUlwiXSA9IDRdID0gXCJPVEhFUlwiO1xuICB9KShQcmVwYXJzZWRFbGVtZW50VHlwZSB8fCAoUHJlcGFyc2VkRWxlbWVudFR5cGUgPSB7fSkpO1xuICB2YXIgUHJlcGFyc2VkRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xuICAgICAgICAgIHRoaXMuaHJlZkF0dHIgPSBocmVmQXR0cjtcbiAgICAgICAgICB0aGlzLm5vbkJpbmRhYmxlID0gbm9uQmluZGFibGU7XG4gICAgICAgICAgdGhpcy5wcm9qZWN0QXMgPSBwcm9qZWN0QXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJlcGFyc2VkRWxlbWVudDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcbiAgICAgIGlmIChzZWxlY3RBdHRyID09PSBudWxsIHx8IHNlbGVjdEF0dHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RBdHRyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICAvLyBHcm91cCAxID0gXCJiaW5kLVwiXG4gIC8vIEdyb3VwIDIgPSBcImxldC1cIlxuICAvLyBHcm91cCAzID0gXCJyZWYtLyNcIlxuICAvLyBHcm91cCA0ID0gXCJvbi1cIlxuICAvLyBHcm91cCA1ID0gXCJiaW5kb24tXCJcbiAgLy8gR3JvdXAgNiA9IFwiQFwiXG4gIC8vIEdyb3VwIDcgPSB0aGUgaWRlbnRpZmllciBhZnRlciBcImJpbmQtXCIsIFwibGV0LVwiLCBcInJlZi0vI1wiLCBcIm9uLVwiLCBcImJpbmRvbi1cIiBvciBcIkBcIlxuICAvLyBHcm91cCA4ID0gaWRlbnRpZmllciBpbnNpZGUgWygpXVxuICAvLyBHcm91cCA5ID0gaWRlbnRpZmllciBpbnNpZGUgW11cbiAgLy8gR3JvdXAgMTAgPSBpZGVudGlmaWVyIGluc2lkZSAoKVxuICB2YXIgQklORF9OQU1FX1JFR0VYUCA9IC9eKD86KD86KD86KGJpbmQtKXwobGV0LSl8KHJlZi18Iyl8KG9uLSl8KGJpbmRvbi0pfChAKSkoLispKXxcXFtcXCgoW15cXCldKylcXClcXF18XFxbKFteXFxdXSspXFxdfFxcKChbXlxcKV0rKVxcKSkkLztcbiAgdmFyIEtXX0JJTkRfSURYID0gMTtcbiAgdmFyIEtXX0xFVF9JRFggPSAyO1xuICB2YXIgS1dfUkVGX0lEWCA9IDM7XG4gIHZhciBLV19PTl9JRFggPSA0O1xuICB2YXIgS1dfQklORE9OX0lEWCA9IDU7XG4gIHZhciBLV19BVF9JRFggPSA2O1xuICB2YXIgSURFTlRfS1dfSURYID0gNztcbiAgdmFyIElERU5UX0JBTkFOQV9CT1hfSURYID0gODtcbiAgdmFyIElERU5UX1BST1BFUlRZX0lEWCA9IDk7XG4gIHZhciBJREVOVF9FVkVOVF9JRFggPSAxMDtcbiAgdmFyIFRFTVBMQVRFX0VMRU1FTlQgPSAndGVtcGxhdGUnO1xuICB2YXIgVEVNUExBVEVfQVRUUiA9ICd0ZW1wbGF0ZSc7XG4gIHZhciBURU1QTEFURV9BVFRSX1BSRUZJWCA9ICcqJztcbiAgdmFyIENMQVNTX0FUVFIgPSAnY2xhc3MnO1xuICB2YXIgVEVYVF9DU1NfU0VMRUNUT1IgPSBDc3NTZWxlY3Rvci5wYXJzZSgnKicpWzBdO1xuICAvKipcbiAgICogUHJvdmlkZXMgYW4gYXJyYXkgb2Yge0BsaW5rIFRlbXBsYXRlQXN0VmlzaXRvcn1zIHdoaWNoIHdpbGwgYmUgdXNlZCB0byB0cmFuc2Zvcm1cbiAgICogcGFyc2VkIHRlbXBsYXRlcyBiZWZvcmUgY29tcGlsYXRpb24gaXMgaW52b2tlZCwgYWxsb3dpbmcgY3VzdG9tIGV4cHJlc3Npb24gc3ludGF4XG4gICAqIGFuZCBvdGhlciBhZHZhbmNlZCB0cmFuc2Zvcm1hdGlvbnMuXG4gICAqXG4gICAqIFRoaXMgaXMgY3VycmVudGx5IGFuIGludGVybmFsLW9ubHkgZmVhdHVyZSBhbmQgbm90IG1lYW50IGZvciBnZW5lcmFsIHVzZS5cbiAgICovXG4gIHZhciBURU1QTEFURV9UUkFOU0ZPUk1TID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ1RlbXBsYXRlVHJhbnNmb3JtcycpO1xuICB2YXIgVGVtcGxhdGVQYXJzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyhUZW1wbGF0ZVBhcnNlRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlRXJyb3IobWVzc2FnZSwgc3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtZXNzYWdlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVGVtcGxhdGVQYXJzZUVycm9yO1xuICB9KFBhcnNlRXJyb3IpKTtcbiAgdmFyIFRlbXBsYXRlUGFyc2VSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZVJlc3VsdCh0ZW1wbGF0ZUFzdCwgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUFzdCA9IHRlbXBsYXRlQXN0O1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZVBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlcihfZXhwclBhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfaHRtbFBhcnNlciwgX2NvbnNvbGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuICAgICAgfVxuICAgICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuV0FSTklORzsgfSk7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMOyB9KTtcbiAgICAgICAgICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oXCJUZW1wbGF0ZSBwYXJzZSB3YXJuaW5nczpcXG5cIiArIHdhcm5pbmdzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnRlbXBsYXRlQXN0O1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cnlQYXJzZUh0bWwodGhpcy5leHBhbmRIdG1sKHRoaXMuX2h0bWxQYXJzZXIucGFyc2UodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCB0cnVlLCB0aGlzLmdldEludGVycG9sYXRpb25Db25maWcoY29tcG9uZW50KSkpLCBjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZUh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IGh0bWxBc3RXaXRoRXJyb3JzLmVycm9ycztcbiAgICAgICAgICBpZiAoaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHVuaXFEaXJlY3RpdmVzID0gcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICAgIHZhciB1bmlxUGlwZXMgPSByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyhwaXBlcyk7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlclZpZXdDb250ZXh0ID0gbmV3IFByb3ZpZGVyVmlld0NvbnRleHQoY29tcG9uZW50LCBodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXNbMF0uc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQ29uZmlnID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnRlbXBsYXRlICYmIGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uWzFdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBiaW5kaW5nUGFyc2VyID0gbmV3IEJpbmRpbmdQYXJzZXIodGhpcy5fZXhwclBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZywgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHVuaXFQaXBlcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlVmlzaXRvciA9IG5ldyBUZW1wbGF0ZVBhcnNlVmlzaXRvcihwcm92aWRlclZpZXdDb250ZXh0LCB1bmlxRGlyZWN0aXZlcywgYmluZGluZ1BhcnNlciwgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHNjaGVtYXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZpc2l0QWxsKHBhcnNlVmlzaXRvciwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLCBFTVBUWV9FTEVNRU5UX0NPTlRFWFQpO1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIHByb3ZpZGVyVmlld0NvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9hc3NlcnROb1JlZmVyZW5jZUR1cGxpY2F0aW9uT25UZW1wbGF0ZShyZXN1bHQsIGVycm9ycyk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJzZVJlc3VsdChyZXN1bHQsIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy50cmFuc2Zvcm1zKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNmb3JtKSB7IHJlc3VsdCA9IHRlbXBsYXRlVmlzaXRBbGwodHJhbnNmb3JtLCByZXN1bHQpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcnNlUmVzdWx0KHJlc3VsdCwgZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuZXhwYW5kSHRtbCA9IGZ1bmN0aW9uIChodG1sQXN0V2l0aEVycm9ycywgZm9yY2VkKSB7XG4gICAgICAgICAgaWYgKGZvcmNlZCA9PT0gdm9pZCAwKSB7IGZvcmNlZCA9IGZhbHNlOyB9XG4gICAgICAgICAgdmFyIGVycm9ycyA9IGh0bWxBc3RXaXRoRXJyb3JzLmVycm9ycztcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PSAwIHx8IGZvcmNlZCkge1xuICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSUNVIG1lc3NhZ2VzIHRvIGFuZ3VsYXIgZGlyZWN0aXZlc1xuICAgICAgICAgICAgICB2YXIgZXhwYW5kZWRIdG1sQXN0ID0gZXhwYW5kTm9kZXMoaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbmRlZEh0bWxBc3QuZXJyb3JzKTtcbiAgICAgICAgICAgICAgaHRtbEFzdFdpdGhFcnJvcnMgPSBuZXcgUGFyc2VUcmVlUmVzdWx0KGV4cGFuZGVkSHRtbEFzdC5ub2RlcywgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGh0bWxBc3RXaXRoRXJyb3JzO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5nZXRJbnRlcnBvbGF0aW9uQ29uZmlnID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgIGlmIChjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KGNvbXBvbmVudC50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLl9hc3NlcnROb1JlZmVyZW5jZUR1cGxpY2F0aW9uT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGVycm9ycykge1xuICAgICAgICAgIHZhciBleGlzdGluZ1JlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgICByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiAhIWVsZW1lbnQucmVmZXJlbmNlczsgfSlcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSByZWZlcmVuY2UubmFtZTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUmVmZXJlbmNlcy5pbmRleE9mKG5hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdSZWZlcmVuY2VzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgVGVtcGxhdGVQYXJzZUVycm9yKFwiUmVmZXJlbmNlIFxcXCIjXCIgKyBuYW1lICsgXCJcXFwiIGlzIGRlZmluZWQgc2V2ZXJhbCB0aW1lc1wiLCByZWZlcmVuY2Uuc291cmNlU3BhbiwgZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRkFUQUwpO1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IH0pO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFRlbXBsYXRlUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuICAgICAgICAgIHsgdHlwZTogSTE4Tkh0bWxQYXJzZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBDb25zb2xlLCB9LFxuICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW1RFTVBMQVRFX1RSQU5TRk9STVMsXSB9LF0gfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gVGVtcGxhdGVQYXJzZXI7XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZVBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlVmlzaXRvcihwcm92aWRlclZpZXdDb250ZXh0LCBkaXJlY3RpdmVzLCBfYmluZGluZ1BhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfc2NoZW1hcywgX3RhcmdldEVycm9ycykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5wcm92aWRlclZpZXdDb250ZXh0ID0gcHJvdmlkZXJWaWV3Q29udGV4dDtcbiAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyID0gX2JpbmRpbmdQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hcyA9IF9zY2hlbWFzO1xuICAgICAgICAgIHRoaXMuX3RhcmdldEVycm9ycyA9IF90YXJnZXRFcnJvcnM7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmVzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRDb3VudCA9IDA7XG4gICAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IENzc1NlbGVjdG9yLnBhcnNlKGRpcmVjdGl2ZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICAgIF90aGlzLnNlbGVjdG9yTWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhzZWxlY3RvciwgZGlyZWN0aXZlKTtcbiAgICAgICAgICAgICAgX3RoaXMuZGlyZWN0aXZlc0luZGV4LnNldChkaXJlY3RpdmUsIGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpO1xuICAgICAgICAgIHZhciBleHByID0gdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRUZXh0QXN0KGV4cHIsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXN0KHRleHQudmFsdWUsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5uYW1lO1xuICAgICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFKSB7XG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCAmJlxuICAgICAgICAgICAgICBpc1N0eWxlVXJsUmVzb2x2YWJsZShwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKSkge1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZyBzdHlsZXNoZWV0cyB3aXRoIGVpdGhlciByZWxhdGl2ZSB1cmxzIG9yIHBhY2thZ2Ugc2NoZW1lIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgIC8vIHRoZW0gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtYXRjaGFibGVBdHRycyA9IFtdO1xuICAgICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVSZWZzID0gW107XG4gICAgICAgICAgdmFyIGVsZW1lbnRWYXJzID0gW107XG4gICAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgICAgdmFyIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50VmFycyA9IFtdO1xuICAgICAgICAgIHZhciBoYXNJbmxpbmVUZW1wbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgICAgICB2YXIgbGNFbE5hbWUgPSBzcGxpdE5zTmFtZShub2RlTmFtZS50b0xvd2VyQ2FzZSgpKVsxXTtcbiAgICAgICAgICB2YXIgaXNUZW1wbGF0ZUVsZW1lbnQgPSBsY0VsTmFtZSA9PSBURU1QTEFURV9FTEVNRU5UO1xuICAgICAgICAgIGVsZW1lbnQuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICB2YXIgaGFzQmluZGluZyA9IF90aGlzLl9wYXJzZUF0dHIoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIG1hdGNoYWJsZUF0dHJzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZXZlbnRzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50VmFycyk7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgcHJlZml4VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpID09IFRFTVBMQVRFX0FUVFIpIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICBwcmVmaXhUb2tlbiA9IGF0dHIubmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKTsgLy8gcmVtb3ZlIHRoZSBzdGFyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGhhc1RlbXBsYXRlQmluZGluZyA9IGlzUHJlc2VudCh0ZW1wbGF0ZUJpbmRpbmdzU291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKGhhc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIkNhbid0IGhhdmUgbXVsdGlwbGUgdGVtcGxhdGUgYmluZGluZ3Mgb24gb25lIGVsZW1lbnQuIFVzZSBvbmx5IG9uZSBhdHRyaWJ1dGUgbmFtZWQgJ3RlbXBsYXRlJyBvciBwcmVmaXhlZCB3aXRoICpcIiwgYXR0ci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGhhc0lubGluZVRlbXBsYXRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyhhdHRyLm5hbWUsIHByZWZpeFRva2VuLCB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlLCBhdHRyLnNvdXJjZVNwYW4sIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICBtYXRjaGFibGVBdHRycy5wdXNoKFthdHRyLm5hbWUsIGF0dHIudmFsdWVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBlbGVtZW50Q3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3Iobm9kZU5hbWUsIG1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3RvciksIGRpcmVjdGl2ZU1ldGFzID0gX2EuZGlyZWN0aXZlcywgbWF0Y2hFbGVtZW50ID0gX2EubWF0Y2hFbGVtZW50O1xuICAgICAgICAgIHZhciByZWZlcmVuY2VzID0gW107XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKGlzVGVtcGxhdGVFbGVtZW50LCBlbGVtZW50Lm5hbWUsIGRpcmVjdGl2ZU1ldGFzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudC5zb3VyY2VTcGFuLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBkaXJlY3RpdmVBc3RzKTtcbiAgICAgICAgICB2YXIgaXNWaWV3Um9vdCA9IHBhcmVudC5pc1RlbXBsYXRlRWxlbWVudCB8fCBoYXNJbmxpbmVUZW1wbGF0ZXM7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyQ29udGV4dCA9IG5ldyBQcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgaXNWaWV3Um9vdCwgZGlyZWN0aXZlQXN0cywgYXR0cnMsIHJlZmVyZW5jZXMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gdmlzaXRBbGwocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSA/IE5PTl9CSU5EQUJMRV9WSVNJVE9SIDogdGhpcywgZWxlbWVudC5jaGlsZHJlbiwgRWxlbWVudENvbnRleHQuY3JlYXRlKGlzVGVtcGxhdGVFbGVtZW50LCBkaXJlY3RpdmVBc3RzLCBpc1RlbXBsYXRlRWxlbWVudCA/IHBhcmVudC5wcm92aWRlckNvbnRleHQgOiBwcm92aWRlckNvbnRleHQpKTtcbiAgICAgICAgICBwcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGFjdHVhbCBzZWxlY3RvciB3aGVuIHRoZSBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZSBpcyBwcm92aWRlZFxuICAgICAgICAgIHZhciBwcm9qZWN0aW9uU2VsZWN0b3IgPSBpc1ByZXNlbnQocHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMpID9cbiAgICAgICAgICAgICAgQ3NzU2VsZWN0b3IucGFyc2UocHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMpWzBdIDpcbiAgICAgICAgICAgICAgZWxlbWVudENzc1NlbGVjdG9yO1xuICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgICB2YXIgcGFyc2VkRWxlbWVudDtcbiAgICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICYmICFlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KF9pc0VtcHR5VGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIjxuZy1jb250ZW50PiBlbGVtZW50IGNhbm5vdCBoYXZlIGNvbnRlbnQuXCIsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBOZ0NvbnRlbnRBc3QodGhpcy5uZ0NvbnRlbnRDb3VudCsrLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Fzc2VydEFsbEV2ZW50c1B1Ymxpc2hlZEJ5RGlyZWN0aXZlcyhkaXJlY3RpdmVBc3RzLCBldmVudHMpO1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKGRpcmVjdGl2ZUFzdHMsIGVsZW1lbnRQcm9wcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBldmVudHMsIHJlZmVyZW5jZXMsIGVsZW1lbnRWYXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fYXNzZXJ0RWxlbWVudEV4aXN0cyhtYXRjaEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50KGRpcmVjdGl2ZUFzdHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleF8xID0gaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50QXN0KG5vZGVOYW1lLCBhdHRycywgZWxlbWVudFByb3BzLCBldmVudHMsIHJlZmVyZW5jZXMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXhfMSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyhkaXJlY3RpdmVBc3RzKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudERpcmVjdGl2ZUFzdCkgeyByZXR1cm4gX3RoaXMuX3ZhbGlkYXRlRWxlbWVudEFuaW1hdGlvbklucHV0T3V0cHV0cyhjb21wb25lbnREaXJlY3RpdmVBc3QuaG9zdFByb3BlcnRpZXMsIGNvbXBvbmVudERpcmVjdGl2ZUFzdC5ob3N0RXZlbnRzLCBjb21wb25lbnREaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnRlbXBsYXRlKTsgfSk7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRUZW1wbGF0ZSA9IHByb3ZpZGVyQ29udGV4dC52aWV3Q29udGV4dC5jb21wb25lbnQudGVtcGxhdGU7XG4gICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlRWxlbWVudEFuaW1hdGlvbklucHV0T3V0cHV0cyhlbGVtZW50UHJvcHMsIGV2ZW50cywgY29tcG9uZW50VGVtcGxhdGUudG9TdW1tYXJ5KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzSW5saW5lVGVtcGxhdGVzKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUNzc1NlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKFRFTVBMQVRFX0VMRU1FTlQsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVNZXRhcyA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgdGVtcGxhdGVDc3NTZWxlY3RvcikuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHModHJ1ZSwgZWxlbWVudC5uYW1lLCB0ZW1wbGF0ZURpcmVjdGl2ZU1ldGFzLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBbXSwgZWxlbWVudC5zb3VyY2VTcGFuLCBbXSk7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRQcm9wcyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMoZWxlbWVudC5uYW1lLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMpO1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVFbGVtZW50UHJvcHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dCA9IG5ldyBQcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50LCB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMsIFtdLCBbXSwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdGVtcGxhdGVQcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRW1iZWRkZWRUZW1wbGF0ZUFzdChbXSwgW10sIFtdLCB0ZW1wbGF0ZUVsZW1lbnRWYXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBbcGFyc2VkRWxlbWVudF0sIG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyc2VkRWxlbWVudDtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlRWxlbWVudEFuaW1hdGlvbklucHV0T3V0cHV0cyA9IGZ1bmN0aW9uIChpbnB1dHMsIG91dHB1dHMsIHRlbXBsYXRlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdHJpZ2dlckxvb2t1cCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0ZW1wbGF0ZS5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHRyaWdnZXJMb29rdXAuYWRkKGVudHJ5KTsgfSk7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbklucHV0cyA9IGlucHV0cy5maWx0ZXIoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5pc0FuaW1hdGlvbjsgfSk7XG4gICAgICAgICAgYW5pbWF0aW9uSW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gaW5wdXQubmFtZTtcbiAgICAgICAgICAgICAgaWYgKCF0cmlnZ2VyTG9va3VwLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbiBhbmltYXRpb24gZW50cnkgZm9yIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgaW5wdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgICAgICBpZiAob3V0cHV0LmlzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBhbmltYXRpb25JbnB1dHMuZmluZChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0Lm5hbWUgPT0gb3V0cHV0Lm5hbWU7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlVuYWJsZSB0byBsaXN0ZW4gb24gKEBcIiArIG91dHB1dC5uYW1lICsgXCIuXCIgKyBvdXRwdXQucGhhc2UgKyBcIikgYmVjYXVzZSB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgW0BcIiArIG91dHB1dC5uYW1lICsgXCJdIGlzbid0IGJlaW5nIHVzZWQgb24gdGhlIHNhbWUgZWxlbWVudFwiLCBvdXRwdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXR0ciA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgYXR0ciwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRFdmVudHMsIHRhcmdldFJlZnMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIHZhciBzcmNTcGFuID0gYXR0ci5zb3VyY2VTcGFuO1xuICAgICAgICAgIHZhciBiaW5kUGFydHMgPSBuYW1lLm1hdGNoKEJJTkRfTkFNRV9SRUdFWFApO1xuICAgICAgICAgIHZhciBoYXNCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGJpbmRQYXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBoYXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChiaW5kUGFydHNbS1dfQklORF9JRFhdKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19MRVRfSURYXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVZhcmlhYmxlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRWYXJzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcImxldC1cXFwiIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHRlbXBsYXRlIGVsZW1lbnRzLlwiLCBzcmNTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfUkVGX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0UmVmcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX09OX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19CSU5ET05fSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQVRfSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VFdmVudChiaW5kUGFydHNbSURFTlRfRVZFTlRfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBoYXNCaW5kaW5nID0gdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFoYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VMaXRlcmFsQXR0cihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhhc0JpbmRpbmc7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIC9eZGF0YS0vaS50ZXN0KGF0dHJOYW1lKSA/IGF0dHJOYW1lLnN1YnN0cmluZyg1KSA6IGF0dHJOYW1lO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VWYXJpYWJsZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0VmFycykge1xuICAgICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHZhcmlhYmxlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0UmVmcykge1xuICAgICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHJlZmVyZW5jZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0UmVmcy5wdXNoKG5ldyBFbGVtZW50T3JEaXJlY3RpdmVSZWYoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXNzaWdubWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIE5lZWQgdG8gc29ydCB0aGUgZGlyZWN0aXZlcyBzbyB0aGF0IHdlIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgdGhyb3VnaG91dCxcbiAgICAgICAgICAvLyBhcyBzZWxlY3Rvck1hdGNoZXIgdXNlcyBNYXBzIGluc2lkZS5cbiAgICAgICAgICAvLyBBbHNvIGRlZHVwbGljYXRlIGRpcmVjdGl2ZXMgYXMgdGhleSBtaWdodCBtYXRjaCBtb3JlIHRoYW4gb25lIHRpbWUhXG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBuZXcgQXJyYXkodGhpcy5kaXJlY3RpdmVzSW5kZXguc2l6ZSk7XG4gICAgICAgICAgLy8gV2hldGhlciBhbnkgZGlyZWN0aXZlIHNlbGVjdG9yIG1hdGNoZXMgb24gdGhlIGVsZW1lbnQgbmFtZVxuICAgICAgICAgIHZhciBtYXRjaEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICBzZWxlY3Rvck1hdGNoZXIubWF0Y2goZWxlbWVudENzc1NlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVzW190aGlzLmRpcmVjdGl2ZXNJbmRleC5nZXQoZGlyZWN0aXZlKV0gPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICAgIG1hdGNoRWxlbWVudCA9IG1hdGNoRWxlbWVudCB8fCBzZWxlY3Rvci5oYXNFbGVtZW50U2VsZWN0b3IoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAhIWRpcjsgfSksXG4gICAgICAgICAgICAgIG1hdGNoRWxlbWVudDogbWF0Y2hFbGVtZW50LFxuICAgICAgICAgIH07XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVBc3RzID0gZnVuY3Rpb24gKGlzVGVtcGxhdGVFbGVtZW50LCBlbGVtZW50TmFtZSwgZGlyZWN0aXZlcywgcHJvcHMsIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMsIGVsZW1lbnRTb3VyY2VTcGFuLCB0YXJnZXRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbWF0Y2hlZFJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSBkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihlbGVtZW50U291cmNlU3Bhbi5zdGFydCwgZWxlbWVudFNvdXJjZVNwYW4uZW5kLCBcIkRpcmVjdGl2ZSBcIiArIGRpcmVjdGl2ZS50eXBlLm5hbWUpO1xuICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZVByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGhvc3RQcm9wZXJ0aWVzID0gX3RoaXMuX2JpbmRpbmdQYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyhkaXJlY3RpdmUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNoZWNrIHRoZSBob3N0IHByb3BlcnRpZXMgaGVyZSBhcyB3ZWxsLFxuICAgICAgICAgICAgICAvLyBhcyB3ZSBkb24ndCBrbm93IHRoZSBlbGVtZW50IG5hbWUgaW4gdGhlIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlciB5ZXQuXG4gICAgICAgICAgICAgIF90aGlzLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYShlbGVtZW50TmFtZSwgaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICB2YXIgaG9zdEV2ZW50cyA9IF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyhkaXJlY3RpdmUuaW5wdXRzLCBwcm9wcywgZGlyZWN0aXZlUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZWxPckRpclJlZikge1xuICAgICAgICAgICAgICAgICAgaWYgKChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA9PT0gMCAmJiBkaXJlY3RpdmUuaXNDb21wb25lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGRpcmVjdGl2ZS5leHBvcnRBcyA9PSBlbE9yRGlyUmVmLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFJlZmVyZW5jZXMucHVzaChuZXcgUmVmZXJlbmNlQXN0KGVsT3JEaXJSZWYubmFtZSwgaWRlbnRpZmllclRva2VuKGRpcmVjdGl2ZS50eXBlKSwgZWxPckRpclJlZi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFJlZmVyZW5jZXMuYWRkKGVsT3JEaXJSZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IERpcmVjdGl2ZUFzdChkaXJlY3RpdmUsIGRpcmVjdGl2ZVByb3BlcnRpZXMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgICAgaWYgKGVsT3JEaXJSZWYudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkUmVmZXJlbmNlcy5oYXMoZWxPckRpclJlZi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZXJlIGlzIG5vIGRpcmVjdGl2ZSB3aXRoIFxcXCJleHBvcnRBc1xcXCIgc2V0IHRvIFxcXCJcIiArIGVsT3JEaXJSZWYudmFsdWUgKyBcIlxcXCJcIiwgZWxPckRpclJlZi5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVmVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVmVG9rZW4gPSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRhcmdldFJlZmVyZW5jZXMucHVzaChuZXcgUmVmZXJlbmNlQXN0KGVsT3JEaXJSZWYubmFtZSwgcmVmVG9rZW4sIGVsT3JEaXJSZWYuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nIGlzc3VlOiBgXG4gICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZUFzdHM7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUHJvcGVydGllcywgYm91bmRQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcykge1xuICAgICAgICAgIGlmIChkaXJlY3RpdmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIHZhciBib3VuZFByb3BzQnlOYW1lXzEgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gYm91bmRQcm9wc0J5TmFtZV8xLmdldChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXByZXZWYWx1ZSB8fCBwcmV2VmFsdWUuaXNMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZSBbYV09XCJiXCIgYSBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIGE9XCJiXCIgb24gdGhlIHNhbWUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWVfMS5zZXQoYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVQcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZWxQcm9wID0gZGlyZWN0aXZlUHJvcGVydGllc1tkaXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgIHZhciBib3VuZFByb3AgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGVsUHJvcCk7XG4gICAgICAgICAgICAgICAgICAvLyBCaW5kaW5ncyBhcmUgb3B0aW9uYWwsIHNvIHRoaXMgYmluZGluZyBvbmx5IG5lZWRzIHRvIGJlIHNldCB1cCBpZiBhbiBleHByZXNzaW9uIGlzIGdpdmVuLlxuICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcHMucHVzaChuZXcgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdChkaXJQcm9wLCBib3VuZFByb3AubmFtZSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIGJvdW5kUHJvcC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHByb3BzLCBkaXJlY3RpdmVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYm91bmRFbGVtZW50UHJvcHMgPSBbXTtcbiAgICAgICAgICB2YXIgYm91bmREaXJlY3RpdmVQcm9wc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZS5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgYm91bmREaXJlY3RpdmVQcm9wc0luZGV4LnNldChwcm9wLnRlbXBsYXRlTmFtZSwgcHJvcCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKCFwcm9wLmlzTGl0ZXJhbCAmJiAhYm91bmREaXJlY3RpdmVQcm9wc0luZGV4LmdldChwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZEVsZW1lbnRQcm9wcy5wdXNoKF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50TmFtZSwgcHJvcCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEoZWxlbWVudE5hbWUsIGJvdW5kRWxlbWVudFByb3BzKTtcbiAgICAgICAgICByZXR1cm4gYm91bmRFbGVtZW50UHJvcHM7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzKSB7XG4gICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZXMoZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuZGlyZWN0aXZlLnR5cGUubmFtZTsgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50ID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICAgIGlmIChjb21wb25lbnRUeXBlTmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIk1vcmUgdGhhbiBvbmUgY29tcG9uZW50IG1hdGNoZWQgb24gdGhpcyBlbGVtZW50LlxcblwiICtcbiAgICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRoYXQgb25seSBvbmUgY29tcG9uZW50J3Mgc2VsZWN0b3IgY2FuIG1hdGNoIGEgZ2l2ZW4gZWxlbWVudC5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAoXCJDb25mbGljdGluZyBjb21wb25lbnRzOiBcIiArIGNvbXBvbmVudFR5cGVOYW1lcy5qb2luKCcsJykpLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBNYWtlIHN1cmUgdGhhdCBub24tYW5ndWxhciB0YWdzIGNvbmZvcm0gdG8gdGhlIHNjaGVtYXMuXG4gICAgICAgKlxuICAgICAgICogTm90ZTogQW4gZWxlbWVudCBpcyBjb25zaWRlcmVkIGFuIGFuZ3VsYXIgdGFnIHdoZW4gYXQgbGVhc3Qgb25lIGRpcmVjdGl2ZSBzZWxlY3RvciBtYXRjaGVzIHRoZVxuICAgICAgICogdGFnIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIG1hdGNoRWxlbWVudCBXaGV0aGVyIGFueSBkaXJlY3RpdmUgaGFzIG1hdGNoZWQgb24gdGhlIHRhZyBuYW1lXG4gICAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgaHRtbCBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0RWxlbWVudEV4aXN0cyA9IGZ1bmN0aW9uIChtYXRjaEVsZW1lbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgZWxOYW1lID0gZWxlbWVudC5uYW1lLnJlcGxhY2UoL146eGh0bWw6LywgJycpO1xuICAgICAgICAgIGlmICghbWF0Y2hFbGVtZW50ICYmICF0aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNFbGVtZW50KGVsTmFtZSwgdGhpcy5fc2NoZW1hcykpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yTXNnID0gKFwiJ1wiICsgZWxOYW1lICsgXCInIGlzIG5vdCBhIGtub3duIGVsZW1lbnQ6XFxuXCIpICtcbiAgICAgICAgICAgICAgICAgIChcIjEuIElmICdcIiArIGVsTmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGNvbXBvbmVudCwgdGhlbiB2ZXJpZnkgdGhhdCBpdCBpcyBwYXJ0IG9mIHRoaXMgbW9kdWxlLlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAoXCIyLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkIFxcXCJDVVNUT01fRUxFTUVOVFNfU0NIRU1BXFxcIiB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXCIpO1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvck1zZywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGVsZW1lbnRQcm9wcywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVOYW1lcyA9IHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVOYW1lcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJDb21wb25lbnRzIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlOiBcIiArIGNvbXBvbmVudFR5cGVOYW1lcy5qb2luKCcsJyksIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50UHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJQcm9wZXJ0eSBiaW5kaW5nIFwiICsgcHJvcC5uYW1lICsgXCIgbm90IHVzZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3BlcnR5IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJkaXJlY3RpdmVzXFxcIiBzZWN0aW9uLlwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydEFsbEV2ZW50c1B1Ymxpc2hlZEJ5RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBldmVudHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBhbGxEaXJlY3RpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyZWN0aXZlLmRpcmVjdGl2ZS5vdXRwdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZGlyZWN0aXZlLmRpcmVjdGl2ZS5vdXRwdXRzW2tdO1xuICAgICAgICAgICAgICAgICAgYWxsRGlyZWN0aXZlRXZlbnRzLmFkZChldmVudE5hbWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChldmVudC50YXJnZXQpIHx8ICFhbGxEaXJlY3RpdmVFdmVudHMuaGFzKGV2ZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJFdmVudCBiaW5kaW5nIFwiICsgZXZlbnQuZnVsbE5hbWUgKyBcIiBub3QgZW1pdHRlZCBieSBhbnkgZGlyZWN0aXZlIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlLiBNYWtlIHN1cmUgdGhhdCB0aGUgZXZlbnQgbmFtZSBpcyBzcGVsbGVkIGNvcnJlY3RseSBhbmQgYWxsIGRpcmVjdGl2ZXMgYXJlIGxpc3RlZCBpbiB0aGUgXFxcImRpcmVjdGl2ZXNcXFwiIHNlY3Rpb24uXCIsIGV2ZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgYm91bmRQcm9wcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKGJvdW5kUHJvcC50eXBlID09PSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHkgJiZcbiAgICAgICAgICAgICAgICAgICFfdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzUHJvcGVydHkoZWxlbWVudE5hbWUsIGJvdW5kUHJvcC5uYW1lLCBfdGhpcy5fc2NoZW1hcykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IFwiQ2FuJ3QgYmluZCB0byAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBzaW5jZSBpdCBpc24ndCBhIGtub3duIHByb3BlcnR5IG9mICdcIiArIGVsZW1lbnROYW1lICsgXCInLlwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnROYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMS4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQgYW5kIGl0IGhhcyAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBpbnB1dCwgdGhlbiB2ZXJpZnkgdGhhdCBpdCBpcyBwYXJ0IG9mIHRoaXMgbW9kdWxlLlwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcXG4yLiBJZiAnXCIgKyBlbGVtZW50TmFtZSArIFwiJyBpcyBhIFdlYiBDb21wb25lbnQgdGhlbiBhZGQgXFxcIkNVU1RPTV9FTEVNRU5UU19TQ0hFTUFcXFwiIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50IHRvIHN1cHByZXNzIHRoaXMgbWVzc2FnZS5cXG5cIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMOyB9XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFBhcnNlRXJyb3Ioc291cmNlU3BhbiwgbWVzc2FnZSwgbGV2ZWwpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVZpc2l0b3I7XG4gIH0oKSk7XG4gIHZhciBOb25CaW5kYWJsZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTm9uQmluZGFibGVWaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChhc3QpO1xuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFIHx8XG4gICAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCkge1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFuZCBzdHlsZXNoZWV0cyBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGVtXG4gICAgICAgICAgICAgIC8vIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXR0ck5hbWVBbmRWYWx1ZXMgPSBhc3QuYXR0cnMubWFwKGZ1bmN0aW9uIChhdHRyQXN0KSB7IHJldHVybiBbYXR0ckFzdC5uYW1lLCBhdHRyQXN0LnZhbHVlXTsgfSk7XG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGFzdC5uYW1lLCBhdHRyTmFtZUFuZFZhbHVlcyk7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChzZWxlY3Rvcik7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBFTVBUWV9FTEVNRU5UX0NPTlRFWFQpO1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudEFzdChhc3QubmFtZSwgdmlzaXRBbGwodGhpcywgYXN0LmF0dHJzKSwgW10sIFtdLCBbXSwgW10sIFtdLCBmYWxzZSwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBhc3Quc291cmNlU3BhbiwgYXN0LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQXR0ckFzdChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXN0KHRleHQudmFsdWUsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IHJldHVybiBleHBhbnNpb247IH07XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IHJldHVybiBleHBhbnNpb25DYXNlOyB9O1xuICAgICAgcmV0dXJuIE5vbkJpbmRhYmxlVmlzaXRvcjtcbiAgfSgpKTtcbiAgdmFyIEVsZW1lbnRPckRpcmVjdGl2ZVJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbGVtZW50T3JEaXJlY3RpdmVSZWYobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEVsZW1lbnRPckRpcmVjdGl2ZVJlZjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzQXR0clZhbHVlKSB7XG4gICAgICByZXR1cm4gY2xhc3NBdHRyVmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xuICB9XG4gIHZhciBFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbGVtZW50Q29udGV4dChpc1RlbXBsYXRlRWxlbWVudCwgX25nQ29udGVudEluZGV4TWF0Y2hlciwgX3dpbGRjYXJkTmdDb250ZW50SW5kZXgsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICAgIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIgPSBfbmdDb250ZW50SW5kZXhNYXRjaGVyO1xuICAgICAgICAgIHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXggPSBfd2lsZGNhcmROZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVyQ29udGV4dCA9IHByb3ZpZGVyQ29udGV4dDtcbiAgICAgIH1cbiAgICAgIEVsZW1lbnRDb250ZXh0LmNyZWF0ZSA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgZGlyZWN0aXZlcywgcHJvdmlkZXJDb250ZXh0KSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgICAgdmFyIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBudWxsO1xuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB2YXIgbmdDb250ZW50U2VsZWN0b3JzID0gY29tcG9uZW50LmRpcmVjdGl2ZS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnM7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBuZ0NvbnRlbnRTZWxlY3RvcnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhDc3NTZWxlY3Rvci5wYXJzZShuZ0NvbnRlbnRTZWxlY3RvcnNbaV0pLCBpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRDb250ZXh0KGlzVGVtcGxhdGVFbGVtZW50LCBtYXRjaGVyLCB3aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIEVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5maW5kTmdDb250ZW50SW5kZXggPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgbmdDb250ZW50SW5kaWNlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX25nQ29udGVudEluZGV4TWF0Y2hlci5tYXRjaChzZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBuZ0NvbnRlbnRJbmRleCkgeyBuZ0NvbnRlbnRJbmRpY2VzLnB1c2gobmdDb250ZW50SW5kZXgpOyB9KTtcbiAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnNvcnQoKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgIG5nQ29udGVudEluZGljZXMucHVzaCh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5nQ29udGVudEluZGljZXMubGVuZ3RoID4gMCA/IG5nQ29udGVudEluZGljZXNbMF0gOiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBFbGVtZW50Q29udGV4dDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGVsZW1lbnROYW1lLCBtYXRjaGFibGVBdHRycykge1xuICAgICAgdmFyIGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICB2YXIgZWxOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKVsxXTtcbiAgICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxOYW1lTm9Ocyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoYWJsZUF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHJOYW1lID0gbWF0Y2hhYmxlQXR0cnNbaV1bMF07XG4gICAgICAgICAgdmFyIGF0dHJOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGF0dHJOYW1lKVsxXTtcbiAgICAgICAgICB2YXIgYXR0clZhbHVlID0gbWF0Y2hhYmxlQXR0cnNbaV1bMV07XG4gICAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKGF0dHJOYW1lTm9OcywgYXR0clZhbHVlKTtcbiAgICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PSBDTEFTU19BVFRSKSB7XG4gICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc3BsaXRDbGFzc2VzKGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBjc3NTZWxlY3Rvci5hZGRDbGFzc05hbWUoY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xuICB9XG4gIHZhciBFTVBUWV9FTEVNRU5UX0NPTlRFWFQgPSBuZXcgRWxlbWVudENvbnRleHQodHJ1ZSwgbmV3IFNlbGVjdG9yTWF0Y2hlcigpLCBudWxsLCBudWxsKTtcbiAgdmFyIE5PTl9CSU5EQUJMRV9WSVNJVE9SID0gbmV3IE5vbkJpbmRhYmxlVmlzaXRvcigpO1xuICBmdW5jdGlvbiBfaXNFbXB0eVRleHROb2RlKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCAmJiBub2RlLnZhbHVlLnRyaW0oKS5sZW5ndGggPT0gMDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyhpdGVtcykge1xuICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoIW1hcC5nZXQoaXRlbS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgbWFwLnNldChpdGVtLnR5cGUucmVmZXJlbmNlLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmltcGxlbWVudGVkJDEoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgfVxuICB2YXIgQ29tcGlsZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZXJDb25maWcoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5yZW5kZXJUeXBlcywgcmVuZGVyVHlwZXMgPSBfYyA9PT0gdm9pZCAwID8gbmV3IERlZmF1bHRSZW5kZXJUeXBlcygpIDogX2MsIF9kID0gX2IuZGVmYXVsdEVuY2Fwc3VsYXRpb24sIGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gX2QgPT09IHZvaWQgMCA/IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgOiBfZCwgZ2VuRGVidWdJbmZvID0gX2IuZ2VuRGVidWdJbmZvLCBsb2dCaW5kaW5nVXBkYXRlID0gX2IubG9nQmluZGluZ1VwZGF0ZSwgX2UgPSBfYi51c2VKaXQsIHVzZUppdCA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2U7XG4gICAgICAgICAgdGhpcy5yZW5kZXJUeXBlcyA9IHJlbmRlclR5cGVzO1xuICAgICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICB0aGlzLl9nZW5EZWJ1Z0luZm8gPSBnZW5EZWJ1Z0luZm87XG4gICAgICAgICAgdGhpcy5fbG9nQmluZGluZ1VwZGF0ZSA9IGxvZ0JpbmRpbmdVcGRhdGU7XG4gICAgICAgICAgdGhpcy51c2VKaXQgPSB1c2VKaXQ7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZXJDb25maWcucHJvdG90eXBlLCBcImdlbkRlYnVnSW5mb1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5EZWJ1Z0luZm8gPT09IHZvaWQgMCA/IF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkgOiB0aGlzLl9nZW5EZWJ1Z0luZm87XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZXJDb25maWcucHJvdG90eXBlLCBcImxvZ0JpbmRpbmdVcGRhdGVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nQmluZGluZ1VwZGF0ZSA9PT0gdm9pZCAwID8gX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSA6IHRoaXMuX2xvZ0JpbmRpbmdVcGRhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tcGlsZXJDb25maWc7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBUeXBlcyB1c2VkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIENhbiBiZSByZXBsYWNlZCB0byBzcGVjaWFsaXplIHRoZSBnZW5lcmF0ZWQgb3V0cHV0IHRvIGEgc3BlY2lmaWMgcmVuZGVyZXJcbiAgICogdG8gaGVscCB0cmVlIHNoYWtpbmcuXG4gICAqL1xuICB2YXIgUmVuZGVyVHlwZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVuZGVyVHlwZXMoKSB7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyVGV4dFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkJDEoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCQxKCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJDb21tZW50XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyTm9kZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkJDEoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckV2ZW50XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZW5kZXJUeXBlcztcbiAgfSgpKTtcbiAgdmFyIERlZmF1bHRSZW5kZXJUeXBlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEZWZhdWx0UmVuZGVyVHlwZXMoKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJUZXh0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVuZGVyQ29tbWVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0UmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlbmRlcmVyKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICA7XG4gICAgICByZXR1cm4gRGVmYXVsdFJlbmRlclR5cGVzO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLy8vLyBUeXBlc1xuICB2YXIgVHlwZU1vZGlmaWVyO1xuICAoZnVuY3Rpb24gKFR5cGVNb2RpZmllcikge1xuICAgICAgVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllcltcIkNvbnN0XCJdID0gMF0gPSBcIkNvbnN0XCI7XG4gIH0pKFR5cGVNb2RpZmllciB8fCAoVHlwZU1vZGlmaWVyID0ge30pKTtcbiAgdmFyIFR5cGUkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUeXBlKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBUeXBlLnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgICAgcmV0dXJuIFR5cGU7XG4gIH0oKSk7XG4gIHZhciBCdWlsdGluVHlwZU5hbWU7XG4gIChmdW5jdGlvbiAoQnVpbHRpblR5cGVOYW1lKSB7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRHluYW1pY1wiXSA9IDBdID0gXCJEeW5hbWljXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiQm9vbFwiXSA9IDFdID0gXCJCb29sXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiU3RyaW5nXCJdID0gMl0gPSBcIlN0cmluZ1wiO1xuICAgICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkludFwiXSA9IDNdID0gXCJJbnRcIjtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOdW1iZXJcIl0gPSA0XSA9IFwiTnVtYmVyXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRnVuY3Rpb25cIl0gPSA1XSA9IFwiRnVuY3Rpb25cIjtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOdWxsXCJdID0gNl0gPSBcIk51bGxcIjtcbiAgfSkoQnVpbHRpblR5cGVOYW1lIHx8IChCdWlsdGluVHlwZU5hbWUgPSB7fSkpO1xuICB2YXIgQnVpbHRpblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEJ1aWx0aW5UeXBlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQnVpbHRpblR5cGUobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBCdWlsdGluVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJ1aWx0aW50VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQnVpbHRpblR5cGU7XG4gIH0oVHlwZSQxKSk7XG4gIHZhciBFeHRlcm5hbFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEV4dGVybmFsVHlwZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEV4dGVybmFsVHlwZSh2YWx1ZSwgdHlwZVBhcmFtcywgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICAgIH1cbiAgICAgIEV4dGVybmFsVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRXh0ZXJuYWxUeXBlO1xuICB9KFR5cGUkMSkpO1xuICB2YXIgQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBcnJheVR5cGUob2YsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm9mID0gb2Y7XG4gICAgICB9XG4gICAgICBBcnJheVR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheVR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFycmF5VHlwZTtcbiAgfShUeXBlJDEpKTtcbiAgdmFyIE1hcFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKE1hcFR5cGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBNYXBUeXBlKHZhbHVlVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICAgICAgfVxuICAgICAgTWFwVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRNYXBUeXBlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIE1hcFR5cGU7XG4gIH0oVHlwZSQxKSk7XG4gIHZhciBEWU5BTUlDX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkR5bmFtaWMpO1xuICB2YXIgQk9PTF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Cb29sKTtcbiAgdmFyIElOVF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5JbnQpO1xuICB2YXIgTlVNQkVSX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLk51bWJlcik7XG4gIHZhciBTVFJJTkdfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuU3RyaW5nKTtcbiAgdmFyIEZVTkNUSU9OX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uKTtcbiAgdmFyIE5VTExfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuTnVsbCk7XG4gIC8vLy8vIEV4cHJlc3Npb25zXG4gIHZhciBCaW5hcnlPcGVyYXRvcjtcbiAgKGZ1bmN0aW9uIChCaW5hcnlPcGVyYXRvcikge1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJFcXVhbHNcIl0gPSAwXSA9IFwiRXF1YWxzXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk5vdEVxdWFsc1wiXSA9IDFdID0gXCJOb3RFcXVhbHNcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiSWRlbnRpY2FsXCJdID0gMl0gPSBcIklkZW50aWNhbFwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RJZGVudGljYWxcIl0gPSAzXSA9IFwiTm90SWRlbnRpY2FsXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk1pbnVzXCJdID0gNF0gPSBcIk1pbnVzXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIlBsdXNcIl0gPSA1XSA9IFwiUGx1c1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJEaXZpZGVcIl0gPSA2XSA9IFwiRGl2aWRlXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk11bHRpcGx5XCJdID0gN10gPSBcIk11bHRpcGx5XCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk1vZHVsb1wiXSA9IDhdID0gXCJNb2R1bG9cIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQW5kXCJdID0gOV0gPSBcIkFuZFwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJPclwiXSA9IDEwXSA9IFwiT3JcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTG93ZXJcIl0gPSAxMV0gPSBcIkxvd2VyXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyRXF1YWxzXCJdID0gMTJdID0gXCJMb3dlckVxdWFsc1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaWdnZXJcIl0gPSAxM10gPSBcIkJpZ2dlclwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaWdnZXJFcXVhbHNcIl0gPSAxNF0gPSBcIkJpZ2dlckVxdWFsc1wiO1xuICB9KShCaW5hcnlPcGVyYXRvciB8fCAoQmluYXJ5T3BlcmF0b3IgPSB7fSkpO1xuICB2YXIgRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHByZXNzaW9uKHR5cGUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUpOyB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24gKGluZGV4LCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIodGhpcywgaW5kZXgsIHR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhbGxNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VNZXRob2RFeHByKHRoaXMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbEZuID0gZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gbmV3IEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBwYXJhbXMpOyB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocGFyYW1zLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgSW5zdGFudGlhdGVFeHByKHRoaXMsIHBhcmFtcywgdHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uZGl0aW9uYWwgPSBmdW5jdGlvbiAodHJ1ZUNhc2UsIGZhbHNlQ2FzZSkge1xuICAgICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIodGhpcywgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlkZW50aWNhbCA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5JZGVudGljYWwsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubm90SWRlbnRpY2FsID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5taW51cyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5wbHVzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLlBsdXMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTW9kdWxvLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuT3IsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXIgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXIsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYmlnZ2VyID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlciwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gTm90ZTogV2UgdXNlIGVxdWFscyBieSBwdXJwb3NlIGhlcmUgdG8gY29tcGFyZSB0byBudWxsIGFuZCB1bmRlZmluZWQgaW4gSlMuXG4gICAgICAgICAgLy8gV2UgdXNlIHRoZSB0eXBlZCBudWxsIHRvIGFsbG93IHN0cmljdE51bGxDaGVja3MgdG8gbmFycm93IHR5cGVzLlxuICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhUWVBFRF9OVUxMX0VYUFIpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gbmV3IENhc3RFeHByKHRoaXMsIHR5cGUpOyB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdG10ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcyk7IH07XG4gICAgICByZXR1cm4gRXhwcmVzc2lvbjtcbiAgfSgpKTtcbiAgdmFyIEJ1aWx0aW5WYXI7XG4gIChmdW5jdGlvbiAoQnVpbHRpblZhcikge1xuICAgICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiVGhpc1wiXSA9IDBdID0gXCJUaGlzXCI7XG4gICAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJTdXBlclwiXSA9IDFdID0gXCJTdXBlclwiO1xuICAgICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiQ2F0Y2hFcnJvclwiXSA9IDJdID0gXCJDYXRjaEVycm9yXCI7XG4gICAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJDYXRjaFN0YWNrXCJdID0gM10gPSBcIkNhdGNoU3RhY2tcIjtcbiAgfSkoQnVpbHRpblZhciB8fCAoQnVpbHRpblZhciA9IHt9KSk7XG4gIHZhciBSZWFkVmFyRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoUmVhZFZhckV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBSZWFkVmFyRXhwcihuYW1lLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuYnVpbHRpbiA9IG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWFkVmFyRXhwci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgV3JpdGVWYXJFeHByKHRoaXMubmFtZSwgdmFsdWUpOyB9O1xuICAgICAgcmV0dXJuIFJlYWRWYXJFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIFdyaXRlVmFyRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoV3JpdGVWYXJFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gV3JpdGVWYXJFeHByKG5hbWUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXcml0ZVZhckV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgV3JpdGVLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihXcml0ZUtleUV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBXcml0ZUtleUV4cHIocmVjZWl2ZXIsIGluZGV4LCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVLZXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXcml0ZUtleUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgV3JpdGVQcm9wRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoV3JpdGVQcm9wRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFdyaXRlUHJvcEV4cHIocmVjZWl2ZXIsIG5hbWUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSk7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgV3JpdGVQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFdyaXRlUHJvcEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgQnVpbHRpbk1ldGhvZDtcbiAgKGZ1bmN0aW9uIChCdWlsdGluTWV0aG9kKSB7XG4gICAgICBCdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2RbXCJDb25jYXRBcnJheVwiXSA9IDBdID0gXCJDb25jYXRBcnJheVwiO1xuICAgICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiU3Vic2NyaWJlT2JzZXJ2YWJsZVwiXSA9IDFdID0gXCJTdWJzY3JpYmVPYnNlcnZhYmxlXCI7XG4gICAgICBCdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2RbXCJCaW5kXCJdID0gMl0gPSBcIkJpbmRcIjtcbiAgfSkoQnVpbHRpbk1ldGhvZCB8fCAoQnVpbHRpbk1ldGhvZCA9IHt9KSk7XG4gIHZhciBJbnZva2VNZXRob2RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihJbnZva2VNZXRob2RFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW52b2tlTWV0aG9kRXhwcihyZWNlaXZlciwgbWV0aG9kLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBtZXRob2Q7XG4gICAgICAgICAgICAgIHRoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBtZXRob2Q7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgSW52b2tlTWV0aG9kRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZU1ldGhvZEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEludm9rZU1ldGhvZEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgSW52b2tlRnVuY3Rpb25FeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihJbnZva2VGdW5jdGlvbkV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBJbnZva2VGdW5jdGlvbkV4cHIoZm4sIGFyZ3MsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBJbnZva2VGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEludm9rZUZ1bmN0aW9uRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBJbnN0YW50aWF0ZUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEluc3RhbnRpYXRlRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRlRXhwcihjbGFzc0V4cHIsIGFyZ3MsIHR5cGUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLmNsYXNzRXhwciA9IGNsYXNzRXhwcjtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgSW5zdGFudGlhdGVFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5zdGFudGlhdGVFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbnN0YW50aWF0ZUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTGl0ZXJhbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKExpdGVyYWxFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgTGl0ZXJhbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGl0ZXJhbEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgRXh0ZXJuYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihFeHRlcm5hbEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBFeHRlcm5hbEV4cHIodmFsdWUsIHR5cGUsIHR5cGVQYXJhbXMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgICAgfVxuICAgICAgRXh0ZXJuYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXh0ZXJuYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBFeHRlcm5hbEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgQ29uZGl0aW9uYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihDb25kaXRpb25hbEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHIoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB0cnVlQ2FzZS50eXBlKTtcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgICB0aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICAgICAgICB0aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICB9XG4gICAgICBDb25kaXRpb25hbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBOb3RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihOb3RFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTm90RXhwcihjb25kaXRpb24pIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBCT09MX1RZUEUpO1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgfVxuICAgICAgTm90RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5vdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIE5vdEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgQ2FzdEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKENhc3RFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2FzdEV4cHIodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBDYXN0RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhc3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDYXN0RXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBGblBhcmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEZuUGFyYW0obmFtZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gRm5QYXJhbTtcbiAgfSgpKTtcbiAgdmFyIEZ1bmN0aW9uRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByKHBhcmFtcywgc3RhdGVtZW50cywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgfVxuICAgICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIEZ1bmN0aW9uRXhwci5wcm90b3R5cGUudG9EZWNsU3RtdCA9IGZ1bmN0aW9uIChuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyZUZ1bmN0aW9uU3RtdChuYW1lLCB0aGlzLnBhcmFtcywgdGhpcy5zdGF0ZW1lbnRzLCB0aGlzLnR5cGUsIG1vZGlmaWVycyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBCaW5hcnlPcGVyYXRvckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEJpbmFyeU9wZXJhdG9yRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCBsaHMudHlwZSk7XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgfVxuICAgICAgQmluYXJ5T3BlcmF0b3JFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5hcnlPcGVyYXRvckV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgUmVhZFByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihSZWFkUHJvcEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBSZWFkUHJvcEV4cHIocmVjZWl2ZXIsIG5hbWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlUHJvcEV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlYWRQcm9wRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBSZWFkS2V5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoUmVhZEtleUV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBSZWFkS2V5RXhwcihyZWNlaXZlciwgaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZEtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVhZEtleUV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVLZXlFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMuaW5kZXgsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmVhZEtleUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTGl0ZXJhbEFycmF5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoTGl0ZXJhbEFycmF5RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxBcnJheUV4cHIoZW50cmllcywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgfVxuICAgICAgTGl0ZXJhbEFycmF5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxBcnJheUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTGl0ZXJhbE1hcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKExpdGVyYWxNYXBFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTGl0ZXJhbE1hcEV4cHIoZW50cmllcywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICAgIHRoaXMudmFsdWVUeXBlID0gbnVsbDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVUeXBlID0gdHlwZS52YWx1ZVR5cGU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgTGl0ZXJhbE1hcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsTWFwRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGl0ZXJhbE1hcEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgVEhJU19FWFBSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuVGhpcyk7XG4gIHZhciBTVVBFUl9FWFBSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuU3VwZXIpO1xuICB2YXIgQ0FUQ0hfRVJST1JfVkFSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcik7XG4gIHZhciBDQVRDSF9TVEFDS19WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaFN0YWNrKTtcbiAgdmFyIE5VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBudWxsKTtcbiAgdmFyIFRZUEVEX05VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBOVUxMX1RZUEUpO1xuICAvLy8vIFN0YXRlbWVudHNcbiAgdmFyIFN0bXRNb2RpZmllcjtcbiAgKGZ1bmN0aW9uIChTdG10TW9kaWZpZXIpIHtcbiAgICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJGaW5hbFwiXSA9IDBdID0gXCJGaW5hbFwiO1xuICAgICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIlByaXZhdGVcIl0gPSAxXSA9IFwiUHJpdmF0ZVwiO1xuICB9KShTdG10TW9kaWZpZXIgfHwgKFN0bXRNb2RpZmllciA9IHt9KSk7XG4gIHZhciBTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhdGVtZW50KG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgICByZXR1cm4gU3RhdGVtZW50O1xuICB9KCkpO1xuICB2YXIgRGVjbGFyZVZhclN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKERlY2xhcmVWYXJTdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRGVjbGFyZVZhclN0bXQobmFtZSwgdmFsdWUsIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCB2YWx1ZS50eXBlO1xuICAgICAgfVxuICAgICAgRGVjbGFyZVZhclN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVWYXJTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEZWNsYXJlVmFyU3RtdDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIERlY2xhcmVGdW5jdGlvblN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKERlY2xhcmVGdW5jdGlvblN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBEZWNsYXJlRnVuY3Rpb25TdG10KG5hbWUsIHBhcmFtcywgc3RhdGVtZW50cywgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICAgIERlY2xhcmVGdW5jdGlvblN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIERlY2xhcmVGdW5jdGlvblN0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihFeHByZXNzaW9uU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICAgIH1cbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBFeHByZXNzaW9uU3RhdGVtZW50O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgUmV0dXJuU3RhdGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihSZXR1cm5TdGF0ZW1lbnQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQodmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBSZXR1cm5TdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJldHVyblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJldHVyblN0YXRlbWVudDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIEFic3RyYWN0Q2xhc3NQYXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Q2xhc3NQYXJ0KHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICAgIGlmICghbW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgQWJzdHJhY3RDbGFzc1BhcnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgICByZXR1cm4gQWJzdHJhY3RDbGFzc1BhcnQ7XG4gIH0oKSk7XG4gIHZhciBDbGFzc0ZpZWxkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihDbGFzc0ZpZWxkLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2xhc3NGaWVsZChuYW1lLCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2xhc3NGaWVsZDtcbiAgfShBYnN0cmFjdENsYXNzUGFydCkpO1xuICB2YXIgQ2xhc3NNZXRob2QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKENsYXNzTWV0aG9kLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2xhc3NNZXRob2QobmFtZSwgcGFyYW1zLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDbGFzc01ldGhvZDtcbiAgfShBYnN0cmFjdENsYXNzUGFydCkpO1xuICB2YXIgQ2xhc3NHZXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKENsYXNzR2V0dGVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2xhc3NHZXR0ZXIobmFtZSwgYm9keSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2xhc3NHZXR0ZXI7XG4gIH0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbiAgdmFyIENsYXNzU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQ2xhc3NTdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2xhc3NTdG10KG5hbWUsIHBhcmVudCwgZmllbGRzLCBnZXR0ZXJzLCBjb25zdHJ1Y3Rvck1ldGhvZCwgbWV0aG9kcywgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgICAgdGhpcy5nZXR0ZXJzID0gZ2V0dGVycztcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yTWV0aG9kID0gY29uc3RydWN0b3JNZXRob2Q7XG4gICAgICAgICAgdGhpcy5tZXRob2RzID0gbWV0aG9kcztcbiAgICAgIH1cbiAgICAgIENsYXNzU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ2xhc3NTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgSWZTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihJZlN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBJZlN0bXQoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlKSB7XG4gICAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IFtdOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgICAgdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgICAgICAgIHRoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgICAgfVxuICAgICAgSWZTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJZlN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIElmU3RtdDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIENvbW1lbnRTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihDb21tZW50U3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbW1lbnRTdG10KGNvbW1lbnQpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgfVxuICAgICAgQ29tbWVudFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnRTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21tZW50U3RtdDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIFRyeUNhdGNoU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoVHJ5Q2F0Y2hTdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gVHJ5Q2F0Y2hTdG10KGJvZHlTdG10cywgY2F0Y2hTdG10cykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keVN0bXRzID0gYm9keVN0bXRzO1xuICAgICAgICAgIHRoaXMuY2F0Y2hTdG10cyA9IGNhdGNoU3RtdHM7XG4gICAgICB9XG4gICAgICBUcnlDYXRjaFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyeUNhdGNoU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVHJ5Q2F0Y2hTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgVGhyb3dTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihUaHJvd1N0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUaHJvd1N0bXQoZXJyb3IpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgICBUaHJvd1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRocm93U3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVGhyb3dTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgRXhwcmVzc2lvblRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25UcmFuc2Zvcm1lcigpIHtcbiAgICAgIH1cbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVWYXJFeHByKGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVLZXlFeHByKGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlUHJvcEV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBtZXRob2QgPSBhc3QuYnVpbHRpbiB8fCBhc3QubmFtZTtcbiAgICAgICAgICByZXR1cm4gbmV3IEludm9rZU1ldGhvZEV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgbWV0aG9kLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEludm9rZUZ1bmN0aW9uRXhwcihhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEluc3RhbnRpYXRlRXhwcihhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb3RFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDYXN0RXhwcihhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGFzdC5vcGVyYXRvciwgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRQcm9wRXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QubmFtZSwgYXN0LnR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRLZXlFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBhc3QuZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBbZW50cnlbMF0sIGVudHJ5WzFdLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCksXTsgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcihlbnRyaWVzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBleHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQudHlwZSwgc3RtdC5tb2RpZmllcnMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJldHVyblN0YXRlbWVudChzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJZlN0bXQoc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRyeUNhdGNoU3RtdCh0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGhyb3dTdG10KHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gc3RtdHMubWFwKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbiAgfSgpKTtcbiAgdmFyIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5WzFdLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIHN0bXQ7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBzdG10cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiByZXBsYWNlVmFySW5FeHByZXNzaW9uKHZhck5hbWUsIG5ld1ZhbHVlLCBleHByZXNzaW9uKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyKHZhck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uLnZpc2l0RXhwcmVzc2lvbih0cmFuc2Zvcm1lciwgbnVsbCk7XG4gIH1cbiAgdmFyIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyKF92YXJOYW1lLCBfbmV3VmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLl92YXJOYW1lID0gX3Zhck5hbWU7XG4gICAgICAgICAgdGhpcy5fbmV3VmFsdWUgPSBfbmV3VmFsdWU7XG4gICAgICB9XG4gICAgICBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGFzdC5uYW1lID09IHRoaXMuX3Zhck5hbWUgPyB0aGlzLl9uZXdWYWx1ZSA6IGFzdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyO1xuICB9KEV4cHJlc3Npb25UcmFuc2Zvcm1lcikpO1xuICBmdW5jdGlvbiBmaW5kUmVhZFZhck5hbWVzKHN0bXRzKSB7XG4gICAgICB2YXIgZmluZGVyID0gbmV3IF9WYXJpYWJsZUZpbmRlcigpO1xuICAgICAgZmluZGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgbnVsbCk7XG4gICAgICByZXR1cm4gZmluZGVyLnZhck5hbWVzO1xuICB9XG4gIHZhciBfVmFyaWFibGVGaW5kZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKF9WYXJpYWJsZUZpbmRlciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIF9WYXJpYWJsZUZpbmRlcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLnZhck5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgX1ZhcmlhYmxlRmluZGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHRoaXMudmFyTmFtZXMuYWRkKGFzdC5uYW1lKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ZhcmlhYmxlRmluZGVyO1xuICB9KFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yKSk7XG4gIGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIobmFtZSwgdHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gaW1wb3J0RXhwcihpZCwgdHlwZVBhcmFtcykge1xuICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBFeHRlcm5hbEV4cHIoaWQsIG51bGwsIHR5cGVQYXJhbXMpO1xuICB9XG4gIGZ1bmN0aW9uIGltcG9ydFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIHtcbiAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgIGlmICh0eXBlTW9kaWZpZXJzID09PSB2b2lkIDApIHsgdHlwZU1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgIHJldHVybiBpc1ByZXNlbnQoaWQpID8gbmV3IEV4dGVybmFsVHlwZShpZCwgdHlwZVBhcmFtcywgdHlwZU1vZGlmaWVycykgOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGxpdGVyYWxBcnIodmFsdWVzLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheUV4cHIodmFsdWVzLCB0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBsaXRlcmFsTWFwKHZhbHVlcywgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcih2YWx1ZXMsIHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIG5vdChleHByKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEV4cHIoZXhwcik7XG4gIH1cbiAgZnVuY3Rpb24gZm4ocGFyYW1zLCBib2R5LCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRXhwcihwYXJhbXMsIGJvZHksIHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGxpdGVyYWwodmFsdWUsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDEzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgQW5pbWF0aW9uQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFzdCgpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgICAgdGhpcy5wbGF5VGltZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uQXN0O1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uU3RhdGVBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0YXRlQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVBc3QoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25FbnRyeUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uRW50cnlBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25FbnRyeUFzdChuYW1lLCBzdGF0ZURlY2xhcmF0aW9ucywgc3RhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5zdGF0ZURlY2xhcmF0aW9ucyA9IHN0YXRlRGVjbGFyYXRpb25zO1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9ucyA9IHN0YXRlVHJhbnNpdGlvbnM7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25FbnRyeUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uRW50cnkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvbkVudHJ5QXN0O1xuICB9KEFuaW1hdGlvbkFzdCkpO1xuICB2YXIgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3Qoc3RhdGVOYW1lLCBzdHlsZXMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0YXRlTmFtZSA9IHN0YXRlTmFtZTtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb24odGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3Q7XG4gIH0oQW5pbWF0aW9uU3RhdGVBc3QpKTtcbiAgdmFyIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uRXhwcmVzc2lvbihmcm9tU3RhdGUsIHRvU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmZyb21TdGF0ZSA9IGZyb21TdGF0ZTtcbiAgICAgICAgICB0aGlzLnRvU3RhdGUgPSB0b1N0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb247XG4gIH0oKSk7XG4gIHZhciBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdChzdGF0ZUNoYW5nZXMsIGFuaW1hdGlvbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzID0gc3RhdGVDaGFuZ2VzO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25TdGF0ZVRyYW5zaXRpb24odGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdDtcbiAgfShBbmltYXRpb25TdGF0ZUFzdCkpO1xuICB2YXIgQW5pbWF0aW9uU3RlcEFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3RlcEFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0ZXBBc3Qoc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0aW5nU3R5bGVzID0gc3RhcnRpbmdTdHlsZXM7XG4gICAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG4gICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblN0ZXBBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblN0ZXAodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0ZXBBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25TdHlsZXNBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0eWxlc0FzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0eWxlc0FzdChzdHlsZXMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblN0eWxlc0FzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uU3R5bGVzKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25TdHlsZXNBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25LZXlmcmFtZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uS2V5ZnJhbWVBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25LZXlmcmFtZUFzdChvZmZzZXQsIHN0eWxlcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uS2V5ZnJhbWVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvbktleWZyYW1lKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25LZXlmcmFtZUFzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvbldpdGhTdGVwc0FzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uV2l0aFN0ZXBzQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvbldpdGhTdGVwc0FzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvbkdyb3VwQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25Hcm91cEFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkdyb3VwQXN0KHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uR3JvdXBBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvbkdyb3VwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cEFzdDtcbiAgfShBbmltYXRpb25XaXRoU3RlcHNBc3QpKTtcbiAgdmFyIEFuaW1hdGlvblNlcXVlbmNlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TZXF1ZW5jZUFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlQXN0KHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uU2VxdWVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblNlcXVlbmNlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25TZXF1ZW5jZUFzdDtcbiAgfShBbmltYXRpb25XaXRoU3RlcHNBc3QpKTtcblxuICB2YXIgQW5pbWF0aW9uRW50cnlDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVudHJ5Q29tcGlsZVJlc3VsdChuYW1lLCBzdGF0ZW1lbnRzLCBmbkV4cCkge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgICB0aGlzLmZuRXhwID0gZm5FeHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uRW50cnlDb21waWxlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uQ29tcGlsZXIoKSB7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25Db21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChmYWN0b3J5TmFtZVByZWZpeCwgcGFyc2VkQW5pbWF0aW9ucykge1xuICAgICAgICAgIHJldHVybiBwYXJzZWRBbmltYXRpb25zLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgdmFyIGZhY3RvcnlOYW1lID0gZmFjdG9yeU5hbWVQcmVmaXggKyBcIl9cIiArIGVudHJ5Lm5hbWU7XG4gICAgICAgICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9BbmltYXRpb25CdWlsZGVyKGVudHJ5Lm5hbWUsIGZhY3RvcnlOYW1lKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuYnVpbGQoZW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25Db21waWxlcjtcbiAgfSgpKTtcbiAgdmFyIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiA9IHZhcmlhYmxlKCdlbGVtZW50Jyk7XG4gIHZhciBfQU5JTUFUSU9OX0RFRkFVTFRfU1RBVEVfVkFSID0gdmFyaWFibGUoJ2RlZmF1bHRTdGF0ZVN0eWxlcycpO1xuICB2YXIgX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfVkFSID0gdmFyaWFibGUoJ3ZpZXcnKTtcbiAgdmFyIF9BTklNQVRJT05fRkFDVE9SWV9WSUVXX0NPTlRFWFQgPSBfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19WQVIucHJvcCgnYW5pbWF0aW9uQ29udGV4dCcpO1xuICB2YXIgX0FOSU1BVElPTl9GQUNUT1JZX1JFTkRFUkVSX1ZBUiA9IF9BTklNQVRJT05fRkFDVE9SWV9WSUVXX1ZBUi5wcm9wKCdyZW5kZXJlcicpO1xuICB2YXIgX0FOSU1BVElPTl9DVVJSRU5UX1NUQVRFX1ZBUiA9IHZhcmlhYmxlKCdjdXJyZW50U3RhdGUnKTtcbiAgdmFyIF9BTklNQVRJT05fTkVYVF9TVEFURV9WQVIgPSB2YXJpYWJsZSgnbmV4dFN0YXRlJyk7XG4gIHZhciBfQU5JTUFUSU9OX1BMQVlFUl9WQVIgPSB2YXJpYWJsZSgncGxheWVyJyk7XG4gIHZhciBfQU5JTUFUSU9OX1RJTUVfVkFSID0gdmFyaWFibGUoJ3RvdGFsVGltZScpO1xuICB2YXIgX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSID0gdmFyaWFibGUoJ3N0YXJ0U3RhdGVTdHlsZXMnKTtcbiAgdmFyIF9BTklNQVRJT05fRU5EX1NUQVRFX1NUWUxFU19WQVIgPSB2YXJpYWJsZSgnZW5kU3RhdGVTdHlsZXMnKTtcbiAgdmFyIF9BTklNQVRJT05fQ09MTEVDVEVEX1NUWUxFUyA9IHZhcmlhYmxlKCdjb2xsZWN0ZWRTdHlsZXMnKTtcbiAgdmFyIEVNUFRZX01BUCA9IGxpdGVyYWxNYXAoW10pO1xuICB2YXIgX0FuaW1hdGlvbkJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FuaW1hdGlvbkJ1aWxkZXIoYW5pbWF0aW9uTmFtZSwgZmFjdG9yeU5hbWUpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25OYW1lO1xuICAgICAgICAgIHRoaXMuX2ZuVmFyTmFtZSA9IGZhY3RvcnlOYW1lICsgJ19mYWN0b3J5JztcbiAgICAgICAgICB0aGlzLl9zdGF0ZXNNYXBWYXJOYW1lID0gZmFjdG9yeU5hbWUgKyAnX3N0YXRlcyc7XG4gICAgICAgICAgdGhpcy5fc3RhdGVzTWFwVmFyID0gdmFyaWFibGUodGhpcy5fc3RhdGVzTWFwVmFyTmFtZSk7XG4gICAgICB9XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25TdHlsZXMgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIHN0eWxlc0FyciA9IFtdO1xuICAgICAgICAgIGlmIChjb250ZXh0LmlzRXhwZWN0aW5nRmlyc3RTdHlsZVN0ZXApIHtcbiAgICAgICAgICAgICAgc3R5bGVzQXJyLnB1c2goX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSKTtcbiAgICAgICAgICAgICAgY29udGV4dC5pc0V4cGVjdGluZ0ZpcnN0U3R5bGVTdGVwID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzdC5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBPYmplY3Qua2V5cyhlbnRyeSkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIGxpdGVyYWwoZW50cnlba2V5XSldOyB9KTtcbiAgICAgICAgICAgICAgc3R5bGVzQXJyLnB1c2gobGl0ZXJhbE1hcChlbnRyaWVzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQW5pbWF0aW9uU3R5bGVzKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgIF9BTklNQVRJT05fQ09MTEVDVEVEX1NUWUxFUywgbGl0ZXJhbEFycihzdHlsZXNBcnIpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uS2V5ZnJhbWUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQW5pbWF0aW9uS2V5ZnJhbWUpKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm9mZnNldCksIGFzdC5zdHlsZXMudmlzaXQodGhpcywgY29udGV4dClcbiAgICAgICAgICBdKTtcbiAgICAgIH07XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25TdGVwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKGNvbnRleHQuZW5kU3RhdGVBbmltYXRlU3RlcCA9PT0gYXN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdEVuZFN0YXRlQW5pbWF0aW9uKGFzdCwgY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydGluZ1N0eWxlc0V4cHIgPSBhc3Quc3RhcnRpbmdTdHlsZXMudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgdmFyIGtleWZyYW1lRXhwcmVzc2lvbnMgPSBhc3Qua2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5ZnJhbWVFbnRyeSkgeyByZXR1cm4ga2V5ZnJhbWVFbnRyeS52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsQW5pbWF0ZU1ldGhvZChhc3QsIHN0YXJ0aW5nU3R5bGVzRXhwciwgbGl0ZXJhbEFycihrZXlmcmFtZUV4cHJlc3Npb25zKSwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLl92aXNpdEVuZFN0YXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0YXJ0aW5nU3R5bGVzRXhwciA9IGFzdC5zdGFydGluZ1N0eWxlcy52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB2YXIga2V5ZnJhbWVFeHByZXNzaW9ucyA9IGFzdC5rZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXlmcmFtZSkgeyByZXR1cm4ga2V5ZnJhbWUudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICB2YXIga2V5ZnJhbWVzRXhwciA9IGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcykpLmNhbGxGbihbXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fQ09MTEVDVEVEX1NUWUxFUywgX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUixcbiAgICAgICAgICAgICAgbGl0ZXJhbEFycihrZXlmcmFtZUV4cHJlc3Npb25zKVxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsQW5pbWF0ZU1ldGhvZChhc3QsIHN0YXJ0aW5nU3R5bGVzRXhwciwga2V5ZnJhbWVzRXhwciwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLl9jYWxsQW5pbWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChhc3QsIHN0YXJ0aW5nU3R5bGVzRXhwciwga2V5ZnJhbWVzRXhwciwgY29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQudG90YWxUcmFuc2l0aW9uVGltZSArPSBhc3QuZHVyYXRpb24gKyBhc3QuZGVsYXk7XG4gICAgICAgICAgcmV0dXJuIF9BTklNQVRJT05fRkFDVE9SWV9SRU5ERVJFUl9WQVIuY2FsbE1ldGhvZCgnYW5pbWF0ZScsIFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLCBzdGFydGluZ1N0eWxlc0V4cHIsIGtleWZyYW1lc0V4cHIsIGxpdGVyYWwoYXN0LmR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgbGl0ZXJhbChhc3QuZGVsYXkpLCBsaXRlcmFsKGFzdC5lYXNpbmcpXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uU2VxdWVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcGxheWVyRXhwcnMgPSBhc3Quc3RlcHMubWFwKGZ1bmN0aW9uIChzdGVwKSB7IHJldHVybiBzdGVwLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIpKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIocGxheWVyRXhwcnMpXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uR3JvdXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcGxheWVyRXhwcnMgPSBhc3Quc3RlcHMubWFwKGZ1bmN0aW9uIChzdGVwKSB7IHJldHVybiBzdGVwLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQW5pbWF0aW9uR3JvdXBQbGF5ZXIpKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIocGxheWVyRXhwcnMpXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgZmxhdFN0eWxlcyA9IHt9O1xuICAgICAgICAgIF9nZXRTdHlsZXNBcnJheShhc3QpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZmxhdFN0eWxlc1trZXldID0gZW50cnlba2V5XTsgfSk7IH0pO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGVNYXAucmVnaXN0ZXJTdGF0ZShhc3Quc3RhdGVOYW1lLCBmbGF0U3R5bGVzKTtcbiAgICAgIH07XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25TdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIHN0ZXBzID0gYXN0LmFuaW1hdGlvbi5zdGVwcztcbiAgICAgICAgICB2YXIgbGFzdFN0ZXAgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoX2lzRW5kU3RhdGVBbmltYXRlU3RlcChsYXN0U3RlcCkpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5lbmRTdGF0ZUFuaW1hdGVTdGVwID0gbGFzdFN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQudG90YWxUcmFuc2l0aW9uVGltZSA9IDA7XG4gICAgICAgICAgY29udGV4dC5pc0V4cGVjdGluZ0ZpcnN0U3R5bGVTdGVwID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgc3RhdGVDaGFuZ2VQcmVjb25kaXRpb25zID0gW107XG4gICAgICAgICAgYXN0LnN0YXRlQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICBzdGF0ZUNoYW5nZVByZWNvbmRpdGlvbnMucHVzaChfY29tcGFyZVRvQW5pbWF0aW9uU3RhdGVFeHByKF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIsIHN0YXRlQ2hhbmdlLmZyb21TdGF0ZSlcbiAgICAgICAgICAgICAgICAgIC5hbmQoX2NvbXBhcmVUb0FuaW1hdGlvblN0YXRlRXhwcihfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSLCBzdGF0ZUNoYW5nZS50b1N0YXRlKSkpO1xuICAgICAgICAgICAgICBpZiAoc3RhdGVDaGFuZ2UuZnJvbVN0YXRlICE9IEFOWV9TVEFURSkge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGF0ZU1hcC5yZWdpc3RlclN0YXRlKHN0YXRlQ2hhbmdlLmZyb21TdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLnRvU3RhdGUgIT0gQU5ZX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnN0YXRlTWFwLnJlZ2lzdGVyU3RhdGUoc3RhdGVDaGFuZ2UudG9TdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uUGxheWVyRXhwciA9IGFzdC5hbmltYXRpb24udmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgdmFyIHJlZHVjZWRTdGF0ZUNoYW5nZXNQcmVjb25kaXRpb24gPSBzdGF0ZUNoYW5nZVByZWNvbmRpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLm9yKGIpOyB9KTtcbiAgICAgICAgICB2YXIgcHJlY29uZGl0aW9uID0gX0FOSU1BVElPTl9QTEFZRVJfVkFSLmVxdWFscyhOVUxMX0VYUFIpLmFuZChyZWR1Y2VkU3RhdGVDaGFuZ2VzUHJlY29uZGl0aW9uKTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uU3RtdCA9IF9BTklNQVRJT05fUExBWUVSX1ZBUi5zZXQoYW5pbWF0aW9uUGxheWVyRXhwcikudG9TdG10KCk7XG4gICAgICAgICAgdmFyIHRvdGFsVGltZVN0bXQgPSBfQU5JTUFUSU9OX1RJTUVfVkFSLnNldChsaXRlcmFsKGNvbnRleHQudG90YWxUcmFuc2l0aW9uVGltZSkpLnRvU3RtdCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgSWZTdG10KHByZWNvbmRpdGlvbiwgW2FuaW1hdGlvblN0bXQsIHRvdGFsVGltZVN0bXRdKTtcbiAgICAgIH07XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25FbnRyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIHZpc2l0IGVhY2ggb2YgdGhlIGRlY2xhcmF0aW9ucyBmaXJzdCB0byBidWlsZCB0aGUgY29udGV4dCBzdGF0ZSBtYXBcbiAgICAgICAgICBhc3Quc3RhdGVEZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBkZWYudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICAvLyB0aGlzIHNob3VsZCBhbHdheXMgYmUgZGVmaW5lZCBldmVuIGlmIHRoZSB1c2VyIG92ZXJyaWRlcyBpdFxuICAgICAgICAgIGNvbnRleHQuc3RhdGVNYXAucmVnaXN0ZXJTdGF0ZShERUZBVUxUX1NUQVRFLCB7fSk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfQ09OVEVYVFxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnY2FuY2VsQWN0aXZlQW5pbWF0aW9uJywgW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIsIGxpdGVyYWwodGhpcy5hbmltYXRpb25OYW1lKSxcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUi5lcXVhbHMobGl0ZXJhbChFTVBUWV9BTklNQVRJT05fU1RBVEUpKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fQ09MTEVDVEVEX1NUWUxFUy5zZXQoRU1QVFlfTUFQKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX1BMQVlFUl9WQVIuc2V0KE5VTExfRVhQUikudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9USU1FX1ZBUi5zZXQobGl0ZXJhbCgwKSkudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9ERUZBVUxUX1NUQVRFX1ZBUi5zZXQodGhpcy5fc3RhdGVzTWFwVmFyLmtleShsaXRlcmFsKERFRkFVTFRfU1RBVEUpKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUi5zZXQodGhpcy5fc3RhdGVzTWFwVmFyLmtleShfQU5JTUFUSU9OX0NVUlJFTlRfU1RBVEVfVkFSKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5ldyBJZlN0bXQoX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSLmVxdWFscyhOVUxMX0VYUFIpLCBbX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSLnNldChfQU5JTUFUSU9OX0RFRkFVTFRfU1RBVEVfVkFSKS50b1N0bXQoKV0pKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUi5zZXQodGhpcy5fc3RhdGVzTWFwVmFyLmtleShfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5ldyBJZlN0bXQoX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUi5lcXVhbHMoTlVMTF9FWFBSKSwgW19BTklNQVRJT05fRU5EX1NUQVRFX1NUWUxFU19WQVIuc2V0KF9BTklNQVRJT05fREVGQVVMVF9TVEFURV9WQVIpLnRvU3RtdCgpXSkpO1xuICAgICAgICAgIHZhciBSRU5ERVJfU1RZTEVTX0ZOID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5yZW5kZXJTdHlsZXMpKTtcbiAgICAgICAgICAvLyBiZWZvcmUgd2Ugc3RhcnQgYW55IGFuaW1hdGlvbiB3ZSB3YW50IHRvIGNsZWFyIG91dCB0aGUgc3RhcnRpbmdcbiAgICAgICAgICAvLyBzdHlsZXMgZnJvbSB0aGUgZWxlbWVudCdzIHN0eWxlIHByb3BlcnR5IChzaW5jZSB0aGV5IHdlcmUgcGxhY2VkXG4gICAgICAgICAgLy8gdGhlcmUgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBhbmltYXRpb25cbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goUkVOREVSX1NUWUxFU19GTlxuICAgICAgICAgICAgICAuY2FsbEZuKFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLCBfQU5JTUFUSU9OX0ZBQ1RPUllfUkVOREVSRVJfVkFSLFxuICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNsZWFyU3R5bGVzKSlcbiAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW19BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUl0pXG4gICAgICAgICAgXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICBhc3Quc3RhdGVUcmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc0FzdCkgeyByZXR1cm4gc3RhdGVtZW50cy5wdXNoKHRyYW5zQXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KSk7IH0pO1xuICAgICAgICAgIC8vIHRoaXMgY2hlY2sgZW5zdXJlcyB0aGF0IHRoZSBhbmltYXRpb24gZmFjdG9yeSBhbHdheXMgcmV0dXJucyBhIHBsYXllclxuICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIG9uRG9uZSBjYWxsYmFjayBjYW4gYmUgdXNlZCBmb3IgdHJhY2tpbmdcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IElmU3RtdChfQU5JTUFUSU9OX1BMQVlFUl9WQVIuZXF1YWxzKE5VTExfRVhQUiksIFtfQU5JTUFUSU9OX1BMQVlFUl9WQVJcbiAgICAgICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Ob09wQW5pbWF0aW9uUGxheWVyKSkuaW5zdGFudGlhdGUoW10pKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpXSkpO1xuICAgICAgICAgIC8vIG9uY2UgY29tcGxldGUgd2Ugd2FudCB0byBhcHBseSB0aGUgc3R5bGVzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgLy8gc2luY2UgdGhlIGRlc3RpbmF0aW9uIHN0YXRlJ3MgdmFsdWVzIHNob3VsZCBwZXJzaXN0IG9uY2VcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHNlcXVlbmNlIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fUExBWUVSX1ZBUlxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnb25Eb25lJywgW2ZuKFtdLCBbXG4gICAgICAgICAgICAgICAgICBfQU5JTUFUSU9OX1BMQVlFUl9WQVIuY2FsbE1ldGhvZCgnZGVzdHJveScsIFtdKS50b1N0bXQoKSxcbiAgICAgICAgICAgICAgICAgIFJFTkRFUl9TVFlMRVNfRk5cbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgICBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIsIF9BTklNQVRJT05fRkFDVE9SWV9SRU5ERVJFUl9WQVIsXG4gICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5wcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSXG4gICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpXG4gICAgICAgICAgICAgIF0pXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfQ09OVEVYVFxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgncXVldWVBbmltYXRpb24nLCBbXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiwgbGl0ZXJhbCh0aGlzLmFuaW1hdGlvbk5hbWUpLFxuICAgICAgICAgICAgICBfQU5JTUFUSU9OX1BMQVlFUl9WQVJcbiAgICAgICAgICBdKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgUmV0dXJuU3RhdGVtZW50KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQW5pbWF0aW9uVHJhbnNpdGlvbikpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9QTEFZRVJfVkFSLCBfQU5JTUFUSU9OX0NVUlJFTlRfU1RBVEVfVkFSLCBfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSLFxuICAgICAgICAgICAgICBfQU5JTUFUSU9OX1RJTUVfVkFSXG4gICAgICAgICAgXSkpKTtcbiAgICAgICAgICByZXR1cm4gZm4oW1xuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19WQVIubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBWaWV3KSwgW0RZTkFNSUNfVFlQRV0pKSxcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIubmFtZSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpXG4gICAgICAgICAgXSwgc3RhdGVtZW50cywgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BbmltYXRpb25UcmFuc2l0aW9uKSkpO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBfQW5pbWF0aW9uQnVpbGRlckNvbnRleHQoKTtcbiAgICAgICAgICB2YXIgZm5TdGF0ZW1lbnQgPSBhc3QudmlzaXQodGhpcywgY29udGV4dCkudG9EZWNsU3RtdCh0aGlzLl9mblZhck5hbWUpO1xuICAgICAgICAgIHZhciBmblZhcmlhYmxlID0gdmFyaWFibGUodGhpcy5fZm5WYXJOYW1lKTtcbiAgICAgICAgICB2YXIgbG9va3VwTWFwID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMoY29udGV4dC5zdGF0ZU1hcC5zdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0LnN0YXRlTWFwLnN0YXRlc1tzdGF0ZU5hbWVdO1xuICAgICAgICAgICAgICB2YXIgdmFyaWFibGVWYWx1ZSA9IEVNUFRZX01BUDtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdHlsZU1hcF8xID0gW107XG4gICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHN0eWxlTWFwXzEucHVzaChba2V5LCBsaXRlcmFsKHZhbHVlW2tleV0pXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgdmFyaWFibGVWYWx1ZSA9IGxpdGVyYWxNYXAoc3R5bGVNYXBfMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9va3VwTWFwLnB1c2goW3N0YXRlTmFtZSwgdmFyaWFibGVWYWx1ZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjb21waWxlZFN0YXRlc01hcFN0bXQgPSB0aGlzLl9zdGF0ZXNNYXBWYXIuc2V0KGxpdGVyYWxNYXAobG9va3VwTWFwKSkudG9EZWNsU3RtdCgpO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW2NvbXBpbGVkU3RhdGVzTWFwU3RtdCwgZm5TdGF0ZW1lbnRdO1xuICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uRW50cnlDb21waWxlUmVzdWx0KHRoaXMuYW5pbWF0aW9uTmFtZSwgc3RhdGVtZW50cywgZm5WYXJpYWJsZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9BbmltYXRpb25CdWlsZGVyO1xuICB9KCkpO1xuICB2YXIgX0FuaW1hdGlvbkJ1aWxkZXJDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25CdWlsZGVyQ29udGV4dCgpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlTWFwID0gbmV3IF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXAoKTtcbiAgICAgICAgICB0aGlzLmVuZFN0YXRlQW5pbWF0ZVN0ZXAgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaXNFeHBlY3RpbmdGaXJzdFN0eWxlU3RlcCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudG90YWxUcmFuc2l0aW9uVGltZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbkJ1aWxkZXJDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfQW5pbWF0aW9uQnVpbGRlclN0YXRlTWFwKCkge1xuICAgICAgICAgIHRoaXMuX3N0YXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXAucHJvdG90eXBlLCBcInN0YXRlc1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0ZXM7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcC5wcm90b3R5cGUucmVnaXN0ZXJTdGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gbnVsbDsgfVxuICAgICAgICAgIHZhciBleGlzdGluZ0VudHJ5ID0gdGhpcy5fc3RhdGVzW25hbWVdO1xuICAgICAgICAgIGlmICghZXhpc3RpbmdFbnRyeSkge1xuICAgICAgICAgICAgICB0aGlzLl9zdGF0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXA7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9jb21wYXJlVG9BbmltYXRpb25TdGF0ZUV4cHIodmFsdWUsIGFuaW1hdGlvblN0YXRlKSB7XG4gICAgICB2YXIgZW1wdHlTdGF0ZUxpdGVyYWwgPSBsaXRlcmFsKEVNUFRZX0FOSU1BVElPTl9TVEFURSk7XG4gICAgICBzd2l0Y2ggKGFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBFTVBUWV9BTklNQVRJT05fU1RBVEU6XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5lcXVhbHMoZW1wdHlTdGF0ZUxpdGVyYWwpO1xuICAgICAgICAgIGNhc2UgQU5ZX1NUQVRFOlxuICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0cnVlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZXF1YWxzKGxpdGVyYWwoYW5pbWF0aW9uU3RhdGUpKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfaXNFbmRTdGF0ZUFuaW1hdGVTdGVwKHN0ZXApIHtcbiAgICAgIC8vIHRoZSBmaW5hbCBhbmltYXRpb24gc3RlcCBpcyBjaGFyYWN0ZXJpemVkIGJ5IGhhdmluZyBvbmx5IFRXT1xuICAgICAgLy8ga2V5ZnJhbWUgdmFsdWVzIGFuZCBpdCBtdXN0IGhhdmUgemVybyBzdHlsZXMgZm9yIGJvdGgga2V5ZnJhbWVzXG4gICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIEFuaW1hdGlvblN0ZXBBc3QgJiYgc3RlcC5kdXJhdGlvbiA+IDAgJiYgc3RlcC5rZXlmcmFtZXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICB2YXIgc3R5bGVzMSA9IF9nZXRTdHlsZXNBcnJheShzdGVwLmtleWZyYW1lc1swXSlbMF07XG4gICAgICAgICAgdmFyIHN0eWxlczIgPSBfZ2V0U3R5bGVzQXJyYXkoc3RlcC5rZXlmcmFtZXNbMV0pWzBdO1xuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZXMxKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoc3R5bGVzMikubGVuZ3RoID09PSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRTdHlsZXNBcnJheShvYmopIHtcbiAgICAgIHJldHVybiBvYmouc3R5bGVzLnN0eWxlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHRva2VuKSB7XG4gICAgICBpZiAoaXNQcmVzZW50KHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsKHRva2VuLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRva2VuLmlkZW50aWZpZXJJc0luc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIodG9rZW4uaWRlbnRpZmllcilcbiAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKFtdLCBpbXBvcnRUeXBlKHRva2VuLmlkZW50aWZpZXIsIFtdLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIodG9rZW4uaWRlbnRpZmllcik7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW5saW5lQXJyYXkodmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVNUFRZX0lOTElORV9BUlJBWSkpO1xuICAgICAgfVxuICAgICAgdmFyIGxvZzIgPSBNYXRoLmxvZyh2YWx1ZXMubGVuZ3RoKSAvIE1hdGgubG9nKDIpO1xuICAgICAgdmFyIGluZGV4ID0gTWF0aC5jZWlsKGxvZzIpO1xuICAgICAgdmFyIGlkZW50aWZpZXJTcGVjID0gaW5kZXggPCBJZGVudGlmaWVycy5pbmxpbmVBcnJheXMubGVuZ3RoID8gSWRlbnRpZmllcnMuaW5saW5lQXJyYXlzW2luZGV4XSA6XG4gICAgICAgICAgSWRlbnRpZmllcnMuSW5saW5lQXJyYXlEeW5hbWljO1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSByZXNvbHZlSWRlbnRpZmllcihpZGVudGlmaWVyU3BlYyk7XG4gICAgICByZXR1cm4gaW1wb3J0RXhwcihpZGVudGlmaWVyKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgbGl0ZXJhbCh2YWx1ZXMubGVuZ3RoKVxuICAgICAgXS5jb25jYXQodmFsdWVzKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUHVyZVByb3h5KGZuLCBhcmdDb3VudCwgcHVyZVByb3h5UHJvcCwgYnVpbGRlcikge1xuICAgICAgYnVpbGRlci5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwdXJlUHJveHlQcm9wLm5hbWUsIG51bGwpKTtcbiAgICAgIHZhciBwdXJlUHJveHlJZCA9IGFyZ0NvdW50IDwgSWRlbnRpZmllcnMucHVyZVByb3hpZXMubGVuZ3RoID8gSWRlbnRpZmllcnMucHVyZVByb3hpZXNbYXJnQ291bnRdIDogbnVsbDtcbiAgICAgIGlmICghcHVyZVByb3h5SWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBudW1iZXIgb2YgYXJndW1lbnQgZm9yIHB1cmUgZnVuY3Rpb25zOiBcIiArIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIGJ1aWxkZXIuY3RvclN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AocHVyZVByb3h5UHJvcC5uYW1lKVxuICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihwdXJlUHJveHlJZCkpLmNhbGxGbihbZm5dKSlcbiAgICAgICAgICAudG9TdG10KCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1FeHByZXNzaW9uKGVudW1UeXBlLCBlbnVtVmFsdWUpIHtcbiAgICAgIHZhciBlbnVtTmFtZSA9IE9iamVjdC5rZXlzKGVudW1UeXBlLnJ1bnRpbWUpLmZpbmQoZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBlbnVtVHlwZS5ydW50aW1lW3Byb3BOYW1lXSA9PT0gZW51bVZhbHVlOyB9KTtcbiAgICAgIGlmICghZW51bU5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVudW0gdmFsdWUgXCIgKyBlbnVtVmFsdWUgKyBcIiBpbiBcIiArIGVudW1UeXBlLm5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUVudW1JZGVudGlmaWVyKHJlc29sdmVJZGVudGlmaWVyKGVudW1UeXBlKSwgZW51bU5hbWUpKTtcbiAgfVxuXG4gIHZhciBDaGVja0JpbmRpbmdGaWVsZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDaGVja0JpbmRpbmdGaWVsZChleHByZXNzaW9uLCBiaW5kaW5nSWQpIHtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuYmluZGluZ0lkID0gYmluZGluZ0lkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENoZWNrQmluZGluZ0ZpZWxkO1xuICB9KCkpO1xuICBmdW5jdGlvbiBjcmVhdGVDaGVja0JpbmRpbmdGaWVsZChidWlsZGVyKSB7XG4gICAgICB2YXIgYmluZGluZ0lkID0gXCJcIiArIGJ1aWxkZXIuZmllbGRzLmxlbmd0aDtcbiAgICAgIHZhciBmaWVsZEV4cHIgPSBjcmVhdGVCaW5kRmllbGRFeHByKGJpbmRpbmdJZCk7XG4gICAgICAvLyBwcml2YXRlIGlzIGZpbmUgaGVyZSBhcyBubyBjaGlsZCB2aWV3IHdpbGwgcmVmZXJlbmNlIHRoZSBjYWNoZWQgdmFsdWUuLi5cbiAgICAgIGJ1aWxkZXIuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoZmllbGRFeHByLm5hbWUsIG51bGwsIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgIGJ1aWxkZXIuY3RvclN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoZmllbGRFeHByLm5hbWUpXG4gICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlVOSU5JVElBTElaRUQpKSlcbiAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgcmV0dXJuIG5ldyBDaGVja0JpbmRpbmdGaWVsZChmaWVsZEV4cHIsIGJpbmRpbmdJZCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ2hlY2tCaW5kaW5nU3RtdChldmFsUmVzdWx0LCBmaWVsZEV4cHIsIHRocm93T25DaGFuZ2VWYXIsIGFjdGlvbnMpIHtcbiAgICAgIHZhciBjb25kaXRpb24gPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNoZWNrQmluZGluZykpLmNhbGxGbihbXG4gICAgICAgICAgdGhyb3dPbkNoYW5nZVZhciwgZmllbGRFeHByLCBldmFsUmVzdWx0LmN1cnJWYWxFeHByXG4gICAgICBdKTtcbiAgICAgIGlmIChldmFsUmVzdWx0LmZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgY29uZGl0aW9uID0gZXZhbFJlc3VsdC5mb3JjZVVwZGF0ZS5vcihjb25kaXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2YWxSZXN1bHQuc3RtdHMuY29uY2F0KFtcbiAgICAgICAgICBuZXcgSWZTdG10KGNvbmRpdGlvbiwgYWN0aW9ucy5jb25jYXQoW1xuICAgICAgICAgICAgICBUSElTX0VYUFIucHJvcChmaWVsZEV4cHIubmFtZSkuc2V0KGV2YWxSZXN1bHQuY3VyclZhbEV4cHIpLnRvU3RtdCgpXG4gICAgICAgICAgXSkpXG4gICAgICBdKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCaW5kRmllbGRFeHByKGJpbmRpbmdJZCkge1xuICAgICAgcmV0dXJuIFRISVNfRVhQUi5wcm9wKFwiX2V4cHJfXCIgKyBiaW5kaW5nSWQpO1xuICB9XG5cbiAgdmFyIFZBTF9VTldSQVBQRVJfVkFSID0gdmFyaWFibGUoXCJ2YWxVbndyYXBwZXJcIik7XG4gIHZhciBFdmVudEhhbmRsZXJWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlclZhcnMoKSB7XG4gICAgICB9XG4gICAgICBFdmVudEhhbmRsZXJWYXJzLmV2ZW50ID0gdmFyaWFibGUoJyRldmVudCcpO1xuICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnM7XG4gIH0oKSk7XG4gIHZhciBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByLCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgICB0aGlzLmN1cnJWYWxFeHByID0gY3VyclZhbEV4cHI7XG4gICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSA9IGZvcmNlVXBkYXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQ7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uIGlzXG4gICAqIHVzZWQgaW4gYSBwcm9wZXJ0eSBiaW5kaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZyhidWlsZGVyLCBuYW1lUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGV4cHJlc3Npb24sIGJpbmRpbmdJZCkge1xuICAgICAgdmFyIGN1cnJWYWxFeHByID0gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSWQpO1xuICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICBpZiAoIW5hbWVSZXNvbHZlcikge1xuICAgICAgICAgIG5hbWVSZXNvbHZlciA9IG5ldyBEZWZhdWx0TmFtZVJlc29sdmVyKCk7XG4gICAgICB9XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IoYnVpbGRlciwgbmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBWQUxfVU5XUkFQUEVSX1ZBUiwgYmluZGluZ0lkLCBmYWxzZSk7XG4gICAgICB2YXIgb3V0cHV0RXhwciA9IGV4cHJlc3Npb24udmlzaXQodmlzaXRvciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICBpZiAoIW91dHB1dEV4cHIpIHtcbiAgICAgICAgICAvLyBlLmcuIGFuIGVtcHR5IGV4cHJlc3Npb24gd2FzIGdpdmVuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodmlzaXRvci50ZW1wb3JhcnlDb3VudCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaXRvci50ZW1wb3JhcnlDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIHN0bXRzLnB1c2godGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpc2l0b3IubmVlZHNWYWx1ZVVud3JhcHBlcikge1xuICAgICAgICAgIHZhciBpbml0VmFsdWVVbndyYXBwZXJTdG10ID0gVkFMX1VOV1JBUFBFUl9WQVIuY2FsbE1ldGhvZCgncmVzZXQnLCBbXSkudG9TdG10KCk7XG4gICAgICAgICAgc3RtdHMucHVzaChpbml0VmFsdWVVbndyYXBwZXJTdG10KTtcbiAgICAgIH1cbiAgICAgIHN0bXRzLnB1c2goY3VyclZhbEV4cHIuc2V0KG91dHB1dEV4cHIpLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgIGlmICh2aXNpdG9yLm5lZWRzVmFsdWVVbndyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByLCBWQUxfVU5XUkFQUEVSX1ZBUi5wcm9wKCdoYXNXcmFwcGVkVmFsdWUnKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByLCBudWxsKTtcbiAgICAgIH1cbiAgfVxuICB2YXIgQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQoc3RtdHMsIHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5zdG10cyA9IHN0bXRzO1xuICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb252ZXJ0QWN0aW9uQmluZGluZ1Jlc3VsdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBleHByZXNzaW9uIEFTVCBpbnRvIGFuIGV4ZWN1dGFibGUgb3V0cHV0IEFTVCwgYXNzdW1pbmcgdGhlIGV4cHJlc3Npb24gaXNcbiAgICogdXNlZCBpbiBhbiBhY3Rpb24gYmluZGluZyAoZS5nLiBhbiBldmVudCBoYW5kbGVyKS5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbnZlcnRBY3Rpb25CaW5kaW5nKGJ1aWxkZXIsIG5hbWVSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYWN0aW9uLCBiaW5kaW5nSWQpIHtcbiAgICAgIGlmICghbmFtZVJlc29sdmVyKSB7XG4gICAgICAgICAgbmFtZVJlc29sdmVyID0gbmV3IERlZmF1bHROYW1lUmVzb2x2ZXIoKTtcbiAgICAgIH1cbiAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihidWlsZGVyLCBuYW1lUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIG51bGwsIGJpbmRpbmdJZCwgdHJ1ZSk7XG4gICAgICB2YXIgYWN0aW9uU3RtdHMgPSBbXTtcbiAgICAgIGZsYXR0ZW5TdGF0ZW1lbnRzKGFjdGlvbi52aXNpdCh2aXNpdG9yLCBfTW9kZS5TdGF0ZW1lbnQpLCBhY3Rpb25TdG10cyk7XG4gICAgICBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModmlzaXRvci50ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBhY3Rpb25TdG10cyk7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gYWN0aW9uU3RtdHMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBwcmV2ZW50RGVmYXVsdFZhciA9IG51bGw7XG4gICAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgICB2YXIgbGFzdFN0YXRlbWVudCA9IGFjdGlvblN0bXRzW2xhc3RJbmRleF07XG4gICAgICAgICAgdmFyIHJldHVybkV4cHIgPSBjb252ZXJ0U3RtdEludG9FeHByZXNzaW9uKGxhc3RTdGF0ZW1lbnQpO1xuICAgICAgICAgIGlmIChyZXR1cm5FeHByKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gY2FzdCB0aGUgcmVzdWx0IG9mIHRoZSBtZXRob2QgY2FsbCB0byBkeW5hbWljLFxuICAgICAgICAgICAgICAvLyBhcyBpdCBtaWdodCBiZSBhIHZvaWQgbWV0aG9kIVxuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhciA9IGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCk7XG4gICAgICAgICAgICAgIGFjdGlvblN0bXRzW2xhc3RJbmRleF0gPVxuICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIuc2V0KHJldHVybkV4cHIuY2FzdChEWU5BTUlDX1RZUEUpLm5vdElkZW50aWNhbChsaXRlcmFsKGZhbHNlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQoYWN0aW9uU3RtdHMsIHByZXZlbnREZWZhdWx0VmFyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB2YXJpYWJsZXMgdGhhdCBhcmUgc2hhcmVkIGJ5IG11bHRpcGxlIGNhbGxzIHRvIGBjb252ZXJ0QWN0aW9uQmluZGluZ2AgL1xuICAgKiBgY29udmVydFByb3BlcnR5QmluZGluZ2BcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXJlZEJpbmRpbmdWYXJpYWJsZXNJZk5lZWRlZChzdG10cykge1xuICAgICAgdmFyIHVud3JhcHBlclN0bXRzID0gW107XG4gICAgICB2YXIgcmVhZFZhcnMgPSBmaW5kUmVhZFZhck5hbWVzKHN0bXRzKTtcbiAgICAgIGlmIChyZWFkVmFycy5oYXMoVkFMX1VOV1JBUFBFUl9WQVIubmFtZSkpIHtcbiAgICAgICAgICB1bndyYXBwZXJTdG10cy5wdXNoKFZBTF9VTldSQVBQRVJfVkFSXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WYWx1ZVVud3JhcHBlcikpLmluc3RhbnRpYXRlKFtdKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bndyYXBwZXJTdG10cztcbiAgfVxuICBmdW5jdGlvbiB0ZW1wb3JhcnlOYW1lKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSB7XG4gICAgICByZXR1cm4gXCJ0bXBfXCIgKyBiaW5kaW5nSWQgKyBcIl9cIiArIHRlbXBvcmFyeU51bWJlcjtcbiAgfVxuICBmdW5jdGlvbiB0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgICAgcmV0dXJuIG5ldyBEZWNsYXJlVmFyU3RtdCh0ZW1wb3JhcnlOYW1lKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSwgTlVMTF9FWFBSKTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgc3RhdGVtZW50cykge1xuICAgICAgZm9yICh2YXIgaSA9IHRlbXBvcmFyeUNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQodGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgICB9XG4gIH1cbiAgdmFyIF9Nb2RlO1xuICAoZnVuY3Rpb24gKF9Nb2RlKSB7XG4gICAgICBfTW9kZVtfTW9kZVtcIlN0YXRlbWVudFwiXSA9IDBdID0gXCJTdGF0ZW1lbnRcIjtcbiAgICAgIF9Nb2RlW19Nb2RlW1wiRXhwcmVzc2lvblwiXSA9IDFdID0gXCJFeHByZXNzaW9uXCI7XG4gIH0pKF9Nb2RlIHx8IChfTW9kZSA9IHt9KSk7XG4gIGZ1bmN0aW9uIGVuc3VyZVN0YXRlbWVudE1vZGUobW9kZSwgYXN0KSB7XG4gICAgICBpZiAobW9kZSAhPT0gX01vZGUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYSBzdGF0ZW1lbnQsIGJ1dCBzYXcgXCIgKyBhc3QpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCkge1xuICAgICAgaWYgKG1vZGUgIT09IF9Nb2RlLkV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbiBleHByZXNzaW9uLCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBleHByKSB7XG4gICAgICBpZiAobW9kZSA9PT0gX01vZGUuU3RhdGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHIudG9TdG10KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgIH1cbiAgfVxuICB2YXIgX0FzdFRvSXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9Bc3RUb0lyVmlzaXRvcihfYnVpbGRlciwgX25hbWVSZXNvbHZlciwgX2ltcGxpY2l0UmVjZWl2ZXIsIF92YWx1ZVVud3JhcHBlciwgYmluZGluZ0lkLCBpc0FjdGlvbikge1xuICAgICAgICAgIHRoaXMuX2J1aWxkZXIgPSBfYnVpbGRlcjtcbiAgICAgICAgICB0aGlzLl9uYW1lUmVzb2x2ZXIgPSBfbmFtZVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIgPSBfaW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLl92YWx1ZVVud3JhcHBlciA9IF92YWx1ZVVud3JhcHBlcjtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgICAgICB0aGlzLmlzQWN0aW9uID0gaXNBY3Rpb247XG4gICAgICAgICAgdGhpcy5fbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeSA9IDA7XG4gICAgICAgICAgdGhpcy5uZWVkc1ZhbHVlVW53cmFwcGVyID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBvcDtcbiAgICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLlBsdXM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk1pbnVzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuRGl2aWRlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Nb2R1bG87XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5BbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5PcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkVxdWFscztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFscztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5JZGVudGljYWw7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Mb3dlcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG9wZXJhdGlvbiBcIiArIGFzdC5vcGVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihvcCwgdGhpcy52aXNpdChhc3QubGVmdCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMudmlzaXQoYXN0LnJpZ2h0LCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBtb2RlKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52aXNpdChhc3QuY29uZGl0aW9uLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFsdWUuY29uZGl0aW9uYWwodGhpcy52aXNpdChhc3QudHJ1ZUV4cCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMudmlzaXQoYXN0LmZhbHNlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMudmlzaXQoYXN0LmV4cCwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9uYW1lUmVzb2x2ZXIuY2FsbFBpcGUoYXN0Lm5hbWUsIGlucHV0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IFBpcGUgXCIgKyBhc3QubmFtZSArIFwiIGlzIG5vdCBhbGxvd2VkIGhlcmUhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5lZWRzVmFsdWVVbndyYXBwZXIgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLl92YWx1ZVVud3JhcHBlci5jYWxsTWV0aG9kKCd1bndyYXAnLCBbdmFsdWVdKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy52aXNpdChhc3QudGFyZ2V0LCBfTW9kZS5FeHByZXNzaW9uKS5jYWxsRm4odGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbbGl0ZXJhbChhc3QuZXhwcmVzc2lvbnMubGVuZ3RoKV07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3Quc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgYXJncy5wdXNoKGxpdGVyYWwoYXN0LnN0cmluZ3NbaV0pKTtcbiAgICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMudmlzaXQoYXN0LmV4cHJlc3Npb25zW2ldLCBfTW9kZS5FeHByZXNzaW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2FzdC5zdHJpbmdzLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgICAgcmV0dXJuIGFzdC5leHByZXNzaW9ucy5sZW5ndGggPD0gOSA/XG4gICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuaW5saW5lSW50ZXJwb2xhdGUpKS5jYWxsRm4oYXJncykgOlxuICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmludGVycG9sYXRlKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMF0sIGxpdGVyYWxBcnIoYXJncy5zbGljZSgxKSlcbiAgICAgICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy52aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKS5rZXkodGhpcy52aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBvYmogPSB0aGlzLnZpc2l0KGFzdC5vYmosIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciBrZXkgPSB0aGlzLnZpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgb2JqLmtleShrZXkpLnNldCh2YWx1ZSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIHBhcnRzID0gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIG1vZGUpO1xuICAgICAgICAgIHZhciBsaXRlcmFsQXJyJCQgPSB0aGlzLmlzQWN0aW9uID8gbGl0ZXJhbEFycihwYXJ0cykgOiBjcmVhdGVDYWNoZWRMaXRlcmFsQXJyYXkodGhpcy5fYnVpbGRlciwgcGFydHMpO1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBsaXRlcmFsQXJyJCQpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChbYXN0LmtleXNbaV0sIHRoaXMudmlzaXQoYXN0LnZhbHVlc1tpXSwgX01vZGUuRXhwcmVzc2lvbildKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxpdGVyYWxNYXAkJCA9IHRoaXMuaXNBY3Rpb24gPyBsaXRlcmFsTWFwKHBhcnRzKSA6IGNyZWF0ZUNhY2hlZExpdGVyYWxNYXAodGhpcy5fYnVpbGRlciwgcGFydHMpO1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBsaXRlcmFsTWFwJCQpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBsaXRlcmFsKGFzdC52YWx1ZSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuX2dldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0FjdGlvbiAmJiBuYW1lID09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVSZXNvbHZlci5nZXRMb2NhbChuYW1lKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YXJFeHByID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YXJFeHByKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhckV4cHIuY2FsbEZuKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmNhbGxNZXRob2QoYXN0Lm5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBub3QodGhpcy52aXNpdChhc3QuZXhwcmVzc2lvbiwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBsZWZ0TW9zdFNhZmUgPSB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KTtcbiAgICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgIHZhciB2YXJFeHByID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHZhckV4cHIpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhc3NpZ24gdG8gYSByZWZlcmVuY2Ugb3IgdmFyaWFibGUhJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUpLnNldCh0aGlzLnZpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpLCBtb2RlKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KSwgbW9kZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzLCBtb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXN0cy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gX3RoaXMudmlzaXQoYXN0LCBtb2RlKTsgfSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVvdGVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBldmFsdWF0aW9uIScpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuY29udmVydFNhZmVBY2Nlc3MgPSBmdW5jdGlvbiAoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgICAgLy8gYW4gZXhwcmVzc2lvbiB0aGF0IGd1YXJkcyB0aGUgYWNjZXNzIHRvIHRoZSBtZW1iZXIgYnkgY2hlY2tpbmcgdGhlIHJlY2VpdmVyIGZvciBibGFuay4gQXNcbiAgICAgICAgICAvLyBleGVjdXRpb24gcHJvY2VlZHMgZnJvbSBsZWZ0IHRvIHJpZ2h0LCB0aGUgbGVmdCBtb3N0IHBhcnQgb2YgdGhlIGV4cHJlc3Npb24gbXVzdCBiZSBndWFyZGVkXG4gICAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgICAvLyB0aGUgdG9wIG9mIHRoZSBBU1QuIFRoZSBkZXNpcmVkIHJlc3VsdCByZXF1aXJlcyBsaWZ0aW5nIGEgY29weSBvZiB0aGUgdGhlIGxlZnQgcGFydCBvZiB0aGVcbiAgICAgICAgICAvLyBleHByZXNzaW9uIHVwIHRvIHRlc3QgaXQgZm9yIGJsYW5rIGJlZm9yZSBnZW5lcmF0aW5nIHRoZSB1bmd1YXJkZWQgdmVyc2lvbi5cbiAgICAgICAgICAvLyBDb25zaWRlciwgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uOiBhPy5iLmM/LmQuZVxuICAgICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiB0aGUgYXN0OlxuICAgICAgICAgIC8vICAgICAgICAgLlxuICAgICAgICAgIC8vICAgICAgICAvIFxcXG4gICAgICAgICAgLy8gICAgICAgPy4gICBlXG4gICAgICAgICAgLy8gICAgICAvICBcXFxuICAgICAgICAgIC8vICAgICAuICAgIGRcbiAgICAgICAgICAvLyAgICAvIFxcXG4gICAgICAgICAgLy8gICA/LiAgY1xuICAgICAgICAgIC8vICAvICBcXFxuICAgICAgICAgIC8vIGEgICAgYlxuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHJlZSBzaG91bGQgYmUgZ2VuZXJhdGVkOlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgIC8tLS0tID8gLS0tLVxcXG4gICAgICAgICAgLy8gICAgICAgLyAgICAgIHwgICAgICBcXFxuICAgICAgICAgIC8vICAgICBhICAgLy0tLSA/IC0tLVxcICBudWxsXG4gICAgICAgICAgLy8gICAgICAgIC8gICAgIHwgICAgIFxcXG4gICAgICAgICAgLy8gICAgICAgLiAgICAgIC4gICAgIG51bGxcbiAgICAgICAgICAvLyAgICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAgIC8vICAgICAuICBjICAgLiAgIGVcbiAgICAgICAgICAvLyAgICAvIFxcICAgIC8gXFxcbiAgICAgICAgICAvLyAgIGEgICBiICAsICAgZFxuICAgICAgICAgIC8vICAgICAgICAgLyBcXFxuICAgICAgICAgIC8vICAgICAgICAuICAgY1xuICAgICAgICAgIC8vICAgICAgIC8gXFxcbiAgICAgICAgICAvLyAgICAgIGEgICBiXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGUgZmlyc3QgZ3VhcmQgY29uZGl0aW9uIGlzIHRoZSBsZWZ0IGhhbmQgb2YgdGhlIGxlZnQgbW9zdCBzYWZlIGFjY2VzcyBub2RlXG4gICAgICAgICAgLy8gd2hpY2ggY29tZXMgaW4gYXMgbGVmdE1vc3RTYWZlIHRvIHRoaXMgcm91dGluZS5cbiAgICAgICAgICB2YXIgZ3VhcmRlZEV4cHJlc3Npb24gPSB0aGlzLnZpc2l0KGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIHRlbXBvcmFyeTtcbiAgICAgICAgICBpZiAodGhpcy5uZWVkc1RlbXBvcmFyeShsZWZ0TW9zdFNhZmUucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBleHByZXNzaW9uIGhhcyBtZXRob2QgY2FsbHMgb3IgcGlwZXMgdGhlbiB3ZSBuZWVkIHRvIHNhdmUgdGhlIHJlc3VsdCBpbnRvIGFcbiAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGF2b2lkIGNhbGxpbmcgc3RhdGVmdWwgb3IgaW1wdXJlIGNvZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgICAgIHRlbXBvcmFyeSA9IHRoaXMuYWxsb2NhdGVUZW1wb3JhcnkoKTtcbiAgICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIHJlc3VsdCBpbiB0aGUgdGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgICAgICAgICAgIGd1YXJkZWRFeHByZXNzaW9uID0gdGVtcG9yYXJ5LnNldChndWFyZGVkRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgZnVydGhlciByZWZlcmVuY2VzIHRvIHRoZSBndWFyZGVkIGV4cHJlc3Npb24gcmVmZXIgdG8gdGhlIHRlbXBvcmFyeSBpbnN0ZWFkLlxuICAgICAgICAgICAgICB0aGlzLl9yZXN1bHRNYXAuc2V0KGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgdGVtcG9yYXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IGd1YXJkZWRFeHByZXNzaW9uLmlzQmxhbmsoKTtcbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBhc3QgdG8gYW4gdW5ndWFyZGVkIGFjY2VzcyB0byB0aGUgcmVjZWl2ZXIncyBtZW1iZXIuIFRoZSBtYXAgd2lsbCBzdWJzdGl0dXRlXG4gICAgICAgICAgLy8gbGVmdE1vc3ROb2RlIHdpdGggaXRzIHVuZ3VhcmRlZCB2ZXJzaW9uIGluIHRoZSBjYWxsIHRvIGB0aGlzLnZpc2l0KClgLlxuICAgICAgICAgIGlmIChsZWZ0TW9zdFNhZmUgaW5zdGFuY2VvZiBTYWZlTWV0aG9kQ2FsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBNZXRob2RDYWxsKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lLCBsZWZ0TW9zdFNhZmUuYXJncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgUHJvcGVydHlSZWFkKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdGhlIG5vZGUgbm93IHdpdGhvdXQgdGhlIGd1YXJkZWQgbWVtYmVyIGFjY2Vzcy5cbiAgICAgICAgICB2YXIgYWNjZXNzID0gdGhpcy52aXNpdChhc3QsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWFwcGluZy4gVGhpcyBpcyBub3Qgc3RyaWN0bHkgcmVxdWlyZWQgYXMgdGhlIGNvbnZlcnRlciBvbmx5IHRyYXZlcnNlcyBlYWNoIG5vZGVcbiAgICAgICAgICAvLyBvbmNlIGJ1dCBpcyBzYWZlciBpZiB0aGUgY29udmVyc2lvbiBpcyBjaGFuZ2VkIHRvIHRyYXZlcnNlIHRoZSBub2RlcyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgICB0aGlzLl9ub2RlTWFwLmRlbGV0ZShsZWZ0TW9zdFNhZmUpO1xuICAgICAgICAgIC8vIElmIHdlIGFsbGNvYXRlZCBhIHRlbXBvcmFyeSwgcmVsZWFzZSBpdC5cbiAgICAgICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICAgIHRoaXMucmVsZWFzZVRlbXBvcmFyeSh0ZW1wb3JhcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9kdWNlIHRoZSBjb25kaXRpb25hbFxuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBjb25kaXRpb24uY29uZGl0aW9uYWwobGl0ZXJhbChudWxsKSwgYWNjZXNzKSk7XG4gICAgICB9O1xuICAgICAgLy8gR2l2ZW4gYSBleHByZXNzaW9uIG9mIHRoZSBmb3JtIGE/LmIuYz8uZC5lIHRoZSB0aGUgbGVmdCBtb3N0IHNhZmUgbm9kZSBpc1xuICAgICAgLy8gdGhlIChhPy5iKS4gVGhlIC4gYW5kID8uIGFyZSBsZWZ0IGFzc29jaWF0aXZlIHRodXMgY2FuIGJlIHJld3JpdHRlbiBhczpcbiAgICAgIC8vICgoKChhPy5jKS5iKS5jKT8uZCkuZS4gVGhpcyByZXR1cm5zIHRoZSBtb3N0IGRlZXBseSBuZXN0ZWQgc2FmZSByZWFkIG9yXG4gICAgICAvLyBzYWZlIG1ldGhvZCBjYWxsIGFzIHRoaXMgbmVlZHMgYmUgdHJhbnNmb3JtIGluaXRpYWxseSB0bzpcbiAgICAgIC8vICAgYSA9PSBudWxsID8gbnVsbCA6IGEuYy5iLmM/LmQuZVxuICAgICAgLy8gdGhlbiB0bzpcbiAgICAgIC8vICAgYSA9PSBudWxsID8gbnVsbCA6IGEuYi5jID09IG51bGwgPyBudWxsIDogYS5iLmMuZC5lXG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmxlZnRNb3N0U2FmZU5vZGUgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiAoX3RoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRDaGFpbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdEtleWVkUmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0Lm9iaik7IH0sXG4gICAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UGlwZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQcmVmaXhOb3Q6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0OyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8vIFJldHVybnMgdHJ1ZSBvZiB0aGUgQVNUIGluY2x1ZGVzIGEgbWV0aG9kIG9yIGEgcGlwZSBpbmRpY2F0aW5nIHRoYXQsIGlmIHRoZVxuICAgICAgLy8gZXhwcmVzc2lvbiBpcyB1c2VkIGFzIHRoZSB0YXJnZXQgb2YgYSBzYWZlIHByb3BlcnR5IG9yIG1ldGhvZCBhY2Nlc3MgdGhlblxuICAgICAgLy8gdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHN0b3JlZCBpbnRvIGEgdGVtcG9yYXJ5IHZhcmlhYmxlLlxuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5uZWVkc1RlbXBvcmFyeSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciB2aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzdCAmJiAoX3RoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB2aXNpdFNvbWUgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3Quc29tZShmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh2aXNpdG9yLCBhc3QpOyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmxlZnQpIHx8IHZpc2l0KHRoaXMsIGFzdC5yaWdodCk7IH0sXG4gICAgICAgICAgICAgIHZpc2l0Q2hhaW46IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICB2aXNpdENvbmRpdGlvbmFsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmNvbmRpdGlvbikgfHwgdmlzaXQodGhpcywgYXN0LnRydWVFeHApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgdmlzaXQodGhpcywgYXN0LmZhbHNlRXhwKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXRTb21lKHRoaXMsIGFzdC5leHByZXNzaW9ucyk7IH0sXG4gICAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJlZml4Tm90OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QuZXhwcmVzc2lvbik7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmFsbG9jYXRlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ZW1wTnVtYmVyID0gdGhpcy5fY3VycmVudFRlbXBvcmFyeSsrO1xuICAgICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSBNYXRoLm1heCh0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LCB0aGlzLnRlbXBvcmFyeUNvdW50KTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRWYXJFeHByKHRlbXBvcmFyeU5hbWUodGhpcy5iaW5kaW5nSWQsIHRlbXBOdW1iZXIpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnJlbGVhc2VUZW1wb3JhcnkgPSBmdW5jdGlvbiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeS0tO1xuICAgICAgICAgIGlmICh0ZW1wb3JhcnkubmFtZSAhPSB0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW1wb3JhcnkgXCIgKyB0ZW1wb3JhcnkubmFtZSArIFwiIHJlbGVhc2VkIG91dCBvZiBvcmRlclwiKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Bc3RUb0lyVmlzaXRvcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZmxhdHRlblN0YXRlbWVudHMoYXJnLCBvdXRwdXQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGZsYXR0ZW5TdGF0ZW1lbnRzKGVudHJ5LCBvdXRwdXQpOyB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5wdXNoKGFyZyk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGVkTGl0ZXJhbEFycmF5KGJ1aWxkZXIsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9BUlJBWSkpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3h5RXhwciA9IFRISVNfRVhQUi5wcm9wKFwiX2Fycl9cIiArIGJ1aWxkZXIuZmllbGRzLmxlbmd0aCk7XG4gICAgICB2YXIgcHJveHlQYXJhbXMgPSBbXTtcbiAgICAgIHZhciBwcm94eVJldHVybkVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IFwicFwiICsgaTtcbiAgICAgICAgICBwcm94eVBhcmFtcy5wdXNoKG5ldyBGblBhcmFtKHBhcmFtTmFtZSkpO1xuICAgICAgICAgIHByb3h5UmV0dXJuRW50cmllcy5wdXNoKHZhcmlhYmxlKHBhcmFtTmFtZSkpO1xuICAgICAgfVxuICAgICAgY3JlYXRlUHVyZVByb3h5KGZuKHByb3h5UGFyYW1zLCBbbmV3IFJldHVyblN0YXRlbWVudChsaXRlcmFsQXJyKHByb3h5UmV0dXJuRW50cmllcykpXSwgbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUpKSwgdmFsdWVzLmxlbmd0aCwgcHJveHlFeHByLCBidWlsZGVyKTtcbiAgICAgIHJldHVybiBwcm94eUV4cHIuY2FsbEZuKHZhbHVlcyk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGVkTGl0ZXJhbE1hcChidWlsZGVyLCBlbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9NQVApKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm94eUV4cHIgPSBUSElTX0VYUFIucHJvcChcIl9tYXBfXCIgKyBidWlsZGVyLmZpZWxkcy5sZW5ndGgpO1xuICAgICAgdmFyIHByb3h5UGFyYW1zID0gW107XG4gICAgICB2YXIgcHJveHlSZXR1cm5FbnRyaWVzID0gW107XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyYW1OYW1lID0gXCJwXCIgKyBpO1xuICAgICAgICAgIHByb3h5UGFyYW1zLnB1c2gobmV3IEZuUGFyYW0ocGFyYW1OYW1lKSk7XG4gICAgICAgICAgcHJveHlSZXR1cm5FbnRyaWVzLnB1c2goW2VudHJpZXNbaV1bMF0sIHZhcmlhYmxlKHBhcmFtTmFtZSldKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChlbnRyaWVzW2ldWzFdKTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZVB1cmVQcm94eShmbihwcm94eVBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbE1hcChwcm94eVJldHVybkVudHJpZXMpKV0sIG5ldyBNYXBUeXBlKERZTkFNSUNfVFlQRSkpLCBlbnRyaWVzLmxlbmd0aCwgcHJveHlFeHByLCBidWlsZGVyKTtcbiAgICAgIHJldHVybiBwcm94eUV4cHIuY2FsbEZuKHZhbHVlcyk7XG4gIH1cbiAgdmFyIERlZmF1bHROYW1lUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGVmYXVsdE5hbWVSZXNvbHZlcigpIHtcbiAgICAgIH1cbiAgICAgIERlZmF1bHROYW1lUmVzb2x2ZXIucHJvdG90eXBlLmNhbGxQaXBlID0gZnVuY3Rpb24gKG5hbWUsIGlucHV0LCBhcmdzKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgRGVmYXVsdE5hbWVSZXNvbHZlci5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIHJldHVybiBEZWZhdWx0TmFtZVJlc29sdmVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJZCkge1xuICAgICAgcmV0dXJuIHZhcmlhYmxlKFwiY3VyclZhbF9cIiArIGJpbmRpbmdJZCk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nOiBgXG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUHJldmVudERlZmF1bHRWYXIoYmluZGluZ0lkKSB7XG4gICAgICByZXR1cm4gdmFyaWFibGUoXCJwZF9cIiArIGJpbmRpbmdJZCk7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihzdG10KSB7XG4gICAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gc3RtdC5leHByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCkge1xuICAgICAgICAgIHJldHVybiBzdG10LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVRvUmVuZGVyZXIodmlldywgYm91bmRQcm9wLCByZW5kZXJFbGVtZW50LCByZW5kZXJWYWx1ZSwgbG9nQmluZGluZ1VwZGF0ZSwgc2VjdXJpdHlDb250ZXh0RXhwcmVzc2lvbikge1xuICAgICAgdmFyIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICB2YXIgcmVuZGVyZXIgPSB2aWV3LnByb3AoJ3JlbmRlcmVyJyk7XG4gICAgICByZW5kZXJWYWx1ZSA9IHNhbml0aXplZFZhbHVlKHZpZXcsIGJvdW5kUHJvcCwgcmVuZGVyVmFsdWUsIHNlY3VyaXR5Q29udGV4dEV4cHJlc3Npb24pO1xuICAgICAgc3dpdGNoIChib3VuZFByb3AudHlwZSkge1xuICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5OlxuICAgICAgICAgICAgICBpZiAobG9nQmluZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLnNldEJpbmRpbmdEZWJ1Z0luZm8pKVxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW3JlbmRlcmVyLCByZW5kZXJFbGVtZW50LCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChyZW5kZXJlclxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRQcm9wZXJ0eScsIFtyZW5kZXJFbGVtZW50LCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlOlxuICAgICAgICAgICAgICByZW5kZXJWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICByZW5kZXJWYWx1ZS5pc0JsYW5rKCkuY29uZGl0aW9uYWwoTlVMTF9FWFBSLCByZW5kZXJWYWx1ZS5jYWxsTWV0aG9kKCd0b1N0cmluZycsIFtdKSk7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2gocmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdzZXRFbGVtZW50QXR0cmlidXRlJywgW3JlbmRlckVsZW1lbnQsIGxpdGVyYWwoYm91bmRQcm9wLm5hbWUpLCByZW5kZXJWYWx1ZV0pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzczpcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChyZW5kZXJlclxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRDbGFzcycsIFtyZW5kZXJFbGVtZW50LCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU6XG4gICAgICAgICAgICAgIHZhciBzdHJWYWx1ZSA9IHJlbmRlclZhbHVlLmNhbGxNZXRob2QoJ3RvU3RyaW5nJywgW10pO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGJvdW5kUHJvcC51bml0KSkge1xuICAgICAgICAgICAgICAgICAgc3RyVmFsdWUgPSBzdHJWYWx1ZS5wbHVzKGxpdGVyYWwoYm91bmRQcm9wLnVuaXQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZW5kZXJWYWx1ZSA9IHJlbmRlclZhbHVlLmlzQmxhbmsoKS5jb25kaXRpb25hbChOVUxMX0VYUFIsIHN0clZhbHVlKTtcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChyZW5kZXJlclxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRTdHlsZScsIFtyZW5kZXJFbGVtZW50LCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgc3RhdGU6IFNob3VsZCBub3QgY29tZSBoZXJlIScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVN0bXRzO1xuICB9XG4gIGZ1bmN0aW9uIHNhbml0aXplZFZhbHVlKHZpZXcsIGJvdW5kUHJvcCwgcmVuZGVyVmFsdWUsIHNlY3VyaXR5Q29udGV4dEV4cHJlc3Npb24pIHtcbiAgICAgIGlmIChib3VuZFByb3Auc2VjdXJpdHlDb250ZXh0ID09PSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlclZhbHVlOyAvLyBObyBzYW5pdGl6YXRpb24gbmVlZGVkLlxuICAgICAgfVxuICAgICAgaWYgKCFib3VuZFByb3AubmVlZHNSdW50aW1lU2VjdXJpdHlDb250ZXh0KSB7XG4gICAgICAgICAgc2VjdXJpdHlDb250ZXh0RXhwcmVzc2lvbiA9XG4gICAgICAgICAgICAgIGNyZWF0ZUVudW1FeHByZXNzaW9uKElkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCwgYm91bmRQcm9wLnNlY3VyaXR5Q29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAoIXNlY3VyaXR5Q29udGV4dEV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvciwgbm8gU2VjdXJpdHlDb250ZXh0IGdpdmVuIFwiICsgYm91bmRQcm9wLm5hbWUpO1xuICAgICAgfVxuICAgICAgdmFyIGN0eCA9IHZpZXcucHJvcCgndmlld1V0aWxzJykucHJvcCgnc2FuaXRpemVyJyk7XG4gICAgICB2YXIgYXJncyA9IFtzZWN1cml0eUNvbnRleHRFeHByZXNzaW9uLCByZW5kZXJWYWx1ZV07XG4gICAgICByZXR1cm4gY3R4LmNhbGxNZXRob2QoJ3Nhbml0aXplJywgYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlckFuaW1hdGlvbih2aWV3LCBjb21wb25lbnRWaWV3LCBib3VuZFByb3AsIGV2ZW50TGlzdGVuZXIsIHJlbmRlckVsZW1lbnQsIHJlbmRlclZhbHVlLCBsYXN0UmVuZGVyVmFsdWUpIHtcbiAgICAgIHZhciBkZXRhY2hTdG10cyA9IFtdO1xuICAgICAgdmFyIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICB2YXIgYW5pbWF0aW9uTmFtZSA9IGJvdW5kUHJvcC5uYW1lO1xuICAgICAgdmFyIGFuaW1hdGlvbkZuRXhwciA9IGNvbXBvbmVudFZpZXcucHJvcCgnY29tcG9uZW50VHlwZScpLnByb3AoJ2FuaW1hdGlvbnMnKS5rZXkobGl0ZXJhbChhbmltYXRpb25OYW1lKSk7XG4gICAgICAvLyBpdCdzIGltcG9ydGFudCB0byBub3JtYWxpemUgdGhlIHZvaWQgdmFsdWUgYXMgYHZvaWRgIGV4cGxpY2l0bHlcbiAgICAgIC8vIHNvIHRoYXQgdGhlIHN0eWxlcyBkYXRhIGNhbiBiZSBvYnRhaW5lZCBmcm9tIHRoZSBzdHJpbmdtYXBcbiAgICAgIHZhciBlbXB0eVN0YXRlVmFsdWUgPSBsaXRlcmFsKEVNUFRZX0FOSU1BVElPTl9TVEFURSk7XG4gICAgICB2YXIgdW5pdGlhbGl6ZWRWYWx1ZSA9IGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVU5JTklUSUFMSVpFRCkpO1xuICAgICAgdmFyIGFuaW1hdGlvblRyYW5zaXRpb25WYXIgPSB2YXJpYWJsZSgnYW5pbWF0aW9uVHJhbnNpdGlvbl8nICsgYW5pbWF0aW9uTmFtZSk7XG4gICAgICB1cGRhdGVTdG10cy5wdXNoKGFuaW1hdGlvblRyYW5zaXRpb25WYXJcbiAgICAgICAgICAuc2V0KGFuaW1hdGlvbkZuRXhwci5jYWxsRm4oW1xuICAgICAgICAgIHZpZXcsIHJlbmRlckVsZW1lbnQsXG4gICAgICAgICAgbGFzdFJlbmRlclZhbHVlLmVxdWFscyh1bml0aWFsaXplZFZhbHVlKS5jb25kaXRpb25hbChlbXB0eVN0YXRlVmFsdWUsIGxhc3RSZW5kZXJWYWx1ZSksXG4gICAgICAgICAgcmVuZGVyVmFsdWUuZXF1YWxzKHVuaXRpYWxpemVkVmFsdWUpLmNvbmRpdGlvbmFsKGVtcHR5U3RhdGVWYWx1ZSwgcmVuZGVyVmFsdWUpXG4gICAgICBdKSlcbiAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgIGRldGFjaFN0bXRzLnB1c2goYW5pbWF0aW9uVHJhbnNpdGlvblZhclxuICAgICAgICAgIC5zZXQoYW5pbWF0aW9uRm5FeHByLmNhbGxGbihbdmlldywgcmVuZGVyRWxlbWVudCwgbGFzdFJlbmRlclZhbHVlLCBlbXB0eVN0YXRlVmFsdWVdKSlcbiAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgIHZhciByZWdpc3RlclN0bXRzID0gW1xuICAgICAgICAgIGFuaW1hdGlvblRyYW5zaXRpb25WYXJcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ29uU3RhcnQnLCBbZXZlbnRMaXN0ZW5lci5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQmluZCwgW3ZpZXcsIGxpdGVyYWwoQm91bmRFdmVudEFzdC5jYWxjRnVsbE5hbWUoYW5pbWF0aW9uTmFtZSwgbnVsbCwgJ3N0YXJ0JykpXSldKVxuICAgICAgICAgICAgICAudG9TdG10KCksXG4gICAgICAgICAgYW5pbWF0aW9uVHJhbnNpdGlvblZhclxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnb25Eb25lJywgW2V2ZW50TGlzdGVuZXIuY2FsbE1ldGhvZChCdWlsdGluTWV0aG9kLkJpbmQsIFt2aWV3LCBsaXRlcmFsKEJvdW5kRXZlbnRBc3QuY2FsY0Z1bGxOYW1lKGFuaW1hdGlvbk5hbWUsIG51bGwsICdkb25lJykpXSldKVxuICAgICAgICAgICAgICAudG9TdG10KCksXG4gICAgICBdO1xuICAgICAgdXBkYXRlU3RtdHMucHVzaC5hcHBseSh1cGRhdGVTdG10cywgcmVnaXN0ZXJTdG10cyk7XG4gICAgICBkZXRhY2hTdG10cy5wdXNoLmFwcGx5KGRldGFjaFN0bXRzLCByZWdpc3RlclN0bXRzKTtcbiAgICAgIHJldHVybiB7IHVwZGF0ZVN0bXRzOiB1cGRhdGVTdG10cywgZGV0YWNoU3RtdHM6IGRldGFjaFN0bXRzIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNsYXNzIHN0bXRzIGJhc2VkIG9uIHRoZSBnaXZlbiBkYXRhLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3NTdG10KGNvbmZpZykge1xuICAgICAgdmFyIHBhcmVudEFyZ3MgPSBjb25maWcucGFyZW50QXJncyB8fCBbXTtcbiAgICAgIHZhciBzdXBlckN0b3JTdG10cyA9IGNvbmZpZy5wYXJlbnQgPyBbU1VQRVJfRVhQUi5jYWxsRm4ocGFyZW50QXJncykudG9TdG10KCldIDogW107XG4gICAgICB2YXIgYnVpbGRlciA9IGNvbmNhdENsYXNzQnVpbGRlclBhcnRzKEFycmF5LmlzQXJyYXkoY29uZmlnLmJ1aWxkZXJzKSA/IGNvbmZpZy5idWlsZGVycyA6IFtjb25maWcuYnVpbGRlcnNdKTtcbiAgICAgIHZhciBjdG9yID0gbmV3IENsYXNzTWV0aG9kKG51bGwsIGNvbmZpZy5jdG9yUGFyYW1zIHx8IFtdLCBzdXBlckN0b3JTdG10cy5jb25jYXQoYnVpbGRlci5jdG9yU3RtdHMpKTtcbiAgICAgIHJldHVybiBuZXcgQ2xhc3NTdG10KGNvbmZpZy5uYW1lLCBjb25maWcucGFyZW50LCBidWlsZGVyLmZpZWxkcywgYnVpbGRlci5nZXR0ZXJzLCBjdG9yLCBidWlsZGVyLm1ldGhvZHMsIGNvbmZpZy5tb2RpZmllcnMgfHwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIGNvbmNhdENsYXNzQnVpbGRlclBhcnRzKGJ1aWxkZXJzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGZpZWxkczogKF9hID0gW10pLmNvbmNhdC5hcHBseShfYSwgYnVpbGRlcnMubWFwKGZ1bmN0aW9uIChidWlsZGVyKSB7IHJldHVybiBidWlsZGVyLmZpZWxkcyB8fCBbXTsgfSkpLFxuICAgICAgICAgIG1ldGhvZHM6IChfYiA9IFtdKS5jb25jYXQuYXBwbHkoX2IsIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5tZXRob2RzIHx8IFtdOyB9KSksXG4gICAgICAgICAgZ2V0dGVyczogKF9jID0gW10pLmNvbmNhdC5hcHBseShfYywgYnVpbGRlcnMubWFwKGZ1bmN0aW9uIChidWlsZGVyKSB7IHJldHVybiBidWlsZGVyLmdldHRlcnMgfHwgW107IH0pKSxcbiAgICAgICAgICBjdG9yU3RtdHM6IChfZCA9IFtdKS5jb25jYXQuYXBwbHkoX2QsIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5jdG9yU3RtdHMgfHwgW107IH0pKSxcbiAgICAgIH07XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIH1cblxuICB2YXIgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgZGlyV3JhcHBlckNsYXNzVmFyKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgICB0aGlzLmRpcldyYXBwZXJDbGFzc1ZhciA9IGRpcldyYXBwZXJDbGFzc1ZhcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIENPTlRFWFRfRklFTERfTkFNRSA9ICdjb250ZXh0JztcbiAgdmFyIENIQU5HRVNfRklFTERfTkFNRSA9ICdfY2hhbmdlcyc7XG4gIHZhciBDSEFOR0VEX0ZJRUxEX05BTUUgPSAnX2NoYW5nZWQnO1xuICB2YXIgRVZFTlRfSEFORExFUl9GSUVMRF9OQU1FID0gJ19ldmVudEhhbmRsZXInO1xuICB2YXIgQ1VSUl9WQUxVRV9WQVIgPSB2YXJpYWJsZSgnY3VyclZhbHVlJyk7XG4gIHZhciBUSFJPV19PTl9DSEFOR0VfVkFSID0gdmFyaWFibGUoJ3Rocm93T25DaGFuZ2UnKTtcbiAgdmFyIEZPUkNFX1VQREFURV9WQVIgPSB2YXJpYWJsZSgnZm9yY2VVcGRhdGUnKTtcbiAgdmFyIFZJRVdfVkFSID0gdmFyaWFibGUoJ3ZpZXcnKTtcbiAgdmFyIENPTVBPTkVOVF9WSUVXX1ZBUiA9IHZhcmlhYmxlKCdjb21wb25lbnRWaWV3Jyk7XG4gIHZhciBSRU5ERVJfRUxfVkFSID0gdmFyaWFibGUoJ2VsJyk7XG4gIHZhciBFVkVOVF9OQU1FX1ZBUiA9IHZhcmlhYmxlKCdldmVudE5hbWUnKTtcbiAgdmFyIFJFU0VUX0NIQU5HRVNfU1RNVCA9IFRISVNfRVhQUi5wcm9wKENIQU5HRVNfRklFTERfTkFNRSkuc2V0KGxpdGVyYWxNYXAoW10pKS50b1N0bXQoKTtcbiAgLyoqXG4gICAqIFdlIGdlbmVyYXRlIGRpcmVjdGl2ZSB3cmFwcGVycyB0byBwcmV2ZW50IGNvZGUgYmxvYXQgd2hlbiBhIGRpcmVjdGl2ZSBpcyB1c2VkLlxuICAgKiBBIGRpcmVjdGl2ZSB3cmFwcGVyIGVuY2Fwc3VsYXRlc1xuICAgKiB0aGUgZGlydHkgY2hlY2tpbmcgZm9yIGBASW5wdXRgLCB0aGUgaGFuZGxpbmcgb2YgYEBIb3N0TGlzdGVuZXJgIC8gYEBIb3N0QmluZGluZ2BcbiAgICogYW5kIGNhbGxpbmcgdGhlIGxpZmVjeWNsZWhvb2tzIGBuZ09uSW5pdGAsIGBuZ09uQ2hhbmdlc2AsIGBuZ0RvQ2hlY2tgLlxuICAgKlxuICAgKiBTbyBmYXIsIG9ubHkgYEBJbnB1dGAgYW5kIHRoZSBsaWZlY3ljbGUgaG9va3MgaGF2ZSBiZWVuIGltcGxlbWVudGVkLlxuICAgKi9cbiAgdmFyIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIoY29tcGlsZXJDb25maWcsIF9leHByUGFyc2VyLCBfc2NoZW1hUmVnaXN0cnksIF9jb25zb2xlKSB7XG4gICAgICAgICAgdGhpcy5jb21waWxlckNvbmZpZyA9IGNvbXBpbGVyQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICB9XG4gICAgICBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIuZGlyV3JhcHBlckNsYXNzTmFtZSA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gXCJXcmFwcGVyX1wiICsgaWQubmFtZTsgfTtcbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChkaXJNZXRhKSB7XG4gICAgICAgICAgdmFyIGhvc3RQYXJzZVJlc3VsdCA9IHBhcnNlSG9zdEJpbmRpbmdzKGRpck1ldGEsIHRoaXMuX2V4cHJQYXJzZXIsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5KTtcbiAgICAgICAgICByZXBvcnRQYXJzZUVycm9ycyhob3N0UGFyc2VSZXN1bHQuZXJyb3JzLCB0aGlzLl9jb25zb2xlKTtcbiAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBEaXJlY3RpdmVXcmFwcGVyQnVpbGRlcih0aGlzLmNvbXBpbGVyQ29uZmlnLCBkaXJNZXRhKTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLmlucHV0cykuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXRGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgYWRkQ2hlY2tJbnB1dE1ldGhvZChpbnB1dEZpZWxkTmFtZSwgYnVpbGRlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkTmdEb0NoZWNrTWV0aG9kKGJ1aWxkZXIpO1xuICAgICAgICAgIGFkZENoZWNrSG9zdE1ldGhvZChob3N0UGFyc2VSZXN1bHQuaG9zdFByb3BzLCBidWlsZGVyKTtcbiAgICAgICAgICBhZGRIYW5kbGVFdmVudE1ldGhvZChob3N0UGFyc2VSZXN1bHQuaG9zdExpc3RlbmVycywgYnVpbGRlcik7XG4gICAgICAgICAgYWRkU3Vic2NyaWJlTWV0aG9kKGRpck1ldGEsIGJ1aWxkZXIpO1xuICAgICAgICAgIHZhciBjbGFzc1N0bXQgPSBidWlsZGVyLmJ1aWxkKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZVJlc3VsdChbY2xhc3NTdG10XSwgY2xhc3NTdG10Lm5hbWUpO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICAgICAgICB7IHR5cGU6IFBhcnNlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbiAgICAgICAgICB7IHR5cGU6IENvbnNvbGUsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcjtcbiAgfSgpKTtcbiAgdmFyIERpcmVjdGl2ZVdyYXBwZXJCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVdyYXBwZXJCdWlsZGVyKGNvbXBpbGVyQ29uZmlnLCBkaXJNZXRhKSB7XG4gICAgICAgICAgdGhpcy5jb21waWxlckNvbmZpZyA9IGNvbXBpbGVyQ29uZmlnO1xuICAgICAgICAgIHRoaXMuZGlyTWV0YSA9IGRpck1ldGE7XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLm1ldGhvZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmN0b3JTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuZGV0YWNoU3RtdHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lTdG10cyA9IFtdO1xuICAgICAgICAgIHZhciBkaXJMaWZlY3ljbGVIb29rcyA9IGRpck1ldGEudHlwZS5saWZlY3ljbGVIb29rcztcbiAgICAgICAgICB0aGlzLmdlbkNoYW5nZXMgPSBkaXJMaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcykgIT09IC0xIHx8XG4gICAgICAgICAgICAgIHRoaXMuY29tcGlsZXJDb25maWcubG9nQmluZGluZ1VwZGF0ZTtcbiAgICAgICAgICB0aGlzLm5nT25DaGFuZ2VzID0gZGlyTGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMpICE9PSAtMTtcbiAgICAgICAgICB0aGlzLm5nT25Jbml0ID0gZGlyTGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkluaXQpICE9PSAtMTtcbiAgICAgICAgICB0aGlzLm5nRG9DaGVjayA9IGRpckxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuRG9DaGVjaykgIT09IC0xO1xuICAgICAgICAgIHRoaXMubmdPbkRlc3Ryb3kgPSBkaXJMaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xO1xuICAgICAgICAgIGlmICh0aGlzLm5nT25EZXN0cm95KSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVzdHJveVN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKS5jYWxsTWV0aG9kKCduZ09uRGVzdHJveScsIFtdKS50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgRGlyZWN0aXZlV3JhcHBlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkaXJEZXBQYXJhbU5hbWVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpck1ldGEudHlwZS5kaURlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZGlyRGVwUGFyYW1OYW1lcy5wdXNoKFwicFwiICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZXRob2RzID0gW1xuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ25nT25EZXRhY2gnLCBbXG4gICAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShWSUVXX1ZBUi5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcFZpZXcpLCBbRFlOQU1JQ19UWVBFXSkpLFxuICAgICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oQ09NUE9ORU5UX1ZJRVdfVkFSLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShSRU5ERVJfRUxfVkFSLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIF0sIHRoaXMuZGV0YWNoU3RtdHMpLFxuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ25nT25EZXN0cm95JywgW10sIHRoaXMuZGVzdHJveVN0bXRzKSxcbiAgICAgICAgICBdO1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAgICAgICAgIG5ldyBDbGFzc0ZpZWxkKEVWRU5UX0hBTkRMRVJfRklFTERfTkFNRSwgRlVOQ1RJT05fVFlQRSwgW1N0bXRNb2RpZmllci5Qcml2YXRlXSksXG4gICAgICAgICAgICAgIG5ldyBDbGFzc0ZpZWxkKENPTlRFWFRfRklFTERfTkFNRSwgaW1wb3J0VHlwZSh0aGlzLmRpck1ldGEudHlwZSkpLFxuICAgICAgICAgICAgICBuZXcgQ2xhc3NGaWVsZChDSEFOR0VEX0ZJRUxEX05BTUUsIEJPT0xfVFlQRSwgW1N0bXRNb2RpZmllci5Qcml2YXRlXSksXG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgY3RvclN0bXRzID0gW1RISVNfRVhQUi5wcm9wKENIQU5HRURfRklFTERfTkFNRSkuc2V0KGxpdGVyYWwoZmFsc2UpKS50b1N0bXQoKV07XG4gICAgICAgICAgaWYgKHRoaXMuZ2VuQ2hhbmdlcykge1xuICAgICAgICAgICAgICBmaWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChDSEFOR0VTX0ZJRUxEX05BTUUsIG5ldyBNYXBUeXBlKERZTkFNSUNfVFlQRSksIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgICAgICAgICAgY3RvclN0bXRzLnB1c2goUkVTRVRfQ0hBTkdFU19TVE1UKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3RvclN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKVxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIodGhpcy5kaXJNZXRhLnR5cGUpXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZShkaXJEZXBQYXJhbU5hbWVzLm1hcChmdW5jdGlvbiAocGFyYW1OYW1lKSB7IHJldHVybiB2YXJpYWJsZShwYXJhbU5hbWUpOyB9KSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNsYXNzU3RtdCh7XG4gICAgICAgICAgICAgIG5hbWU6IERpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5kaXJXcmFwcGVyQ2xhc3NOYW1lKHRoaXMuZGlyTWV0YS50eXBlKSxcbiAgICAgICAgICAgICAgY3RvclBhcmFtczogZGlyRGVwUGFyYW1OYW1lcy5tYXAoZnVuY3Rpb24gKHBhcmFtTmFtZSkgeyByZXR1cm4gbmV3IEZuUGFyYW0ocGFyYW1OYW1lLCBEWU5BTUlDX1RZUEUpOyB9KSxcbiAgICAgICAgICAgICAgYnVpbGRlcnM6IFt7IGZpZWxkczogZmllbGRzLCBjdG9yU3RtdHM6IGN0b3JTdG10cywgbWV0aG9kczogbWV0aG9kcyB9LCB0aGlzXVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVXcmFwcGVyQnVpbGRlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gYWRkTmdEb0NoZWNrTWV0aG9kKGJ1aWxkZXIpIHtcbiAgICAgIHZhciBjaGFuZ2VkVmFyID0gdmFyaWFibGUoJ2NoYW5nZWQnKTtcbiAgICAgIHZhciBzdG10cyA9IFtcbiAgICAgICAgICBjaGFuZ2VkVmFyLnNldChUSElTX0VYUFIucHJvcChDSEFOR0VEX0ZJRUxEX05BTUUpKS50b0RlY2xTdG10KCksXG4gICAgICAgICAgVEhJU19FWFBSLnByb3AoQ0hBTkdFRF9GSUVMRF9OQU1FKS5zZXQobGl0ZXJhbChmYWxzZSkpLnRvU3RtdCgpLFxuICAgICAgXTtcbiAgICAgIHZhciBsaWZlY3ljbGVTdG10cyA9IFtdO1xuICAgICAgaWYgKGJ1aWxkZXIuZ2VuQ2hhbmdlcykge1xuICAgICAgICAgIHZhciBvbkNoYW5nZXNTdG10cyA9IFtdO1xuICAgICAgICAgIGlmIChidWlsZGVyLm5nT25DaGFuZ2VzKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlc1N0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKVxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ25nT25DaGFuZ2VzJywgW1RISVNfRVhQUi5wcm9wKENIQU5HRVNfRklFTERfTkFNRSldKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ1aWxkZXIuY29tcGlsZXJDb25maWcubG9nQmluZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgICBvbkNoYW5nZXNTdG10cy5wdXNoKGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXMpKVxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbVklFV19WQVIucHJvcCgncmVuZGVyZXInKSwgUkVOREVSX0VMX1ZBUiwgVEhJU19FWFBSLnByb3AoQ0hBTkdFU19GSUVMRF9OQU1FKV0pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbkNoYW5nZXNTdG10cy5wdXNoKFJFU0VUX0NIQU5HRVNfU1RNVCk7XG4gICAgICAgICAgbGlmZWN5Y2xlU3RtdHMucHVzaChuZXcgSWZTdG10KGNoYW5nZWRWYXIsIG9uQ2hhbmdlc1N0bXRzKSk7XG4gICAgICB9XG4gICAgICBpZiAoYnVpbGRlci5uZ09uSW5pdCkge1xuICAgICAgICAgIGxpZmVjeWNsZVN0bXRzLnB1c2gobmV3IElmU3RtdChWSUVXX1ZBUi5wcm9wKCdudW1iZXJPZkNoZWNrcycpLmlkZW50aWNhbChuZXcgTGl0ZXJhbEV4cHIoMCkpLCBbVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKS5jYWxsTWV0aG9kKCduZ09uSW5pdCcsIFtdKS50b1N0bXQoKV0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChidWlsZGVyLm5nRG9DaGVjaykge1xuICAgICAgICAgIGxpZmVjeWNsZVN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKS5jYWxsTWV0aG9kKCduZ0RvQ2hlY2snLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICAgICAgaWYgKGxpZmVjeWNsZVN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdG10cy5wdXNoKG5ldyBJZlN0bXQobm90KFRIUk9XX09OX0NIQU5HRV9WQVIpLCBsaWZlY3ljbGVTdG10cykpO1xuICAgICAgfVxuICAgICAgc3RtdHMucHVzaChuZXcgUmV0dXJuU3RhdGVtZW50KGNoYW5nZWRWYXIpKTtcbiAgICAgIGJ1aWxkZXIubWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZCgnbmdEb0NoZWNrJywgW1xuICAgICAgICAgIG5ldyBGblBhcmFtKFZJRVdfVkFSLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0VMX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFRIUk9XX09OX0NIQU5HRV9WQVIubmFtZSwgQk9PTF9UWVBFKSxcbiAgICAgIF0sIHN0bXRzLCBCT09MX1RZUEUpKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRDaGVja0lucHV0TWV0aG9kKGlucHV0LCBidWlsZGVyKSB7XG4gICAgICB2YXIgZmllbGQgPSBjcmVhdGVDaGVja0JpbmRpbmdGaWVsZChidWlsZGVyKTtcbiAgICAgIHZhciBvbkNoYW5nZVN0YXRlbWVudHMgPSBbXG4gICAgICAgICAgVEhJU19FWFBSLnByb3AoQ0hBTkdFRF9GSUVMRF9OQU1FKS5zZXQobGl0ZXJhbCh0cnVlKSkudG9TdG10KCksXG4gICAgICAgICAgVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKS5wcm9wKGlucHV0KS5zZXQoQ1VSUl9WQUxVRV9WQVIpLnRvU3RtdCgpLFxuICAgICAgXTtcbiAgICAgIGlmIChidWlsZGVyLmdlbkNoYW5nZXMpIHtcbiAgICAgICAgICBvbkNoYW5nZVN0YXRlbWVudHMucHVzaChUSElTX0VYUFIucHJvcChDSEFOR0VTX0ZJRUxEX05BTUUpXG4gICAgICAgICAgICAgIC5rZXkobGl0ZXJhbChpbnB1dCkpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TaW1wbGVDaGFuZ2UpKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW2ZpZWxkLmV4cHJlc3Npb24sIENVUlJfVkFMVUVfVkFSXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICB9XG4gICAgICB2YXIgbWV0aG9kQm9keSA9IGNyZWF0ZUNoZWNrQmluZGluZ1N0bXQoeyBjdXJyVmFsRXhwcjogQ1VSUl9WQUxVRV9WQVIsIGZvcmNlVXBkYXRlOiBGT1JDRV9VUERBVEVfVkFSLCBzdG10czogW10gfSwgZmllbGQuZXhwcmVzc2lvbiwgVEhST1dfT05fQ0hBTkdFX1ZBUiwgb25DaGFuZ2VTdGF0ZW1lbnRzKTtcbiAgICAgIGJ1aWxkZXIubWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZChcImNoZWNrX1wiICsgaW5wdXQsIFtcbiAgICAgICAgICBuZXcgRm5QYXJhbShDVVJSX1ZBTFVFX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFRIUk9XX09OX0NIQU5HRV9WQVIubmFtZSwgQk9PTF9UWVBFKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShGT1JDRV9VUERBVEVfVkFSLm5hbWUsIEJPT0xfVFlQRSksXG4gICAgICBdLCBtZXRob2RCb2R5KSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkQ2hlY2tIb3N0TWV0aG9kKGhvc3RQcm9wcywgYnVpbGRlcikge1xuICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICB2YXIgbWV0aG9kUGFyYW1zID0gW1xuICAgICAgICAgIG5ldyBGblBhcmFtKFZJRVdfVkFSLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oQ09NUE9ORU5UX1ZJRVdfVkFSLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0VMX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFRIUk9XX09OX0NIQU5HRV9WQVIubmFtZSwgQk9PTF9UWVBFKSxcbiAgICAgIF07XG4gICAgICBob3N0UHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdFByb3AsIGhvc3RQcm9wSWR4KSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY3JlYXRlQ2hlY2tCaW5kaW5nRmllbGQoYnVpbGRlcik7XG4gICAgICAgICAgdmFyIGV2YWxSZXN1bHQgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKGJ1aWxkZXIsIG51bGwsIFRISVNfRVhQUi5wcm9wKENPTlRFWFRfRklFTERfTkFNRSksIGhvc3RQcm9wLnZhbHVlLCBmaWVsZC5iaW5kaW5nSWQpO1xuICAgICAgICAgIGlmICghZXZhbFJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZWN1cml0eUNvbnRleHRFeHByO1xuICAgICAgICAgIGlmIChob3N0UHJvcC5uZWVkc1J1bnRpbWVTZWN1cml0eUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0RXhwciA9IHZhcmlhYmxlKFwic2VjQ3R4X1wiICsgbWV0aG9kUGFyYW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgIG1ldGhvZFBhcmFtcy5wdXNoKG5ldyBGblBhcmFtKHNlY3VyaXR5Q29udGV4dEV4cHIubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TZWN1cml0eUNvbnRleHQpKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hlY2tCaW5kaW5nU3RtdHM7XG4gICAgICAgICAgaWYgKGhvc3RQcm9wLmlzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBfYSA9IHRyaWdnZXJBbmltYXRpb24oVklFV19WQVIsIENPTVBPTkVOVF9WSUVXX1ZBUiwgaG9zdFByb3AsIFRISVNfRVhQUi5wcm9wKEVWRU5UX0hBTkRMRVJfRklFTERfTkFNRSlcbiAgICAgICAgICAgICAgICAgIC5vcihpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLm5vb3ApKSksIFJFTkRFUl9FTF9WQVIsIGV2YWxSZXN1bHQuY3VyclZhbEV4cHIsIGZpZWxkLmV4cHJlc3Npb24pLCB1cGRhdGVTdG10cyA9IF9hLnVwZGF0ZVN0bXRzLCBkZXRhY2hTdG10cyA9IF9hLmRldGFjaFN0bXRzO1xuICAgICAgICAgICAgICBjaGVja0JpbmRpbmdTdG10cyA9IHVwZGF0ZVN0bXRzO1xuICAgICAgICAgICAgICAoX2IgPSBidWlsZGVyLmRldGFjaFN0bXRzKS5wdXNoLmFwcGx5KF9iLCBkZXRhY2hTdG10cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjaGVja0JpbmRpbmdTdG10cyA9IHdyaXRlVG9SZW5kZXJlcihWSUVXX1ZBUiwgaG9zdFByb3AsIFJFTkRFUl9FTF9WQVIsIGV2YWxSZXN1bHQuY3VyclZhbEV4cHIsIGJ1aWxkZXIuY29tcGlsZXJDb25maWcubG9nQmluZGluZ1VwZGF0ZSwgc2VjdXJpdHlDb250ZXh0RXhwcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0bXRzLnB1c2guYXBwbHkoc3RtdHMsIGNyZWF0ZUNoZWNrQmluZGluZ1N0bXQoZXZhbFJlc3VsdCwgZmllbGQuZXhwcmVzc2lvbiwgVEhST1dfT05fQ0hBTkdFX1ZBUiwgY2hlY2tCaW5kaW5nU3RtdHMpKTtcbiAgICAgICAgICB2YXIgX2I7XG4gICAgICB9KTtcbiAgICAgIGJ1aWxkZXIubWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZCgnY2hlY2tIb3N0JywgbWV0aG9kUGFyYW1zLCBzdG10cykpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEhhbmRsZUV2ZW50TWV0aG9kKGhvc3RMaXN0ZW5lcnMsIGJ1aWxkZXIpIHtcbiAgICAgIHZhciByZXN1bHRWYXIgPSB2YXJpYWJsZShcInJlc3VsdFwiKTtcbiAgICAgIHZhciBhY3Rpb25TdG10cyA9IFtyZXN1bHRWYXIuc2V0KGxpdGVyYWwodHJ1ZSkpLnRvRGVjbFN0bXQoQk9PTF9UWVBFKV07XG4gICAgICBob3N0TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RMaXN0ZW5lciwgZXZlbnRJZHgpIHtcbiAgICAgICAgICB2YXIgZXZhbFJlc3VsdCA9IGNvbnZlcnRBY3Rpb25CaW5kaW5nKGJ1aWxkZXIsIG51bGwsIFRISVNfRVhQUi5wcm9wKENPTlRFWFRfRklFTERfTkFNRSksIGhvc3RMaXN0ZW5lci5oYW5kbGVyLCBcInN1Yl9cIiArIGV2ZW50SWR4KTtcbiAgICAgICAgICB2YXIgdHJ1ZVN0bXRzID0gZXZhbFJlc3VsdC5zdG10cztcbiAgICAgICAgICBpZiAoZXZhbFJlc3VsdC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICB0cnVlU3RtdHMucHVzaChyZXN1bHRWYXIuc2V0KGV2YWxSZXN1bHQucHJldmVudERlZmF1bHQuYW5kKHJlc3VsdFZhcikpLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBjb252ZXJ0IHRoaXMgaW50byBhIGBzd2l0Y2hgIG9uY2Ugb3VyIE91dHB1dEFzdCBzdXBwb3J0cyBpdC5cbiAgICAgICAgICBhY3Rpb25TdG10cy5wdXNoKG5ldyBJZlN0bXQoRVZFTlRfTkFNRV9WQVIuZXF1YWxzKGxpdGVyYWwoaG9zdExpc3RlbmVyLmZ1bGxOYW1lKSksIHRydWVTdG10cykpO1xuICAgICAgfSk7XG4gICAgICBhY3Rpb25TdG10cy5wdXNoKG5ldyBSZXR1cm5TdGF0ZW1lbnQocmVzdWx0VmFyKSk7XG4gICAgICBidWlsZGVyLm1ldGhvZHMucHVzaChuZXcgQ2xhc3NNZXRob2QoJ2hhbmRsZUV2ZW50JywgW1xuICAgICAgICAgIG5ldyBGblBhcmFtKEVWRU5UX05BTUVfVkFSLm5hbWUsIFNUUklOR19UWVBFKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUsIERZTkFNSUNfVFlQRSlcbiAgICAgIF0sIGFjdGlvblN0bXRzLCBCT09MX1RZUEUpKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRTdWJzY3JpYmVNZXRob2QoZGlyTWV0YSwgYnVpbGRlcikge1xuICAgICAgdmFyIG1ldGhvZFBhcmFtcyA9IFtcbiAgICAgICAgICBuZXcgRm5QYXJhbShWSUVXX1ZBUi5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcFZpZXcpLCBbRFlOQU1JQ19UWVBFXSkpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKEVWRU5UX0hBTkRMRVJfRklFTERfTkFNRSwgRFlOQU1JQ19UWVBFKVxuICAgICAgXTtcbiAgICAgIHZhciBzdG10cyA9IFtcbiAgICAgICAgICBUSElTX0VYUFIucHJvcChFVkVOVF9IQU5ETEVSX0ZJRUxEX05BTUUpLnNldCh2YXJpYWJsZShFVkVOVF9IQU5ETEVSX0ZJRUxEX05BTUUpKS50b1N0bXQoKVxuICAgICAgXTtcbiAgICAgIE9iamVjdC5rZXlzKGRpck1ldGEub3V0cHV0cykuZm9yRWFjaChmdW5jdGlvbiAoZW1pdHRlclByb3BOYW1lLCBlbWl0dGVySWR4KSB7XG4gICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGRpck1ldGEub3V0cHV0c1tlbWl0dGVyUHJvcE5hbWVdO1xuICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBcImVtaXRcIiArIGVtaXR0ZXJJZHg7XG4gICAgICAgICAgbWV0aG9kUGFyYW1zLnB1c2gobmV3IEZuUGFyYW0ocGFyYW1OYW1lLCBCT09MX1RZUEUpKTtcbiAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uRmllbGROYW1lID0gXCJzdWJzY3JpcHRpb25cIiArIGVtaXR0ZXJJZHg7XG4gICAgICAgICAgYnVpbGRlci5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChzdWJzY3JpcHRpb25GaWVsZE5hbWUsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3IElmU3RtdCh2YXJpYWJsZShwYXJhbU5hbWUpLCBbXG4gICAgICAgICAgICAgIFRISVNfRVhQUi5wcm9wKHN1YnNjcmlwdGlvbkZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgIC5zZXQoVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKVxuICAgICAgICAgICAgICAgICAgLnByb3AoZW1pdHRlclByb3BOYW1lKVxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlLCBbdmFyaWFibGUoRVZFTlRfSEFORExFUl9GSUVMRF9OQU1FKVxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQmluZCwgW1ZJRVdfVkFSLCBsaXRlcmFsKGV2ZW50TmFtZSldKV0pKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpXG4gICAgICAgICAgXSkpO1xuICAgICAgICAgIGJ1aWxkZXIuZGVzdHJveVN0bXRzLnB1c2goVEhJU19FWFBSLnByb3Aoc3Vic2NyaXB0aW9uRmllbGROYW1lKVxuICAgICAgICAgICAgICAuYW5kKFRISVNfRVhQUi5wcm9wKHN1YnNjcmlwdGlvbkZpZWxkTmFtZSkuY2FsbE1ldGhvZCgndW5zdWJzY3JpYmUnLCBbXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICB9KTtcbiAgICAgIGJ1aWxkZXIubWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZCgnc3Vic2NyaWJlJywgbWV0aG9kUGFyYW1zLCBzdG10cykpO1xuICB9XG4gIHZhciBQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZVJlc3VsdChob3N0UHJvcHMsIGhvc3RMaXN0ZW5lcnMsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMuaG9zdFByb3BzID0gaG9zdFByb3BzO1xuICAgICAgICAgIHRoaXMuaG9zdExpc3RlbmVycyA9IGhvc3RMaXN0ZW5lcnM7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VSZXN1bHQ7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIHBhcnNlSG9zdEJpbmRpbmdzKGRpck1ldGEsIGV4cHJQYXJzZXIsIHNjaGVtYVJlZ2lzdHJ5KSB7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IEJpbmRpbmdQYXJzZXIoZXhwclBhcnNlciwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgc2NoZW1hUmVnaXN0cnksIFtdLCBlcnJvcnMpO1xuICAgICAgdmFyIHNvdXJjZUZpbGVOYW1lID0gZGlyTWV0YS50eXBlLm1vZHVsZVVybCA/XG4gICAgICAgICAgXCJpbiBEaXJlY3RpdmUgXCIgKyBkaXJNZXRhLnR5cGUubmFtZSArIFwiIGluIFwiICsgZGlyTWV0YS50eXBlLm1vZHVsZVVybCA6XG4gICAgICAgICAgXCJpbiBEaXJlY3RpdmUgXCIgKyBkaXJNZXRhLnR5cGUubmFtZTtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIG51bGwsIG51bGwsIG51bGwpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCBudWxsLCBudWxsLCBudWxsKSk7XG4gICAgICB2YXIgcGFyc2VkSG9zdFByb3BzID0gcGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMoZGlyTWV0YS50b1N1bW1hcnkoKSwgc291cmNlU3Bhbik7XG4gICAgICB2YXIgcGFyc2VkSG9zdExpc3RlbmVycyA9IHBhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0RXZlbnRBc3RzKGRpck1ldGEudG9TdW1tYXJ5KCksIHNvdXJjZVNwYW4pO1xuICAgICAgcmV0dXJuIG5ldyBQYXJzZVJlc3VsdChwYXJzZWRIb3N0UHJvcHMsIHBhcnNlZEhvc3RMaXN0ZW5lcnMsIGVycm9ycyk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwb3J0UGFyc2VFcnJvcnMocGFyc2VFcnJvcnMsIGNvbnNvbGUpIHtcbiAgICAgIHZhciB3YXJuaW5ncyA9IHBhcnNlRXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yLmxldmVsID09PSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HOyB9KTtcbiAgICAgIHZhciBlcnJvcnMgPSBwYXJzZUVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRkFUQUw7IH0pO1xuICAgICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oXCJEaXJlY3RpdmUgcGFyc2Ugd2FybmluZ3M6XFxuXCIgKyB3YXJuaW5ncy5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXJlY3RpdmUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgfVxuICB2YXIgRGlyZWN0aXZlV3JhcHBlckV4cHJlc3Npb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVdyYXBwZXJFeHByZXNzaW9ucygpIHtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJFeHByZXNzaW9ucy5jcmVhdGUgPSBmdW5jdGlvbiAoZGlyLCBkZXBzRXhwcikge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKGRpcikuaW5zdGFudGlhdGUoZGVwc0V4cHIsIGltcG9ydFR5cGUoZGlyKSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlV3JhcHBlckV4cHJlc3Npb25zLmNvbnRleHQgPSBmdW5jdGlvbiAoZGlyV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiBkaXJXcmFwcGVyLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVXcmFwcGVyRXhwcmVzc2lvbnMubmdEb0NoZWNrID0gZnVuY3Rpb24gKGRpcldyYXBwZXIsIHZpZXcsIHJlbmRlckVsZW1lbnQsIHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gZGlyV3JhcHBlci5jYWxsTWV0aG9kKCduZ0RvQ2hlY2snLCBbdmlldywgcmVuZGVyRWxlbWVudCwgdGhyb3dPbkNoYW5nZV0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJFeHByZXNzaW9ucy5jaGVja0hvc3QgPSBmdW5jdGlvbiAoaG9zdFByb3BzLCBkaXJXcmFwcGVyLCB2aWV3LCBjb21wb25lbnRWaWV3LCByZW5kZXJFbGVtZW50LCB0aHJvd09uQ2hhbmdlLCBydW50aW1lU2VjdXJpdHlDb250ZXh0cykge1xuICAgICAgICAgIGlmIChob3N0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbZGlyV3JhcHBlclxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdjaGVja0hvc3QnLCBbdmlldywgY29tcG9uZW50VmlldywgcmVuZGVyRWxlbWVudCwgdGhyb3dPbkNoYW5nZV0uY29uY2F0KHJ1bnRpbWVTZWN1cml0eUNvbnRleHRzKSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVXcmFwcGVyRXhwcmVzc2lvbnMubmdPbkRldGFjaCA9IGZ1bmN0aW9uIChob3N0UHJvcHMsIGRpcldyYXBwZXIsIHZpZXcsIGNvbXBvbmVudFZpZXcsIHJlbmRlckVsKSB7XG4gICAgICAgICAgaWYgKGhvc3RQcm9wcy5zb21lKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wLmlzQW5pbWF0aW9uOyB9KSkge1xuICAgICAgICAgICAgICByZXR1cm4gW2RpcldyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnbmdPbkRldGFjaCcsIFtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRWwsXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJFeHByZXNzaW9ucy5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uIChkaXIsIGRpcldyYXBwZXIpIHtcbiAgICAgICAgICBpZiAoZGlyLnR5cGUubGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3kpICE9PSAtMSB8fFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkaXIub3V0cHV0cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2RpcldyYXBwZXIuY2FsbE1ldGhvZCgnbmdPbkRlc3Ryb3knLCBbXSkudG9TdG10KCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVXcmFwcGVyRXhwcmVzc2lvbnMuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGRpck1ldGEsIGhvc3RQcm9wcywgdXNlZEV2ZW50cywgZGlyV3JhcHBlciwgdmlldywgZXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIHZhciBuZWVkc1N1YnNjcmliZSA9IGZhbHNlO1xuICAgICAgICAgIHZhciBldmVudEZsYWdzID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5vdXRwdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZGlyTWV0YS5vdXRwdXRzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50VXNlZCA9IHVzZWRFdmVudHMuaW5kZXhPZihldmVudE5hbWUpID4gLTE7XG4gICAgICAgICAgICAgIG5lZWRzU3Vic2NyaWJlID0gbmVlZHNTdWJzY3JpYmUgfHwgZXZlbnRVc2VkO1xuICAgICAgICAgICAgICBldmVudEZsYWdzLnB1c2gobGl0ZXJhbChldmVudFVzZWQpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBob3N0UHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdFByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKGhvc3RQcm9wLmlzQW5pbWF0aW9uICYmIHVzZWRFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgbmVlZHNTdWJzY3JpYmUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG5lZWRzU3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICBkaXJXcmFwcGVyLmNhbGxNZXRob2QoJ3N1YnNjcmliZScsIFt2aWV3LCBldmVudExpc3RlbmVyXS5jb25jYXQoZXZlbnRGbGFncykpLnRvU3RtdCgpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJFeHByZXNzaW9ucy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChob3N0RXZlbnRzLCBkaXJXcmFwcGVyLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGRpcldyYXBwZXIuY2FsbE1ldGhvZCgnaGFuZGxlRXZlbnQnLCBbZXZlbnROYW1lLCBldmVudF0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVXcmFwcGVyRXhwcmVzc2lvbnM7XG4gIH0oKSk7XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlVG9PdXRwdXRBc3QodmFsdWUsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoKSwgdHlwZSk7XG4gIH1cbiAgdmFyIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKCkge1xuICAgICAgfVxuICAgICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB0eXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIG51bGwpOyB9KSwgdHlwZSk7XG4gICAgICB9O1xuICAgICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgdHlwZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBlbnRyaWVzLnB1c2goW2tleSwgdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIG51bGwpXSk7IH0pO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsTWFwKGVudHJpZXMsIHR5cGUpO1xuICAgICAgfTtcbiAgICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkgeyByZXR1cm4gbGl0ZXJhbCh2YWx1ZSwgdHlwZSk7IH07XG4gICAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogRG9uJ3Qgbm93IGhvdyB0byBjb21waWxlIHZhbHVlIFwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXI7XG4gIH0oKSk7XG5cbiAgdmFyIF9EZWJ1Z1N0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9EZWJ1Z1N0YXRlKG5vZGVJbmRleCwgc291cmNlQXN0KSB7XG4gICAgICAgICAgdGhpcy5ub2RlSW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VBc3QgPSBzb3VyY2VBc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gX0RlYnVnU3RhdGU7XG4gIH0oKSk7XG4gIHZhciBOVUxMX0RFQlVHX1NUQVRFID0gbmV3IF9EZWJ1Z1N0YXRlKG51bGwsIG51bGwpO1xuICB2YXIgQ29tcGlsZU1ldGhvZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlTWV0aG9kKF92aWV3KSB7XG4gICAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICAgIHRoaXMuX25ld1N0YXRlID0gTlVMTF9ERUJVR19TVEFURTtcbiAgICAgICAgICB0aGlzLl9jdXJyU3RhdGUgPSBOVUxMX0RFQlVHX1NUQVRFO1xuICAgICAgICAgIHRoaXMuX2JvZHlTdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgdGhpcy5fZGVidWdFbmFibGVkID0gdGhpcy5fdmlldy5nZW5Db25maWcuZ2VuRGVidWdJbmZvO1xuICAgICAgfVxuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuX3VwZGF0ZURlYnVnQ29udGV4dElmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9uZXdTdGF0ZS5ub2RlSW5kZXggIT09IHRoaXMuX2N1cnJTdGF0ZS5ub2RlSW5kZXggfHxcbiAgICAgICAgICAgICAgdGhpcy5fbmV3U3RhdGUuc291cmNlQXN0ICE9PSB0aGlzLl9jdXJyU3RhdGUuc291cmNlQXN0KSB7XG4gICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5fdXBkYXRlRGVidWdDb250ZXh0KHRoaXMuX25ld1N0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChleHByKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYm9keVN0YXRlbWVudHMucHVzaChleHByLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRGVidWdDb250ZXh0ID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgICAgdGhpcy5fY3VyclN0YXRlID0gdGhpcy5fbmV3U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy5fZGVidWdFbmFibGVkKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VMb2NhdGlvbiA9IGlzUHJlc2VudChuZXdTdGF0ZS5zb3VyY2VBc3QpID8gbmV3U3RhdGUuc291cmNlQXN0LnNvdXJjZVNwYW4uc3RhcnQgOiBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gVEhJU19FWFBSLmNhbGxNZXRob2QoJ2RlYnVnJywgW1xuICAgICAgICAgICAgICAgICAgbGl0ZXJhbChuZXdTdGF0ZS5ub2RlSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgaXNQcmVzZW50KHNvdXJjZUxvY2F0aW9uKSA/IGxpdGVyYWwoc291cmNlTG9jYXRpb24ubGluZSkgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgICBpc1ByZXNlbnQoc291cmNlTG9jYXRpb24pID8gbGl0ZXJhbChzb3VyY2VMb2NhdGlvbi5jb2wpIDogTlVMTF9FWFBSXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLnJlc2V0RGVidWdJbmZvRXhwciA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIHRlbXBsYXRlQXN0KSB7XG4gICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3VwZGF0ZURlYnVnQ29udGV4dChuZXcgX0RlYnVnU3RhdGUobm9kZUluZGV4LCB0ZW1wbGF0ZUFzdCkpO1xuICAgICAgICAgIHJldHVybiByZXMgfHwgTlVMTF9FWFBSO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLnJlc2V0RGVidWdJbmZvID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgdGVtcGxhdGVBc3QpIHtcbiAgICAgICAgICB0aGlzLl9uZXdTdGF0ZSA9IG5ldyBfRGVidWdTdGF0ZShub2RlSW5kZXgsIHRlbXBsYXRlQXN0KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdG10cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHN0bXRzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZFN0bXRzKHN0bXRzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5hZGRTdG10ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHRJZk5lZWRlZCgpO1xuICAgICAgICAgIHRoaXMuX2JvZHlTdGF0ZW1lbnRzLnB1c2goc3RtdCk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuYWRkU3RtdHMgPSBmdW5jdGlvbiAoc3RtdHMpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHRJZk5lZWRlZCgpO1xuICAgICAgICAgIChfYSA9IHRoaXMuX2JvZHlTdGF0ZW1lbnRzKS5wdXNoLmFwcGx5KF9hLCBzdG10cyk7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2JvZHlTdGF0ZW1lbnRzOyB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2JvZHlTdGF0ZW1lbnRzLmxlbmd0aCA9PT0gMDsgfTtcbiAgICAgIHJldHVybiBDb21waWxlTWV0aG9kO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0UHJvcGVydHlJblZpZXcocHJvcGVydHksIGNhbGxpbmdWaWV3LCBkZWZpbmVkVmlldykge1xuICAgICAgaWYgKGNhbGxpbmdWaWV3ID09PSBkZWZpbmVkVmlldykge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB2aWV3UHJvcCA9IFRISVNfRVhQUjtcbiAgICAgICAgICB2YXIgY3VyclZpZXcgPSBjYWxsaW5nVmlldztcbiAgICAgICAgICB3aGlsZSAoY3VyclZpZXcgIT09IGRlZmluZWRWaWV3ICYmIGlzUHJlc2VudChjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldykpIHtcbiAgICAgICAgICAgICAgY3VyclZpZXcgPSBjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldztcbiAgICAgICAgICAgICAgdmlld1Byb3AgPSB2aWV3UHJvcC5wcm9wKCdwYXJlbnRWaWV3Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyVmlldyAhPT0gZGVmaW5lZFZpZXcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IENvdWxkIG5vdCBjYWxjdWxhdGUgYSBwcm9wZXJ0eSBpbiBhIHBhcmVudCB2aWV3OiBcIiArIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5LnZpc2l0RXhwcmVzc2lvbihuZXcgX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXIodmlld1Byb3AsIGRlZmluZWRWaWV3KSwgbnVsbCk7XG4gICAgICB9XG4gIH1cbiAgdmFyIF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxNShfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyKF92aWV3RXhwciwgX3ZpZXcpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLl92aWV3RXhwciA9IF92aWV3RXhwcjtcbiAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICB9XG4gICAgICBfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lci5wcm90b3R5cGUuX2lzVGhpcyA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBleHByLmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuVGhpcztcbiAgICAgIH07XG4gICAgICBfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faXNUaGlzKGFzdCkgPyB0aGlzLl92aWV3RXhwciA6IGFzdDtcbiAgICAgIH07XG4gICAgICBfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzVGhpcyhhc3QucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IERvbid0IGNhc3QgZm9yIG1lbWJlcnMgb2YgdGhlIEFwcFZpZXcgYmFzZSBjbGFzcy4uLlxuICAgICAgICAgICAgICBpZiAodGhpcy5fdmlldy5maWVsZHMuc29tZShmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIGZpZWxkLm5hbWUgPT0gYXN0Lm5hbWU7IH0pIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLl92aWV3LmdldHRlcnMuc29tZShmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIGZpZWxkLm5hbWUgPT0gYXN0Lm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld0V4cHIuY2FzdCh0aGlzLl92aWV3LmNsYXNzVHlwZSkucHJvcChhc3QubmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIuY2FsbCh0aGlzLCBhc3QsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lcjtcbiAgfShFeHByZXNzaW9uVHJhbnNmb3JtZXIpKTtcbiAgZnVuY3Rpb24gaW5qZWN0RnJvbVZpZXdQYXJlbnRJbmplY3Rvcih2aWV3LCB0b2tlbiwgb3B0aW9uYWwpIHtcbiAgICAgIHZhciB2aWV3RXhwcjtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5IT1NUKSB7XG4gICAgICAgICAgdmlld0V4cHIgPSBUSElTX0VYUFI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2aWV3RXhwciA9IFRISVNfRVhQUi5wcm9wKCdwYXJlbnRWaWV3Jyk7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IFtjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbiksIFRISVNfRVhQUi5wcm9wKCdwYXJlbnRJbmRleCcpXTtcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgIGFyZ3MucHVzaChOVUxMX0VYUFIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZpZXdFeHByLmNhbGxNZXRob2QoJ2luamVjdG9yR2V0JywgYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Vmlld0NsYXNzTmFtZShjb21wb25lbnQsIGVtYmVkZGVkVGVtcGxhdGVJbmRleCkge1xuICAgICAgcmV0dXJuIFwiVmlld19cIiArIGNvbXBvbmVudC50eXBlLm5hbWUgKyBlbWJlZGRlZFRlbXBsYXRlSW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SGFuZGxlRXZlbnRNZXRob2ROYW1lKGVsZW1lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIFwiaGFuZGxlRXZlbnRfXCIgKyBlbGVtZW50SW5kZXg7XG4gIH1cblxuICB2YXIgVmlld1F1ZXJ5VmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdRdWVyeVZhbHVlcyh2aWV3LCB2YWx1ZXMpIHtcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFZpZXdRdWVyeVZhbHVlcztcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVRdWVyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlUXVlcnkobWV0YSwgcXVlcnlMaXN0LCBvd25lckRpcmVjdGl2ZUV4cHJlc3Npb24sIHZpZXcpIHtcbiAgICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICAgIHRoaXMucXVlcnlMaXN0ID0gcXVlcnlMaXN0O1xuICAgICAgICAgIHRoaXMub3duZXJEaXJlY3RpdmVFeHByZXNzaW9uID0gb3duZXJEaXJlY3RpdmVFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IFZpZXdRdWVyeVZhbHVlcyh2aWV3LCBbXSk7XG4gICAgICB9XG4gICAgICBDb21waWxlUXVlcnkucHJvdG90eXBlLmFkZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCB2aWV3KSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRWaWV3ID0gdmlldztcbiAgICAgICAgICB2YXIgZWxQYXRoID0gW107XG4gICAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjdXJyZW50VmlldykgJiYgY3VycmVudFZpZXcgIT09IHRoaXMudmlldykge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBjdXJyZW50Vmlldy5kZWNsYXJhdGlvbkVsZW1lbnQ7XG4gICAgICAgICAgICAgIGVsUGF0aC51bnNoaWZ0KHBhcmVudEVsKTtcbiAgICAgICAgICAgICAgY3VycmVudFZpZXcgPSBwYXJlbnRFbC52aWV3O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcXVlcnlMaXN0Rm9yRGlydHlFeHByID0gZ2V0UHJvcGVydHlJblZpZXcodGhpcy5xdWVyeUxpc3QsIHZpZXcsIHRoaXMudmlldyk7XG4gICAgICAgICAgdmFyIHZpZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgICAgZWxQYXRoLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0ID0gdmlld1ZhbHVlcy52YWx1ZXMubGVuZ3RoID4gMCA/IHZpZXdWYWx1ZXMudmFsdWVzW3ZpZXdWYWx1ZXMudmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXMgJiYgbGFzdC52aWV3ID09PSBlbC5lbWJlZGRlZFZpZXcpIHtcbiAgICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMgPSBsYXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZpZXdWYWx1ZXMgPSBuZXcgVmlld1F1ZXJ5VmFsdWVzKGVsLmVtYmVkZGVkVmlldywgW10pO1xuICAgICAgICAgICAgICAgICAgdmlld1ZhbHVlcy52YWx1ZXMucHVzaChuZXdWaWV3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMgPSBuZXdWaWV3VmFsdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlld1ZhbHVlcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGVsUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZpZXcuZGlydHlQYXJlbnRRdWVyaWVzTWV0aG9kLmFkZFN0bXQocXVlcnlMaXN0Rm9yRGlydHlFeHByLmNhbGxNZXRob2QoJ3NldERpcnR5JywgW10pLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVF1ZXJ5LnByb3RvdHlwZS5faXNTdGF0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLl92YWx1ZXMudmFsdWVzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFZpZXdRdWVyeVZhbHVlczsgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVF1ZXJ5LnByb3RvdHlwZS5hZnRlckNoaWxkcmVuID0gZnVuY3Rpb24gKHRhcmdldFN0YXRpY01ldGhvZCwgdGFyZ2V0RHluYW1pY01ldGhvZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBjcmVhdGVRdWVyeVZhbHVlcyh0aGlzLl92YWx1ZXMpO1xuICAgICAgICAgIHZhciB1cGRhdGVTdG10cyA9IFt0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdyZXNldCcsIFtsaXRlcmFsQXJyKHZhbHVlcyldKS50b1N0bXQoKV07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlRXhwciA9IHRoaXMubWV0YS5maXJzdCA/IHRoaXMucXVlcnlMaXN0LnByb3AoJ2ZpcnN0JykgOiB0aGlzLnF1ZXJ5TGlzdDtcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbi5wcm9wKHRoaXMubWV0YS5wcm9wZXJ0eU5hbWUpLnNldCh2YWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLm1ldGEuZmlyc3QpIHtcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdub3RpZnlPbkNoYW5nZXMnLCBbXSkudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5tZXRhLmZpcnN0ICYmIHRoaXMuX2lzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgLy8gZm9yIHF1ZXJpZXMgdGhhdCBkb24ndCBjaGFuZ2UgYW5kIHRoZSB1c2VyIGFza2VkIGZvciBhIHNpbmdsZSBlbGVtZW50LFxuICAgICAgICAgICAgICAvLyBzZXQgaXQgaW1tZWRpYXRlbHkuIFRoYXQgaXMgZS5nLiBuZWVkZWQgZm9yIHF1ZXJ5aW5nIGZvciBWaWV3Q29udGFpbmVyUmVmcywgLi4uXG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IGRvIHRoaXMgZm9yIFF1ZXJ5TGlzdHMgZm9yIG5vdyBhcyB0aGlzIHdvdWxkIGJyZWFrIHRoZSB0aW1pbmcgd2hlblxuICAgICAgICAgICAgICAvLyB3ZSBjYWxsIFF1ZXJ5TGlzdCBsaXN0ZW5lcnMuLi5cbiAgICAgICAgICAgICAgdGFyZ2V0U3RhdGljTWV0aG9kLmFkZFN0bXRzKHVwZGF0ZVN0bXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldER5bmFtaWNNZXRob2QuYWRkU3RtdChuZXcgSWZTdG10KHRoaXMucXVlcnlMaXN0LnByb3AoJ2RpcnR5JyksIHVwZGF0ZVN0bXRzKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlUXVlcnk7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5VmFsdWVzKHZpZXdWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBMaXN0V3JhcHBlci5mbGF0dGVuKHZpZXdWYWx1ZXMudmFsdWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcE5lc3RlZFZpZXdzKGVudHJ5LnZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnZpZXdDb250YWluZXIsIGVudHJ5LnZpZXcsIGNyZWF0ZVF1ZXJ5VmFsdWVzKGVudHJ5KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcE5lc3RlZFZpZXdzKHZpZXdDb250YWluZXIsIHZpZXcsIGV4cHJlc3Npb25zKSB7XG4gICAgICB2YXIgYWRqdXN0ZWRFeHByZXNzaW9ucyA9IGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gcmVwbGFjZVZhckluRXhwcmVzc2lvbihUSElTX0VYUFIubmFtZSwgdmFyaWFibGUoJ25lc3RlZFZpZXcnKSwgZXhwcik7IH0pO1xuICAgICAgcmV0dXJuIHZpZXdDb250YWluZXIuY2FsbE1ldGhvZCgnbWFwTmVzdGVkVmlld3MnLCBbXG4gICAgICAgICAgdmFyaWFibGUodmlldy5jbGFzc05hbWUpLFxuICAgICAgICAgIGZuKFtuZXcgRm5QYXJhbSgnbmVzdGVkVmlldycsIHZpZXcuY2xhc3NUeXBlKV0sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWxBcnIoYWRqdXN0ZWRFeHByZXNzaW9ucykpXSwgRFlOQU1JQ19UWVBFKVxuICAgICAgXSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUXVlcnlMaXN0KHF1ZXJ5LCBkaXJlY3RpdmVJbnN0YW5jZSwgcHJvcGVydHlOYW1lLCBjb21waWxlVmlldykge1xuICAgICAgY29tcGlsZVZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQocHJvcGVydHlOYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlF1ZXJ5TGlzdCksIFtEWU5BTUlDX1RZUEVdKSkpO1xuICAgICAgdmFyIGV4cHIgPSBUSElTX0VYUFIucHJvcChwcm9wZXJ0eU5hbWUpO1xuICAgICAgY29tcGlsZVZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVEhJU19FWFBSLnByb3AocHJvcGVydHlOYW1lKVxuICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5RdWVyeUxpc3QpLCBbRFlOQU1JQ19UWVBFXSlcbiAgICAgICAgICAuaW5zdGFudGlhdGUoW10pKVxuICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBmdW5jdGlvbiBhZGRRdWVyeVRvVG9rZW5NYXAobWFwLCBxdWVyeSkge1xuICAgICAgcXVlcnkubWV0YS5zZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KHNlbGVjdG9yLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICBlbnRyeSA9IFtdO1xuICAgICAgICAgICAgICBtYXAuc2V0KHNlbGVjdG9yLnJlZmVyZW5jZSwgZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnRyeS5wdXNoKHF1ZXJ5KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgdmFyIFZpZXdUeXBlRW51bSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3VHlwZUVudW0oKSB7XG4gICAgICB9XG4gICAgICBWaWV3VHlwZUVudW0uZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVudW1FeHByZXNzaW9uKElkZW50aWZpZXJzLlZpZXdUeXBlLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFZpZXdUeXBlRW51bTtcbiAgfSgpKTtcbiAgdmFyIFZpZXdFbmNhcHN1bGF0aW9uRW51bSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3RW5jYXBzdWxhdGlvbkVudW0oKSB7XG4gICAgICB9XG4gICAgICBWaWV3RW5jYXBzdWxhdGlvbkVudW0uZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVudW1FeHByZXNzaW9uKElkZW50aWZpZXJzLlZpZXdFbmNhcHN1bGF0aW9uLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFZpZXdFbmNhcHN1bGF0aW9uRW51bTtcbiAgfSgpKTtcbiAgdmFyIENoYW5nZURldGVjdG9yU3RhdHVzRW51bSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclN0YXR1c0VudW0oKSB7XG4gICAgICB9XG4gICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c0VudW0uZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVudW1FeHByZXNzaW9uKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yU3RhdHVzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENoYW5nZURldGVjdG9yU3RhdHVzRW51bTtcbiAgfSgpKTtcbiAgdmFyIFZpZXdDb25zdHJ1Y3RvclZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0NvbnN0cnVjdG9yVmFycygpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzID0gdmFyaWFibGUoJ3ZpZXdVdGlscycpO1xuICAgICAgVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRWaWV3ID0gdmFyaWFibGUoJ3BhcmVudFZpZXcnKTtcbiAgICAgIFZpZXdDb25zdHJ1Y3RvclZhcnMucGFyZW50SW5kZXggPSB2YXJpYWJsZSgncGFyZW50SW5kZXgnKTtcbiAgICAgIFZpZXdDb25zdHJ1Y3RvclZhcnMucGFyZW50RWxlbWVudCA9IHZhcmlhYmxlKCdwYXJlbnRFbGVtZW50Jyk7XG4gICAgICByZXR1cm4gVmlld0NvbnN0cnVjdG9yVmFycztcbiAgfSgpKTtcbiAgdmFyIFZpZXdQcm9wZXJ0aWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdQcm9wZXJ0aWVzKCkge1xuICAgICAgfVxuICAgICAgVmlld1Byb3BlcnRpZXMucmVuZGVyZXIgPSBUSElTX0VYUFIucHJvcCgncmVuZGVyZXInKTtcbiAgICAgIFZpZXdQcm9wZXJ0aWVzLnZpZXdVdGlscyA9IFRISVNfRVhQUi5wcm9wKCd2aWV3VXRpbHMnKTtcbiAgICAgIHJldHVybiBWaWV3UHJvcGVydGllcztcbiAgfSgpKTtcbiAgdmFyIEluamVjdE1ldGhvZFZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSB2YXJpYWJsZSgndG9rZW4nKTtcbiAgICAgIEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleCA9IHZhcmlhYmxlKCdyZXF1ZXN0Tm9kZUluZGV4Jyk7XG4gICAgICBJbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0ID0gdmFyaWFibGUoJ25vdEZvdW5kUmVzdWx0Jyk7XG4gICAgICByZXR1cm4gSW5qZWN0TWV0aG9kVmFycztcbiAgfSgpKTtcbiAgdmFyIERldGVjdENoYW5nZXNWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERldGVjdENoYW5nZXNWYXJzKCkge1xuICAgICAgfVxuICAgICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSA9IHZhcmlhYmxlKFwidGhyb3dPbkNoYW5nZVwiKTtcbiAgICAgIERldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMgPSB2YXJpYWJsZShcImNoYW5nZXNcIik7XG4gICAgICBEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkID0gdmFyaWFibGUoXCJjaGFuZ2VkXCIpO1xuICAgICAgcmV0dXJuIERldGVjdENoYW5nZXNWYXJzO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIFZpZXdDbGFzc0RlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0NsYXNzRGVwZW5kZW5jeShjb21wLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFZpZXdDbGFzc0RlcGVuZGVuY3k7XG4gIH0oKSk7XG4gIHZhciBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeShjb21wLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5O1xuICB9KCkpO1xuICB2YXIgRGlyZWN0aXZlV3JhcHBlckRlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGlyZWN0aXZlV3JhcHBlckRlcGVuZGVuY3koZGlyLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBEaXJlY3RpdmVXcmFwcGVyRGVwZW5kZW5jeTtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBDb21waWxlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlTm9kZShwYXJlbnQsIHZpZXcsIG5vZGVJbmRleCwgcmVuZGVyTm9kZSwgc291cmNlQXN0KSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLm5vZGVJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgICB0aGlzLnJlbmRlck5vZGUgPSByZW5kZXJOb2RlO1xuICAgICAgICAgIHRoaXMuc291cmNlQXN0ID0gc291cmNlQXN0O1xuICAgICAgfVxuICAgICAgQ29tcGlsZU5vZGUucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLnJlbmRlck5vZGU7IH07XG4gICAgICBDb21waWxlTm9kZS5wcm90b3R5cGUuaXNSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmlldyAhPSB0aGlzLnBhcmVudC52aWV3OyB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVOb2RlO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUVsZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE0KENvbXBpbGVFbGVtZW50LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUVsZW1lbnQocGFyZW50LCB2aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIHNvdXJjZUFzdCwgY29tcG9uZW50LCBfZGlyZWN0aXZlcywgX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXksIGhhc1ZpZXdDb250YWluZXIsIGhhc0VtYmVkZGVkVmlldywgcmVmZXJlbmNlcywgX3RhcmdldERlcGVuZGVuY2llcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCB2aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIHNvdXJjZUFzdCk7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlcyA9IF9kaXJlY3RpdmVzO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXkgPSBfcmVzb2x2ZWRQcm92aWRlcnNBcnJheTtcbiAgICAgICAgICB0aGlzLmhhc1ZpZXdDb250YWluZXIgPSBoYXNWaWV3Q29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuaGFzRW1iZWRkZWRWaWV3ID0gaGFzRW1iZWRkZWRWaWV3O1xuICAgICAgICAgIHRoaXMuX3RhcmdldERlcGVuZGVuY2llcyA9IF90YXJnZXREZXBlbmRlbmNpZXM7XG4gICAgICAgICAgdGhpcy5jb21wVmlld0V4cHIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3F1ZXJ5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMuX3F1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlZmVyZW5jZVRva2VucyA9IHt9O1xuICAgICAgICAgIHJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBfdGhpcy5yZWZlcmVuY2VUb2tlbnNbcmVmLm5hbWVdID0gcmVmLnZhbHVlOyB9KTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPVxuICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVsZW1lbnRSZWYpKS5pbnN0YW50aWF0ZShbdGhpcy5yZW5kZXJOb2RlXSk7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuRWxlbWVudFJlZikucmVmZXJlbmNlLCB0aGlzLmVsZW1lbnRSZWYpO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkluamVjdG9yKS5yZWZlcmVuY2UsIFRISVNfRVhQUi5jYWxsTWV0aG9kKCdpbmplY3RvcicsIFtsaXRlcmFsKHRoaXMubm9kZUluZGV4KV0pKTtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5SZW5kZXJlcikucmVmZXJlbmNlLCBUSElTX0VYUFIucHJvcCgncmVuZGVyZXInKSk7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzVmlld0NvbnRhaW5lciB8fCB0aGlzLmhhc0VtYmVkZGVkVmlldykge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWaWV3Q29udGFpbmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21waWxlRWxlbWVudC5jcmVhdGVOdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgW10sIFtdLCBmYWxzZSwgZmFsc2UsIFtdLCBbXSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9jcmVhdGVWaWV3Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl92Y19cIiArIHRoaXMubm9kZUluZGV4O1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlSW5kZXggPSB0aGlzLmlzUm9vdEVsZW1lbnQoKSA/IG51bGwgOiB0aGlzLnBhcmVudC5ub2RlSW5kZXg7XG4gICAgICAgICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSBhIFZpZXdDb250YWluZXJcbiAgICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoZmllbGROYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlZpZXdDb250YWluZXIpKSwgW1N0bXRNb2RpZmllci5Qcml2YXRlXSkpO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsKHRoaXMubm9kZUluZGV4KSwgbGl0ZXJhbChwYXJlbnROb2RlSW5kZXgpLCBUSElTX0VYUFIsIHRoaXMucmVuZGVyTm9kZVxuICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KHN0YXRlbWVudCk7XG4gICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyKS5yZWZlcmVuY2UsIHRoaXMudmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgdGhpcy52aWV3LnZpZXdDb250YWluZXJzLnB1c2godGhpcy52aWV3Q29udGFpbmVyKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudC5lbnRyeUNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChlbnRyeUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB2YXIgaWQgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGVudHJ5Q29tcG9uZW50Lm5hbWUgfSk7XG4gICAgICAgICAgICAgIF90aGlzLl90YXJnZXREZXBlbmRlbmNpZXMucHVzaChuZXcgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koZW50cnlDb21wb25lbnQsIGlkKSk7XG4gICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWVudHJ5Q29tcG9uZW50cyB8fCBlbnRyeUNvbXBvbmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlckV4cHIgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIoZW50cnlDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoZW50cnlDb21wb25lbnQpIHsgcmV0dXJuIGltcG9ydEV4cHIoZW50cnlDb21wb25lbnQpOyB9KSksXG4gICAgICAgICAgICAgIGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IodGhpcy52aWV3LCByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciksIGZhbHNlKVxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHRva2VuOiByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciksXG4gICAgICAgICAgICAgIHVzZVZhbHVlOiBjcmVhdGVDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJFeHByXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gQWRkIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciBhcyBmaXJzdCBwcm92aWRlciBhcyBpdCBkb2VzIG5vdCBoYXZlIGRlcHMgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAgICAgICAgLy8gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlIGFzIG9ubHkgdGhlIGNvbXBvbmVudCBhbmQgaXRzIHZpZXcgY2FuIHNlZSBpdCxcbiAgICAgICAgICAvLyBidXQgbm9ib2R5IGVsc2VcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlZFByb3ZpZGVyc0FycmF5LnVuc2hpZnQobmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBmYWxzZSwgdHJ1ZSwgW3Byb3ZpZGVyXSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UsIFtdLCB0aGlzLnNvdXJjZUFzdC5zb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLnNldENvbXBvbmVudFZpZXcgPSBmdW5jdGlvbiAoY29tcFZpZXdFeHByKSB7XG4gICAgICAgICAgdGhpcy5jb21wVmlld0V4cHIgPSBjb21wVmlld0V4cHI7XG4gICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4ID1cbiAgICAgICAgICAgICAgbmV3IEFycmF5KHRoaXMuY29tcG9uZW50LnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleFtpXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuc2V0RW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKGVtYmVkZGVkVmlldykge1xuICAgICAgICAgIHRoaXMuZW1iZWRkZWRWaWV3ID0gZW1iZWRkZWRWaWV3O1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZW1iZWRkZWRWaWV3KSkge1xuICAgICAgICAgICAgICB2YXIgY3JlYXRlVGVtcGxhdGVSZWZFeHByID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZl8pKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgICAgICBUSElTX0VYUFIsIGxpdGVyYWwodGhpcy5ub2RlSW5kZXgpLCB0aGlzLnJlbmRlck5vZGVcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICB0b2tlbjogcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZiksXG4gICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogY3JlYXRlVGVtcGxhdGVSZWZFeHByXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBBZGQgVGVtcGxhdGVSZWYgYXMgZmlyc3QgcHJvdmlkZXIgYXMgaXQgZG9lcyBub3QgaGF2ZSBkZXBzIG9uIG90aGVyIHByb3ZpZGVyc1xuICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZFByb3ZpZGVyc0FycmF5LnVuc2hpZnQobmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBmYWxzZSwgdHJ1ZSwgW3Byb3ZpZGVyXSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQnVpbHRpbiwgW10sIHRoaXMuc291cmNlQXN0LnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLmJlZm9yZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzVmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKS5yZWZlcmVuY2UsIHRoaXMudmlld0NvbnRhaW5lci5wcm9wKCd2Y1JlZicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gX3RoaXMuX3Jlc29sdmVkUHJvdmlkZXJzLnNldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIHByb3ZpZGVyKTsgfSk7XG4gICAgICAgICAgLy8gY3JlYXRlIGFsbCB0aGUgcHJvdmlkZXIgaW5zdGFuY2VzLCBzb21lIGluIHRoZSB2aWV3IGNvbnN0cnVjdG9yLFxuICAgICAgICAgIC8vIHNvbWUgYXMgZ2V0dGVycy4gV2UgcmVseSBvbiB0aGUgZmFjdCB0aGF0IHRoZXkgYXJlIGFscmVhZHkgc29ydGVkIHRvcG9sb2dpY2FsbHkuXG4gICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9yZXNvbHZlZFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgaXNEaXJlY3RpdmVXcmFwcGVyID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCB8fFxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZTtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXApOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihwcm92aWRlci51c2VGYWN0b3J5KS5jYWxsRm4oZGVwc0V4cHIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXApOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaXJlY3RpdmVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVySWRlbnRpZmllciA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLmRpcldyYXBwZXJDbGFzc05hbWUocHJvdmlkZXIudXNlQ2xhc3MpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RGVwZW5kZW5jaWVzLnB1c2gobmV3IERpcmVjdGl2ZVdyYXBwZXJEZXBlbmRlbmN5KHByb3ZpZGVyLnVzZUNsYXNzLCBkaXJlY3RpdmVXcmFwcGVySWRlbnRpZmllcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGlyZWN0aXZlV3JhcHBlckV4cHJlc3Npb25zLmNyZWF0ZShkaXJlY3RpdmVXcmFwcGVySWRlbnRpZmllciwgZGVwc0V4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoZGVwc0V4cHIsIGltcG9ydFR5cGUocHJvdmlkZXIudXNlQ2xhc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFZhbHVlVG9PdXRwdXRBc3QocHJvdmlkZXIudXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfXCIgKyByZXNvbHZlZFByb3ZpZGVyLnRva2VuLm5hbWUgKyBcIl9cIiArIF90aGlzLm5vZGVJbmRleCArIFwiX1wiICsgX3RoaXMuaW5zdGFuY2VzLnNpemU7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHJlc29sdmVkUHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyLCByZXNvbHZlZFByb3ZpZGVyLmVhZ2VyLCBfdGhpcyk7XG4gICAgICAgICAgICAgIGlmIChpc0RpcmVjdGl2ZVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZS5zZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlcy5zZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIERpcmVjdGl2ZVdyYXBwZXJFeHByZXNzaW9ucy5jb250ZXh0KGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVkUHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IHRoaXNfMS5fZGlyZWN0aXZlc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gdGhpc18xLmluc3RhbmNlcy5nZXQoaWRlbnRpZmllclRva2VuKGRpcmVjdGl2ZS50eXBlKS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBkaXJlY3RpdmUucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeU1ldGEpIHsgX3RoaXMuX2FkZFF1ZXJ5KHF1ZXJ5TWV0YSwgZGlyZWN0aXZlSW5zdGFuY2UpOyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcXVlcmllc1dpdGhSZWFkcyA9IFtdO1xuICAgICAgICAgIEFycmF5LmZyb20odGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJpZXNGb3JQcm92aWRlciA9IF90aGlzLl9nZXRRdWVyaWVzRm9yKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICBxdWVyaWVzV2l0aFJlYWRzLnB1c2guYXBwbHkocXVlcmllc1dpdGhSZWFkcywgcXVlcmllc0ZvclByb3ZpZGVyLm1hcChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIG5ldyBfUXVlcnlXaXRoUmVhZChxdWVyeSwgcmVzb2x2ZWRQcm92aWRlci50b2tlbik7IH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnJlZmVyZW5jZVRva2VucykuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBfdGhpcy5yZWZlcmVuY2VUb2tlbnNbdmFyTmFtZV07XG4gICAgICAgICAgICAgIHZhciB2YXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICB2YXJWYWx1ZSA9IF90aGlzLmluc3RhbmNlcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhclZhbHVlID0gX3RoaXMucmVuZGVyTm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy52aWV3LmxvY2Fscy5zZXQodmFyTmFtZSwgdmFyVmFsdWUpO1xuICAgICAgICAgICAgICB2YXIgdmFyVG9rZW4gPSBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogdmFyTmFtZSB9KTtcbiAgICAgICAgICAgICAgcXVlcmllc1dpdGhSZWFkcy5wdXNoLmFwcGx5KHF1ZXJpZXNXaXRoUmVhZHMsIF90aGlzLl9nZXRRdWVyaWVzRm9yKHZhclRva2VuKS5tYXAoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBuZXcgX1F1ZXJ5V2l0aFJlYWQocXVlcnksIHZhclRva2VuKTsgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHF1ZXJpZXNXaXRoUmVhZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlXaXRoUmVhZCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcnlXaXRoUmVhZC5yZWFkLmlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBxdWVyeSBmb3IgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5pbnN0YW5jZXMuZ2V0KHF1ZXJ5V2l0aFJlYWQucmVhZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gcXVlcnkgZm9yIGEgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBfdGhpcy5yZWZlcmVuY2VUb2tlbnNbcXVlcnlXaXRoUmVhZC5yZWFkLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5pbnN0YW5jZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmVsZW1lbnRSZWY7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5V2l0aFJlYWQucXVlcnkuYWRkVmFsdWUodmFsdWUsIF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLmFmdGVyQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGROb2RlQ291bnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIEFycmF5LmZyb20odGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogYWZ0ZXJDaGlsZHJlbiBpcyBjYWxsZWQgYWZ0ZXIgcmVjdXJzaW5nIGludG8gY2hpbGRyZW4uXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgZ29vZCBzbyB0aGF0IGFuIGluamVjdG9yIG1hdGNoIGluIGFuIGVsZW1lbnQgdGhhdCBpcyBjbG9zZXIgdG8gYSByZXF1ZXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgLy8gbWF0Y2hlcyBmaXJzdC5cbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyRXhwciA9IF90aGlzLmluc3RhbmNlcy5nZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAvLyBOb3RlOiB2aWV3IHByb3ZpZGVycyBhcmUgb25seSB2aXNpYmxlIG9uIHRoZSBpbmplY3RvciBvZiB0aGF0IGVsZW1lbnQuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYXMgdGhlIHJ1bGVzIGR1cmluZyBjb2RlZ2VuIGRvbid0IGFsbG93IGEgZGlyZWN0aXZlXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBob2xkIG9mIGEgdmlldyBwcm92ZGllciBvbiB0aGUgc2FtZSBlbGVtZW50LiBXZSBzdGlsbCBkbyB0aGlzIHNlbWFudGljXG4gICAgICAgICAgICAgIC8vIGFzIGl0IHNpbXBsaWZpZXMgb3VyIG1vZGVsIHRvIGhhdmluZyBvbmx5IG9uZSBydW50aW1lIGluamVjdG9yIHBlciBlbGVtZW50LlxuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJDaGlsZE5vZGVDb3VudCA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSA/IDAgOiBjaGlsZE5vZGVDb3VudDtcbiAgICAgICAgICAgICAgX3RoaXMudmlldy5pbmplY3RvckdldE1ldGhvZC5hZGRTdG10KGNyZWF0ZUluamVjdEludGVybmFsQ29uZGl0aW9uKF90aGlzLm5vZGVJbmRleCwgcHJvdmlkZXJDaGlsZE5vZGVDb3VudCwgcmVzb2x2ZWRQcm92aWRlciwgcHJvdmlkZXJFeHByKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9xdWVyaWVzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocXVlcmllcykgeyByZXR1cm4gcXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBxLmFmdGVyQ2hpbGRyZW4oX3RoaXMudmlldy5jcmVhdGVNZXRob2QsIF90aGlzLnZpZXcudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QpO1xuICAgICAgICAgIH0pOyB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuYWRkQ29udGVudE5vZGUgPSBmdW5jdGlvbiAobmdDb250ZW50SW5kZXgsIG5vZGVFeHByKSB7XG4gICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4W25nQ29udGVudEluZGV4XS5wdXNoKG5vZGVFeHByKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb21wb25lbnQpID9cbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuZ2V0KGlkZW50aWZpZXJUb2tlbih0aGlzLmNvbXBvbmVudC50eXBlKS5yZWZlcmVuY2UpIDpcbiAgICAgICAgICAgICAgbnVsbDtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuZ2V0UHJvdmlkZXJUb2tlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMudmFsdWVzKCkpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHsgcmV0dXJuIGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pOyB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgdmFyIGN1cnJlbnRFbCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICB2YXIgcXVlcmllcztcbiAgICAgICAgICB3aGlsZSAoIWN1cnJlbnRFbC5pc051bGwoKSkge1xuICAgICAgICAgICAgICBxdWVyaWVzID0gY3VycmVudEVsLl9xdWVyaWVzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkubWV0YS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLnZpZXcuY29tcG9uZW50Vmlldy52aWV3UXVlcmllcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9hZGRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfcXVlcnlfXCIgKyBxdWVyeU1ldGEuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHRoaXMubm9kZUluZGV4ICsgXCJfXCIgKyB0aGlzLl9xdWVyeUNvdW50Kys7XG4gICAgICAgICAgdmFyIHF1ZXJ5TGlzdCA9IGNyZWF0ZVF1ZXJ5TGlzdChxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlLCBwcm9wTmFtZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgQ29tcGlsZVF1ZXJ5KHF1ZXJ5TWV0YSwgcXVlcnlMaXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICBhZGRRdWVyeVRvVG9rZW5NYXAodGhpcy5fcXVlcmllcywgcXVlcnkpO1xuICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXApIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlcC50b2tlbikpIHtcbiAgICAgICAgICAgICAgLy8gYWNjZXNzIGJ1aWx0aW5zIHdpdGggc3BlY2lhbCB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBWaWV3RXhwci5wcm9wKCdyZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhUSElTX0VYUFIucHJvcCgncmVmJyksIHRoaXMudmlldywgdGhpcy52aWV3LmNvbXBvbmVudFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBhY2Nlc3MgcmVndWxhciBwcm92aWRlcnMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMuZ2V0KGRlcC50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWxsb3cgZGlyZWN0aXZlcyAvIHB1YmxpYyBzZXJ2aWNlcyB0byBhY2Nlc3MgcHJpdmF0ZSBzZXJ2aWNlcy5cbiAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY29tcG9uZW50cyBhbmQgcHJpdmF0ZSBzZXJ2aWNlcyBjYW4gYWNjZXNzIHByaXZhdGUgc2VydmljZXMuXG4gICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlciAmJiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaW5zdGFuY2VzLmdldChkZXAudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXApIHtcbiAgICAgICAgICB2YXIgY3VyckVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmIChkZXAuaXNWYWx1ZSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBsaXRlcmFsKGRlcC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0ICYmICFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbERlcGVuZGVuY3kocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgIWN1cnJFbGVtZW50LnBhcmVudC5pc051bGwoKSkge1xuICAgICAgICAgICAgICBjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyckVsZW1lbnQuX2dldExvY2FsRGVwZW5kZW5jeShleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IGRlcC50b2tlbiB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IodGhpcy52aWV3LCBkZXAudG9rZW4sIGRlcC5pc09wdGlvbmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gTlVMTF9FWFBSO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHlJblZpZXcocmVzdWx0LCB0aGlzLnZpZXcsIGN1cnJFbGVtZW50LnZpZXcpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlRWxlbWVudDtcbiAgfShDb21waWxlTm9kZSkpO1xuICBmdW5jdGlvbiBjcmVhdGVJbmplY3RJbnRlcm5hbENvbmRpdGlvbihub2RlSW5kZXgsIGNoaWxkTm9kZUNvdW50LCBwcm92aWRlciwgcHJvdmlkZXJFeHByKSB7XG4gICAgICB2YXIgaW5kZXhDb25kaXRpb247XG4gICAgICBpZiAoY2hpbGROb2RlQ291bnQgPiAwKSB7XG4gICAgICAgICAgaW5kZXhDb25kaXRpb24gPSBsaXRlcmFsKG5vZGVJbmRleClcbiAgICAgICAgICAgICAgLmxvd2VyRXF1YWxzKEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleClcbiAgICAgICAgICAgICAgLmFuZChJbmplY3RNZXRob2RWYXJzLnJlcXVlc3ROb2RlSW5kZXgubG93ZXJFcXVhbHMobGl0ZXJhbChub2RlSW5kZXggKyBjaGlsZE5vZGVDb3VudCkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGluZGV4Q29uZGl0aW9uID0gbGl0ZXJhbChub2RlSW5kZXgpLmlkZW50aWNhbChJbmplY3RNZXRob2RWYXJzLnJlcXVlc3ROb2RlSW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBJZlN0bXQoSW5qZWN0TWV0aG9kVmFycy50b2tlbi5pZGVudGljYWwoY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24ocHJvdmlkZXIudG9rZW4pKS5hbmQoaW5kZXhDb25kaXRpb24pLCBbbmV3IFJldHVyblN0YXRlbWVudChwcm92aWRlckV4cHIpXSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXJQcm9wZXJ0eShwcm9wTmFtZSwgcHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgaXNNdWx0aSwgaXNFYWdlciwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByO1xuICAgICAgdmFyIHR5cGU7XG4gICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIgPSBsaXRlcmFsQXJyKHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyk7XG4gICAgICAgICAgdHlwZSA9IG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIgPSBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNbMF07XG4gICAgICAgICAgdHlwZSA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXS50eXBlO1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdHlwZSA9IERZTkFNSUNfVFlQRTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VhZ2VyKSB7XG4gICAgICAgICAgdmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwcm9wTmFtZSwgdHlwZSkpO1xuICAgICAgICAgIHZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVEhJU19FWFBSLnByb3AocHJvcE5hbWUpLnNldChyZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByKS50b1N0bXQoKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgaW50ZXJuYWxGaWVsZCA9IFwiX1wiICsgcHJvcE5hbWU7XG4gICAgICAgICAgdmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChpbnRlcm5hbEZpZWxkLCB0eXBlKSk7XG4gICAgICAgICAgdmFyIGdldHRlciA9IG5ldyBDb21waWxlTWV0aG9kKHZpZXcpO1xuICAgICAgICAgIGdldHRlci5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGNvbXBpbGVFbGVtZW50LnNvdXJjZUFzdCk7XG4gICAgICAgICAgLy8gTm90ZTogRXF1YWxzIGlzIGltcG9ydGFudCBmb3IgSlMgc28gdGhhdCBpdCBhbHNvIGNoZWNrcyB0aGUgdW5kZWZpbmVkIGNhc2UhXG4gICAgICAgICAgZ2V0dGVyLmFkZFN0bXQobmV3IElmU3RtdChUSElTX0VYUFIucHJvcChpbnRlcm5hbEZpZWxkKS5pc0JsYW5rKCksIFtUSElTX0VYUFIucHJvcChpbnRlcm5hbEZpZWxkKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCldKSk7XG4gICAgICAgICAgZ2V0dGVyLmFkZFN0bXQobmV3IFJldHVyblN0YXRlbWVudChUSElTX0VYUFIucHJvcChpbnRlcm5hbEZpZWxkKSkpO1xuICAgICAgICAgIHZpZXcuZ2V0dGVycy5wdXNoKG5ldyBDbGFzc0dldHRlcihwcm9wTmFtZSwgZ2V0dGVyLmZpbmlzaCgpLCB0eXBlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVEhJU19FWFBSLnByb3AocHJvcE5hbWUpO1xuICB9XG4gIHZhciBfUXVlcnlXaXRoUmVhZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfUXVlcnlXaXRoUmVhZChxdWVyeSwgbWF0Y2gpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgdGhpcy5yZWFkID0gcXVlcnkubWV0YS5yZWFkIHx8IG1hdGNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9RdWVyeVdpdGhSZWFkO1xuICB9KCkpO1xuXG4gIHZhciBDb21waWxlUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlUGlwZSh2aWV3LCBtZXRhKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICAgICAgdGhpcy5fcHVyZVBpcGVQcm94eUNvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlID0gVEhJU19FWFBSLnByb3AoXCJfcGlwZV9cIiArIG1ldGEubmFtZSArIFwiX1wiICsgdmlldy5waXBlQ291bnQrKyk7XG4gICAgICAgICAgdmFyIGRlcHMgPSB0aGlzLm1ldGEudHlwZS5kaURlcHMubWFwKGZ1bmN0aW9uIChkaURlcCkge1xuICAgICAgICAgICAgICBpZiAoZGlEZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHlJblZpZXcoVEhJU19FWFBSLnByb3AoJ3JlZicpLCBfdGhpcy52aWV3LCBfdGhpcy52aWV3LmNvbXBvbmVudFZpZXcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbmplY3RGcm9tVmlld1BhcmVudEluamVjdG9yKHZpZXcsIGRpRGVwLnRva2VuLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKHRoaXMuaW5zdGFuY2UubmFtZSwgaW1wb3J0VHlwZSh0aGlzLm1ldGEudHlwZSkpKTtcbiAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvKG51bGwsIG51bGwpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcCh0aGlzLmluc3RhbmNlLm5hbWUpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcih0aGlzLm1ldGEudHlwZSkuaW5zdGFudGlhdGUoZGVwcykpXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICB9XG4gICAgICBDb21waWxlUGlwZS5jYWxsID0gZnVuY3Rpb24gKHZpZXcsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICB2YXIgY29tcFZpZXcgPSB2aWV3LmNvbXBvbmVudFZpZXc7XG4gICAgICAgICAgdmFyIG1ldGEgPSBfZmluZFBpcGVNZXRhKGNvbXBWaWV3LCBuYW1lKTtcbiAgICAgICAgICB2YXIgcGlwZTtcbiAgICAgICAgICBpZiAobWV0YS5wdXJlKSB7XG4gICAgICAgICAgICAgIC8vIHB1cmUgcGlwZXMgbGl2ZSBvbiB0aGUgY29tcG9uZW50IHZpZXdcbiAgICAgICAgICAgICAgcGlwZSA9IGNvbXBWaWV3LnB1cmVQaXBlcy5nZXQobmFtZSk7XG4gICAgICAgICAgICAgIGlmICghcGlwZSkge1xuICAgICAgICAgICAgICAgICAgcGlwZSA9IG5ldyBDb21waWxlUGlwZShjb21wVmlldywgbWV0YSk7XG4gICAgICAgICAgICAgICAgICBjb21wVmlldy5wdXJlUGlwZXMuc2V0KG5hbWUsIHBpcGUpO1xuICAgICAgICAgICAgICAgICAgY29tcFZpZXcucGlwZXMucHVzaChwaXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm9uIHB1cmUgcGlwZXMgbGl2ZSBvbiB0aGUgdmlldyB0aGF0IGNhbGxlZCBpdFxuICAgICAgICAgICAgICBwaXBlID0gbmV3IENvbXBpbGVQaXBlKHZpZXcsIG1ldGEpO1xuICAgICAgICAgICAgICB2aWV3LnBpcGVzLnB1c2gocGlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwaXBlLl9jYWxsKHZpZXcsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlUGlwZS5wcm90b3R5cGUsIFwicHVyZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1ldGEucHVyZTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBDb21waWxlUGlwZS5wcm90b3R5cGUuX2NhbGwgPSBmdW5jdGlvbiAoY2FsbGluZ1ZpZXcsIGFyZ3MpIHtcbiAgICAgICAgICBpZiAodGhpcy5tZXRhLnB1cmUpIHtcbiAgICAgICAgICAgICAgLy8gUHVyZVBpcGVQcm94aWVzIGxpdmUgb24gdGhlIHZpZXcgdGhhdCBjYWxsZWQgdGhlbS5cbiAgICAgICAgICAgICAgdmFyIHB1cmVQaXBlUHJveHlJbnN0YW5jZSA9IFRISVNfRVhQUi5wcm9wKHRoaXMuaW5zdGFuY2UubmFtZSArIFwiX1wiICsgdGhpcy5fcHVyZVBpcGVQcm94eUNvdW50KyspO1xuICAgICAgICAgICAgICB2YXIgcGlwZUluc3RhbmNlU2VlbkZyb21QdXJlUHJveHkgPSBnZXRQcm9wZXJ0eUluVmlldyh0aGlzLmluc3RhbmNlLCBjYWxsaW5nVmlldywgdGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgY3JlYXRlUHVyZVByb3h5KHBpcGVJbnN0YW5jZVNlZW5Gcm9tUHVyZVByb3h5LnByb3AoJ3RyYW5zZm9ybScpXG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZChCdWlsdGluTWV0aG9kLkJpbmQsIFtwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eV0pLCBhcmdzLmxlbmd0aCwgcHVyZVBpcGVQcm94eUluc3RhbmNlLCB7IGZpZWxkczogY2FsbGluZ1ZpZXcuZmllbGRzLCBjdG9yU3RtdHM6IGNhbGxpbmdWaWV3LmNyZWF0ZU1ldGhvZCB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY2FzdEJ5VmFsdWUpKVxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbcHVyZVBpcGVQcm94eUluc3RhbmNlLCBwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eS5wcm9wKCd0cmFuc2Zvcm0nKV0pXG4gICAgICAgICAgICAgICAgICAuY2FsbEZuKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3BlcnR5SW5WaWV3KHRoaXMuaW5zdGFuY2UsIGNhbGxpbmdWaWV3LCB0aGlzLnZpZXcpLmNhbGxNZXRob2QoJ3RyYW5zZm9ybScsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZVBpcGU7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9maW5kUGlwZU1ldGEodmlldywgbmFtZSkge1xuICAgICAgdmFyIHBpcGVNZXRhID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSB2aWV3LnBpcGVNZXRhcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsb2NhbFBpcGVNZXRhID0gdmlldy5waXBlTWV0YXNbaV07XG4gICAgICAgICAgaWYgKGxvY2FsUGlwZU1ldGEubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgIHBpcGVNZXRhID0gbG9jYWxQaXBlTWV0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBmaW5kIHBpcGUgXCIgKyBuYW1lICsgXCIgYWx0aG91Z2ggdGhlIHBhcnNlciBzaG91bGQgaGF2ZSBkZXRlY3RlZCB0aGlzIGVycm9yIVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgfVxuXG4gIHZhciBDb21waWxlVmlld1Jvb3ROb2RlVHlwZTtcbiAgKGZ1bmN0aW9uIChDb21waWxlVmlld1Jvb3ROb2RlVHlwZSkge1xuICAgICAgQ29tcGlsZVZpZXdSb290Tm9kZVR5cGVbQ29tcGlsZVZpZXdSb290Tm9kZVR5cGVbXCJOb2RlXCJdID0gMF0gPSBcIk5vZGVcIjtcbiAgICAgIENvbXBpbGVWaWV3Um9vdE5vZGVUeXBlW0NvbXBpbGVWaWV3Um9vdE5vZGVUeXBlW1wiVmlld0NvbnRhaW5lclwiXSA9IDFdID0gXCJWaWV3Q29udGFpbmVyXCI7XG4gICAgICBDb21waWxlVmlld1Jvb3ROb2RlVHlwZVtDb21waWxlVmlld1Jvb3ROb2RlVHlwZVtcIk5nQ29udGVudFwiXSA9IDJdID0gXCJOZ0NvbnRlbnRcIjtcbiAgfSkoQ29tcGlsZVZpZXdSb290Tm9kZVR5cGUgfHwgKENvbXBpbGVWaWV3Um9vdE5vZGVUeXBlID0ge30pKTtcbiAgdmFyIENvbXBpbGVWaWV3Um9vdE5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVZpZXdSb290Tm9kZSh0eXBlLCBleHByLCBuZ0NvbnRlbnRJbmRleCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZVZpZXdSb290Tm9kZTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVWaWV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVWaWV3KGNvbXBvbmVudCwgZ2VuQ29uZmlnLCBwaXBlTWV0YXMsIHN0eWxlcywgYW5pbWF0aW9ucywgdmlld0luZGV4LCBkZWNsYXJhdGlvbkVsZW1lbnQsIHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5nZW5Db25maWcgPSBnZW5Db25maWc7XG4gICAgICAgICAgdGhpcy5waXBlTWV0YXMgPSBwaXBlTWV0YXM7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICAgICAgICB0aGlzLnZpZXdJbmRleCA9IHZpZXdJbmRleDtcbiAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uRWxlbWVudCA9IGRlY2xhcmF0aW9uRWxlbWVudDtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncyA9IHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncztcbiAgICAgICAgICB0aGlzLnZpZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMubGFzdFJlbmRlck5vZGUgPSBOVUxMX0VYUFI7XG4gICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVycyA9IFtdO1xuICAgICAgICAgIHRoaXMubWV0aG9kcyA9IFtdO1xuICAgICAgICAgIHRoaXMuY3RvclN0bXRzID0gW107XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gW107XG4gICAgICAgICAgdGhpcy5wdXJlUGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IFtdO1xuICAgICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbEFycmF5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbE1hcENvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLnBpcGVDb3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5jcmVhdGVNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkJpbmRpbmdzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5pbmplY3RvckdldE1ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXN0cm95TWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXRhY2hNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpZXdUeXBlID0gZ2V0Vmlld1R5cGUoY29tcG9uZW50LCB2aWV3SW5kZXgpO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gZ2V0Vmlld0NsYXNzTmFtZShjb21wb25lbnQsIHZpZXdJbmRleCk7XG4gICAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBpbXBvcnRUeXBlKG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogdGhpcy5jbGFzc05hbWUgfSkpO1xuICAgICAgICAgIHRoaXMuY2xhc3NFeHByID0gdmFyaWFibGUodGhpcy5jbGFzc05hbWUpO1xuICAgICAgICAgIGlmICh0aGlzLnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgfHwgdGhpcy52aWV3VHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudFZpZXcgPSB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRWaWV3ID0gdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldy5jb21wb25lbnRWaWV3O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRleHQgPVxuICAgICAgICAgICAgICBnZXRQcm9wZXJ0eUluVmlldyhUSElTX0VYUFIucHJvcCgnY29udGV4dCcpLCB0aGlzLCB0aGlzLmNvbXBvbmVudFZpZXcpO1xuICAgICAgICAgIHZhciB2aWV3UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBpZiAodGhpcy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbnN0YW5jZV8xID0gVEhJU19FWFBSLnByb3AoJ2NvbnRleHQnKTtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQudmlld1F1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlNZXRhLCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBcIl92aWV3UXVlcnlfXCIgKyBxdWVyeU1ldGEuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHF1ZXJ5SW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YXIgcXVlcnlMaXN0ID0gY3JlYXRlUXVlcnlMaXN0KHF1ZXJ5TWV0YSwgZGlyZWN0aXZlSW5zdGFuY2VfMSwgcHJvcE5hbWUsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBDb21waWxlUXVlcnkocXVlcnlNZXRhLCBxdWVyeUxpc3QsIGRpcmVjdGl2ZUluc3RhbmNlXzEsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgIGFkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgcXVlcnkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IHZpZXdRdWVyaWVzO1xuICAgICAgICAgIHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBfdGhpcy5sb2NhbHMuc2V0KGVudHJ5WzFdLCBUSElTX0VYUFIucHJvcCgnY29udGV4dCcpLnByb3AoZW50cnlbMF0pKTsgfSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmRlY2xhcmF0aW9uRWxlbWVudC5pc051bGwoKSkge1xuICAgICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uRWxlbWVudC5zZXRFbWJlZGRlZFZpZXcodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ29tcGlsZVZpZXcucHJvdG90eXBlLmNhbGxQaXBlID0gZnVuY3Rpb24gKG5hbWUsIGlucHV0LCBhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIENvbXBpbGVQaXBlLmNhbGwodGhpcywgbmFtZSwgW2lucHV0XS5jb25jYXQoYXJncykpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVWaWV3LnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzLmV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VyclZpZXcgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjdXJyVmlldy5sb2NhbHMuZ2V0KG5hbWUpO1xuICAgICAgICAgIHdoaWxlICghcmVzdWx0ICYmIGlzUHJlc2VudChjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldykpIHtcbiAgICAgICAgICAgICAgY3VyclZpZXcgPSBjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldztcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyclZpZXcubG9jYWxzLmdldChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhyZXN1bHQsIHRoaXMsIGN1cnJWaWV3KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlVmlldy5wcm90b3R5cGUuYWZ0ZXJOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIEFycmF5LmZyb20odGhpcy52aWV3UXVlcmllcy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJpZXMpIHsgcmV0dXJuIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocSkgeyByZXR1cm4gcS5hZnRlckNoaWxkcmVuKF90aGlzLmNyZWF0ZU1ldGhvZCwgX3RoaXMudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QpOyB9KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVWaWV3O1xuICB9KCkpO1xuICBmdW5jdGlvbiBnZXRWaWV3VHlwZShjb21wb25lbnQsIGVtYmVkZGVkVGVtcGxhdGVJbmRleCkge1xuICAgICAgaWYgKGVtYmVkZGVkVGVtcGxhdGVJbmRleCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gVmlld1R5cGUuRU1CRURERUQ7XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9uZW50LnR5cGUuaXNIb3N0KSB7XG4gICAgICAgICAgcmV0dXJuIFZpZXdUeXBlLkhPU1Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gVmlld1R5cGUuQ09NUE9ORU5UO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluZE91dHB1dHMoYm91bmRFdmVudHMsIGRpcmVjdGl2ZXMsIGNvbXBpbGVFbGVtZW50LCBiaW5kVG9SZW5kZXJlcikge1xuICAgICAgdmFyIHVzZWRFdmVudHMgPSBjb2xsZWN0RXZlbnRzKGJvdW5kRXZlbnRzLCBkaXJlY3RpdmVzKTtcbiAgICAgIGlmICghdXNlZEV2ZW50cy5zaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRUb1JlbmRlcmVyKSB7XG4gICAgICAgICAgc3Vic2NyaWJlVG9SZW5kZXJFdmVudHModXNlZEV2ZW50cywgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlVG9EaXJlY3RpdmVFdmVudHModXNlZEV2ZW50cywgZGlyZWN0aXZlcywgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgZ2VuZXJhdGVIYW5kbGVFdmVudE1ldGhvZChib3VuZEV2ZW50cywgZGlyZWN0aXZlcywgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY29sbGVjdEV2ZW50cyhib3VuZEV2ZW50cywgZGlyZWN0aXZlcykge1xuICAgICAgdmFyIHVzZWRFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICBib3VuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyB1c2VkRXZlbnRzLnNldChldmVudC5mdWxsTmFtZSwgZXZlbnQpOyB9KTtcbiAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyQXN0KSB7XG4gICAgICAgICAgZGlyQXN0Lmhvc3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgdXNlZEV2ZW50cy5zZXQoZXZlbnQuZnVsbE5hbWUsIGV2ZW50KTsgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1c2VkRXZlbnRzO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvUmVuZGVyRXZlbnRzKHVzZWRFdmVudHMsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgZXZlbnRBbmRUYXJnZXRFeHBycyA9IFtdO1xuICAgICAgdXNlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmICghZXZlbnQucGhhc2UpIHtcbiAgICAgICAgICAgICAgZXZlbnRBbmRUYXJnZXRFeHBycy5wdXNoKGxpdGVyYWwoZXZlbnQubmFtZSksIGxpdGVyYWwoZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZXZlbnRBbmRUYXJnZXRFeHBycy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGlzcG9zYWJsZVZhciA9IHZhcmlhYmxlKFwiZGlzcG9zYWJsZV9cIiArIGNvbXBpbGVFbGVtZW50LnZpZXcuZGlzcG9zYWJsZXMubGVuZ3RoKTtcbiAgICAgICAgICBjb21waWxlRWxlbWVudC52aWV3LmRpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZVZhcik7XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChkaXNwb3NhYmxlVmFyXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5zdWJzY3JpYmVUb1JlbmRlckVsZW1lbnQpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICBUSElTX0VYUFIsIGNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIGNyZWF0ZUlubGluZUFycmF5KGV2ZW50QW5kVGFyZ2V0RXhwcnMpLFxuICAgICAgICAgICAgICBoYW5kbGVFdmVudEV4cHIoY29tcGlsZUVsZW1lbnQpXG4gICAgICAgICAgXSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KEZVTkNUSU9OX1RZUEUsIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0RpcmVjdGl2ZUV2ZW50cyh1c2VkRXZlbnRzLCBkaXJlY3RpdmVzLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIHVzZWRFdmVudE5hbWVzID0gQXJyYXkuZnJvbSh1c2VkRXZlbnRzLmtleXMoKSk7XG4gICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICAgIHZhciBkaXJXcmFwcGVyID0gY29tcGlsZUVsZW1lbnQuZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLmdldChkaXJBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICBjb21waWxlRWxlbWVudC52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10cyhEaXJlY3RpdmVXcmFwcGVyRXhwcmVzc2lvbnMuc3Vic2NyaWJlKGRpckFzdC5kaXJlY3RpdmUsIGRpckFzdC5ob3N0UHJvcGVydGllcywgdXNlZEV2ZW50TmFtZXMsIGRpcldyYXBwZXIsIFRISVNfRVhQUiwgaGFuZGxlRXZlbnRFeHByKGNvbXBpbGVFbGVtZW50KSkpO1xuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIYW5kbGVFdmVudE1ldGhvZChib3VuZEV2ZW50cywgZGlyZWN0aXZlcywgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciBoYXNDb21wb25lbnRIb3N0TGlzdGVuZXIgPSBkaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGRpckFzdCkgeyByZXR1cm4gZGlyQXN0Lmhvc3RFdmVudHMuc29tZShmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pOyB9KTtcbiAgICAgIHZhciBtYXJrUGF0aFRvUm9vdFN0YXJ0ID0gaGFzQ29tcG9uZW50SG9zdExpc3RlbmVyID8gY29tcGlsZUVsZW1lbnQuY29tcFZpZXdFeHByIDogVEhJU19FWFBSO1xuICAgICAgdmFyIGhhbmRsZUV2ZW50U3RtdHMgPSBuZXcgQ29tcGlsZU1ldGhvZChjb21waWxlRWxlbWVudC52aWV3KTtcbiAgICAgIGhhbmRsZUV2ZW50U3RtdHMucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgICAgaGFuZGxlRXZlbnRTdG10cy5wdXNoKG1hcmtQYXRoVG9Sb290U3RhcnQuY2FsbE1ldGhvZCgnbWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZScsIFtdKS50b1N0bXQoKSk7XG4gICAgICB2YXIgZXZlbnROYW1lVmFyID0gdmFyaWFibGUoJ2V2ZW50TmFtZScpO1xuICAgICAgdmFyIHJlc3VsdFZhciA9IHZhcmlhYmxlKCdyZXN1bHQnKTtcbiAgICAgIGhhbmRsZUV2ZW50U3RtdHMucHVzaChyZXN1bHRWYXIuc2V0KGxpdGVyYWwodHJ1ZSkpLnRvRGVjbFN0bXQoQk9PTF9UWVBFKSk7XG4gICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpckFzdCwgZGlySWR4KSB7XG4gICAgICAgICAgdmFyIGRpcldyYXBwZXIgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UuZ2V0KGRpckFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChkaXJBc3QuaG9zdEV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUV2ZW50U3RtdHMucHVzaChyZXN1bHRWYXJcbiAgICAgICAgICAgICAgICAgIC5zZXQoRGlyZWN0aXZlV3JhcHBlckV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAuaGFuZGxlRXZlbnQoZGlyQXN0Lmhvc3RFdmVudHMsIGRpcldyYXBwZXIsIGV2ZW50TmFtZVZhciwgRXZlbnRIYW5kbGVyVmFycy5ldmVudClcbiAgICAgICAgICAgICAgICAgIC5hbmQocmVzdWx0VmFyKSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBib3VuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZW5kZXJFdmVudCwgcmVuZGVyRXZlbnRJZHgpIHtcbiAgICAgICAgICB2YXIgZXZhbFJlc3VsdCA9IGNvbnZlcnRBY3Rpb25CaW5kaW5nKGNvbXBpbGVFbGVtZW50LnZpZXcsIGNvbXBpbGVFbGVtZW50LnZpZXcsIGNvbXBpbGVFbGVtZW50LnZpZXcuY29tcG9uZW50Q29udGV4dCwgcmVuZGVyRXZlbnQuaGFuZGxlciwgXCJzdWJfXCIgKyByZW5kZXJFdmVudElkeCk7XG4gICAgICAgICAgdmFyIHRydWVTdG10cyA9IGV2YWxSZXN1bHQuc3RtdHM7XG4gICAgICAgICAgaWYgKGV2YWxSZXN1bHQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgdHJ1ZVN0bXRzLnB1c2gocmVzdWx0VmFyLnNldChldmFsUmVzdWx0LnByZXZlbnREZWZhdWx0LmFuZChyZXN1bHRWYXIpKS50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8odGJvc2NoKTogY29udmVydCB0aGlzIGludG8gYSBgc3dpdGNoYCBvbmNlIG91ciBPdXRwdXRBc3Qgc3VwcG9ydHMgaXQuXG4gICAgICAgICAgaGFuZGxlRXZlbnRTdG10cy5wdXNoKG5ldyBJZlN0bXQoZXZlbnROYW1lVmFyLmVxdWFscyhsaXRlcmFsKHJlbmRlckV2ZW50LmZ1bGxOYW1lKSksIHRydWVTdG10cykpO1xuICAgICAgfSk7XG4gICAgICBoYW5kbGVFdmVudFN0bXRzLnB1c2gobmV3IFJldHVyblN0YXRlbWVudChyZXN1bHRWYXIpKTtcbiAgICAgIGNvbXBpbGVFbGVtZW50LnZpZXcubWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZChnZXRIYW5kbGVFdmVudE1ldGhvZE5hbWUoY29tcGlsZUVsZW1lbnQubm9kZUluZGV4KSwgW1xuICAgICAgICAgIG5ldyBGblBhcmFtKGV2ZW50TmFtZVZhci5uYW1lLCBTVFJJTkdfVFlQRSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lLCBEWU5BTUlDX1RZUEUpXG4gICAgICBdLCBoYW5kbGVFdmVudFN0bXRzLmZpbmlzaCgpLCBCT09MX1RZUEUpKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVFdmVudEV4cHIoY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciBoYW5kbGVFdmVudE1ldGhvZE5hbWUgPSBnZXRIYW5kbGVFdmVudE1ldGhvZE5hbWUoY29tcGlsZUVsZW1lbnQubm9kZUluZGV4KTtcbiAgICAgIHJldHVybiBUSElTX0VYUFIuY2FsbE1ldGhvZCgnZXZlbnRIYW5kbGVyJywgW1RISVNfRVhQUi5wcm9wKGhhbmRsZUV2ZW50TWV0aG9kTmFtZSldKTtcbiAgfVxuXG4gIHZhciBTVEFURV9JU19ORVZFUl9DSEVDS0VEID0gVEhJU19FWFBSLnByb3AoJ251bWJlck9mQ2hlY2tzJykuaWRlbnRpY2FsKG5ldyBMaXRlcmFsRXhwcigwKSk7XG4gIHZhciBOT1RfVEhST1dfT05fQ0hBTkdFUyA9IG5vdChEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlKTtcbiAgZnVuY3Rpb24gYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IGRpcmVjdGl2ZU1ldGEudHlwZS5saWZlY3ljbGVIb29rcztcbiAgICAgIHZhciBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QgPSB2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZDtcbiAgICAgIGFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGNvbXBpbGVFbGVtZW50LnNvdXJjZUFzdCk7XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0KSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChuZXcgSWZTdG10KFNUQVRFX0lTX05FVkVSX0NIRUNLRUQsIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudEluaXQnLCBbXSkudG9TdG10KCldKSk7XG4gICAgICB9XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkKSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudENoZWNrZWQnLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVBZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlTWV0YSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgdmlldyA9IGNvbXBpbGVFbGVtZW50LnZpZXc7XG4gICAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBkaXJlY3RpdmVNZXRhLnR5cGUubGlmZWN5Y2xlSG9va3M7XG4gICAgICB2YXIgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gdmlldy5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2Q7XG4gICAgICBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCkgIT09IC0xKSB7XG4gICAgICAgICAgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmFkZFN0bXQobmV3IElmU3RtdChTVEFURV9JU19ORVZFUl9DSEVDS0VELCBbZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdBZnRlclZpZXdJbml0JywgW10pLnRvU3RtdCgpXSkpO1xuICAgICAgfVxuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZCkgIT09IC0xKSB7XG4gICAgICAgICAgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmFkZFN0bXQoZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdBZnRlclZpZXdDaGVja2VkJywgW10pLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5kRGlyZWN0aXZlV3JhcHBlckxpZmVjeWNsZUNhbGxiYWNrcyhkaXIsIGRpcmVjdGl2ZVdyYXBwZXJJbnRhbmNlLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgY29tcGlsZUVsZW1lbnQudmlldy5kZXN0cm95TWV0aG9kLmFkZFN0bXRzKERpcmVjdGl2ZVdyYXBwZXJFeHByZXNzaW9ucy5uZ09uRGVzdHJveShkaXIuZGlyZWN0aXZlLCBkaXJlY3RpdmVXcmFwcGVySW50YW5jZSkpO1xuICAgICAgY29tcGlsZUVsZW1lbnQudmlldy5kZXRhY2hNZXRob2QuYWRkU3RtdHMoRGlyZWN0aXZlV3JhcHBlckV4cHJlc3Npb25zLm5nT25EZXRhY2goZGlyLmhvc3RQcm9wZXJ0aWVzLCBkaXJlY3RpdmVXcmFwcGVySW50YW5jZSwgVEhJU19FWFBSLCBjb21waWxlRWxlbWVudC5jb21wVmlld0V4cHIgfHwgVEhJU19FWFBSLCBjb21waWxlRWxlbWVudC5yZW5kZXJOb2RlKSk7XG4gIH1cbiAgZnVuY3Rpb24gYmluZEluamVjdGFibGVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzKHByb3ZpZGVyLCBwcm92aWRlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIG9uRGVzdHJveU1ldGhvZCA9IGNvbXBpbGVFbGVtZW50LnZpZXcuZGVzdHJveU1ldGhvZDtcbiAgICAgIG9uRGVzdHJveU1ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGNvbXBpbGVFbGVtZW50LnNvdXJjZUFzdCk7XG4gICAgICBpZiAocHJvdmlkZXIucHJvdmlkZXJUeXBlICE9PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgJiZcbiAgICAgICAgICBwcm92aWRlci5wcm92aWRlclR5cGUgIT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCAmJlxuICAgICAgICAgIHByb3ZpZGVyLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSAhPT0gLTEpIHtcbiAgICAgICAgICBvbkRlc3Ryb3lNZXRob2QuYWRkU3RtdChwcm92aWRlckluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5kUGlwZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocGlwZU1ldGEsIHBpcGVJbnN0YW5jZSwgdmlldykge1xuICAgICAgdmFyIG9uRGVzdHJveU1ldGhvZCA9IHZpZXcuZGVzdHJveU1ldGhvZDtcbiAgICAgIGlmIChwaXBlTWV0YS50eXBlLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSAhPT0gLTEpIHtcbiAgICAgICAgICBvbkRlc3Ryb3lNZXRob2QuYWRkU3RtdChwaXBlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdPbkRlc3Ryb3knLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmluZFJlbmRlclRleHQoYm91bmRUZXh0LCBjb21waWxlTm9kZSwgdmlldykge1xuICAgICAgdmFyIHZhbHVlRmllbGQgPSBjcmVhdGVDaGVja0JpbmRpbmdGaWVsZCh2aWV3KTtcbiAgICAgIHZhciBldmFsUmVzdWx0ID0gY29udmVydFByb3BlcnR5QmluZGluZyh2aWV3LCB2aWV3LCB2aWV3LmNvbXBvbmVudENvbnRleHQsIGJvdW5kVGV4dC52YWx1ZSwgdmFsdWVGaWVsZC5iaW5kaW5nSWQpO1xuICAgICAgaWYgKCFldmFsUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVOb2RlLm5vZGVJbmRleCwgYm91bmRUZXh0KTtcbiAgICAgIHZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QuYWRkU3RtdHMoY3JlYXRlQ2hlY2tCaW5kaW5nU3RtdChldmFsUmVzdWx0LCB2YWx1ZUZpZWxkLmV4cHJlc3Npb24sIERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UsIFtUSElTX0VYUFIucHJvcCgncmVuZGVyZXInKVxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnc2V0VGV4dCcsIFtjb21waWxlTm9kZS5yZW5kZXJOb2RlLCBldmFsUmVzdWx0LmN1cnJWYWxFeHByXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpXSkpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJJbnB1dHMoYm91bmRQcm9wcywgaGFzRXZlbnRzLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIHJlbmRlck5vZGUgPSBjb21waWxlRWxlbWVudC5yZW5kZXJOb2RlO1xuICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICB2YXIgYmluZGluZ0ZpZWxkID0gY3JlYXRlQ2hlY2tCaW5kaW5nRmllbGQodmlldyk7XG4gICAgICAgICAgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgdmFyIGV2YWxSZXN1bHQgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZpZXcsIHZpZXcsIGNvbXBpbGVFbGVtZW50LnZpZXcuY29tcG9uZW50Q29udGV4dCwgYm91bmRQcm9wLnZhbHVlLCBiaW5kaW5nRmllbGQuYmluZGluZ0lkKTtcbiAgICAgICAgICBpZiAoIWV2YWxSZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hlY2tCaW5kaW5nU3RtdHMgPSBbXTtcbiAgICAgICAgICB2YXIgY29tcGlsZU1ldGhvZCA9IHZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2Q7XG4gICAgICAgICAgc3dpdGNoIChib3VuZFByb3AudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlOlxuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzczpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU6XG4gICAgICAgICAgICAgICAgICBjaGVja0JpbmRpbmdTdG10cy5wdXNoLmFwcGx5KGNoZWNrQmluZGluZ1N0bXRzLCB3cml0ZVRvUmVuZGVyZXIoVEhJU19FWFBSLCBib3VuZFByb3AsIHJlbmRlck5vZGUsIGV2YWxSZXN1bHQuY3VyclZhbEV4cHIsIHZpZXcuZ2VuQ29uZmlnLmxvZ0JpbmRpbmdVcGRhdGUpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb246XG4gICAgICAgICAgICAgICAgICBjb21waWxlTWV0aG9kID0gdmlldy5hbmltYXRpb25CaW5kaW5nc01ldGhvZDtcbiAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHRyaWdnZXJBbmltYXRpb24oVEhJU19FWFBSLCBUSElTX0VYUFIsIGJvdW5kUHJvcCwgKGhhc0V2ZW50cyA/IFRISVNfRVhQUi5wcm9wKGdldEhhbmRsZUV2ZW50TWV0aG9kTmFtZShjb21waWxlRWxlbWVudC5ub2RlSW5kZXgpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5ub29wKSkpXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5CaW5kLCBbVEhJU19FWFBSXSksIGNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIGV2YWxSZXN1bHQuY3VyclZhbEV4cHIsIGJpbmRpbmdGaWVsZC5leHByZXNzaW9uKSwgdXBkYXRlU3RtdHMgPSBfYS51cGRhdGVTdG10cywgZGV0YWNoU3RtdHMgPSBfYS5kZXRhY2hTdG10cztcbiAgICAgICAgICAgICAgICAgIGNoZWNrQmluZGluZ1N0bXRzLnB1c2guYXBwbHkoY2hlY2tCaW5kaW5nU3RtdHMsIHVwZGF0ZVN0bXRzKTtcbiAgICAgICAgICAgICAgICAgIHZpZXcuZGV0YWNoTWV0aG9kLmFkZFN0bXRzKGRldGFjaFN0bXRzKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21waWxlTWV0aG9kLmFkZFN0bXRzKGNyZWF0ZUNoZWNrQmluZGluZ1N0bXQoZXZhbFJlc3VsdCwgYmluZGluZ0ZpZWxkLmV4cHJlc3Npb24sIERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UsIGNoZWNrQmluZGluZ1N0bXRzKSk7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBiaW5kRGlyZWN0aXZlSG9zdFByb3BzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCwgZWxlbWVudE5hbWUsIHNjaGVtYVJlZ2lzdHJ5KSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdGhlIFNlY3VyaXR5Q29udGV4dCBmb3IgcHJvcGVydGllcyB0aGF0IGNvdWxkIG5lZWQgc2FuaXRpemF0aW9uLlxuICAgICAgdmFyIHJ1bnRpbWVTZWN1cml0eUN0eEV4cHJzID0gZGlyZWN0aXZlQXN0Lmhvc3RQcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbiAoYm91bmRQcm9wKSB7IHJldHVybiBib3VuZFByb3AubmVlZHNSdW50aW1lU2VjdXJpdHlDb250ZXh0OyB9KVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xuICAgICAgICAgIHZhciBjdHg7XG4gICAgICAgICAgc3dpdGNoIChib3VuZFByb3AudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTpcbiAgICAgICAgICAgICAgICAgIGN0eCA9IHNjaGVtYVJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dChlbGVtZW50TmFtZSwgYm91bmRQcm9wLm5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU6XG4gICAgICAgICAgICAgICAgICBjdHggPSBzY2hlbWFSZWdpc3RyeS5zZWN1cml0eUNvbnRleHQoZWxlbWVudE5hbWUsIGJvdW5kUHJvcC5uYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogT25seSBwcm9wZXJ0eSAvIGF0dHJpYnV0ZSBiaW5kaW5ncyBjYW4gaGF2ZSBhbiB1bmtub3duIHNlY3VyaXR5IGNvbnRleHQhIEJpbmRpbmcgXCIgKyBib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjcmVhdGVFbnVtRXhwcmVzc2lvbihJZGVudGlmaWVycy5TZWN1cml0eUNvbnRleHQsIGN0eCk7XG4gICAgICB9KTtcbiAgICAgIGNvbXBpbGVFbGVtZW50LnZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QuYWRkU3RtdHMoRGlyZWN0aXZlV3JhcHBlckV4cHJlc3Npb25zLmNoZWNrSG9zdChkaXJlY3RpdmVBc3QuaG9zdFByb3BlcnRpZXMsIGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZSwgVEhJU19FWFBSLCBjb21waWxlRWxlbWVudC5jb21wVmlld0V4cHIgfHwgVEhJU19FWFBSLCBjb21waWxlRWxlbWVudC5yZW5kZXJOb2RlLCBEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlLCBydW50aW1lU2VjdXJpdHlDdHhFeHBycykpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVJbnB1dHMoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UsIGRpckluZGV4LCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IHZpZXcuZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kO1xuICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgIGRpcmVjdGl2ZUFzdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGlucHV0SWR4KSB7XG4gICAgICAgICAgLy8gTm90ZTogV2UgY2FuJ3QgdXNlIGBmaWVsZHMubGVuZ3RoYCBoZXJlLCBhcyB3ZSBhcmUgbm90IGFkZGluZyBhIGZpZWxkIVxuICAgICAgICAgIHZhciBiaW5kaW5nSWQgPSBjb21waWxlRWxlbWVudC5ub2RlSW5kZXggKyBcIl9cIiArIGRpckluZGV4ICsgXCJfXCIgKyBpbnB1dElkeDtcbiAgICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBpbnB1dCk7XG4gICAgICAgICAgdmFyIGV2YWxSZXN1bHQgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZpZXcsIHZpZXcsIHZpZXcuY29tcG9uZW50Q29udGV4dCwgaW5wdXQudmFsdWUsIGJpbmRpbmdJZCk7XG4gICAgICAgICAgaWYgKCFldmFsUmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXRzKGV2YWxSZXN1bHQuc3RtdHMpO1xuICAgICAgICAgIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZC5hZGRTdG10KGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZVxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZChcImNoZWNrX1wiICsgaW5wdXQuZGlyZWN0aXZlTmFtZSwgW1xuICAgICAgICAgICAgICBldmFsUmVzdWx0LmN1cnJWYWxFeHByLCBEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlLFxuICAgICAgICAgICAgICBldmFsUmVzdWx0LmZvcmNlVXBkYXRlIHx8IGxpdGVyYWwoZmFsc2UpXG4gICAgICAgICAgXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzT25QdXNoQ29tcCA9IGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQgJiZcbiAgICAgICAgICAhaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24pO1xuICAgICAgdmFyIGRpcmVjdGl2ZURldGVjdENoYW5nZXNFeHByID0gRGlyZWN0aXZlV3JhcHBlckV4cHJlc3Npb25zLm5nRG9DaGVjayhkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UsIFRISVNfRVhQUiwgY29tcGlsZUVsZW1lbnQucmVuZGVyTm9kZSwgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSk7XG4gICAgICB2YXIgZGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc1N0bXQgPSBpc09uUHVzaENvbXAgP1xuICAgICAgICAgIG5ldyBJZlN0bXQoZGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc0V4cHIsIFtjb21waWxlRWxlbWVudC5jb21wVmlld0V4cHIuY2FsbE1ldGhvZCgnbWFya0FzQ2hlY2tPbmNlJywgW10pLnRvU3RtdCgpXSkgOlxuICAgICAgICAgIGRpcmVjdGl2ZURldGVjdENoYW5nZXNFeHByLnRvU3RtdCgpO1xuICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQoZGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc1N0bXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluZFZpZXcodmlldywgcGFyc2VkVGVtcGxhdGUsIHNjaGVtYVJlZ2lzdHJ5KSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBWaWV3QmluZGVyVmlzaXRvcih2aWV3LCBzY2hlbWFSZWdpc3RyeSk7XG4gICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIHBhcnNlZFRlbXBsYXRlKTtcbiAgICAgIHZpZXcucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyBiaW5kUGlwZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocGlwZS5tZXRhLCBwaXBlLmluc3RhbmNlLCBwaXBlLnZpZXcpOyB9KTtcbiAgfVxuICB2YXIgVmlld0JpbmRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0JpbmRlclZpc2l0b3IodmlldywgX3NjaGVtYVJlZ2lzdHJ5KSB7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnZpZXcubm9kZXNbdGhpcy5fbm9kZUluZGV4KytdO1xuICAgICAgICAgIGJpbmRSZW5kZXJUZXh0KGFzdCwgbm9kZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5fbm9kZUluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNvbXBpbGVFbGVtZW50ID0gdGhpcy52aWV3Lm5vZGVzW3RoaXMuX25vZGVJbmRleCsrXTtcbiAgICAgICAgICB2YXIgaGFzRXZlbnRzID0gYmluZE91dHB1dHMoYXN0Lm91dHB1dHMsIGFzdC5kaXJlY3RpdmVzLCBjb21waWxlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgYmluZFJlbmRlcklucHV0cyhhc3QuaW5wdXRzLCBoYXNFdmVudHMsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QsIGRpckluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlSW5wdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBkaXJJbmRleCwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlSG9zdFByb3BzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCwgYXN0Lm5hbWUsIF90aGlzLl9zY2hlbWFSZWdpc3RyeSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAvLyBhZnRlckNvbnRlbnQgYW5kIGFmdGVyVmlldyBsaWZlY3ljbGVzIG5lZWQgdG8gYmUgY2FsbGVkIGJvdHRvbSB1cFxuICAgICAgICAgIC8vIHNvIHRoYXQgY2hpbGRyZW4gYXJlIG5vdGlmaWVkIGJlZm9yZSBwYXJlbnRzXG4gICAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50Lmluc3RhbmNlcy5nZXQoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlQWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVBZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZVdyYXBwZXJMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVXcmFwcGVySW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhc3QucHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlckluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuaW5zdGFuY2VzLmdldChwcm92aWRlckFzdC50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBiaW5kSW5qZWN0YWJsZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocHJvdmlkZXJBc3QsIHByb3ZpZGVySW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIGNvbXBpbGVFbGVtZW50ID0gdGhpcy52aWV3Lm5vZGVzW3RoaXMuX25vZGVJbmRleCsrXTtcbiAgICAgICAgICBiaW5kT3V0cHV0cyhhc3Qub3V0cHV0cywgYXN0LmRpcmVjdGl2ZXMsIGNvbXBpbGVFbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0LCBkaXJJbmRleCkge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLmdldChkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUlucHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZSwgZGlySW5kZXgsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlQWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVXcmFwcGVyTGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXN0LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlckFzdCkge1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50Lmluc3RhbmNlcy5nZXQocHJvdmlkZXJBc3QudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZEluamVjdGFibGVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzKHByb3ZpZGVyQXN0LCBwcm92aWRlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYmluZFZpZXcoY29tcGlsZUVsZW1lbnQuZW1iZWRkZWRWaWV3LCBhc3QuY2hpbGRyZW4sIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBldmVudFRhcmdldEFuZE5hbWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFZpZXdCaW5kZXJWaXNpdG9yO1xuICB9KCkpO1xuXG4gIHZhciBJTVBMSUNJVF9URU1QTEFURV9WQVIgPSAnXFwkaW1wbGljaXQnO1xuICB2YXIgQ0xBU1NfQVRUUiQxID0gJ2NsYXNzJztcbiAgdmFyIFNUWUxFX0FUVFIgPSAnc3R5bGUnO1xuICB2YXIgTkdfQ09OVEFJTkVSX1RBRyA9ICduZy1jb250YWluZXInO1xuICB2YXIgcGFyZW50UmVuZGVyTm9kZVZhciA9IHZhcmlhYmxlKCdwYXJlbnRSZW5kZXJOb2RlJyk7XG4gIHZhciByb290U2VsZWN0b3JWYXIgPSB2YXJpYWJsZSgncm9vdFNlbGVjdG9yJyk7XG4gIGZ1bmN0aW9uIGJ1aWxkVmlldyh2aWV3LCB0ZW1wbGF0ZSwgdGFyZ2V0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB2YXIgYnVpbGRlclZpc2l0b3IgPSBuZXcgVmlld0J1aWxkZXJWaXNpdG9yKHZpZXcsIHRhcmdldERlcGVuZGVuY2llcyk7XG4gICAgICB2YXIgcGFyZW50RWwgPSB2aWV3LmRlY2xhcmF0aW9uRWxlbWVudC5pc051bGwoKSA/IHZpZXcuZGVjbGFyYXRpb25FbGVtZW50IDogdmlldy5kZWNsYXJhdGlvbkVsZW1lbnQucGFyZW50O1xuICAgICAgdGVtcGxhdGVWaXNpdEFsbChidWlsZGVyVmlzaXRvciwgdGVtcGxhdGUsIHBhcmVudEVsKTtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5FTUJFRERFRCB8fCB2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5IT1NUKSB7XG4gICAgICAgICAgdmlldy5sYXN0UmVuZGVyTm9kZSA9IGJ1aWxkZXJWaXNpdG9yLmdldE9yQ3JlYXRlTGFzdFJlbmRlck5vZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyVmlzaXRvci5uZXN0ZWRWaWV3Q291bnQ7XG4gIH1cbiAgZnVuY3Rpb24gZmluaXNoVmlldyh2aWV3LCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICB2aWV3LmFmdGVyTm9kZXMoKTtcbiAgICAgIGNyZWF0ZVZpZXdUb3BMZXZlbFN0bXRzKHZpZXcsIHRhcmdldFN0YXRlbWVudHMpO1xuICAgICAgdmlldy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb21waWxlRWxlbWVudCAmJiBub2RlLmhhc0VtYmVkZGVkVmlldykge1xuICAgICAgICAgICAgICBmaW5pc2hWaWV3KG5vZGUuZW1iZWRkZWRWaWV3LCB0YXJnZXRTdGF0ZW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICB2YXIgVmlld0J1aWxkZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdCdWlsZGVyVmlzaXRvcih2aWV3LCB0YXJnZXREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMudGFyZ2V0RGVwZW5kZW5jaWVzID0gdGFyZ2V0RGVwZW5kZW5jaWVzO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX2lzUm9vdE5vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7IHJldHVybiBwYXJlbnQudmlldyAhPT0gdGhpcy52aWV3OyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fYWRkUm9vdE5vZGVBbmRQcm9qZWN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgcHJvamVjdGVkTm9kZSA9IF9nZXRPdXRlckNvbnRhaW5lck9yU2VsZihub2RlKTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcHJvamVjdGVkTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcHJvamVjdGVkTm9kZS5zb3VyY2VBc3QubmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSAobm9kZSBpbnN0YW5jZW9mIENvbXBpbGVFbGVtZW50ICYmIG5vZGUuaGFzVmlld0NvbnRhaW5lcikgPyBub2RlLnZpZXdDb250YWluZXIgOiBudWxsO1xuICAgICAgICAgIGlmICh0aGlzLl9pc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy52aWV3VHlwZSAhPT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucm9vdE5vZGVzLnB1c2gobmV3IENvbXBpbGVWaWV3Um9vdE5vZGUodmlld0NvbnRhaW5lciA/IENvbXBpbGVWaWV3Um9vdE5vZGVUeXBlLlZpZXdDb250YWluZXIgOiBDb21waWxlVmlld1Jvb3ROb2RlVHlwZS5Ob2RlLCB2aWV3Q29udGFpbmVyIHx8IG5vZGUucmVuZGVyTm9kZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwYXJlbnQuY29tcG9uZW50KSAmJiBpc1ByZXNlbnQobmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5hZGRDb250ZW50Tm9kZShuZ0NvbnRlbnRJbmRleCwgbmV3IENvbXBpbGVWaWV3Um9vdE5vZGUodmlld0NvbnRhaW5lciA/IENvbXBpbGVWaWV3Um9vdE5vZGVUeXBlLlZpZXdDb250YWluZXIgOiBDb21waWxlVmlld1Jvb3ROb2RlVHlwZS5Ob2RlLCB2aWV3Q29udGFpbmVyIHx8IG5vZGUucmVuZGVyTm9kZSkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9nZXRQYXJlbnRSZW5kZXJOb2RlID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IF9nZXRPdXRlckNvbnRhaW5lclBhcmVudE9yU2VsZihwYXJlbnQpO1xuICAgICAgICAgIGlmICh0aGlzLl9pc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50UmVuZGVyTm9kZVZhcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSBvZiBhbiBlbWJlZGRlZC9ob3N0IHZpZXdcbiAgICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX0VYUFI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQocGFyZW50LmNvbXBvbmVudCkgJiZcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5jb21wb25lbnQudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiAhPT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUgP1xuICAgICAgICAgICAgICAgICAgTlVMTF9FWFBSIDpcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW5kZXJOb2RlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLmdldE9yQ3JlYXRlTGFzdFJlbmRlck5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XG4gICAgICAgICAgaWYgKHZpZXcucm9vdE5vZGVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICB2aWV3LnJvb3ROb2Rlc1t2aWV3LnJvb3ROb2Rlcy5sZW5ndGggLSAxXS50eXBlICE9PSBDb21waWxlVmlld1Jvb3ROb2RlVHlwZS5Ob2RlKSB7XG4gICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl9lbF9cIiArIHZpZXcubm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZSh2aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJFbGVtZW50KSkpO1xuICAgICAgICAgICAgICB2aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgIC5zZXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVGVtcGxhdGVBbmNob3InLCBbTlVMTF9FWFBSLCBOVUxMX0VYUFJdKSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgIHZpZXcucm9vdE5vZGVzLnB1c2gobmV3IENvbXBpbGVWaWV3Um9vdE5vZGUoQ29tcGlsZVZpZXdSb290Tm9kZVR5cGUuTm9kZSwgVEhJU19FWFBSLnByb3AoZmllbGROYW1lKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmlldy5yb290Tm9kZXNbdmlldy5yb290Tm9kZXMubGVuZ3RoIC0gMV0uZXhwcjtcbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0VGV4dChhc3QsICcnLCBwYXJlbnQpO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0VGV4dChhc3QsIGFzdC52YWx1ZSwgcGFyZW50KTtcbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCB2YWx1ZSwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IFwiX3RleHRfXCIgKyB0aGlzLnZpZXcubm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChmaWVsZE5hbWUsIGltcG9ydFR5cGUodGhpcy52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJUZXh0KSkpO1xuICAgICAgICAgIHZhciByZW5kZXJOb2RlID0gVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgICB2YXIgY29tcGlsZU5vZGUgPSBuZXcgQ29tcGlsZU5vZGUocGFyZW50LCB0aGlzLnZpZXcsIHRoaXMudmlldy5ub2Rlcy5sZW5ndGgsIHJlbmRlck5vZGUsIGFzdCk7XG4gICAgICAgICAgdmFyIGNyZWF0ZVJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpXG4gICAgICAgICAgICAgIC5zZXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVGV4dCcsIFtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLCBsaXRlcmFsKHZhbHVlKSxcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mb0V4cHIodGhpcy52aWV3Lm5vZGVzLmxlbmd0aCwgYXN0KVxuICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgdGhpcy52aWV3Lm5vZGVzLnB1c2goY29tcGlsZU5vZGUpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChjcmVhdGVSZW5kZXJOb2RlKTtcbiAgICAgICAgICB0aGlzLl9hZGRSb290Tm9kZUFuZFByb2plY3QoY29tcGlsZU5vZGUpO1xuICAgICAgICAgIHJldHVybiByZW5kZXJOb2RlO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICAvLyB0aGUgcHJvamVjdGVkIG5vZGVzIG9yaWdpbmF0ZSBmcm9tIGEgZGlmZmVyZW50IHZpZXcsIHNvIHdlIGRvbid0XG4gICAgICAgICAgLy8gaGF2ZSBkZWJ1ZyBpbmZvcm1hdGlvbiBmb3IgdGhlbS4uLlxuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm8obnVsbCwgYXN0KTtcbiAgICAgICAgICB2YXIgcGFyZW50UmVuZGVyTm9kZSA9IHRoaXMuX2dldFBhcmVudFJlbmRlck5vZGUocGFyZW50KTtcbiAgICAgICAgICBpZiAocGFyZW50UmVuZGVyTm9kZSAhPT0gTlVMTF9FWFBSKSB7XG4gICAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIuY2FsbE1ldGhvZCgncHJvamVjdE5vZGVzJywgW3BhcmVudFJlbmRlck5vZGUsIGxpdGVyYWwoYXN0LmluZGV4KV0pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy52aWV3VHlwZSAhPT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdG9yZSByb290IG5vZGVzIG9ubHkgZm9yIGVtYmVkZGVkL2hvc3Qgdmlld3NcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5yb290Tm9kZXMucHVzaChuZXcgQ29tcGlsZVZpZXdSb290Tm9kZShDb21waWxlVmlld1Jvb3ROb2RlVHlwZS5OZ0NvbnRlbnQsIG51bGwsIGFzdC5pbmRleCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudC5jb21wb25lbnQpICYmIGlzUHJlc2VudChhc3QubmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ29udGVudE5vZGUoYXN0Lm5nQ29udGVudEluZGV4LCBuZXcgQ29tcGlsZVZpZXdSb290Tm9kZShDb21waWxlVmlld1Jvb3ROb2RlVHlwZS5OZ0NvbnRlbnQsIG51bGwsIGFzdC5pbmRleCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMudmlldy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGNyZWF0ZVJlbmRlck5vZGVFeHByO1xuICAgICAgICAgIHZhciBkZWJ1Z0NvbnRleHRFeHByID0gdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mb0V4cHIobm9kZUluZGV4LCBhc3QpO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gYXN0LmRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHsgcmV0dXJuIGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmU7IH0pO1xuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgICBpZiAoYXN0Lm5hbWUgPT09IE5HX0NPTlRBSU5FUl9UQUcpIHtcbiAgICAgICAgICAgICAgY3JlYXRlUmVuZGVyTm9kZUV4cHIgPSBWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVUZW1wbGF0ZUFuY2hvcicsIFt0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksIGRlYnVnQ29udGV4dEV4cHJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBodG1sQXR0cnMgPSBfcmVhZEh0bWxBdHRycyhhc3QuYXR0cnMpO1xuICAgICAgICAgICAgICB2YXIgYXR0ck5hbWVBbmRWYWx1ZXMgPSBjcmVhdGVJbmxpbmVBcnJheShfbWVyZ2VIdG1sQW5kRGlyZWN0aXZlQXR0cnMoaHRtbEF0dHJzLCBkaXJlY3RpdmVzKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGxpdGVyYWwodik7IH0pKTtcbiAgICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA9PT0gMCAmJiB0aGlzLnZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlck5vZGVFeHByID1cbiAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLnNlbGVjdE9yQ3JlYXRlUmVuZGVySG9zdEVsZW1lbnQpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy5yZW5kZXJlciwgbGl0ZXJhbChhc3QubmFtZSksIGF0dHJOYW1lQW5kVmFsdWVzLCByb290U2VsZWN0b3JWYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnQ29udGV4dEV4cHJcbiAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlck5vZGVFeHByID1cbiAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNyZWF0ZVJlbmRlckVsZW1lbnQpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy5yZW5kZXJlciwgdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLCBsaXRlcmFsKGFzdC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWVBbmRWYWx1ZXMsIGRlYnVnQ29udGV4dEV4cHJcbiAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfZWxfXCIgKyBub2RlSW5kZXg7XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlckVsZW1lbnQpKSk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSkuc2V0KGNyZWF0ZVJlbmRlck5vZGVFeHByKS50b1N0bXQoKSk7XG4gICAgICAgICAgdmFyIHJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IG5ldyBDb21waWxlRWxlbWVudChwYXJlbnQsIHRoaXMudmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBhc3QsIGNvbXBvbmVudCwgZGlyZWN0aXZlcywgYXN0LnByb3ZpZGVycywgYXN0Lmhhc1ZpZXdDb250YWluZXIsIGZhbHNlLCBhc3QucmVmZXJlbmNlcywgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIHRoaXMudmlldy5ub2Rlcy5wdXNoKGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICB2YXIgY29tcFZpZXdFeHByID0gbnVsbDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZENvbXBvbmVudElkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGdldFZpZXdDbGFzc05hbWUoY29tcG9uZW50LCAwKSB9KTtcbiAgICAgICAgICAgICAgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMucHVzaChuZXcgVmlld0NsYXNzRGVwZW5kZW5jeShjb21wb25lbnQudHlwZSwgbmVzdGVkQ29tcG9uZW50SWRlbnRpZmllcikpO1xuICAgICAgICAgICAgICBjb21wVmlld0V4cHIgPSBUSElTX0VYUFIucHJvcChcImNvbXBWaWV3X1wiICsgbm9kZUluZGV4KTsgLy8gZml4IGhpZ2hsaWdodGluZzogYFxuICAgICAgICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoY29tcFZpZXdFeHByLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtpbXBvcnRUeXBlKGNvbXBvbmVudC50eXBlKV0pKSk7XG4gICAgICAgICAgICAgIHRoaXMudmlldy52aWV3Q2hpbGRyZW4ucHVzaChjb21wVmlld0V4cHIpO1xuICAgICAgICAgICAgICBjb21waWxlRWxlbWVudC5zZXRDb21wb25lbnRWaWV3KGNvbXBWaWV3RXhwcik7XG4gICAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChjb21wVmlld0V4cHJcbiAgICAgICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihuZXN0ZWRDb21wb25lbnRJZGVudGlmaWVyKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy52aWV3VXRpbHMsIFRISVNfRVhQUiwgbGl0ZXJhbChub2RlSW5kZXgpLCByZW5kZXJOb2RlXG4gICAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQuYmVmb3JlQ2hpbGRyZW4oKTtcbiAgICAgICAgICB0aGlzLl9hZGRSb290Tm9kZUFuZFByb2plY3QoY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIHRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQuYWZ0ZXJDaGlsZHJlbih0aGlzLnZpZXcubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wVmlld0V4cHIpKSB7XG4gICAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChjb21wVmlld0V4cHIuY2FsbE1ldGhvZCgnY3JlYXRlJywgW2NvbXBpbGVFbGVtZW50LmdldENvbXBvbmVudCgpXSkudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLnZpZXcubm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl9hbmNob3JfXCIgKyBub2RlSW5kZXg7XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlckNvbW1lbnQpKSk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgLnNldChWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVUZW1wbGF0ZUFuY2hvcicsIFtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLFxuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvRXhwcihub2RlSW5kZXgsIGFzdClcbiAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSk7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncyA9IGFzdC52YXJpYWJsZXMubWFwKGZ1bmN0aW9uICh2YXJBc3QpIHsgcmV0dXJuIFt2YXJBc3QudmFsdWUubGVuZ3RoID4gMCA/IHZhckFzdC52YWx1ZSA6IElNUExJQ0lUX1RFTVBMQVRFX1ZBUiwgdmFyQXN0Lm5hbWVdOyB9KTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGFzdC5kaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgICB2YXIgY29tcGlsZUVsZW1lbnQgPSBuZXcgQ29tcGlsZUVsZW1lbnQocGFyZW50LCB0aGlzLnZpZXcsIG5vZGVJbmRleCwgcmVuZGVyTm9kZSwgYXN0LCBudWxsLCBkaXJlY3RpdmVzLCBhc3QucHJvdmlkZXJzLCBhc3QuaGFzVmlld0NvbnRhaW5lciwgdHJ1ZSwgYXN0LnJlZmVyZW5jZXMsIHRoaXMudGFyZ2V0RGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICB0aGlzLnZpZXcubm9kZXMucHVzaChjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3Q291bnQrKztcbiAgICAgICAgICB2YXIgZW1iZWRkZWRWaWV3ID0gbmV3IENvbXBpbGVWaWV3KHRoaXMudmlldy5jb21wb25lbnQsIHRoaXMudmlldy5nZW5Db25maWcsIHRoaXMudmlldy5waXBlTWV0YXMsIE5VTExfRVhQUiwgdGhpcy52aWV3LmFuaW1hdGlvbnMsIHRoaXMudmlldy52aWV3SW5kZXggKyB0aGlzLm5lc3RlZFZpZXdDb3VudCwgY29tcGlsZUVsZW1lbnQsIHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncyk7XG4gICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3Q291bnQgKz0gYnVpbGRWaWV3KGVtYmVkZGVkVmlldywgYXN0LmNoaWxkcmVuLCB0aGlzLnRhcmdldERlcGVuZGVuY2llcyk7XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQuYmVmb3JlQ2hpbGRyZW4oKTtcbiAgICAgICAgICB0aGlzLl9hZGRSb290Tm9kZUFuZFByb2plY3QoY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmFmdGVyQ2hpbGRyZW4oMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgZXZlbnRUYXJnZXRBbmROYW1lcykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICByZXR1cm4gVmlld0J1aWxkZXJWaXNpdG9yO1xuICB9KCkpO1xuICAvKipcbiAgICogV2Fsa3MgdXAgdGhlIG5vZGVzIHdoaWxlIHRoZSBkaXJlY3QgcGFyZW50IGlzIGEgY29udGFpbmVyLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBvdXRlciBjb250YWluZXIgb3IgdGhlIG5vZGUgaXRzZWxmIHdoZW4gaXQgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIGEgY29udGFpbmVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRPdXRlckNvbnRhaW5lck9yU2VsZihub2RlKSB7XG4gICAgICB2YXIgdmlldyA9IG5vZGUudmlldztcbiAgICAgIHdoaWxlIChfaXNOZ0NvbnRhaW5lcihub2RlLnBhcmVudCwgdmlldykpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvKipcbiAgICogV2Fsa3MgdXAgdGhlIG5vZGVzIHdoaWxlIHRoZXkgYXJlIGNvbnRhaW5lciBhbmQgcmV0dXJucyB0aGUgZmlyc3QgcGFyZW50IHdoaWNoIGlzIG5vdC5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoZSBvdXRlciBjb250YWluZXIgb3IgdGhlIG5vZGUgaXRzZWxmIHdoZW4gaXQgaXMgbm90IGEgY29udGFpbmVyLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRPdXRlckNvbnRhaW5lclBhcmVudE9yU2VsZihlbCkge1xuICAgICAgdmFyIHZpZXcgPSBlbC52aWV3O1xuICAgICAgd2hpbGUgKF9pc05nQ29udGFpbmVyKGVsLCB2aWV3KSkge1xuICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsO1xuICB9XG4gIGZ1bmN0aW9uIF9pc05nQ29udGFpbmVyKG5vZGUsIHZpZXcpIHtcbiAgICAgIHJldHVybiAhbm9kZS5pc051bGwoKSAmJiBub2RlLnNvdXJjZUFzdC5uYW1lID09PSBOR19DT05UQUlORVJfVEFHICYmXG4gICAgICAgICAgbm9kZS52aWV3ID09PSB2aWV3O1xuICB9XG4gIGZ1bmN0aW9uIF9tZXJnZUh0bWxBbmREaXJlY3RpdmVBdHRycyhkZWNsYXJlZEh0bWxBdHRycywgZGlyZWN0aXZlcykge1xuICAgICAgdmFyIG1hcFJlc3VsdCA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoZGVjbGFyZWRIdG1sQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBtYXBSZXN1bHRba2V5XSA9IGRlY2xhcmVkSHRtbEF0dHJzW2tleV07IH0pO1xuICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVNZXRhKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMoZGlyZWN0aXZlTWV0YS5ob3N0QXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkaXJlY3RpdmVNZXRhLmhvc3RBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gbWFwUmVzdWx0W25hbWVdO1xuICAgICAgICAgICAgICBtYXBSZXN1bHRbbmFtZV0gPSBpc1ByZXNlbnQocHJldlZhbHVlKSA/IG1lcmdlQXR0cmlidXRlVmFsdWUobmFtZSwgcHJldlZhbHVlLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFyclJlc3VsdCA9IFtdO1xuICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBzb3J0IHRvIGdldCBhIGRlZmluZWQgb3V0cHV0IG9yZGVyXG4gICAgICAvLyBmb3IgdGVzdHMgYW5kIGZvciBjYWNoaW5nIGdlbmVyYXRlZCBhcnRpZmFjdHMuLi5cbiAgICAgIE9iamVjdC5rZXlzKG1hcFJlc3VsdCkuc29ydCgpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7IGFyclJlc3VsdC5wdXNoKGF0dHJOYW1lLCBtYXBSZXN1bHRbYXR0ck5hbWVdKTsgfSk7XG4gICAgICByZXR1cm4gYXJyUmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIF9yZWFkSHRtbEF0dHJzKGF0dHJzKSB7XG4gICAgICB2YXIgaHRtbEF0dHJzID0ge307XG4gICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHsgaHRtbEF0dHJzW2FzdC5uYW1lXSA9IGFzdC52YWx1ZTsgfSk7XG4gICAgICByZXR1cm4gaHRtbEF0dHJzO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlVmFsdWUoYXR0ck5hbWUsIGF0dHJWYWx1ZTEsIGF0dHJWYWx1ZTIpIHtcbiAgICAgIGlmIChhdHRyTmFtZSA9PSBDTEFTU19BVFRSJDEgfHwgYXR0ck5hbWUgPT0gU1RZTEVfQVRUUikge1xuICAgICAgICAgIHJldHVybiBhdHRyVmFsdWUxICsgXCIgXCIgKyBhdHRyVmFsdWUyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHJWYWx1ZTI7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVmlld1RvcExldmVsU3RtdHModmlldywgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgdmFyIG5vZGVEZWJ1Z0luZm9zVmFyID0gTlVMTF9FWFBSO1xuICAgICAgaWYgKHZpZXcuZ2VuQ29uZmlnLmdlbkRlYnVnSW5mbykge1xuICAgICAgICAgIG5vZGVEZWJ1Z0luZm9zVmFyID0gdmFyaWFibGUoXCJub2RlRGVidWdJbmZvc19cIiArIHZpZXcuY29tcG9uZW50LnR5cGUubmFtZSArIHZpZXcudmlld0luZGV4KTsgLy8gZml4IGhpZ2hsaWdodGluZzogYFxuICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaChub2RlRGVidWdJbmZvc1ZhclxuICAgICAgICAgICAgICAuc2V0KGxpdGVyYWxBcnIodmlldy5ub2Rlcy5tYXAoY3JlYXRlU3RhdGljTm9kZURlYnVnSW5mbyksIG5ldyBBcnJheVR5cGUobmV3IEV4dGVybmFsVHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvKSksIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVuZGVyQ29tcFR5cGVWYXIgPSB2YXJpYWJsZShcInJlbmRlclR5cGVfXCIgKyB2aWV3LmNvbXBvbmVudC50eXBlLm5hbWUpOyAvLyBmaXggaGlnaGxpZ2h0aW5nOiBgXG4gICAgICBpZiAodmlldy52aWV3SW5kZXggPT09IDApIHtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVVcmxJbmZvID0gdm9pZCAwO1xuICAgICAgICAgIGlmICh2aWV3LmNvbXBvbmVudC50ZW1wbGF0ZS50ZW1wbGF0ZVVybCA9PSB2aWV3LmNvbXBvbmVudC50eXBlLm1vZHVsZVVybCkge1xuICAgICAgICAgICAgICB0ZW1wbGF0ZVVybEluZm8gPVxuICAgICAgICAgICAgICAgICAgdmlldy5jb21wb25lbnQudHlwZS5tb2R1bGVVcmwgKyBcIiBjbGFzcyBcIiArIHZpZXcuY29tcG9uZW50LnR5cGUubmFtZSArIFwiIC0gaW5saW5lIHRlbXBsYXRlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0ZW1wbGF0ZVVybEluZm8gPSB2aWV3LmNvbXBvbmVudC50ZW1wbGF0ZS50ZW1wbGF0ZVVybDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHJlbmRlckNvbXBUeXBlVmFyXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5jcmVhdGVSZW5kZXJDb21wb25lbnRUeXBlKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgdmlldy5nZW5Db25maWcuZ2VuRGVidWdJbmZvID8gbGl0ZXJhbCh0ZW1wbGF0ZVVybEluZm8pIDogbGl0ZXJhbCgnJyksXG4gICAgICAgICAgICAgIGxpdGVyYWwodmlldy5jb21wb25lbnQudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aCksXG4gICAgICAgICAgICAgIFZpZXdFbmNhcHN1bGF0aW9uRW51bS5mcm9tVmFsdWUodmlldy5jb21wb25lbnQudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiksXG4gICAgICAgICAgICAgIHZpZXcuc3R5bGVzLFxuICAgICAgICAgICAgICBsaXRlcmFsTWFwKHZpZXcuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBbZW50cnkubmFtZSwgZW50cnkuZm5FeHBdOyB9KSksXG4gICAgICAgICAgXSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUmVuZGVyQ29tcG9uZW50VHlwZSkpKSk7XG4gICAgICB9XG4gICAgICB2YXIgdmlld0NsYXNzID0gY3JlYXRlVmlld0NsYXNzKHZpZXcsIHJlbmRlckNvbXBUeXBlVmFyLCBub2RlRGVidWdJbmZvc1Zhcik7XG4gICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2godmlld0NsYXNzKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVTdGF0aWNOb2RlRGVidWdJbmZvKG5vZGUpIHtcbiAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IG5vZGUgaW5zdGFuY2VvZiBDb21waWxlRWxlbWVudCA/IG5vZGUgOiBudWxsO1xuICAgICAgdmFyIHByb3ZpZGVyVG9rZW5zID0gW107XG4gICAgICB2YXIgY29tcG9uZW50VG9rZW4gPSBOVUxMX0VYUFI7XG4gICAgICB2YXIgdmFyVG9rZW5FbnRyaWVzID0gW107XG4gICAgICBpZiAoaXNQcmVzZW50KGNvbXBpbGVFbGVtZW50KSkge1xuICAgICAgICAgIHByb3ZpZGVyVG9rZW5zID0gY29tcGlsZUVsZW1lbnQuZ2V0UHJvdmlkZXJUb2tlbnMoKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBpbGVFbGVtZW50LmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50VG9rZW4gPSBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihpZGVudGlmaWVyVG9rZW4oY29tcGlsZUVsZW1lbnQuY29tcG9uZW50LnR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmtleXMoY29tcGlsZUVsZW1lbnQucmVmZXJlbmNlVG9rZW5zKS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlbiA9IGNvbXBpbGVFbGVtZW50LnJlZmVyZW5jZVRva2Vuc1t2YXJOYW1lXTtcbiAgICAgICAgICAgICAgdmFyVG9rZW5FbnRyaWVzLnB1c2goW3Zhck5hbWUsIGlzUHJlc2VudCh0b2tlbikgPyBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikgOiBOVUxMX0VYUFJdKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlN0YXRpY05vZGVEZWJ1Z0luZm8pKVxuICAgICAgICAgIC5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgbGl0ZXJhbEFycihwcm92aWRlclRva2VucywgbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSksXG4gICAgICAgICAgY29tcG9uZW50VG9rZW4sXG4gICAgICAgICAgbGl0ZXJhbE1hcCh2YXJUb2tlbkVudHJpZXMsIG5ldyBNYXBUeXBlKERZTkFNSUNfVFlQRSwgW1R5cGVNb2RpZmllci5Db25zdF0pKVxuICAgICAgXSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvKSwgbnVsbCwgW1R5cGVNb2RpZmllci5Db25zdF0pKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVWaWV3Q2xhc3ModmlldywgcmVuZGVyQ29tcFR5cGVWYXIsIG5vZGVEZWJ1Z0luZm9zVmFyKSB7XG4gICAgICB2YXIgdmlld0NvbnN0cnVjdG9yQXJncyA9IFtcbiAgICAgICAgICBuZXcgRm5QYXJhbShWaWV3Q29uc3RydWN0b3JWYXJzLnZpZXdVdGlscy5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlZpZXdVdGlscykpKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudFZpZXcubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBWaWV3KSwgW0RZTkFNSUNfVFlQRV0pKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudEluZGV4Lm5hbWUsIE5VTUJFUl9UWVBFKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudEVsZW1lbnQubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgXTtcbiAgICAgIHZhciBzdXBlckNvbnN0cnVjdG9yQXJncyA9IFtcbiAgICAgICAgICB2YXJpYWJsZSh2aWV3LmNsYXNzTmFtZSksIHJlbmRlckNvbXBUeXBlVmFyLCBWaWV3VHlwZUVudW0uZnJvbVZhbHVlKHZpZXcudmlld1R5cGUpLFxuICAgICAgICAgIFZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzLCBWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudFZpZXcsIFZpZXdDb25zdHJ1Y3RvclZhcnMucGFyZW50SW5kZXgsXG4gICAgICAgICAgVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzRW51bS5mcm9tVmFsdWUoZ2V0Q2hhbmdlRGV0ZWN0aW9uTW9kZSh2aWV3KSlcbiAgICAgIF07XG4gICAgICBpZiAodmlldy5nZW5Db25maWcuZ2VuRGVidWdJbmZvKSB7XG4gICAgICAgICAgc3VwZXJDb25zdHJ1Y3RvckFyZ3MucHVzaChub2RlRGVidWdJbmZvc1Zhcik7XG4gICAgICB9XG4gICAgICBpZiAodmlldy52aWV3VHlwZSA9PT0gVmlld1R5cGUuRU1CRURERUQpIHtcbiAgICAgICAgICB2aWV3Q29uc3RydWN0b3JBcmdzLnB1c2gobmV3IEZuUGFyYW0oJ2RlY2xhcmVkVmlld0NvbnRhaW5lcicsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lcikpKSk7XG4gICAgICAgICAgc3VwZXJDb25zdHJ1Y3RvckFyZ3MucHVzaCh2YXJpYWJsZSgnZGVjbGFyZWRWaWV3Q29udGFpbmVyJykpO1xuICAgICAgfVxuICAgICAgdmFyIHZpZXdNZXRob2RzID0gW1xuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnY3JlYXRlSW50ZXJuYWwnLCBbbmV3IEZuUGFyYW0ocm9vdFNlbGVjdG9yVmFyLm5hbWUsIFNUUklOR19UWVBFKV0sIGdlbmVyYXRlQ3JlYXRlTWV0aG9kKHZpZXcpLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudFJlZiksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdpbmplY3RvckdldEludGVybmFsJywgW1xuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzLnRva2VuLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIC8vIE5vdGU6IENhbid0IHVzZSBvLklOVF9UWVBFIGhlcmUgYXMgdGhlIG1ldGhvZCBpbiBBcHBWaWV3IHVzZXMgbnVtYmVyXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleC5uYW1lLCBOVU1CRVJfVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgICAgIF0sIGFkZFJldHVyblZhbHVlZk5vdEVtcHR5KHZpZXcuaW5qZWN0b3JHZXRNZXRob2QuZmluaXNoKCksIEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQpLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGV0ZWN0Q2hhbmdlc0ludGVybmFsJywgW25ldyBGblBhcmFtKERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UubmFtZSwgQk9PTF9UWVBFKV0sIGdlbmVyYXRlRGV0ZWN0Q2hhbmdlc01ldGhvZCh2aWV3KSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdkaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCcsIFtdLCB2aWV3LmRpcnR5UGFyZW50UXVlcmllc01ldGhvZC5maW5pc2goKSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdkZXN0cm95SW50ZXJuYWwnLCBbXSwgZ2VuZXJhdGVEZXN0cm95TWV0aG9kKHZpZXcpKSxcbiAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2RldGFjaEludGVybmFsJywgW10sIHZpZXcuZGV0YWNoTWV0aG9kLmZpbmlzaCgpKSxcbiAgICAgICAgICBnZW5lcmF0ZVZpc2l0Um9vdE5vZGVzTWV0aG9kKHZpZXcpLCBnZW5lcmF0ZVZpc2l0UHJvamVjdGFibGVOb2Rlc01ldGhvZCh2aWV3KSxcbiAgICAgICAgICBnZW5lcmF0ZUNyZWF0ZUVtYmVkZGVkVmlld3NNZXRob2QodmlldylcbiAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIG1ldGhvZC5ib2R5Lmxlbmd0aCA+IDA7IH0pO1xuICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8gPyBJZGVudGlmaWVycy5EZWJ1Z0FwcFZpZXcgOiBJZGVudGlmaWVycy5BcHBWaWV3O1xuICAgICAgdmFyIHZpZXdDbGFzcyA9IGNyZWF0ZUNsYXNzU3RtdCh7XG4gICAgICAgICAgbmFtZTogdmlldy5jbGFzc05hbWUsXG4gICAgICAgICAgcGFyZW50OiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKHN1cGVyQ2xhc3MpLCBbZ2V0Q29udGV4dFR5cGUodmlldyldKSxcbiAgICAgICAgICBwYXJlbnRBcmdzOiBzdXBlckNvbnN0cnVjdG9yQXJncyxcbiAgICAgICAgICBjdG9yUGFyYW1zOiB2aWV3Q29uc3RydWN0b3JBcmdzLFxuICAgICAgICAgIGJ1aWxkZXJzOiBbeyBtZXRob2RzOiB2aWV3TWV0aG9kcyB9LCB2aWV3XVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmlld0NsYXNzO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlRGVzdHJveU1ldGhvZCh2aWV3KSB7XG4gICAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICAgIHZpZXcudmlld0NvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAodmlld0NvbnRhaW5lcikge1xuICAgICAgICAgIHN0bXRzLnB1c2godmlld0NvbnRhaW5lci5jYWxsTWV0aG9kKCdkZXN0cm95TmVzdGVkVmlld3MnLCBbXSkudG9TdG10KCkpO1xuICAgICAgfSk7XG4gICAgICB2aWV3LnZpZXdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3Q2hpbGQpIHsgc3RtdHMucHVzaCh2aWV3Q2hpbGQuY2FsbE1ldGhvZCgnZGVzdHJveScsIFtdKS50b1N0bXQoKSk7IH0pO1xuICAgICAgc3RtdHMucHVzaC5hcHBseShzdG10cywgdmlldy5kZXN0cm95TWV0aG9kLmZpbmlzaCgpKTtcbiAgICAgIHJldHVybiBzdG10cztcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUNyZWF0ZU1ldGhvZCh2aWV3KSB7XG4gICAgICB2YXIgcGFyZW50UmVuZGVyTm9kZUV4cHIgPSBOVUxMX0VYUFI7XG4gICAgICB2YXIgcGFyZW50UmVuZGVyTm9kZVN0bXRzID0gW107XG4gICAgICBpZiAodmlldy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgcGFyZW50UmVuZGVyTm9kZUV4cHIgPVxuICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVWaWV3Um9vdCcsIFtUSElTX0VYUFIucHJvcCgncGFyZW50RWxlbWVudCcpXSk7XG4gICAgICAgICAgcGFyZW50UmVuZGVyTm9kZVN0bXRzID1cbiAgICAgICAgICAgICAgW3BhcmVudFJlbmRlck5vZGVWYXIuc2V0KHBhcmVudFJlbmRlck5vZGVFeHByKVxuICAgICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUodmlldy5nZW5Db25maWcucmVuZGVyVHlwZXMucmVuZGVyTm9kZSksIFtTdG10TW9kaWZpZXIuRmluYWxdKV07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0RXhwcjtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5IT1NUKSB7XG4gICAgICAgICAgdmFyIGhvc3RFbCA9IHZpZXcubm9kZXNbMF07XG4gICAgICAgICAgcmVzdWx0RXhwciA9XG4gICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29tcG9uZW50UmVmXyksIFtEWU5BTUlDX1RZUEVdKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgICAgICBsaXRlcmFsKGhvc3RFbC5ub2RlSW5kZXgpLCBUSElTX0VYUFIsIGhvc3RFbC5yZW5kZXJOb2RlLCBob3N0RWwuZ2V0Q29tcG9uZW50KClcbiAgICAgICAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHRFeHByID0gTlVMTF9FWFBSO1xuICAgICAgfVxuICAgICAgdmFyIGFsbE5vZGVzRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhc3QoRFlOQU1JQ19UWVBFKVxuICAgICAgICAgIC5wcm9wKCdkaXJlY3RSZW5kZXJlcicpXG4gICAgICAgICAgLmNvbmRpdGlvbmFsKE5VTExfRVhQUiwgbGl0ZXJhbEFycih2aWV3Lm5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5yZW5kZXJOb2RlOyB9KSkpO1xuICAgICAgcmV0dXJuIHBhcmVudFJlbmRlck5vZGVTdG10cy5jb25jYXQodmlldy5jcmVhdGVNZXRob2QuZmluaXNoKCksIFtcbiAgICAgICAgICBUSElTX0VYUFJcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ2luaXQnLCBbXG4gICAgICAgICAgICAgIHZpZXcubGFzdFJlbmRlck5vZGUsXG4gICAgICAgICAgICAgIGFsbE5vZGVzRXhwcixcbiAgICAgICAgICAgICAgdmlldy5kaXNwb3NhYmxlcy5sZW5ndGggPyBsaXRlcmFsQXJyKHZpZXcuZGlzcG9zYWJsZXMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSxcbiAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KHJlc3VsdEV4cHIpXG4gICAgICBdKTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZURldGVjdENoYW5nZXNNZXRob2Qodmlldykge1xuICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICBpZiAodmlldy5hbmltYXRpb25CaW5kaW5nc01ldGhvZC5pc0VtcHR5KCkgJiYgdmlldy5kZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuaXNFbXB0eSgpICYmXG4gICAgICAgICAgdmlldy51cGRhdGVDb250ZW50UXVlcmllc01ldGhvZC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICB2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLmlzRW1wdHkoKSAmJlxuICAgICAgICAgIHZpZXcudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QuaXNFbXB0eSgpICYmIHZpZXcuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmlzRW1wdHkoKSAmJlxuICAgICAgICAgIHZpZXcudmlld0NvbnRhaW5lcnMubGVuZ3RoID09PSAwICYmIHZpZXcudmlld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzdG10cztcbiAgICAgIH1cbiAgICAgIHN0bXRzLnB1c2guYXBwbHkoc3RtdHMsIHZpZXcuYW5pbWF0aW9uQmluZGluZ3NNZXRob2QuZmluaXNoKCkpO1xuICAgICAgc3RtdHMucHVzaC5hcHBseShzdG10cywgdmlldy5kZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuZmluaXNoKCkpO1xuICAgICAgdmlldy52aWV3Q29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgc3RtdHMucHVzaCh2aWV3Q29udGFpbmVyLmNhbGxNZXRob2QoJ2RldGVjdENoYW5nZXNJbk5lc3RlZFZpZXdzJywgW0RldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJDb250ZW50U3RtdHMgPSB2aWV3LnVwZGF0ZUNvbnRlbnRRdWVyaWVzTWV0aG9kLmZpbmlzaCgpLmNvbmNhdCh2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5maW5pc2goKSk7XG4gICAgICBpZiAoYWZ0ZXJDb250ZW50U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3IElmU3RtdChub3QoRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSksIGFmdGVyQ29udGVudFN0bXRzKSk7XG4gICAgICB9XG4gICAgICBzdG10cy5wdXNoLmFwcGx5KHN0bXRzLCB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLmZpbmlzaCgpKTtcbiAgICAgIHZpZXcudmlld0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHZpZXdDaGlsZCkge1xuICAgICAgICAgIHN0bXRzLnB1c2godmlld0NoaWxkLmNhbGxNZXRob2QoJ2RldGVjdENoYW5nZXMnLCBbRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZV0pLnRvU3RtdCgpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFmdGVyVmlld1N0bXRzID0gdmlldy51cGRhdGVWaWV3UXVlcmllc01ldGhvZC5maW5pc2goKS5jb25jYXQodmlldy5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuZmluaXNoKCkpO1xuICAgICAgaWYgKGFmdGVyVmlld1N0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdG10cy5wdXNoKG5ldyBJZlN0bXQobm90KERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UpLCBhZnRlclZpZXdTdG10cykpO1xuICAgICAgfVxuICAgICAgdmFyIHZhclN0bXRzID0gW107XG4gICAgICB2YXIgcmVhZFZhcnMgPSBmaW5kUmVhZFZhck5hbWVzKHN0bXRzKTtcbiAgICAgIGlmIChyZWFkVmFycy5oYXMoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlZC5uYW1lKSkge1xuICAgICAgICAgIHZhclN0bXRzLnB1c2goRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlZC5zZXQobGl0ZXJhbCh0cnVlKSkudG9EZWNsU3RtdChCT09MX1RZUEUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkVmFycy5oYXMoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5uYW1lKSkge1xuICAgICAgICAgIHZhclN0bXRzLnB1c2goRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5zZXQoTlVMTF9FWFBSKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChuZXcgTWFwVHlwZShpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlNpbXBsZUNoYW5nZSkpKSkpO1xuICAgICAgfVxuICAgICAgdmFyU3RtdHMucHVzaC5hcHBseSh2YXJTdG10cywgY3JlYXRlU2hhcmVkQmluZGluZ1ZhcmlhYmxlc0lmTmVlZGVkKHN0bXRzKSk7XG4gICAgICByZXR1cm4gdmFyU3RtdHMuY29uY2F0KHN0bXRzKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRSZXR1cm5WYWx1ZWZOb3RFbXB0eShzdGF0ZW1lbnRzLCB2YWx1ZSkge1xuICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLmNvbmNhdChbbmV3IFJldHVyblN0YXRlbWVudCh2YWx1ZSldKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldENvbnRleHRUeXBlKHZpZXcpIHtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0VHlwZSh2aWV3LmNvbXBvbmVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBEWU5BTUlDX1RZUEU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2hhbmdlRGV0ZWN0aW9uTW9kZSh2aWV3KSB7XG4gICAgICB2YXIgbW9kZTtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICBtb2RlID0gaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kodmlldy5jb21wb25lbnQuY2hhbmdlRGV0ZWN0aW9uKSA/XG4gICAgICAgICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrQWx3YXlzIDpcbiAgICAgICAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tPbmNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgbW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrQWx3YXlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVWaXNpdFJvb3ROb2Rlc01ldGhvZCh2aWV3KSB7XG4gICAgICB2YXIgY2JWYXIgPSB2YXJpYWJsZSgnY2InKTtcbiAgICAgIHZhciBjdHhWYXIgPSB2YXJpYWJsZSgnY3R4Jyk7XG4gICAgICB2YXIgc3RtdHMgPSBnZW5lcmF0ZVZpc2l0Tm9kZXNTdG10cyh2aWV3LnJvb3ROb2RlcywgY2JWYXIsIGN0eFZhcik7XG4gICAgICByZXR1cm4gbmV3IENsYXNzTWV0aG9kKCd2aXNpdFJvb3ROb2Rlc0ludGVybmFsJywgW25ldyBGblBhcmFtKGNiVmFyLm5hbWUsIERZTkFNSUNfVFlQRSksIG5ldyBGblBhcmFtKGN0eFZhci5uYW1lLCBEWU5BTUlDX1RZUEUpXSwgc3RtdHMpO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVmlzaXRQcm9qZWN0YWJsZU5vZGVzTWV0aG9kKHZpZXcpIHtcbiAgICAgIHZhciBub2RlSW5kZXhWYXIgPSB2YXJpYWJsZSgnbm9kZUluZGV4Jyk7XG4gICAgICB2YXIgbmdDb250ZW50SW5kZXhWYXIgPSB2YXJpYWJsZSgnbmdDb250ZW50SW5kZXgnKTtcbiAgICAgIHZhciBjYlZhciA9IHZhcmlhYmxlKCdjYicpO1xuICAgICAgdmFyIGN0eFZhciA9IHZhcmlhYmxlKCdjdHgnKTtcbiAgICAgIHZhciBzdG10cyA9IFtdO1xuICAgICAgdmlldy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb21waWxlRWxlbWVudCAmJiBub2RlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXguZm9yRWFjaChmdW5jdGlvbiAocHJvamVjdGVkTm9kZXMsIG5nQ29udGVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBzdG10cy5wdXNoKG5ldyBJZlN0bXQobm9kZUluZGV4VmFyLmVxdWFscyhsaXRlcmFsKG5vZGUubm9kZUluZGV4KSlcbiAgICAgICAgICAgICAgICAgICAgICAuYW5kKG5nQ29udGVudEluZGV4VmFyLmVxdWFscyhsaXRlcmFsKG5nQ29udGVudEluZGV4KSkpLCBnZW5lcmF0ZVZpc2l0Tm9kZXNTdG10cyhwcm9qZWN0ZWROb2RlcywgY2JWYXIsIGN0eFZhcikpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IENsYXNzTWV0aG9kKCd2aXNpdFByb2plY3RhYmxlTm9kZXNJbnRlcm5hbCcsIFtcbiAgICAgICAgICBuZXcgRm5QYXJhbShub2RlSW5kZXhWYXIubmFtZSwgTlVNQkVSX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKG5nQ29udGVudEluZGV4VmFyLm5hbWUsIE5VTUJFUl9UWVBFKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShjYlZhci5uYW1lLCBEWU5BTUlDX1RZUEUpLCBuZXcgRm5QYXJhbShjdHhWYXIubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgXSwgc3RtdHMpO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVmlzaXROb2Rlc1N0bXRzKG5vZGVzLCBjYiwgY3R4KSB7XG4gICAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIENvbXBpbGVWaWV3Um9vdE5vZGVUeXBlLk5vZGU6XG4gICAgICAgICAgICAgICAgICBzdG10cy5wdXNoKGNiLmNhbGxGbihbbm9kZS5leHByLCBjdHhdKS50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBDb21waWxlVmlld1Jvb3ROb2RlVHlwZS5WaWV3Q29udGFpbmVyOlxuICAgICAgICAgICAgICAgICAgc3RtdHMucHVzaChjYi5jYWxsRm4oW25vZGUuZXhwci5wcm9wKCduYXRpdmVFbGVtZW50JyksIGN0eF0pLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgICAgIHN0bXRzLnB1c2gobm9kZS5leHByLmNhbGxNZXRob2QoJ3Zpc2l0TmVzdGVkVmlld1Jvb3ROb2RlcycsIFtjYiwgY3R4XSkudG9TdG10KCkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQ29tcGlsZVZpZXdSb290Tm9kZVR5cGUuTmdDb250ZW50OlxuICAgICAgICAgICAgICAgICAgc3RtdHMucHVzaChUSElTX0VYUFIuY2FsbE1ldGhvZCgndmlzaXRQcm9qZWN0ZWROb2RlcycsIFtsaXRlcmFsKG5vZGUubmdDb250ZW50SW5kZXgpLCBjYiwgY3R4XSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RtdHM7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDcmVhdGVFbWJlZGRlZFZpZXdzTWV0aG9kKHZpZXcpIHtcbiAgICAgIHZhciBub2RlSW5kZXhWYXIgPSB2YXJpYWJsZSgnbm9kZUluZGV4Jyk7XG4gICAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICAgIHZpZXcubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29tcGlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuZW1iZWRkZWRWaWV3KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZUluZGV4ID0gbm9kZS5pc1Jvb3RFbGVtZW50KCkgPyBudWxsIDogbm9kZS5wYXJlbnQubm9kZUluZGV4O1xuICAgICAgICAgICAgICAgICAgc3RtdHMucHVzaChuZXcgSWZTdG10KG5vZGVJbmRleFZhci5lcXVhbHMobGl0ZXJhbChub2RlLm5vZGVJbmRleCkpLCBbbmV3IFJldHVyblN0YXRlbWVudChub2RlLmVtYmVkZGVkVmlldy5jbGFzc0V4cHIuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy52aWV3VXRpbHMsIFRISVNfRVhQUiwgbGl0ZXJhbChub2RlLm5vZGVJbmRleCksIG5vZGUucmVuZGVyTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS52aWV3Q29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgXSkpXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3IFJldHVyblN0YXRlbWVudChOVUxMX0VYUFIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2xhc3NNZXRob2QoJ2NyZWF0ZUVtYmVkZGVkVmlld0ludGVybmFsJywgW25ldyBGblBhcmFtKG5vZGVJbmRleFZhci5uYW1lLCBOVU1CRVJfVFlQRSldLCBzdG10cywgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBWaWV3KSwgW0RZTkFNSUNfVFlQRV0pKTtcbiAgfVxuXG4gIHZhciBWaWV3Q29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCB2aWV3Q2xhc3NWYXIsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy52aWV3Q2xhc3NWYXIgPSB2aWV3Q2xhc3NWYXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gVmlld0NvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBWaWV3Q29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0NvbXBpbGVyKF9nZW5Db25maWcsIF9zY2hlbWFSZWdpc3RyeSkge1xuICAgICAgICAgIHRoaXMuX2dlbkNvbmZpZyA9IF9nZW5Db25maWc7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICB9XG4gICAgICBWaWV3Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgc3R5bGVzLCBwaXBlcywgY29tcGlsZWRBbmltYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IENvbXBpbGVWaWV3KGNvbXBvbmVudCwgdGhpcy5fZ2VuQ29uZmlnLCBwaXBlcywgc3R5bGVzLCBjb21waWxlZEFuaW1hdGlvbnMsIDAsIENvbXBpbGVFbGVtZW50LmNyZWF0ZU51bGwoKSwgW10pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgYnVpbGRWaWV3KHZpZXcsIHRlbXBsYXRlLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIC8vIE5lZWQgdG8gc2VwYXJhdGUgYmluZGluZyBmcm9tIGNyZWF0aW9uIHRvIGJlIGFibGUgdG8gcmVmZXIgdG9cbiAgICAgICAgICAvLyB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gZGVjbGFyZWQgYWZ0ZXIgdXNhZ2UuXG4gICAgICAgICAgYmluZFZpZXcodmlldywgdGVtcGxhdGUsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5KTtcbiAgICAgICAgICBmaW5pc2hWaWV3KHZpZXcsIHN0YXRlbWVudHMpO1xuICAgICAgICAgIHJldHVybiBuZXcgVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlldy5jbGFzc0V4cHIubmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIH07XG4gICAgICBWaWV3Q29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgVmlld0NvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgICAgICAgeyB0eXBlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFZpZXdDb21waWxlcjtcbiAgfSgpKTtcblxuICB2YXIgU291cmNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNvdXJjZU1vZHVsZShmaWxlVXJsLCBtb2R1bGVVcmwsIHNvdXJjZSkge1xuICAgICAgICAgIHRoaXMuZmlsZVVybCA9IGZpbGVVcmw7XG4gICAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gU291cmNlTW9kdWxlO1xuICB9KCkpO1xuICAvLyBSZXR1cm5zIGFsbCB0aGUgc291cmNlIGZpbGVzIGFuZCBhIG1hcHBpbmcgZnJvbSBtb2R1bGVzIHRvIGRpcmVjdGl2ZXNcbiAgZnVuY3Rpb24gYW5hbHl6ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgb3B0aW9ucywgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgICAgcmV0dXJuIF9sb2FkTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBvcHRpb25zLCBtZXRhZGF0YVJlc29sdmVyKS50aGVuKF9hbmFseXplTmdNb2R1bGVzKTtcbiAgfVxuICBmdW5jdGlvbiBfYW5hbHl6ZU5nTW9kdWxlcyhuZ01vZHVsZU1ldGFzKSB7XG4gICAgICB2YXIgbW9kdWxlTWV0YXNCeVJlZiA9IG5ldyBNYXAoKTtcbiAgICAgIG5nTW9kdWxlTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG1vZHVsZU1ldGFzQnlSZWYuc2V0KG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZSk7IH0pO1xuICAgICAgdmFyIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgbmdNb2R1bGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIG5nRGlyZWN0aXZlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBmaWxlUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAvLyBMb29waW5nIG92ZXIgYWxsIG1vZHVsZXMgdG8gY29uc3RydWN0OlxuICAgICAgLy8gLSBhIG1hcCBmcm9tIGZpbGUgdG8gbW9kdWxlcyBgbmdNb2R1bGVzQnlGaWxlYCxcbiAgICAgIC8vIC0gYSBtYXAgZnJvbSBmaWxlIHRvIGRpcmVjdGl2ZXMgYG5nRGlyZWN0aXZlc0J5RmlsZWAsXG4gICAgICAvLyAtIGEgbWFwIGZyb20gZGlyZWN0aXZlL3BpcGUgdG8gbW9kdWxlIGBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlYC5cbiAgICAgIG5nTW9kdWxlTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgdmFyIHNyY0ZpbGVVcmwgPSBuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UuZmlsZVBhdGg7XG4gICAgICAgICAgZmlsZVBhdGhzLmFkZChzcmNGaWxlVXJsKTtcbiAgICAgICAgICBuZ01vZHVsZXNCeUZpbGUuc2V0KHNyY0ZpbGVVcmwsIChuZ01vZHVsZXNCeUZpbGUuZ2V0KHNyY0ZpbGVVcmwpIHx8IFtdKS5jb25jYXQobmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgbmdNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIHZhciBmaWxlVXJsID0gZGlySWRlbnRpZmllci5yZWZlcmVuY2UuZmlsZVBhdGg7XG4gICAgICAgICAgICAgIGZpbGVQYXRocy5hZGQoZmlsZVVybCk7XG4gICAgICAgICAgICAgIG5nRGlyZWN0aXZlc0J5RmlsZS5zZXQoZmlsZVVybCwgKG5nRGlyZWN0aXZlc0J5RmlsZS5nZXQoZmlsZVVybCkgfHwgW10pLmNvbmNhdChkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgICBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLnNldChkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSwgbmdNb2R1bGVNZXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuZ01vZHVsZU1ldGEuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICB2YXIgZmlsZVVybCA9IHBpcGVJZGVudGlmaWVyLnJlZmVyZW5jZS5maWxlUGF0aDtcbiAgICAgICAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlVXJsKTtcbiAgICAgICAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5zZXQocGlwZUlkZW50aWZpZXIucmVmZXJlbmNlLCBuZ01vZHVsZU1ldGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlsZXMgPSBbXTtcbiAgICAgIGZpbGVQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChzcmNVcmwpIHtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IG5nRGlyZWN0aXZlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgICB2YXIgbmdNb2R1bGVzID0gbmdNb2R1bGVzQnlGaWxlLmdldChzcmNVcmwpIHx8IFtdO1xuICAgICAgICAgIGZpbGVzLnB1c2goeyBzcmNVcmw6IHNyY1VybCwgZGlyZWN0aXZlczogZGlyZWN0aXZlcywgbmdNb2R1bGVzOiBuZ01vZHVsZXMgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgLy8gbWFwIGRpcmVjdGl2ZS9waXBlIHRvIG1vZHVsZVxuICAgICAgICAgIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmU6IG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsXG4gICAgICAgICAgLy8gbGlzdCBtb2R1bGVzIGFuZCBkaXJlY3RpdmVzIGZvciBldmVyeSBzb3VyY2UgZmlsZVxuICAgICAgICAgIGZpbGVzOiBmaWxlcyxcbiAgICAgIH07XG4gIH1cbiAgdmFyIE9mZmxpbmVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBPZmZsaW5lQ29tcGlsZXIoX21ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF9kaXJXcmFwcGVyQ29tcGlsZXIsIF9uZ01vZHVsZUNvbXBpbGVyLCBfb3V0cHV0RW1pdHRlciwgX2xvY2FsZUlkLCBfdHJhbnNsYXRpb25Gb3JtYXQsIF9hbmltYXRpb25QYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGVQYXJzZXIgPSBfdGVtcGxhdGVQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fZGlyV3JhcHBlckNvbXBpbGVyID0gX2RpcldyYXBwZXJDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0RW1pdHRlciA9IF9vdXRwdXRFbWl0dGVyO1xuICAgICAgICAgIHRoaXMuX2xvY2FsZUlkID0gX2xvY2FsZUlkO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0ID0gX3RyYW5zbGF0aW9uRm9ybWF0O1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblBhcnNlciA9IF9hbmltYXRpb25QYXJzZXI7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIgPSBuZXcgQW5pbWF0aW9uQ29tcGlsZXIoKTtcbiAgICAgIH1cbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5jbGVhckNhY2hlKCk7IH07XG4gICAgICBPZmZsaW5lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhbmFseXplTmdNb2R1bGVzKHN0YXRpY1N5bWJvbHMsIG9wdGlvbnMsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICB2YXIgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSA9IF9hLm5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGVzID0gX2EuZmlsZXM7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VNb2R1bGVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZVNyY0ZpbGUoZmlsZS5zcmNVcmwsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGUuZGlyZWN0aXZlcywgZmlsZS5uZ01vZHVsZXMpOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZsYXR0ZW4oc291cmNlTW9kdWxlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVNyY0ZpbGUgPSBmdW5jdGlvbiAoc3JjRmlsZVVybCwgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZGlyZWN0aXZlcywgbmdNb2R1bGVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZmlsZVN1ZmZpeCA9IF9zcGxpdFR5cGVzY3JpcHRTdWZmaXgoc3JjRmlsZVVybClbMV07XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwb3J0ZWRWYXJzID0gW107XG4gICAgICAgICAgdmFyIG91dHB1dFNvdXJjZU1vZHVsZXMgPSBbXTtcbiAgICAgICAgICAvLyBjb21waWxlIGFsbCBuZyBtb2R1bGVzXG4gICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2guYXBwbHkoZXhwb3J0ZWRWYXJzLCBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG5nTW9kdWxlVHlwZSwgc3RhdGVtZW50cyk7IH0pKTtcbiAgICAgICAgICAvLyBjb21waWxlIGRpcmVjdGl2ZSB3cmFwcGVyc1xuICAgICAgICAgIGV4cG9ydGVkVmFycy5wdXNoLmFwcGx5KGV4cG9ydGVkVmFycywgZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlRGlyZWN0aXZlV3JhcHBlcihkaXJlY3RpdmVUeXBlLCBzdGF0ZW1lbnRzKTsgfSkpO1xuICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICAgICAgICB2YXIgY29tcE1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJUeXBlKTtcbiAgICAgICAgICAgICAgaWYgKCFjb21wTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmdNb2R1bGUgPSBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLmdldChkaXJUeXBlKTtcbiAgICAgICAgICAgICAgaWYgKCFuZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgRXJyb3I6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIG1vZHVsZSBmb3IgY29tcG9uZW50IFwiICsgY29tcE1ldGEudHlwZS5uYW1lICsgXCIhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9hc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgICAvLyBjb21waWxlIHN0eWxlc1xuICAgICAgICAgICAgICB2YXIgc3R5bGVzQ29tcGlsZVJlc3VsdHMgPSBfdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgICAgc3R5bGVzQ29tcGlsZVJlc3VsdHMuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21waWxlZFN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFNvdXJjZU1vZHVsZXMucHVzaChfdGhpcy5fY29kZ2VuU3R5bGVzKHNyY0ZpbGVVcmwsIGNvbXBpbGVkU3R5bGVTaGVldCwgZmlsZVN1ZmZpeCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gY29tcGlsZSBjb21wb25lbnRzXG4gICAgICAgICAgICAgIGV4cG9ydGVkVmFycy5wdXNoKF90aGlzLl9jb21waWxlQ29tcG9uZW50RmFjdG9yeShjb21wTWV0YSwgbmdNb2R1bGUsIGZpbGVTdWZmaXgsIHN0YXRlbWVudHMpLCBfdGhpcy5fY29tcGlsZUNvbXBvbmVudChjb21wTWV0YSwgbmdNb2R1bGUsIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcywgc3R5bGVzQ29tcGlsZVJlc3VsdHMuY29tcG9uZW50U3R5bGVzaGVldCwgZmlsZVN1ZmZpeCwgc3RhdGVtZW50cykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHNyY01vZHVsZSA9IHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoc3JjRmlsZVVybCwgX25nZmFjdG9yeU1vZHVsZVVybChzcmNGaWxlVXJsKSwgc3RhdGVtZW50cywgZXhwb3J0ZWRWYXJzKTtcbiAgICAgICAgICAgICAgb3V0cHV0U291cmNlTW9kdWxlcy51bnNoaWZ0KHNyY01vZHVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXRwdXRTb3VyY2VNb2R1bGVzO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGUgPSBmdW5jdGlvbiAobmdNb2R1bGVUeXBlLCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG5nTW9kdWxlVHlwZSk7XG4gICAgICAgICAgdmFyIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgIGlmICh0aGlzLl9sb2NhbGVJZCkge1xuICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgdG9rZW46IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuTE9DQUxFX0lEKSxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl9sb2NhbGVJZCxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fdHJhbnNsYXRpb25Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIHRva2VuOiByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRSQU5TTEFUSU9OU19GT1JNQVQpLFxuICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFwcENvbXBpbGVSZXN1bHQgPSB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNvbXBpbGUobmdNb2R1bGUsIHByb3ZpZGVycyk7XG4gICAgICAgICAgYXBwQ29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5uYW1lID0gX2NvbXBvbmVudEZhY3RvcnlOYW1lKGRlcC5jb21wKTtcbiAgICAgICAgICAgICAgZGVwLnBsYWNlaG9sZGVyLm1vZHVsZVVybCA9IF9uZ2ZhY3RvcnlNb2R1bGVVcmwoZGVwLmNvbXAubW9kdWxlVXJsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgYXBwQ29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gYXBwQ29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZURpcmVjdGl2ZVdyYXBwZXIgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICAgIHZhciBkaXJNZXRhID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICB2YXIgZGlyQ29tcGlsZVJlc3VsdCA9IHRoaXMuX2RpcldyYXBwZXJDb21waWxlci5jb21waWxlKGRpck1ldGEpO1xuICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCBkaXJDb21waWxlUmVzdWx0LnN0YXRlbWVudHMpO1xuICAgICAgICAgIHJldHVybiBkaXJDb21waWxlUmVzdWx0LmRpcldyYXBwZXJDbGFzc1ZhcjtcbiAgICAgIH07XG4gICAgICBPZmZsaW5lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgbmdNb2R1bGUsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIGhvc3RWaWV3RmFjdG9yeVZhciA9IHRoaXMuX2NvbXBpbGVDb21wb25lbnQoaG9zdE1ldGEsIG5nTW9kdWxlLCBbY29tcE1ldGEudHlwZV0sIG51bGwsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpO1xuICAgICAgICAgIHZhciBjb21wRmFjdG9yeVZhciA9IF9jb21wb25lbnRGYWN0b3J5TmFtZShjb21wTWV0YS50eXBlKTtcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2godmFyaWFibGUoY29tcEZhY3RvcnlWYXIpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5KSwgW2ltcG9ydFR5cGUoY29tcE1ldGEudHlwZSldKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsKGNvbXBNZXRhLnNlbGVjdG9yKSxcbiAgICAgICAgICAgICAgdmFyaWFibGUoaG9zdFZpZXdGYWN0b3J5VmFyKSxcbiAgICAgICAgICAgICAgaW1wb3J0RXhwcihjb21wTWV0YS50eXBlKSxcbiAgICAgICAgICBdLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkpLCBbaW1wb3J0VHlwZShjb21wTWV0YS50eXBlKV0sIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBGYWN0b3J5VmFyO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcE1ldGEsIG5nTW9kdWxlLCBkaXJlY3RpdmVJZGVudGlmaWVycywgY29tcG9uZW50U3R5bGVzLCBmaWxlU3VmZml4LCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcGFyc2VkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvblBhcnNlci5wYXJzZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVJZGVudGlmaWVycy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgICAgdmFyIHBpcGVzID0gbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5tYXAoZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVTdW1tYXJ5KHBpcGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgICAgdmFyIHBhcnNlZFRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGUuc2NoZW1hcywgY29tcE1ldGEudHlwZS5uYW1lKTtcbiAgICAgICAgICB2YXIgc3R5bGVzRXhwciA9IGNvbXBvbmVudFN0eWxlcyA/IHZhcmlhYmxlKGNvbXBvbmVudFN0eWxlcy5zdHlsZXNWYXIpIDogbGl0ZXJhbEFycihbXSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvbkNvbXBpbGVyLmNvbXBpbGUoY29tcE1ldGEudHlwZS5uYW1lLCBwYXJzZWRBbmltYXRpb25zKTtcbiAgICAgICAgICB2YXIgdmlld1Jlc3VsdCA9IHRoaXMuX3ZpZXdDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgc3R5bGVzRXhwciwgcGlwZXMsIGNvbXBpbGVkQW5pbWF0aW9ucyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFN0eWxlcykge1xuICAgICAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHMoY29tcG9uZW50U3R5bGVzLCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBpbGVkQW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gdGFyZ2V0U3RhdGVtZW50cy5wdXNoLmFwcGx5KHRhcmdldFN0YXRlbWVudHMsIGVudHJ5LnN0YXRlbWVudHMpOyB9KTtcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgX3Jlc29sdmVWaWV3U3RhdGVtZW50cyh2aWV3UmVzdWx0KSk7XG4gICAgICAgICAgcmV0dXJuIHZpZXdSZXN1bHQudmlld0NsYXNzVmFyO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvZGdlblN0eWxlcyA9IGZ1bmN0aW9uIChmaWxlVXJsLCBzdHlsZXNDb21waWxlUmVzdWx0LCBmaWxlU3VmZml4KSB7XG4gICAgICAgICAgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHMoc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoZmlsZVVybCwgX3N0eWxlc01vZHVsZVVybChzdHlsZXNDb21waWxlUmVzdWx0Lm1ldGEubW9kdWxlVXJsLCBzdHlsZXNDb21waWxlUmVzdWx0LmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCksIHN0eWxlc0NvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgW3N0eWxlc0NvbXBpbGVSZXN1bHQuc3R5bGVzVmFyXSk7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29kZWdlblNvdXJjZU1vZHVsZSA9IGZ1bmN0aW9uIChmaWxlVXJsLCBtb2R1bGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykge1xuICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTW9kdWxlKGZpbGVVcmwsIG1vZHVsZVVybCwgdGhpcy5fb3V0cHV0RW1pdHRlci5lbWl0U3RhdGVtZW50cyhtb2R1bGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBPZmZsaW5lQ29tcGlsZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9yZXNvbHZlVmlld1N0YXRlbWVudHMoY29tcGlsZVJlc3VsdCkge1xuICAgICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgaWYgKGRlcCBpbnN0YW5jZW9mIFZpZXdDbGFzc0RlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgdmFyIHZmZCA9IGRlcDtcbiAgICAgICAgICAgICAgdmZkLnBsYWNlaG9sZGVyLm1vZHVsZVVybCA9IF9uZ2ZhY3RvcnlNb2R1bGVVcmwodmZkLmNvbXAubW9kdWxlVXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZGVwIGluc3RhbmNlb2YgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgdmFyIGNmZCA9IGRlcDtcbiAgICAgICAgICAgICAgY2ZkLnBsYWNlaG9sZGVyLm5hbWUgPSBfY29tcG9uZW50RmFjdG9yeU5hbWUoY2ZkLmNvbXApO1xuICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX25nZmFjdG9yeU1vZHVsZVVybChjZmQuY29tcC5tb2R1bGVVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkZXAgaW5zdGFuY2VvZiBEaXJlY3RpdmVXcmFwcGVyRGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICB2YXIgZHdkID0gZGVwO1xuICAgICAgICAgICAgICBkd2QucGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX25nZmFjdG9yeU1vZHVsZVVybChkd2QuZGlyLm1vZHVsZVVybCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzO1xuICB9XG4gIGZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKGNvbXBpbGVSZXN1bHQsIGZpbGVTdWZmaXgpIHtcbiAgICAgIGNvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgIGRlcC52YWx1ZVBsYWNlaG9sZGVyLm1vZHVsZVVybCA9IF9zdHlsZXNNb2R1bGVVcmwoZGVwLm1vZHVsZVVybCwgZGVwLmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21waWxlUmVzdWx0LnN0YXRlbWVudHM7XG4gIH1cbiAgZnVuY3Rpb24gX25nZmFjdG9yeU1vZHVsZVVybChkaXJVcmwpIHtcbiAgICAgIHZhciB1cmxXaXRoU3VmZml4ID0gX3NwbGl0VHlwZXNjcmlwdFN1ZmZpeChkaXJVcmwpO1xuICAgICAgcmV0dXJuIHVybFdpdGhTdWZmaXhbMF0gKyBcIi5uZ2ZhY3RvcnlcIiArIHVybFdpdGhTdWZmaXhbMV07XG4gIH1cbiAgZnVuY3Rpb24gX2NvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXApIHtcbiAgICAgIHJldHVybiBjb21wLm5hbWUgKyBcIk5nRmFjdG9yeVwiO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHlsZXNNb2R1bGVVcmwoc3R5bGVzaGVldFVybCwgc2hpbSwgc3VmZml4KSB7XG4gICAgICByZXR1cm4gc2hpbSA/IHN0eWxlc2hlZXRVcmwgKyBcIi5zaGltXCIgKyBzdWZmaXggOiBcIlwiICsgc3R5bGVzaGVldFVybCArIHN1ZmZpeDtcbiAgfVxuICBmdW5jdGlvbiBfYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcbiAgICAgIGlmICghbWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21waWxlICdcIiArIG1ldGEudHlwZS5uYW1lICsgXCInIGJlY2F1c2UgaXQgaXMgbm90IGEgY29tcG9uZW50LlwiKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfc3BsaXRUeXBlc2NyaXB0U3VmZml4KHBhdGgpIHtcbiAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcuZC50cycpKSB7XG4gICAgICAgICAgcmV0dXJuIFtwYXRoLnNsaWNlKDAsIC01KSwgJy50cyddO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3REb3QgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICBpZiAobGFzdERvdCAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gW3BhdGguc3Vic3RyaW5nKDAsIGxhc3REb3QpLCBwYXRoLnN1YnN0cmluZyhsYXN0RG90KV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3BhdGgsICcnXTtcbiAgfVxuICAvLyBMb2FkIHRoZSBOZ01vZHVsZXMgYW5kIGNoZWNrXG4gIC8vIHRoYXQgYWxsIGRpcmVjdGl2ZXMgLyBwaXBlcyB0aGF0IGFyZSBwcmVzZW50IGluIHRoZSBwcm9ncmFtXG4gIC8vIGFyZSBhbHNvIGRlY2xhcmVkIGJ5IGEgbW9kdWxlLlxuICBmdW5jdGlvbiBfbG9hZE5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgb3B0aW9ucywgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgICAgdmFyIG5nTW9kdWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBwcm9ncmFtUGlwZXNBbmREaXJlY3RpdmVzID0gW107XG4gICAgICB2YXIgbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZSA9IG5ldyBTZXQoKTtcbiAgICAgIHZhciBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgIHZhciBhZGROZ01vZHVsZSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICBpZiAobmdNb2R1bGVzLmhhcyhzdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9hID0gbWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVNZXRhZGF0YShzdGF0aWNTeW1ib2wsIGZhbHNlLCBmYWxzZSksIG5nTW9kdWxlID0gX2EubmdNb2R1bGUsIGxvYWRpbmcgPSBfYS5sb2FkaW5nO1xuICAgICAgICAgIGlmIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgICBuZ01vZHVsZXMuc2V0KG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZSk7XG4gICAgICAgICAgICAgIGxvYWRpbmdQcm9taXNlcy5wdXNoKGxvYWRpbmcpO1xuICAgICAgICAgICAgICBuZ01vZHVsZS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBuZ01vZHVsZVBpcGVzQW5kRGlyZWN0aXZlLmFkZChkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZS5hZGQocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGl2ZU1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEZvciBldmVyeSBpbnB1dCBtb2R1bGVzIGFkZCB0aGUgbGlzdCBvZiB0cmFuc2l0aXZlbHkgaW5jbHVkZWQgbW9kdWxlc1xuICAgICAgICAgICAgICAgICAgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZE1ldGEpIHsgcmV0dXJuIGFkZE5nTW9kdWxlKG1vZE1ldGEudHlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gISFuZ01vZHVsZTtcbiAgICAgIH07XG4gICAgICBwcm9ncmFtU3RhdGljU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICBpZiAoIWFkZE5nTW9kdWxlKHN0YXRpY1N5bWJvbCkgJiZcbiAgICAgICAgICAgICAgKG1ldGFkYXRhUmVzb2x2ZXIuaXNEaXJlY3RpdmUoc3RhdGljU3ltYm9sKSB8fCBtZXRhZGF0YVJlc29sdmVyLmlzUGlwZShzdGF0aWNTeW1ib2wpKSkge1xuICAgICAgICAgICAgICBwcm9ncmFtUGlwZXNBbmREaXJlY3RpdmVzLnB1c2goc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGFueSBvZiB0aGUgcHJvZ3JhbSBwaXBlIG9yIGRpcmVjdGl2ZXMgaXMgbm90IGRlY2xhcmVkIGJ5IGEgbW9kdWxlXG4gICAgICB2YXIgc3ltYm9sc01pc3NpbmdNb2R1bGUgPSBwcm9ncmFtUGlwZXNBbmREaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gIW5nTW9kdWxlUGlwZXNBbmREaXJlY3RpdmUuaGFzKHMpOyB9KTtcbiAgICAgIGlmIChzeW1ib2xzTWlzc2luZ01vZHVsZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBzeW1ib2xzTWlzc2luZ01vZHVsZS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChcIkNhbm5vdCBkZXRlcm1pbmUgdGhlIG1vZHVsZSBmb3IgY2xhc3MgXCIgKyBzLm5hbWUgKyBcIiBpbiBcIiArIHMuZmlsZVBhdGggKyBcIiFcIik7IH0pO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20obmdNb2R1bGVzLnZhbHVlcygpKTsgfSk7XG4gIH1cblxuICB2YXIgU3R5bGVzQ29sbGVjdGlvbkVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0eWxlc0NvbGxlY3Rpb25FbnRyeSh0aW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgU3R5bGVzQ29sbGVjdGlvbkVudHJ5LnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRpbWUgPT0gdGhpcy50aW1lICYmIHZhbHVlID09IHRoaXMudmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFN0eWxlc0NvbGxlY3Rpb25FbnRyeTtcbiAgfSgpKTtcbiAgdmFyIFN0eWxlc0NvbGxlY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3R5bGVzQ29sbGVjdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgfVxuICAgICAgU3R5bGVzQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0QXRUaW1lID0gZnVuY3Rpb24gKHByb3BlcnR5LCB0aW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciB0dXBsZSA9IG5ldyBTdHlsZXNDb2xsZWN0aW9uRW50cnkodGltZSwgdmFsdWUpO1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5zdHlsZXNbcHJvcGVydHldO1xuICAgICAgICAgIGlmICghaXNQcmVzZW50KGVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGVudHJpZXMgPSB0aGlzLnN0eWxlc1twcm9wZXJ0eV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaW5zZXJ0IHRoaXMgYXQgdGhlIHJpZ2h0IHN0b3AgaW4gdGhlIGFycmF5XG4gICAgICAgICAgLy8gdGhpcyB3YXkgd2UgY2FuIGtlZXAgaXQgc29ydGVkXG4gICAgICAgICAgdmFyIGluc2VydGlvbkluZGV4ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICBpZiAoZW50cmllc1tpXS50aW1lIDw9IHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgdHVwbGUpO1xuICAgICAgfTtcbiAgICAgIFN0eWxlc0NvbGxlY3Rpb24ucHJvdG90eXBlLmdldEJ5SW5kZXggPSBmdW5jdGlvbiAocHJvcGVydHksIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5zdHlsZXNbcHJvcGVydHldO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoaXRlbXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSBpdGVtcy5sZW5ndGggPyBudWxsIDogaXRlbXNbaW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBTdHlsZXNDb2xsZWN0aW9uLnByb3RvdHlwZS5pbmRleE9mQXRPckJlZm9yZVRpbWUgPSBmdW5jdGlvbiAocHJvcGVydHksIHRpbWUpIHtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuc3R5bGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGVudHJpZXMpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZW50cmllc1tpXS50aW1lIDw9IHRpbWUpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFN0eWxlc0NvbGxlY3Rpb247XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDE2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgX0lOSVRJQUxfS0VZRlJBTUUgPSAwO1xuICB2YXIgX1RFUk1JTkFMX0tFWUZSQU1FID0gMTtcbiAgdmFyIF9PTkVfU0VDT05EID0gMTAwMDtcbiAgdmFyIEFuaW1hdGlvblBhcnNlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE2KEFuaW1hdGlvblBhcnNlRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25QYXJzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIiArIHRoaXMubXNnOyB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblBhcnNlRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICB2YXIgQW5pbWF0aW9uRW50cnlQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0KGFzdCwgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uRW50cnlQYXJzZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIEFuaW1hdGlvblBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25QYXJzZXIoX3NjaGVtYSkge1xuICAgICAgICAgIHRoaXMuX3NjaGVtYSA9IF9zY2hlbWE7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25QYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LnR5cGUubmFtZTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uVHJpZ2dlck5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIHZhciBhc3RzID0gY29tcG9uZW50LnRlbXBsYXRlLmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucGFyc2VFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICAgIHZhciBhc3QgPSByZXN1bHQuYXN0O1xuICAgICAgICAgICAgICB2YXIgdHJpZ2dlck5hbWUgPSBhc3QubmFtZTtcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblRyaWdnZXJOYW1lcy5oYXModHJpZ2dlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJUaGUgYW5pbWF0aW9uIHRyaWdnZXIgXFxcIlwiICsgdHJpZ2dlck5hbWUgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgXCIgKyBjb21wb25lbnROYW1lICsgXCIgY29tcG9uZW50XCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblRyaWdnZXJOYW1lcy5hZGQodHJpZ2dlck5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2VfMSA9IFwiLSBVbmFibGUgdG8gcGFyc2UgdGhlIGFuaW1hdGlvbiBzZXF1ZW5jZSBmb3IgXFxcIlwiICsgdHJpZ2dlck5hbWUgKyBcIlxcXCIgb24gdGhlIFwiICsgY29tcG9uZW50TmFtZSArIFwiIGNvbXBvbmVudCBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6XCI7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGVycm9yKSB7IGVycm9yTWVzc2FnZV8xICs9ICdcXG4tLSAnICsgZXJyb3IubXNnOyB9KTtcbiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yTWVzc2FnZV8xKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuaW1hdGlvbiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhc3RzO1xuICAgICAgfTtcbiAgICAgIEFuaW1hdGlvblBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZVN0eWxlcyA9IHt9O1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZURlY2xhcmF0aW9uQXN0cyA9IFtdO1xuICAgICAgICAgIGVudHJ5LmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgX3BhcnNlQW5pbWF0aW9uRGVjbGFyYXRpb25TdGF0ZXMoZGVmLCBfdGhpcy5fc2NoZW1hLCBlcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlRGVjbGFyYXRpb25Bc3RzLnB1c2goYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0eWxlc1thc3Quc3RhdGVOYW1lXSA9IGFzdC5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZVRyYW5zaXRpb25Bc3RzID0gdHJhbnNpdGlvbnMubWFwKGZ1bmN0aW9uICh0cmFuc0RlZikgeyByZXR1cm4gX3BhcnNlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uKHRyYW5zRGVmLCBzdGF0ZVN0eWxlcywgX3RoaXMuX3NjaGVtYSwgZXJyb3JzKTsgfSk7XG4gICAgICAgICAgdmFyIGFzdCA9IG5ldyBBbmltYXRpb25FbnRyeUFzdChlbnRyeS5uYW1lLCBzdGF0ZURlY2xhcmF0aW9uQXN0cywgc3RhdGVUcmFuc2l0aW9uQXN0cyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0KGFzdCwgZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBBbmltYXRpb25QYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgQW5pbWF0aW9uUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBBbmltYXRpb25QYXJzZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9wYXJzZUFuaW1hdGlvbkRlY2xhcmF0aW9uU3RhdGVzKHN0YXRlTWV0YWRhdGEsIHNjaGVtYSwgZXJyb3JzKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZFN0eWxlcyA9IF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKHN0YXRlTWV0YWRhdGEuc3R5bGVzLCB7fSwgc2NoZW1hLCBlcnJvcnMsIGZhbHNlKTtcbiAgICAgIHZhciBkZWZTdHlsZXMgPSBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KG5vcm1hbGl6ZWRTdHlsZXMpO1xuICAgICAgdmFyIHN0YXRlcyA9IHN0YXRlTWV0YWRhdGEuc3RhdGVOYW1lRXhwci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgICByZXR1cm4gc3RhdGVzLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIG5ldyBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uQXN0KHN0YXRlLCBkZWZTdHlsZXMpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25TdGF0ZVRyYW5zaXRpb24odHJhbnNpdGlvblN0YXRlTWV0YWRhdGEsIHN0YXRlU3R5bGVzLCBzY2hlbWEsIGVycm9ycykge1xuICAgICAgdmFyIHN0eWxlcyA9IG5ldyBTdHlsZXNDb2xsZWN0aW9uKCk7XG4gICAgICB2YXIgdHJhbnNpdGlvbkV4cHJzID0gW107XG4gICAgICB2YXIgdHJhbnNpdGlvblN0YXRlcyA9IHRyYW5zaXRpb25TdGF0ZU1ldGFkYXRhLnN0YXRlQ2hhbmdlRXhwci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgICB0cmFuc2l0aW9uU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgdHJhbnNpdGlvbkV4cHJzLnB1c2guYXBwbHkodHJhbnNpdGlvbkV4cHJzLCBfcGFyc2VBbmltYXRpb25UcmFuc2l0aW9uRXhwcihleHByLCBlcnJvcnMpKTsgfSk7XG4gICAgICB2YXIgZW50cnkgPSBfbm9ybWFsaXplQW5pbWF0aW9uRW50cnkodHJhbnNpdGlvblN0YXRlTWV0YWRhdGEuc3RlcHMpO1xuICAgICAgdmFyIGFuaW1hdGlvbiA9IF9ub3JtYWxpemVTdHlsZVN0ZXBzKGVudHJ5LCBzdGF0ZVN0eWxlcywgc2NoZW1hLCBlcnJvcnMpO1xuICAgICAgdmFyIGFuaW1hdGlvbkFzdCA9IF9wYXJzZVRyYW5zaXRpb25BbmltYXRpb24oYW5pbWF0aW9uLCAwLCBzdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIF9maWxsQW5pbWF0aW9uQXN0U3RhcnRpbmdLZXlmcmFtZXMoYW5pbWF0aW9uQXN0LCBzdHlsZXMsIGVycm9ycyk7XG4gICAgICB9XG4gICAgICB2YXIgc3RlcHNBc3QgPSAoYW5pbWF0aW9uQXN0IGluc3RhbmNlb2YgQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KSA/XG4gICAgICAgICAgYW5pbWF0aW9uQXN0IDpcbiAgICAgICAgICBuZXcgQW5pbWF0aW9uU2VxdWVuY2VBc3QoW2FuaW1hdGlvbkFzdF0pO1xuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3QodHJhbnNpdGlvbkV4cHJzLCBzdGVwc0FzdCk7XG4gIH1cbiAgZnVuY3Rpb24gX3BhcnNlQW5pbWF0aW9uQWxpYXMoYWxpYXMsIGVycm9ycykge1xuICAgICAgc3dpdGNoIChhbGlhcykge1xuICAgICAgICAgIGNhc2UgJzplbnRlcic6XG4gICAgICAgICAgICAgIHJldHVybiAndm9pZCA9PiAqJztcbiAgICAgICAgICBjYXNlICc6bGVhdmUnOlxuICAgICAgICAgICAgICByZXR1cm4gJyogPT4gdm9pZCc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJ0aGUgdHJhbnNpdGlvbiBhbGlhcyB2YWx1ZSBcXFwiXCIgKyBhbGlhcyArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuICcqID0+IConO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZUFuaW1hdGlvblRyYW5zaXRpb25FeHByKGV2ZW50U3RyLCBlcnJvcnMpIHtcbiAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgaWYgKGV2ZW50U3RyWzBdID09ICc6Jykge1xuICAgICAgICAgIGV2ZW50U3RyID0gX3BhcnNlQW5pbWF0aW9uQWxpYXMoZXZlbnRTdHIsIGVycm9ycyk7XG4gICAgICB9XG4gICAgICB2YXIgbWF0Y2ggPSBldmVudFN0ci5tYXRjaCgvXihcXCp8Wy1cXHddKylcXHMqKDw/Wz0tXT4pXFxzKihcXCp8Wy1cXHddKykkLyk7XG4gICAgICBpZiAoIWlzUHJlc2VudChtYXRjaCkgfHwgbWF0Y2gubGVuZ3RoIDwgNCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwidGhlIHByb3ZpZGVkIFwiICsgZXZlbnRTdHIgKyBcIiBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgZm9ybWF0XCIpKTtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbVN0YXRlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgc2VwYXJhdG9yID0gbWF0Y2hbMl07XG4gICAgICB2YXIgdG9TdGF0ZSA9IG1hdGNoWzNdO1xuICAgICAgZXhwcmVzc2lvbnMucHVzaChuZXcgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uRXhwcmVzc2lvbihmcm9tU3RhdGUsIHRvU3RhdGUpKTtcbiAgICAgIHZhciBpc0Z1bGxBbnlTdGF0ZUV4cHIgPSBmcm9tU3RhdGUgPT0gQU5ZX1NUQVRFICYmIHRvU3RhdGUgPT0gQU5ZX1NUQVRFO1xuICAgICAgaWYgKHNlcGFyYXRvclswXSA9PSAnPCcgJiYgIWlzRnVsbEFueVN0YXRlRXhwcikge1xuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb24odG9TdGF0ZSwgZnJvbVN0YXRlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gIH1cbiAgZnVuY3Rpb24gX25vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KGVudHJ5KSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlbnRyeSkgPyBuZXcgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoZW50cnkpIDogZW50cnk7XG4gIH1cbiAgZnVuY3Rpb24gX25vcm1hbGl6ZVN0eWxlTWV0YWRhdGEoZW50cnksIHN0YXRlU3R5bGVzLCBzY2hlbWEsIGVycm9ycywgcGVybWl0U3RhdGVSZWZlcmVuY2VzKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZFN0eWxlcyA9IFtdO1xuICAgICAgZW50cnkuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlRW50cnkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlRW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGlmIChwZXJtaXRTdGF0ZVJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdHlsZXMucHVzaC5hcHBseShub3JtYWxpemVkU3R5bGVzLCBfcmVzb2x2ZVN0eWxlc0Zyb21TdGF0ZShzdHlsZUVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlN0YXRlIGJhc2VkIGFuaW1hdGlvbnMgY2Fubm90IGNvbnRhaW4gcmVmZXJlbmNlcyB0byBvdGhlciBzdGF0ZXNcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVzT2JqXzEgPSBzdHlsZUVudHJ5O1xuICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFN0eWxlc09ial8xID0ge307XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlc09ial8xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wID0gc2NoZW1hLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRPdXRwdXQgPSBzY2hlbWEubm9ybWFsaXplQW5pbWF0aW9uU3R5bGVWYWx1ZShub3JtYWxpemVkUHJvcCwgcHJvcE5hbWUsIHN0eWxlc09ial8xW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXphdGlvbkVycm9yID0gbm9ybWFsaXplZE91dHB1dFsnZXJyb3InXTtcbiAgICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihub3JtYWxpemF0aW9uRXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRTdHlsZXNPYmpfMVtub3JtYWxpemVkUHJvcF0gPSBub3JtYWxpemVkT3V0cHV0Wyd2YWx1ZSddO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFN0eWxlcy5wdXNoKG5vcm1hbGl6ZWRTdHlsZXNPYmpfMSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZFN0eWxlcztcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplU3R5bGVTdGVwcyhlbnRyeSwgc3RhdGVTdHlsZXMsIHNjaGVtYSwgZXJyb3JzKSB7XG4gICAgICB2YXIgc3RlcHMgPSBfbm9ybWFsaXplU3R5bGVTdGVwRW50cnkoZW50cnksIHN0YXRlU3R5bGVzLCBzY2hlbWEsIGVycm9ycyk7XG4gICAgICByZXR1cm4gKGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEpID9cbiAgICAgICAgICBuZXcgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoc3RlcHMpIDpcbiAgICAgICAgICBuZXcgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpO1xuICB9XG4gIGZ1bmN0aW9uIF9tZXJnZUFuaW1hdGlvblN0eWxlcyhzdHlsZXNMaXN0LCBuZXdJdGVtKSB7XG4gICAgICBpZiAodHlwZW9mIG5ld0l0ZW0gPT09ICdvYmplY3QnICYmIG5ld0l0ZW0gIT09IG51bGwgJiYgc3R5bGVzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IHN0eWxlc0xpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICB2YXIgbGFzdEl0ZW0gPSBzdHlsZXNMaXN0W2xhc3RJbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBsYXN0SXRlbSA9PT0gJ29iamVjdCcgJiYgbGFzdEl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3R5bGVzTGlzdFtsYXN0SW5kZXhdID0gU3RyaW5nTWFwV3JhcHBlci5tZXJnZShsYXN0SXRlbSwgbmV3SXRlbSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHlsZXNMaXN0LnB1c2gobmV3SXRlbSk7XG4gIH1cbiAgZnVuY3Rpb24gX25vcm1hbGl6ZVN0eWxlU3RlcEVudHJ5KGVudHJ5LCBzdGF0ZVN0eWxlcywgc2NoZW1hLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdGVwcztcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkge1xuICAgICAgICAgIHN0ZXBzID0gZW50cnkuc3RlcHM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2VudHJ5XTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTdGVwcyA9IFtdO1xuICAgICAgdmFyIGNvbWJpbmVkU3R5bGVzO1xuICAgICAgc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBvY2N1cnMgd2hlbiBhIHN0eWxlIHN0ZXAgaXMgZm9sbG93ZWQgYnkgYSBwcmV2aW91cyBzdHlsZSBzdGVwXG4gICAgICAgICAgICAgIC8vIG9yIHdoZW4gdGhlIGZpcnN0IHN0eWxlIHN0ZXAgaXMgcnVuLiBXZSB3YW50IHRvIGNvbmNhdGVuYXRlIGFsbCBzdWJzZXF1ZW50XG4gICAgICAgICAgICAgIC8vIHN0eWxlIHN0ZXBzIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgc3R5bGUgc3RlcCBzdWNoIHRoYXQgd2UgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICAvLyBzdGFydGluZyBrZXlmcmFtZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgYW5pbWF0aW9uIHBsYXllci5cbiAgICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoY29tYmluZWRTdHlsZXMpKSB7XG4gICAgICAgICAgICAgICAgICBjb21iaW5lZFN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKHN0ZXAsIHN0YXRlU3R5bGVzLCBzY2hlbWEsIGVycm9ycywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBfbWVyZ2VBbmltYXRpb25TdHlsZXMoY29tYmluZWRTdHlsZXMsIGVudHJ5KTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBjcmVhdGUgYSBtZXRhZGF0YSBlbnRyeSBvZiB0aGUgY29tYmluZWQgc3R5bGVzXG4gICAgICAgICAgICAgIC8vIGJlZm9yZSB3ZSBnbyBvbiBhbiBwcm9jZXNzIHRoZSBhbmltYXRlLCBzZXF1ZW5jZSBvciBncm91cCBtZXRhZGF0YSBzdGVwcy5cbiAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBBU1Qgd2lsbCBoYXZlIHRoZSBwcmV2aW91cyBzdHlsZXMgcGFpbnRlZCBvblxuICAgICAgICAgICAgICAvLyBzY3JlZW4gYmVmb3JlIGFueSBmdXJ0aGVyIGFuaW1hdGlvbnMgdGhhdCB1c2UgdGhlIHN0eWxlcyB0YWtlIHBsYWNlLlxuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbWJpbmVkU3R5bGVzKSkge1xuICAgICAgICAgICAgICAgICAgbmV3U3RlcHMucHVzaChuZXcgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEoMCwgY29tYmluZWRTdHlsZXMpKTtcbiAgICAgICAgICAgICAgICAgIGNvbWJpbmVkU3R5bGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCByZWN1cnNlIGludG8gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSBzaW5jZVxuICAgICAgICAgICAgICAgICAgLy8gdGhvc2Ugc3R5bGUgc3RlcHMgYXJlIG5vdCBnb2luZyB0byBiZSBzcXVhc2hlZFxuICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVTdHlsZVZhbHVlID0gc3RlcC5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZVN0eWxlVmFsdWUgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVTdHlsZVZhbHVlLnN0eWxlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKGFuaW1hdGVTdHlsZVZhbHVlLCBzdGF0ZVN0eWxlcywgc2NoZW1hLCBlcnJvcnMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYW5pbWF0ZVN0eWxlVmFsdWUgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVTdHlsZVZhbHVlLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcC5zdHlsZXMgPSBfbm9ybWFsaXplU3R5bGVNZXRhZGF0YShzdGVwLCBzdGF0ZVN0eWxlcywgc2NoZW1hLCBlcnJvcnMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHN0ZXAgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbm5lclN0ZXBzID0gX25vcm1hbGl6ZVN0eWxlU3RlcEVudHJ5KHN0ZXAsIHN0YXRlU3R5bGVzLCBzY2hlbWEsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICBzdGVwID0gc3RlcCBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhID9cbiAgICAgICAgICAgICAgICAgICAgICBuZXcgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoaW5uZXJTdGVwcykgOlxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShpbm5lclN0ZXBzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXdTdGVwcy5wdXNoKHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcyBoYXBwZW5zIHdoZW4gb25seSBzdHlsZXMgd2VyZSBhbmltYXRlZCB3aXRoaW4gdGhlIHNlcXVlbmNlXG4gICAgICBpZiAoaXNQcmVzZW50KGNvbWJpbmVkU3R5bGVzKSkge1xuICAgICAgICAgIG5ld1N0ZXBzLnB1c2gobmV3IENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKDAsIGNvbWJpbmVkU3R5bGVzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3U3RlcHM7XG4gIH1cbiAgZnVuY3Rpb24gX3Jlc29sdmVTdHlsZXNGcm9tU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZVN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICBpZiAoc3RhdGVOYW1lWzBdICE9ICc6Jykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwiQW5pbWF0aW9uIHN0YXRlcyB2aWEgc3R5bGVzIG11c3QgYmUgcHJlZml4ZWQgd2l0aCBhIFxcXCI6XFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZFN0YXRlTmFtZSA9IHN0YXRlTmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVTdHlsZXNbbm9ybWFsaXplZFN0YXRlTmFtZV07XG4gICAgICAgICAgaWYgKCFpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwiVW5hYmxlIHRvIGFwcGx5IHN0eWxlcyBkdWUgdG8gbWlzc2luZyBhIHN0YXRlOiBcXFwiXCIgKyBub3JtYWxpemVkU3RhdGVOYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZXNFbnRyeSA9PT0gJ29iamVjdCcgJiYgc3R5bGVzRW50cnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChzdHlsZXNFbnRyeSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gIH1cbiAgdmFyIF9BbmltYXRpb25UaW1pbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25UaW1pbmdzKGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQW5pbWF0aW9uVGltaW5ncztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX3BhcnNlQW5pbWF0aW9uS2V5ZnJhbWVzKGtleWZyYW1lU2VxdWVuY2UsIGN1cnJlbnRUaW1lLCBjb2xsZWN0ZWRTdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciB0b3RhbEVudHJpZXMgPSBrZXlmcmFtZVNlcXVlbmNlLnN0ZXBzLmxlbmd0aDtcbiAgICAgIHZhciB0b3RhbE9mZnNldHMgPSAwO1xuICAgICAga2V5ZnJhbWVTZXF1ZW5jZS5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwKSB7IHJldHVybiB0b3RhbE9mZnNldHMgKz0gKGlzUHJlc2VudChzdGVwLm9mZnNldCkgPyAxIDogMCk7IH0pO1xuICAgICAgaWYgKHRvdGFsT2Zmc2V0cyA+IDAgJiYgdG90YWxPZmZzZXRzIDwgdG90YWxFbnRyaWVzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJOb3QgYWxsIHN0eWxlKCkgZW50cmllcyBjb250YWluIGFuIG9mZnNldCBmb3IgdGhlIHByb3ZpZGVkIGtleWZyYW1lKClcIikpO1xuICAgICAgICAgIHRvdGFsT2Zmc2V0cyA9IHRvdGFsRW50cmllcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW1pdCA9IHRvdGFsRW50cmllcyAtIDE7XG4gICAgICB2YXIgbWFyZ2luID0gdG90YWxPZmZzZXRzID09IDAgPyAoMSAvIGxpbWl0KSA6IDA7XG4gICAgICB2YXIgcmF3S2V5ZnJhbWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGRvU29ydEtleWZyYW1lcyA9IGZhbHNlO1xuICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAga2V5ZnJhbWVTZXF1ZW5jZS5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHN0eWxlTWV0YWRhdGEub2Zmc2V0O1xuICAgICAgICAgIHZhciBrZXlmcmFtZVN0eWxlcyA9IHt9O1xuICAgICAgICAgIHN0eWxlTWV0YWRhdGEuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGtleWZyYW1lU3R5bGVzW3Byb3BdID0gZW50cnlbcHJvcF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQob2Zmc2V0KSkge1xuICAgICAgICAgICAgICBkb1NvcnRLZXlmcmFtZXMgPSBkb1NvcnRLZXlmcmFtZXMgfHwgKG9mZnNldCA8IGxhc3RPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gaW5kZXggPT0gbGltaXQgPyBfVEVSTUlOQUxfS0VZRlJBTUUgOiAobWFyZ2luICogaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByYXdLZXlmcmFtZXMucHVzaChbb2Zmc2V0LCBrZXlmcmFtZVN0eWxlc10pO1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgIH0pO1xuICAgICAgaWYgKGRvU29ydEtleWZyYW1lcykge1xuICAgICAgICAgIHJhd0tleWZyYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIDw9IGJbMF0gPyAtMSA6IDE7IH0pO1xuICAgICAgfVxuICAgICAgdmFyIGZpcnN0S2V5ZnJhbWUgPSByYXdLZXlmcmFtZXNbMF07XG4gICAgICBpZiAoZmlyc3RLZXlmcmFtZVswXSAhPSBfSU5JVElBTF9LRVlGUkFNRSkge1xuICAgICAgICAgIHJhd0tleWZyYW1lcy5zcGxpY2UoMCwgMCwgZmlyc3RLZXlmcmFtZSA9IFtfSU5JVElBTF9LRVlGUkFNRSwge31dKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdEtleWZyYW1lU3R5bGVzID0gZmlyc3RLZXlmcmFtZVsxXTtcbiAgICAgIGxpbWl0ID0gcmF3S2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbGFzdEtleWZyYW1lID0gcmF3S2V5ZnJhbWVzW2xpbWl0XTtcbiAgICAgIGlmIChsYXN0S2V5ZnJhbWVbMF0gIT0gX1RFUk1JTkFMX0tFWUZSQU1FKSB7XG4gICAgICAgICAgcmF3S2V5ZnJhbWVzLnB1c2gobGFzdEtleWZyYW1lID0gW19URVJNSU5BTF9LRVlGUkFNRSwge31dKTtcbiAgICAgICAgICBsaW1pdCsrO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RLZXlmcmFtZVN0eWxlcyA9IGxhc3RLZXlmcmFtZVsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSByYXdLZXlmcmFtZXNbaV07XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IGVudHJ5WzFdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgZmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IEZJTExfU1RZTEVfRkxBRztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gcmF3S2V5ZnJhbWVzW2ldO1xuICAgICAgICAgIHZhciBzdHlsZXMgPSBlbnRyeVsxXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQobGFzdEtleWZyYW1lU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgbGFzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgaSA9IGxpbWl0IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhd0tleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBuZXcgQW5pbWF0aW9uS2V5ZnJhbWVBc3QoZW50cnlbMF0sIG5ldyBBbmltYXRpb25TdHlsZXNBc3QoW2VudHJ5WzFdXSkpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiBfcGFyc2VUcmFuc2l0aW9uQW5pbWF0aW9uKGVudHJ5LCBjdXJyZW50VGltZSwgY29sbGVjdGVkU3R5bGVzLCBzdGF0ZVN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgYXN0O1xuICAgICAgdmFyIHBsYXlUaW1lID0gMDtcbiAgICAgIHZhciBzdGFydGluZ1RpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkge1xuICAgICAgICAgIHZhciBtYXhEdXJhdGlvbl8xID0gMDtcbiAgICAgICAgICB2YXIgc3RlcHNfMSA9IFtdO1xuICAgICAgICAgIHZhciBpc0dyb3VwXzEgPSBlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICAgICAgICAgIHZhciBwcmV2aW91c1N0eWxlc18xO1xuICAgICAgICAgIGVudHJ5LnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgZ2V0IHBpY2tlZCB1cCBieSB0aGUgbmV4dCBzdGVwLi4uXG4gICAgICAgICAgICAgIHZhciB0aW1lID0gaXNHcm91cF8xID8gc3RhcnRpbmdUaW1lIDogY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICBlbnRyeS5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBieSB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCB3ZSBvbmx5IGhhdmUgc3RyaW5nbWFwIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBzdHlsZXNFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgY29sbGVjdGVkU3R5bGVzLmluc2VydEF0VGltZShwcm9wLCB0aW1lLCBtYXBbcHJvcF0pOyB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdHlsZXNfMSA9IGVudHJ5LnN0eWxlcztcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaW5uZXJBc3QgPSBfcGFyc2VUcmFuc2l0aW9uQW5pbWF0aW9uKGVudHJ5LCB0aW1lLCBjb2xsZWN0ZWRTdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByZXZpb3VzU3R5bGVzXzEpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRpbmdTdHlsZXMgPSBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KHByZXZpb3VzU3R5bGVzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzXzEucHVzaChuZXcgQW5pbWF0aW9uU3RlcEFzdChzdGFydGluZ1N0eWxlcywgW10sIDAsIDAsICcnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJTdGVwID0gaW5uZXJBc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgKF9hID0gaW5uZXJTdGVwLnN0YXJ0aW5nU3R5bGVzLnN0eWxlcykucHVzaC5hcHBseShfYSwgcHJldmlvdXNTdHlsZXNfMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1N0eWxlc18xID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYXN0RHVyYXRpb24gPSBpbm5lckFzdC5wbGF5VGltZTtcbiAgICAgICAgICAgICAgY3VycmVudFRpbWUgKz0gYXN0RHVyYXRpb247XG4gICAgICAgICAgICAgIHBsYXlUaW1lICs9IGFzdER1cmF0aW9uO1xuICAgICAgICAgICAgICBtYXhEdXJhdGlvbl8xID0gTWF0aC5tYXgoYXN0RHVyYXRpb24sIG1heER1cmF0aW9uXzEpO1xuICAgICAgICAgICAgICBzdGVwc18xLnB1c2goaW5uZXJBc3QpO1xuICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChwcmV2aW91c1N0eWxlc18xKSkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRpbmdTdHlsZXMgPSBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KHByZXZpb3VzU3R5bGVzXzEpO1xuICAgICAgICAgICAgICBzdGVwc18xLnB1c2gobmV3IEFuaW1hdGlvblN0ZXBBc3Qoc3RhcnRpbmdTdHlsZXMsIFtdLCAwLCAwLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNHcm91cF8xKSB7XG4gICAgICAgICAgICAgIGFzdCA9IG5ldyBBbmltYXRpb25Hcm91cEFzdChzdGVwc18xKTtcbiAgICAgICAgICAgICAgcGxheVRpbWUgPSBtYXhEdXJhdGlvbl8xO1xuICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IHN0YXJ0aW5nVGltZSArIHBsYXlUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYXN0ID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlQXN0KHN0ZXBzXzEpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSkge1xuICAgICAgICAgIHZhciB0aW1pbmdzID0gX3BhcnNlVGltZUV4cHJlc3Npb24oZW50cnkudGltaW5ncywgZXJyb3JzKTtcbiAgICAgICAgICB2YXIgc3R5bGVzID0gZW50cnkuc3R5bGVzO1xuICAgICAgICAgIHZhciBrZXlmcmFtZXMgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHN0eWxlcyBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIGtleWZyYW1lcyA9XG4gICAgICAgICAgICAgICAgICBfcGFyc2VBbmltYXRpb25LZXlmcmFtZXMoc3R5bGVzLCBjdXJyZW50VGltZSwgY29sbGVjdGVkU3R5bGVzLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzdHlsZURhdGEgPSBzdHlsZXM7XG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfVEVSTUlOQUxfS0VZRlJBTUU7XG4gICAgICAgICAgICAgIHZhciBzdHlsZUFzdCA9IG5ldyBBbmltYXRpb25TdHlsZXNBc3Qoc3R5bGVEYXRhLnN0eWxlcyk7XG4gICAgICAgICAgICAgIHZhciBrZXlmcmFtZSA9IG5ldyBBbmltYXRpb25LZXlmcmFtZUFzdChvZmZzZXQsIHN0eWxlQXN0KTtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0gW2tleWZyYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXN0ID0gbmV3IEFuaW1hdGlvblN0ZXBBc3QobmV3IEFuaW1hdGlvblN0eWxlc0FzdChbXSksIGtleWZyYW1lcywgdGltaW5ncy5kdXJhdGlvbiwgdGltaW5ncy5kZWxheSwgdGltaW5ncy5lYXNpbmcpO1xuICAgICAgICAgIHBsYXlUaW1lID0gdGltaW5ncy5kdXJhdGlvbiArIHRpbWluZ3MuZGVsYXk7XG4gICAgICAgICAgY3VycmVudFRpbWUgKz0gcGxheVRpbWU7XG4gICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBrZXlmcmFtZS5zdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5IC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBjb2xsZWN0ZWRTdHlsZXMuaW5zZXJ0QXRUaW1lKHByb3AsIGN1cnJlbnRUaW1lLCBlbnRyeVtwcm9wXSk7IH0pOyB9KTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgY29kZSByZWFjaGVzIHRoaXMgc3RhZ2UgdGhlbiBhbiBlcnJvclxuICAgICAgICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gcG9wdWxhdGVkIHdpdGhpbiB0aGUgX25vcm1hbGl6ZVN0eWxlU3RlcHMoKVxuICAgICAgICAgIC8vIG9wZXJhdGlvbi4uLlxuICAgICAgICAgIGFzdCA9IG5ldyBBbmltYXRpb25TdGVwQXN0KG51bGwsIFtdLCAwLCAwLCAnJyk7XG4gICAgICB9XG4gICAgICBhc3QucGxheVRpbWUgPSBwbGF5VGltZTtcbiAgICAgIGFzdC5zdGFydFRpbWUgPSBzdGFydGluZ1RpbWU7XG4gICAgICByZXR1cm4gYXN0O1xuICB9XG4gIGZ1bmN0aW9uIF9maWxsQW5pbWF0aW9uQXN0U3RhcnRpbmdLZXlmcmFtZXMoYXN0LCBjb2xsZWN0ZWRTdHlsZXMsIGVycm9ycykge1xuICAgICAgLy8gc3RlcHMgdGhhdCBvbmx5IGNvbnRhaW4gc3R5bGUgd2lsbCBub3QgYmUgZmlsbGVkXG4gICAgICBpZiAoKGFzdCBpbnN0YW5jZW9mIEFuaW1hdGlvblN0ZXBBc3QpICYmIGFzdC5rZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBrZXlmcmFtZXMgPSBhc3Qua2V5ZnJhbWVzO1xuICAgICAgICAgIGlmIChrZXlmcmFtZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZEtleWZyYW1lID0ga2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRLZXlmcmFtZSA9IF9jcmVhdGVTdGFydEtleWZyYW1lRnJvbUVuZEtleWZyYW1lKGVuZEtleWZyYW1lLCBhc3Quc3RhcnRUaW1lLCBhc3QucGxheVRpbWUsIGNvbGxlY3RlZFN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgYXN0LmtleWZyYW1lcyA9IFtzdGFydEtleWZyYW1lLCBlbmRLZXlmcmFtZV07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXN0IGluc3RhbmNlb2YgQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KSB7XG4gICAgICAgICAgYXN0LnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBfZmlsbEFuaW1hdGlvbkFzdFN0YXJ0aW5nS2V5ZnJhbWVzKGVudHJ5LCBjb2xsZWN0ZWRTdHlsZXMsIGVycm9ycyk7IH0pO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZVRpbWVFeHByZXNzaW9uKGV4cCwgZXJyb3JzKSB7XG4gICAgICB2YXIgcmVnZXggPSAvXihbXFwuXFxkXSspKG0/cykoPzpcXHMrKFtcXC5cXGRdKykobT9zKSk/KD86XFxzKyhbLWEtel0rKD86XFwoLis/XFwpKT8pKT8vaTtcbiAgICAgIHZhciBkdXJhdGlvbjtcbiAgICAgIHZhciBkZWxheSA9IDA7XG4gICAgICB2YXIgZWFzaW5nID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZXhwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gZXhwLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlRoZSBwcm92aWRlZCB0aW1pbmcgdmFsdWUgXFxcIlwiICsgZXhwICsgXCJcXFwiIGlzIGludmFsaWQuXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQW5pbWF0aW9uVGltaW5ncygwLCAwLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGR1cmF0aW9uTWF0Y2ggPSBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pO1xuICAgICAgICAgIHZhciBkdXJhdGlvblVuaXQgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgIGlmIChkdXJhdGlvblVuaXQgPT0gJ3MnKSB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uTWF0Y2ggKj0gX09ORV9TRUNPTkQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbk1hdGNoKTtcbiAgICAgICAgICB2YXIgZGVsYXlNYXRjaCA9IG1hdGNoZXNbM107XG4gICAgICAgICAgdmFyIGRlbGF5VW5pdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkZWxheU1hdGNoKSkge1xuICAgICAgICAgICAgICB2YXIgZGVsYXlWYWwgPSBwYXJzZUZsb2F0KGRlbGF5TWF0Y2gpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlbGF5VW5pdCkgJiYgZGVsYXlVbml0ID09ICdzJykge1xuICAgICAgICAgICAgICAgICAgZGVsYXlWYWwgKj0gX09ORV9TRUNPTkQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsYXkgPSBNYXRoLmZsb29yKGRlbGF5VmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVhc2luZ1ZhbCA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgaWYgKCFpc0JsYW5rKGVhc2luZ1ZhbCkpIHtcbiAgICAgICAgICAgICAgZWFzaW5nID0gZWFzaW5nVmFsO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGR1cmF0aW9uID0gZXhwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBfQW5pbWF0aW9uVGltaW5ncyhkdXJhdGlvbiwgZGVsYXksIGVhc2luZyk7XG4gIH1cbiAgZnVuY3Rpb24gX2NyZWF0ZVN0YXJ0S2V5ZnJhbWVGcm9tRW5kS2V5ZnJhbWUoZW5kS2V5ZnJhbWUsIHN0YXJ0VGltZSwgZHVyYXRpb24sIGNvbGxlY3RlZFN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgdmFsdWVzID0ge307XG4gICAgICB2YXIgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgICAgZW5kS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZURhdGEpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZURhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHN0eWxlRGF0YVtwcm9wXTtcbiAgICAgICAgICAgICAgaWYgKHByb3AgPT0gJ29mZnNldCcpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIHZhciByZXN1bHRJbmRleCA9IGNvbGxlY3RlZFN0eWxlcy5pbmRleE9mQXRPckJlZm9yZVRpbWUocHJvcCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdEVudHJ5IC8qKiBUT0RPICM5MTAwICovLCBuZXh0RW50cnkgLyoqIFRPRE8gIzkxMDAgKi8sIHZhbHVlO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0RW50cnkgPSBjb2xsZWN0ZWRTdHlsZXMuZ2V0QnlJbmRleChwcm9wLCByZXN1bHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgbmV4dEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzLmdldEJ5SW5kZXgocHJvcCwgcmVzdWx0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBmbGFnIHRoYXQgdGhlIHJ1bnRpbWUgY29kZSB1c2VzIHRvIHBhc3NcbiAgICAgICAgICAgICAgICAgIC8vIGluIGEgdmFsdWUgZWl0aGVyIGZyb20gdGhlIHN0YXRlIGRlY2xhcmF0aW9uIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgLy8gb3IgdXNpbmcgdGhlIEFVVE9fU1RZTEUgdmFsdWUgKGUuZy4gZ2V0Q29tcHV0ZWRTdHlsZSlcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gRklMTF9TVFlMRV9GTEFHO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobmV4dEVudHJ5KSAmJiAhbmV4dEVudHJ5Lm1hdGNoZXMoZW5kVGltZSwgdmFsKSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJUaGUgYW5pbWF0ZWQgQ1NTIHByb3BlcnR5IFxcXCJcIiArIHByb3AgKyBcIlxcXCIgdW5leHBlY3RlZGx5IGNoYW5nZXMgYmV0d2VlbiBzdGVwcyBcXFwiXCIgKyByZXN1bHRFbnRyeS50aW1lICsgXCJtc1xcXCIgYW5kIFxcXCJcIiArIGVuZFRpbWUgKyBcIm1zXFxcIiBhdCBcXFwiXCIgKyBuZXh0RW50cnkudGltZSArIFwibXNcXFwiXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25LZXlmcmFtZUFzdChfSU5JVElBTF9LRVlGUkFNRSwgbmV3IEFuaW1hdGlvblN0eWxlc0FzdChbdmFsdWVzXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogQW4gaW50ZXJmYWNlIGZvciByZXRyaWV2aW5nIGRvY3VtZW50cyBieSBVUkwgdGhhdCB0aGUgY29tcGlsZXIgdXNlc1xuICAgKiB0byBsb2FkIHRlbXBsYXRlcy5cbiAgICovXG4gIHZhciBSZXNvdXJjZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlcigpIHtcbiAgICAgIH1cbiAgICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFJlc291cmNlTG9hZGVyO1xuICB9KCkpO1xuXG4gIHZhciBfQVNTRVRfU0NIRU1FID0gJ2Fzc2V0Oic7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB7QGxpbmsgVXJsUmVzb2x2ZXJ9IHdpdGggbm8gcGFja2FnZSBwcmVmaXguXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVVcmxSZXNvbHZlcldpdGhvdXRQYWNrYWdlUHJlZml4KCkge1xuICAgICAgcmV0dXJuIG5ldyBVcmxSZXNvbHZlcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKSB7XG4gICAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKF9BU1NFVF9TQ0hFTUUpO1xuICB9XG4gIC8qKlxuICAgKiBBIGRlZmF1bHQgcHJvdmlkZXIgZm9yIHtAbGluayBQQUNLQUdFX1JPT1RfVVJMfSB0aGF0IG1hcHMgdG8gJy8nLlxuICAgKi9cbiAgdmFyIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIgPSB7XG4gICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBBQ0tBR0VfUk9PVF9VUkwsXG4gICAgICB1c2VWYWx1ZTogJy8nXG4gIH07XG4gIC8qKlxuICAgKiBVc2VkIGJ5IHRoZSB7QGxpbmsgQ29tcGlsZXJ9IHdoZW4gcmVzb2x2aW5nIEhUTUwgYW5kIENTUyB0ZW1wbGF0ZSBVUkxzLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAgICpcbiAgICogU2VlIHtAbGluayBDb21waWxlcn1cbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiB7QGV4YW1wbGUgY29tcGlsZXIvdHMvdXJsX3Jlc29sdmVyL3VybF9yZXNvbHZlci50cyByZWdpb249J3VybF9yZXNvbHZlcid9XG4gICAqXG4gICAqIEBzZWN1cml0eSAgV2hlbiBjb21waWxpbmcgdGVtcGxhdGVzIGF0IHJ1bnRpbWUsIHlvdSBtdXN0XG4gICAqIGVuc3VyZSB0aGF0IHRoZSBlbnRpcmUgdGVtcGxhdGUgY29tZXMgZnJvbSBhIHRydXN0ZWQgc291cmNlLlxuICAgKiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gICAqIGFwcGxpY2F0aW9uIHRvIFhTUyByaXNrcy4gRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgKi9cbiAgdmFyIFVybFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFVybFJlc29sdmVyKF9wYWNrYWdlUHJlZml4KSB7XG4gICAgICAgICAgaWYgKF9wYWNrYWdlUHJlZml4ID09PSB2b2lkIDApIHsgX3BhY2thZ2VQcmVmaXggPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5fcGFja2FnZVByZWZpeCA9IF9wYWNrYWdlUHJlZml4O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXNvbHZlcyB0aGUgYHVybGAgZ2l2ZW4gdGhlIGBiYXNlVXJsYDpcbiAgICAgICAqIC0gd2hlbiB0aGUgYHVybGAgaXMgbnVsbCwgdGhlIGBiYXNlVXJsYCBpcyByZXR1cm5lZCxcbiAgICAgICAqIC0gaWYgYHVybGAgaXMgcmVsYXRpdmUgKCdwYXRoL3RvL2hlcmUnLCAnLi9wYXRoL3RvL2hlcmUnKSwgdGhlIHJlc29sdmVkIHVybCBpcyBhIGNvbWJpbmF0aW9uIG9mXG4gICAgICAgKiBgYmFzZVVybGAgYW5kIGB1cmxgLFxuICAgICAgICogLSBpZiBgdXJsYCBpcyBhYnNvbHV0ZSAoaXQgaGFzIGEgc2NoZW1lOiAnaHR0cDovLycsICdodHRwczovLycgb3Igc3RhcnQgd2l0aCAnLycpLCB0aGUgYHVybGAgaXNcbiAgICAgICAqIHJldHVybmVkIGFzIGlzIChpZ25vcmluZyB0aGUgYGJhc2VVcmxgKVxuICAgICAgICovXG4gICAgICBVcmxSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChiYXNlVXJsLCB1cmwpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRVcmwgPSB1cmw7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChiYXNlVXJsKSAmJiBiYXNlVXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBfcmVzb2x2ZVVybChiYXNlVXJsLCByZXNvbHZlZFVybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNvbHZlZFBhcnRzID0gX3NwbGl0KHJlc29sdmVkVXJsKTtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5fcGFja2FnZVByZWZpeDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHByZWZpeCkgJiYgaXNQcmVzZW50KHJlc29sdmVkUGFydHMpICYmXG4gICAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gJ3BhY2thZ2UnKSB7XG4gICAgICAgICAgICAgIHZhciBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wYWNrYWdlUHJlZml4ID09PSBfQVNTRVRfU0NIRU1FKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGF0aFNlZ2VtZW50cyA9IHBhdGguc3BsaXQoL1xcLy8pO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBcImFzc2V0OlwiICsgcGF0aFNlZ2VtZW50c1swXSArIFwiL2xpYi9cIiArIHBhdGhTZWdlbWVudHMuc2xpY2UoMSkuam9pbignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcLyskLywgJycpO1xuICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLysvLCAnJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgXCIvXCIgKyBwYXRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlZFVybDtcbiAgICAgIH07XG4gICAgICBVcmxSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBVcmxSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLlBBQ0tBR0VfUk9PVF9VUkwsXSB9LF0gfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gVXJsUmVzb2x2ZXI7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBzY2hlbWUgb2YgYSBVUkwuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRVcmxTY2hlbWUodXJsKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBfc3BsaXQodXJsKTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2hbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0pIHx8ICcnO1xuICB9XG4gIC8vIFRoZSBjb2RlIGJlbG93IGlzIGFkYXB0ZWQgZnJvbSBUcmFjZXVyOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RyYWNldXItY29tcGlsZXIvYmxvYi85NTExYzFkYWZhOTcyYmYwZGUxMjAyYThhODYzYmFkMDJmMGY5NWE4L3NyYy9ydW50aW1lL3VybC5qc1xuICAvKipcbiAgICogQnVpbGRzIGEgVVJJIHN0cmluZyBmcm9tIGFscmVhZHktZW5jb2RlZCBwYXJ0cy5cbiAgICpcbiAgICogTm8gZW5jb2RpbmcgaXMgcGVyZm9ybWVkLiAgQW55IGNvbXBvbmVudCBtYXkgYmUgb21pdHRlZCBhcyBlaXRoZXIgbnVsbCBvclxuICAgKiB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRfc2NoZW1lIFRoZSBzY2hlbWUgc3VjaCBhcyAnaHR0cCcuXG4gICAqIEBwYXJhbSBvcHRfdXNlckluZm8gVGhlIHVzZXIgbmFtZSBiZWZvcmUgdGhlICdAJy5cbiAgICogQHBhcmFtIG9wdF9kb21haW4gVGhlIGRvbWFpbiBzdWNoIGFzICd3d3cuZ29vZ2xlLmNvbScsIGFscmVhZHlcbiAgICogICAgIFVSSS1lbmNvZGVkLlxuICAgKiBAcGFyYW0gb3B0X3BvcnQgVGhlIHBvcnQgbnVtYmVyLlxuICAgKiBAcGFyYW0gb3B0X3BhdGggVGhlIHBhdGgsIGFscmVhZHkgVVJJLWVuY29kZWQuICBJZiBpdCBpcyBub3RcbiAgICogICAgIGVtcHR5LCBpdCBtdXN0IGJlZ2luIHdpdGggYSBzbGFzaC5cbiAgICogQHBhcmFtIG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXG4gICAqIEBwYXJhbSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4gVGhlIGZ1bGx5IGNvbWJpbmVkIFVSSS5cbiAgICovXG4gIGZ1bmN0aW9uIF9idWlsZEZyb21FbmNvZGVkUGFydHMob3B0X3NjaGVtZSwgb3B0X3VzZXJJbmZvLCBvcHRfZG9tYWluLCBvcHRfcG9ydCwgb3B0X3BhdGgsIG9wdF9xdWVyeURhdGEsIG9wdF9mcmFnbWVudCkge1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgaWYgKGlzUHJlc2VudChvcHRfc2NoZW1lKSkge1xuICAgICAgICAgIG91dC5wdXNoKG9wdF9zY2hlbWUgKyAnOicpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJlc2VudChvcHRfZG9tYWluKSkge1xuICAgICAgICAgIG91dC5wdXNoKCcvLycpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQob3B0X3VzZXJJbmZvKSkge1xuICAgICAgICAgICAgICBvdXQucHVzaChvcHRfdXNlckluZm8gKyAnQCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQucHVzaChvcHRfZG9tYWluKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG9wdF9wb3J0KSkge1xuICAgICAgICAgICAgICBvdXQucHVzaCgnOicgKyBvcHRfcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzUHJlc2VudChvcHRfcGF0aCkpIHtcbiAgICAgICAgICBvdXQucHVzaChvcHRfcGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KG9wdF9xdWVyeURhdGEpKSB7XG4gICAgICAgICAgb3V0LnB1c2goJz8nICsgb3B0X3F1ZXJ5RGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KG9wdF9mcmFnbWVudCkpIHtcbiAgICAgICAgICBvdXQucHVzaCgnIycgKyBvcHRfZnJhZ21lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgfVxuICAvKipcbiAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAgICpcbiAgICoge0BsaW5rIGh0dHA6Ly93d3cuZ2Jpdi5jb20vcHJvdG9jb2xzL3VyaS9yZmMvcmZjMzk4Ni5odG1sI1JGQzIyMzR9IHNheXNcbiAgICogQXMgdGhlIFwiZmlyc3QtbWF0Y2gtd2luc1wiIGFsZ29yaXRobSBpcyBpZGVudGljYWwgdG8gdGhlIFwiZ3JlZWR5XCJcbiAgICogZGlzYW1iaWd1YXRpb24gbWV0aG9kIHVzZWQgYnkgUE9TSVggcmVndWxhciBleHByZXNzaW9ucywgaXQgaXMgbmF0dXJhbCBhbmRcbiAgICogY29tbW9ucGxhY2UgdG8gdXNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBwYXJzaW5nIHRoZSBwb3RlbnRpYWwgZml2ZVxuICAgKiBjb21wb25lbnRzIG9mIGEgVVJJIHJlZmVyZW5jZS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBsaW5lIGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nLWRvd24gYVxuICAgKiB3ZWxsLWZvcm1lZCBVUkkgcmVmZXJlbmNlIGludG8gaXRzIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIDxwcmU+XG4gICAqIF4oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT9cbiAgICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxuICAgKiA8L3ByZT5cbiAgICpcbiAgICogVGhlIG51bWJlcnMgaW4gdGhlIHNlY29uZCBsaW5lIGFib3ZlIGFyZSBvbmx5IHRvIGFzc2lzdCByZWFkYWJpbGl0eTsgdGhleVxuICAgKiBpbmRpY2F0ZSB0aGUgcmVmZXJlbmNlIHBvaW50cyBmb3IgZWFjaCBzdWJleHByZXNzaW9uIChpLmUuLCBlYWNoIHBhaXJlZFxuICAgKiBwYXJlbnRoZXNpcykuIFdlIHJlZmVyIHRvIHRoZSB2YWx1ZSBtYXRjaGVkIGZvciBzdWJleHByZXNzaW9uIDxuPiBhcyAkPG4+LlxuICAgKiBGb3IgZXhhbXBsZSwgbWF0Y2hpbmcgdGhlIGFib3ZlIGV4cHJlc3Npb24gdG9cbiAgICogPHByZT5cbiAgICogICAgIGh0dHA6Ly93d3cuaWNzLnVjaS5lZHUvcHViL2lldGYvdXJpLyNSZWxhdGVkXG4gICAqIDwvcHJlPlxuICAgKiByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgc3ViZXhwcmVzc2lvbiBtYXRjaGVzOlxuICAgKiA8cHJlPlxuICAgKiAgICAkMSA9IGh0dHA6XG4gICAqICAgICQyID0gaHR0cFxuICAgKiAgICAkMyA9IC8vd3d3Lmljcy51Y2kuZWR1XG4gICAqICAgICQ0ID0gd3d3Lmljcy51Y2kuZWR1XG4gICAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS9cbiAgICogICAgJDYgPSA8dW5kZWZpbmVkPlxuICAgKiAgICAkNyA9IDx1bmRlZmluZWQ+XG4gICAqICAgICQ4ID0gI1JlbGF0ZWRcbiAgICogICAgJDkgPSBSZWxhdGVkXG4gICAqIDwvcHJlPlxuICAgKiB3aGVyZSA8dW5kZWZpbmVkPiBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tcG9uZW50IGlzIG5vdCBwcmVzZW50LCBhcyBpcyB0aGVcbiAgICogY2FzZSBmb3IgdGhlIHF1ZXJ5IGNvbXBvbmVudCBpbiB0aGUgYWJvdmUgZXhhbXBsZS4gVGhlcmVmb3JlLCB3ZSBjYW5cbiAgICogZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgZml2ZSBjb21wb25lbnRzIGFzXG4gICAqIDxwcmU+XG4gICAqICAgIHNjaGVtZSAgICA9ICQyXG4gICAqICAgIGF1dGhvcml0eSA9ICQ0XG4gICAqICAgIHBhdGggICAgICA9ICQ1XG4gICAqICAgIHF1ZXJ5ICAgICA9ICQ3XG4gICAqICAgIGZyYWdtZW50ICA9ICQ5XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIGhhcyBiZWVuIG1vZGlmaWVkIHNsaWdodGx5IHRvIGV4cG9zZSB0aGVcbiAgICogdXNlckluZm8sIGRvbWFpbiwgYW5kIHBvcnQgc2VwYXJhdGVseSBmcm9tIHRoZSBhdXRob3JpdHkuXG4gICAqIFRoZSBtb2RpZmllZCB2ZXJzaW9uIHlpZWxkc1xuICAgKiA8cHJlPlxuICAgKiAgICAkMSA9IGh0dHAgICAgICAgICAgICAgIHNjaGVtZVxuICAgKiAgICAkMiA9IDx1bmRlZmluZWQ+ICAgICAgIHVzZXJJbmZvIC1cXFxuICAgKiAgICAkMyA9IHd3dy5pY3MudWNpLmVkdSAgIGRvbWFpbiAgICAgfCBhdXRob3JpdHlcbiAgICogICAgJDQgPSA8dW5kZWZpbmVkPiAgICAgICBwb3J0ICAgICAtL1xuICAgKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvICAgIHBhdGhcbiAgICogICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cbiAgICogICAgJDcgPSBSZWxhdGVkICAgICAgICAgICBmcmFnbWVudCB3aXRob3V0ICNcbiAgICogPC9wcmU+XG4gICAqIEB0eXBlIHshUmVnRXhwfVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhciBfc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAgICcoPzonICtcbiAgICAgICcoW146Lz8jLl0rKScgK1xuICAgICAgLy8gdXNlZCBieSBvdGhlciBVUkwgcGFydHMgc3VjaCBhcyA6LFxuICAgICAgLy8gPywgLywgIywgYW5kIC5cbiAgICAgICc6KT8nICtcbiAgICAgICcoPzovLycgK1xuICAgICAgJyg/OihbXi8/I10qKUApPycgK1xuICAgICAgJyhbXFxcXHdcXFxcZFxcXFwtXFxcXHUwMTAwLVxcXFx1ZmZmZi4lXSopJyArXG4gICAgICAvLyBkaWdpdHMsIGRhc2hlcywgZG90cywgcGVyY2VudFxuICAgICAgLy8gZXNjYXBlcywgYW5kIHVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICAgICcoPzo6KFswLTldKykpPycgK1xuICAgICAgJyk/JyArXG4gICAgICAnKFtePyNdKyk/JyArXG4gICAgICAnKD86XFxcXD8oW14jXSopKT8nICtcbiAgICAgICcoPzojKC4qKSk/JyArXG4gICAgICAnJCcpO1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIGVhY2ggVVJJIGNvbXBvbmVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIG9mIGdvb2cudXJpLnV0aWxzLnNwbGl0LlxuICAgKiBAZW51bSB7bnVtYmVyfVxuICAgKi9cbiAgdmFyIF9Db21wb25lbnRJbmRleDtcbiAgKGZ1bmN0aW9uIChfQ29tcG9uZW50SW5kZXgpIHtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJTY2hlbWVcIl0gPSAxXSA9IFwiU2NoZW1lXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiVXNlckluZm9cIl0gPSAyXSA9IFwiVXNlckluZm9cIjtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJEb21haW5cIl0gPSAzXSA9IFwiRG9tYWluXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUG9ydFwiXSA9IDRdID0gXCJQb3J0XCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUGF0aFwiXSA9IDVdID0gXCJQYXRoXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUXVlcnlEYXRhXCJdID0gNl0gPSBcIlF1ZXJ5RGF0YVwiO1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIkZyYWdtZW50XCJdID0gN10gPSBcIkZyYWdtZW50XCI7XG4gIH0pKF9Db21wb25lbnRJbmRleCB8fCAoX0NvbXBvbmVudEluZGV4ID0ge30pKTtcbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gICAqXG4gICAqIEVhY2ggY29tcG9uZW50IGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhlIGNvbXBvbmVudCBpbmRpY2VzOyBmb3IgZXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogZ29vZy51cmkudXRpbHMuc3BsaXQoc29tZVN0cilbZ29vZy51cmkudXRpbHMuQ29tcG9udGVudEluZGV4LlFVRVJZX0RBVEFdO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHVyaSBUaGUgVVJJIHN0cmluZyB0byBleGFtaW5lLlxuICAgKiBAcmV0dXJuIEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxuICAgKiAgICAgRWFjaCBjb21wb25lbnQgdGhhdCBpcyBwcmVzZW50IHdpbGwgY29udGFpbiB0aGUgZW5jb2RlZCB2YWx1ZSwgd2hlcmVhc1xuICAgKiAgICAgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcHJlc2VudCB3aWxsIGJlIHVuZGVmaW5lZCBvciBlbXB0eSwgZGVwZW5kaW5nXG4gICAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXG4gICAqICAgICBhcmJpdHJhcnkgc3RyaW5ncyBtYXkgc3RpbGwgbG9vayBsaWtlIHBhdGggbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfc3BsaXQodXJpKSB7XG4gICAgICByZXR1cm4gdXJpLm1hdGNoKF9zcGxpdFJlKTtcbiAgfVxuICAvKipcbiAgICAqIFJlbW92ZXMgZG90IHNlZ21lbnRzIGluIGdpdmVuIHBhdGggY29tcG9uZW50LCBhcyBkZXNjcmliZWQgaW5cbiAgICAqIFJGQyAzOTg2LCBzZWN0aW9uIDUuMi40LlxuICAgICpcbiAgICAqIEBwYXJhbSBwYXRoIEEgbm9uLWVtcHR5IHBhdGggY29tcG9uZW50LlxuICAgICogQHJldHVybiBQYXRoIGNvbXBvbmVudCB3aXRoIHJlbW92ZWQgZG90IHNlZ21lbnRzLlxuICAgICovXG4gIGZ1bmN0aW9uIF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKSB7XG4gICAgICBpZiAocGF0aCA9PSAnLycpXG4gICAgICAgICAgcmV0dXJuICcvJztcbiAgICAgIHZhciBsZWFkaW5nU2xhc2ggPSBwYXRoWzBdID09ICcvJyA/ICcvJyA6ICcnO1xuICAgICAgdmFyIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgdmFyIHVwID0gMDtcbiAgICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW3Bvc107XG4gICAgICAgICAgc3dpdGNoIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJy4uJzpcbiAgICAgICAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG91dC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZWFkaW5nU2xhc2ggPT0gJycpIHtcbiAgICAgICAgICB3aGlsZSAodXAtLSA+IDApIHtcbiAgICAgICAgICAgICAgb3V0LnVuc2hpZnQoJy4uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICBvdXQucHVzaCgnLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xuICB9XG4gIC8qKlxuICAgKiBUYWtlcyBhbiBhcnJheSBvZiB0aGUgcGFydHMgZnJvbSBzcGxpdCBhbmQgY2Fub25pY2FsaXplcyB0aGUgcGF0aCBwYXJ0XG4gICAqIGFuZCB0aGVuIGpvaW5zIGFsbCB0aGUgcGFydHMuXG4gICAqL1xuICBmdW5jdGlvbiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpIHtcbiAgICAgIHZhciBwYXRoID0gcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgICAgcGF0aCA9IGlzQmxhbmsocGF0aCkgPyAnJyA6IF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKTtcbiAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgICByZXR1cm4gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkRvbWFpbl0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Qb3J0XSwgcGF0aCwgcGFydHNbX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5GcmFnbWVudF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIFVSTC5cbiAgICogQHBhcmFtIGJhc2UgVGhlIFVSTCBhY3RpbmcgYXMgdGhlIGJhc2UgVVJMLlxuICAgKiBAcGFyYW0gdG8gVGhlIFVSTCB0byByZXNvbHZlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBfc3BsaXQoZW5jb2RlVVJJKHVybCkpO1xuICAgICAgdmFyIGJhc2VQYXJ0cyA9IF9zcGxpdChiYXNlKTtcbiAgICAgIGlmIChpc1ByZXNlbnQocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0pKSB7XG4gICAgICAgICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSA9IGJhc2VQYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBfQ29tcG9uZW50SW5kZXguU2NoZW1lOyBpIDw9IF9Db21wb25lbnRJbmRleC5Qb3J0OyBpKyspIHtcbiAgICAgICAgICBpZiAoaXNCbGFuayhwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgcGFydHNbaV0gPSBiYXNlUGFydHNbaV07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXVswXSA9PSAnLycpIHtcbiAgICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXRoID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICAgIGlmIChpc0JsYW5rKHBhdGgpKVxuICAgICAgICAgIHBhdGggPSAnLyc7XG4gICAgICB2YXIgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKSArIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgfVxuXG4gIHZhciBEaXJlY3RpdmVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZU5vcm1hbGl6ZXIoX3Jlc291cmNlTG9hZGVyLCBfdXJsUmVzb2x2ZXIsIF9odG1sUGFyc2VyLCBfY29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXIgPSBfcmVzb3VyY2VMb2FkZXI7XG4gICAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuY2xlYXIoKTsgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAobm9ybWFsaXplZERpcmVjdGl2ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKCFub3JtYWxpemVkRGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUobm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZS50ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgbm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHsgX3RoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZGVsZXRlKHN0eWxlc2hlZXQubW9kdWxlVXJsKTsgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmdldCh1cmwpO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3Jlc291cmNlTG9hZGVyLmdldCh1cmwpO1xuICAgICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLnNldCh1cmwsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplVGVtcGxhdGUgPSBmdW5jdGlvbiAocHJlbm9ybURhdGEpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub3JtYWxpemVkVGVtcGxhdGVTeW5jID0gbnVsbDtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmM7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChwcmVub3JtRGF0YS50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlU3luYyA9IHRoaXMubm9ybWFsaXplVGVtcGxhdGVTeW5jKHByZW5vcm1EYXRhKTtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmMgPSBQcm9taXNlLnJlc29sdmUobm9ybWFsaXplZFRlbXBsYXRlU3luYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHByZW5vcm1EYXRhLnRlbXBsYXRlVXJsKSB7XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jID0gdGhpcy5ub3JtYWxpemVUZW1wbGF0ZUFzeW5jKHByZW5vcm1EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRlbXBsYXRlIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgc3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgJiYgbm9ybWFsaXplZFRlbXBsYXRlU3luYy5zdHlsZVVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIHN5bmMgY2FzZVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChub3JtYWxpemVkVGVtcGxhdGVTeW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFzeW5jIGNhc2VcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQobnVsbCwgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmMudGhlbihmdW5jdGlvbiAobm9ybWFsaXplZFRlbXBsYXRlKSB7IHJldHVybiBfdGhpcy5ub3JtYWxpemVFeHRlcm5hbFN0eWxlc2hlZXRzKG5vcm1hbGl6ZWRUZW1wbGF0ZSk7IH0pKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplVGVtcGxhdGVTeW5jID0gZnVuY3Rpb24gKHByZW5vbURhdGEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZShwcmVub21EYXRhLCBwcmVub21EYXRhLnRlbXBsYXRlLCBwcmVub21EYXRhLm1vZHVsZVVybCk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplVGVtcGxhdGVBc3luYyA9IGZ1bmN0aW9uIChwcmVub21EYXRhKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdGVtcGxhdGVVcmwgPSB0aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKHByZW5vbURhdGEubW9kdWxlVXJsLCBwcmVub21EYXRhLnRlbXBsYXRlVXJsKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2godGVtcGxhdGVVcmwpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUocHJlbm9tRGF0YSwgdmFsdWUsIHRlbXBsYXRlVXJsKTsgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAocHJlbm9tRGF0YSwgdGVtcGxhdGUsIHRlbXBsYXRlQWJzVXJsKSB7XG4gICAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShwcmVub21EYXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICAgIHZhciByb290Tm9kZXNBbmRFcnJvcnMgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCBzdHJpbmdpZnkocHJlbm9tRGF0YS5jb21wb25lbnRUeXBlKSwgZmFsc2UsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChyb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gcm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGVtcGxhdGVNZXRhZGF0YVN0eWxlcyA9IHRoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHN0eWxlczogcHJlbm9tRGF0YS5zdHlsZXMsXG4gICAgICAgICAgICAgIHN0eWxlVXJsczogcHJlbm9tRGF0YS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogcHJlbm9tRGF0YS5tb2R1bGVVcmxcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKTtcbiAgICAgICAgICB2aXNpdEFsbCh2aXNpdG9yLCByb290Tm9kZXNBbmRFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVTdHlsZXMgPSB0aGlzLm5vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IHZpc2l0b3Iuc3R5bGVzLCBzdHlsZVVybHM6IHZpc2l0b3Iuc3R5bGVVcmxzLCBtb2R1bGVVcmw6IHRlbXBsYXRlQWJzVXJsIH0pKTtcbiAgICAgICAgICB2YXIgZW5jYXBzdWxhdGlvbiA9IHByZW5vbURhdGEuZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICBpZiAoaXNCbGFuayhlbmNhcHN1bGF0aW9uKSkge1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gdGhpcy5fY29uZmlnLmRlZmF1bHRFbmNhcHN1bGF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3R5bGVzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZXMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlcyk7XG4gICAgICAgICAgdmFyIHN0eWxlVXJscyA9IHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMuc3R5bGVVcmxzLmNvbmNhdCh0ZW1wbGF0ZVN0eWxlcy5zdHlsZVVybHMpO1xuICAgICAgICAgIGlmIChlbmNhcHN1bGF0aW9uID09PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkICYmIHN0eWxlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgc3R5bGVVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVBYnNVcmwsIHN0eWxlczogc3R5bGVzLCBzdHlsZVVybHM6IHN0eWxlVXJscyxcbiAgICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB2aXNpdG9yLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgYW5pbWF0aW9uczogcHJlbm9tRGF0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBwcmVub21EYXRhLmludGVycG9sYXRpb24sXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU1ldGEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzKHRlbXBsYXRlTWV0YS5zdHlsZVVybHMpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChleHRlcm5hbFN0eWxlc2hlZXRzKSB7IHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0ZW1wbGF0ZU1ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IHRlbXBsYXRlTWV0YS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IGV4dGVybmFsU3R5bGVzaGVldHMsXG4gICAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdGVtcGxhdGVNZXRhLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgYW5pbWF0aW9uczogdGVtcGxhdGVNZXRhLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgIGludGVycG9sYXRpb246IHRlbXBsYXRlTWV0YS5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgfSk7IH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMgPSBmdW5jdGlvbiAoc3R5bGVVcmxzLCBsb2FkZWRTdHlsZXNoZWV0cykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKGxvYWRlZFN0eWxlc2hlZXRzID09PSB2b2lkIDApIHsgbG9hZGVkU3R5bGVzaGVldHMgPSBuZXcgTWFwKCk7IH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgICAuYWxsKHN0eWxlVXJscy5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiAhbG9hZGVkU3R5bGVzaGVldHMuaGFzKHN0eWxlVXJsKTsgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuIF90aGlzLl9mZXRjaChzdHlsZVVybCkudGhlbihmdW5jdGlvbiAobG9hZGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSBfdGhpcy5ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiBbbG9hZGVkU3R5bGVdLCBtb2R1bGVVcmw6IHN0eWxlVXJsIH0pKTtcbiAgICAgICAgICAgICAgbG9hZGVkU3R5bGVzaGVldHMuc2V0KHN0eWxlVXJsLCBzdHlsZXNoZWV0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMoc3R5bGVzaGVldC5zdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKTtcbiAgICAgICAgICB9KTsgfSkpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBBcnJheS5mcm9tKGxvYWRlZFN0eWxlc2hlZXRzLnZhbHVlcygpKTsgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplU3R5bGVzaGVldCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYWxsU3R5bGVVcmxzID0gc3R5bGVzaGVldC5zdHlsZVVybHMuZmlsdGVyKGlzU3R5bGVVcmxSZXNvbHZhYmxlKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIF90aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKHN0eWxlc2hlZXQubW9kdWxlVXJsLCB1cmwpOyB9KTtcbiAgICAgICAgICB2YXIgYWxsU3R5bGVzID0gc3R5bGVzaGVldC5zdHlsZXMubWFwKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVXaXRoSW1wb3J0cyA9IGV4dHJhY3RTdHlsZVVybHMoX3RoaXMuX3VybFJlc29sdmVyLCBzdHlsZXNoZWV0Lm1vZHVsZVVybCwgc3R5bGUpO1xuICAgICAgICAgICAgICBhbGxTdHlsZVVybHMucHVzaC5hcHBseShhbGxTdHlsZVVybHMsIHN0eWxlV2l0aEltcG9ydHMuc3R5bGVVcmxzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlV2l0aEltcG9ydHMuc3R5bGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiBhbGxTdHlsZXMsIHN0eWxlVXJsczogYWxsU3R5bGVVcmxzLCBtb2R1bGVVcmw6IHN0eWxlc2hlZXQubW9kdWxlVXJsIH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IFJlc291cmNlTG9hZGVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogVXJsUmVzb2x2ZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBIdG1sUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcigpIHtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBbXTtcbiAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgICBzd2l0Y2ggKHByZXBhcnNlZEVsZW1lbnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ6XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5zZWxlY3RBdHRyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFOlxuICAgICAgICAgICAgICAgICAgdmFyIHRleHRDb250ZW50XzEgPSAnJztcbiAgICAgICAgICAgICAgICAgIGFzdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnRfMSArPSBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2godGV4dENvbnRlbnRfMSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUOlxuICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMucHVzaChwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xuICAgICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yO1xuICB9KCkpO1xuXG4gIC8qXG4gICAqIFJlc29sdmUgYSBgVHlwZWAgZm9yIHtAbGluayBEaXJlY3RpdmV9LlxuICAgKlxuICAgKiBUaGlzIGludGVyZmFjZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGNyZWF0ZSBjdXN0b20gYmVoYXZpb3IuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XG4gICAqL1xuICB2YXIgRGlyZWN0aXZlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IHJlZmxlY3RvcjsgfVxuICAgICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICB9XG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuaXNEaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMoX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuIHR5cGVNZXRhZGF0YSAmJiB0eXBlTWV0YWRhdGEuc29tZShpc0RpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB7QGxpbmsgRGlyZWN0aXZlfSBmb3IgYSBnaXZlbiBgVHlwZWAuXG4gICAgICAgKi9cbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgICAgdmFyIHR5cGVNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgICBpZiAodHlwZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHR5cGVNZXRhZGF0YS5maW5kKGlzRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLnByb3BNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhKG1ldGFkYXRhLCBwcm9wZXJ0eU1ldGFkYXRhLCB0eXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIERpcmVjdGl2ZSBhbm5vdGF0aW9uIGZvdW5kIG9uIFwiICsgc3RyaW5naWZ5KHR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhID0gZnVuY3Rpb24gKGRtLCBwcm9wZXJ0eU1ldGFkYXRhLCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgdmFyIGlucHV0cyA9IFtdO1xuICAgICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgICAgdmFyIGhvc3QgPSB7fTtcbiAgICAgICAgICB2YXIgcXVlcmllcyA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5TWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5JbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLk91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RCaW5kaW5nID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRXaXRoID0gaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0V2l0aCA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASG9zdEJpbmRpbmcgY2FuIG5vdCBiaW5kIHRvIGV2ZW50cy4gVXNlIEBIb3N0TGlzdGVuZXIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRXaXRoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBIb3N0QmluZGluZyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgcHJvcGVydHkgbmFtZSwgJ2NsYXNzLjxuYW1lPicsIG9yICdhdHRyLjxuYW1lPicuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RbKFwiW1wiICsgaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZSArIFwiXVwiKV0gPSBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RbKFwiW1wiICsgcHJvcE5hbWUgKyBcIl1cIildID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuSG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RMaXN0ZW5lciA9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBob3N0TGlzdGVuZXIuYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIihcIiArIGhvc3RMaXN0ZW5lci5ldmVudE5hbWUgKyBcIilcIildID0gcHJvcE5hbWUgKyBcIihcIiArIGFyZ3Muam9pbignLCcpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5RdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXNbcHJvcE5hbWVdID0gYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlKGRtLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fZXh0cmFjdFB1YmxpY05hbWUgPSBmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBzcGxpdEF0Q29sb24oZGVmLCBbbnVsbCwgZGVmXSlbMV0udHJpbSgpOyB9O1xuICAgICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9tZXJnZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmUsIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcywgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG1lcmdlZElucHV0cyA9IGlucHV0cztcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlLmlucHV0cykge1xuICAgICAgICAgICAgICB2YXIgaW5wdXROYW1lc18xID0gZGlyZWN0aXZlLmlucHV0cy5tYXAoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gX3RoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKGRlZik7IH0pO1xuICAgICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXREZWYpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwdWJsaWNOYW1lID0gX3RoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKGlucHV0RGVmKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dE5hbWVzXzEuaW5kZXhPZihwdWJsaWNOYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgJ1wiICsgcHVibGljTmFtZSArIFwiJyBkZWZpbmVkIG11bHRpcGxlIHRpbWVzIGluICdcIiArIHN0cmluZ2lmeShkaXJlY3RpdmVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1lcmdlZElucHV0cy51bnNoaWZ0LmFwcGx5KG1lcmdlZElucHV0cywgZGlyZWN0aXZlLmlucHV0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZXJnZWRPdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgdmFyIG91dHB1dE5hbWVzXzEgPSBkaXJlY3RpdmUub3V0cHV0cy5tYXAoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gX3RoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKGRlZik7IH0pO1xuICAgICAgICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dERlZikge1xuICAgICAgICAgICAgICAgICAgdmFyIHB1YmxpY05hbWUgPSBfdGhpcy5fZXh0cmFjdFB1YmxpY05hbWUob3V0cHV0RGVmKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXROYW1lc18xLmluZGV4T2YocHVibGljTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk91dHB1dCBldmVudCAnXCIgKyBwdWJsaWNOYW1lICsgXCInIGRlZmluZWQgbXVsdGlwbGUgdGltZXMgaW4gJ1wiICsgc3RyaW5naWZ5KGRpcmVjdGl2ZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWVyZ2VkT3V0cHV0cy51bnNoaWZ0LmFwcGx5KG1lcmdlZE91dHB1dHMsIGRpcmVjdGl2ZS5vdXRwdXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1lcmdlZEhvc3QgPSBkaXJlY3RpdmUuaG9zdCA/IFN0cmluZ01hcFdyYXBwZXIubWVyZ2UoZGlyZWN0aXZlLmhvc3QsIGhvc3QpIDogaG9zdDtcbiAgICAgICAgICB2YXIgbWVyZ2VkUXVlcmllcyA9IGRpcmVjdGl2ZS5xdWVyaWVzID8gU3RyaW5nTWFwV3JhcHBlci5tZXJnZShkaXJlY3RpdmUucXVlcmllcywgcXVlcmllcykgOiBxdWVyaWVzO1xuICAgICAgICAgIGlmIChkaXJlY3RpdmUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICBpbnB1dHM6IG1lcmdlZElucHV0cyxcbiAgICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBkaXJlY3RpdmUubW9kdWxlSWQsXG4gICAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkaXJlY3RpdmUuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBkaXJlY3RpdmUucHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogZGlyZWN0aXZlLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGRpcmVjdGl2ZS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZGlyZWN0aXZlLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IGRpcmVjdGl2ZS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICAgIHN0eWxlczogZGlyZWN0aXZlLnN0eWxlcyxcbiAgICAgICAgICAgICAgICAgIHN0eWxlVXJsczogZGlyZWN0aXZlLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGRpcmVjdGl2ZS5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogZGlyZWN0aXZlLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBkaXJlY3RpdmUuaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZS5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgIGhvc3Q6IG1lcmdlZEhvc3QsXG4gICAgICAgICAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgRGlyZWN0aXZlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIERpcmVjdGl2ZVJlc29sdmVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBpc0RpcmVjdGl2ZU1ldGFkYXRhKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmU7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNMaWZlY3ljbGVIb29rKGhvb2ssIHRva2VuKSB7XG4gICAgICByZXR1cm4gcmVmbGVjdG9yLmhhc0xpZmVjeWNsZUhvb2sodG9rZW4sIGdldEhvb2tOYW1lKGhvb2spKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRIb29rTmFtZShob29rKSB7XG4gICAgICBzd2l0Y2ggKGhvb2spIHtcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uSW5pdDpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ09uSW5pdCc7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3k6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdPbkRlc3Ryb3knO1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuRG9DaGVjazpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ0RvQ2hlY2snO1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzOlxuICAgICAgICAgICAgICByZXR1cm4gJ25nT25DaGFuZ2VzJztcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQ6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdBZnRlckNvbnRlbnRJbml0JztcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQ6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdBZnRlckNvbnRlbnRDaGVja2VkJztcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdBZnRlclZpZXdJbml0JztcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQ6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdBZnRlclZpZXdDaGVja2VkJztcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc05nTW9kdWxlTWV0YWRhdGEob2JqKSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgdHlwZXMgdG8ge0BsaW5rIE5nTW9kdWxlfS5cbiAgICovXG4gIHZhciBOZ01vZHVsZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IHJlZmxlY3RvcjsgfVxuICAgICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICB9XG4gICAgICBOZ01vZHVsZVJlc29sdmVyLnByb3RvdHlwZS5pc05nTW9kdWxlID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKS5zb21lKF9pc05nTW9kdWxlTWV0YWRhdGEpOyB9O1xuICAgICAgTmdNb2R1bGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIHZhciBuZ01vZHVsZU1ldGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSkuZmluZChfaXNOZ01vZHVsZU1ldGFkYXRhKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG5nTW9kdWxlTWV0YSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5nTW9kdWxlTWV0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5nTW9kdWxlIG1ldGFkYXRhIGZvdW5kIGZvciAnXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBOZ01vZHVsZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIE5nTW9kdWxlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIE5nTW9kdWxlUmVzb2x2ZXI7XG4gIH0oKSk7XG5cbiAgZnVuY3Rpb24gX2lzUGlwZU1ldGFkYXRhKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5QaXBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7QGxpbmsgUGlwZX0uXG4gICAqXG4gICAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAgICpcbiAgICogU2VlIHtAbGluayBDb21waWxlcn1cbiAgICovXG4gIHZhciBQaXBlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGlwZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSByZWZsZWN0b3I7IH1cbiAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgfVxuICAgICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5pc1BpcGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMoX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuIHR5cGVNZXRhZGF0YSAmJiB0eXBlTWV0YWRhdGEuc29tZShfaXNQaXBlTWV0YWRhdGEpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHtAbGluayBQaXBlfSBmb3IgYSBnaXZlbiBgVHlwZWAuXG4gICAgICAgKi9cbiAgICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIHZhciBtZXRhcyA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG1ldGFzKSkge1xuICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IG1ldGFzLmZpbmQoX2lzUGlwZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBQaXBlIGRlY29yYXRvciBmb3VuZCBvbiBcIiArIHN0cmluZ2lmeSh0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFBpcGVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBQaXBlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFBpcGVSZXNvbHZlcjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIC8vIERlc2lnbiBub3RlczpcbiAgLy8gLSBkb24ndCBsYXppbHkgY3JlYXRlIG1ldGFkYXRhOlxuICAvLyAgIEZvciBzb21lIG1ldGFkYXRhLCB3ZSBuZWVkIHRvIGRvIGFzeW5jIHdvcmsgc29tZXRpbWVzLFxuICAvLyAgIHNvIHRoZSB1c2VyIGhhcyB0byBraWNrIG9mZiB0aGlzIGxvYWRpbmcuXG4gIC8vICAgQnV0IHdlIHdhbnQgdG8gcmVwb3J0IGVycm9ycyBldmVuIHdoZW4gdGhlIGFzeW5jIHdvcmsgaXNcbiAgLy8gICBub3QgcmVxdWlyZWQgdG8gY2hlY2sgdGhhdCB0aGUgdXNlciB3b3VsZCBoYXZlIGJlZW4gYWJsZVxuICAvLyAgIHRvIHdhaXQgY29ycmVjdGx5LlxuICB2YXIgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoX25nTW9kdWxlUmVzb2x2ZXIsIF9kaXJlY3RpdmVSZXNvbHZlciwgX3BpcGVSZXNvbHZlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfZGlyZWN0aXZlTm9ybWFsaXplciwgX3JlZmxlY3Rvcikge1xuICAgICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IHJlZmxlY3RvcjsgfVxuICAgICAgICAgIHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIgPSBfbmdNb2R1bGVSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciA9IF9kaXJlY3RpdmVSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9waXBlUmVzb2x2ZXIgPSBfcGlwZVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIgPSBfZGlyZWN0aXZlTm9ybWFsaXplcjtcbiAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZVN1bW1hcnlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9waXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fcGlwZVN1bW1hcnlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hbm9ueW1vdXNUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hbm9ueW1vdXNUeXBlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLnNhbml0aXplVG9rZW5OYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBzdHJpbmdpZnkodG9rZW4pO1xuICAgICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGNhc2U6IGFub255bW91cyBmdW5jdGlvbnMhXG4gICAgICAgICAgICAgIHZhciBmb3VuZCA9IHRoaXMuX2Fub255bW91c1R5cGVzLmdldCh0b2tlbik7XG4gICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Fub255bW91c1R5cGVzLnNldCh0b2tlbiwgdGhpcy5fYW5vbnltb3VzVHlwZUluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLl9hbm9ueW1vdXNUeXBlcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcImFub255bW91c190b2tlbl9cIiArIGZvdW5kICsgXCJfXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHZhciBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVTdW1tYXJ5Q2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICAgIHRoaXMuX3BpcGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdGhpcy5fcGlwZVN1bW1hcnlDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICAvLyBDbGVhciBhbGwgb2YgdGhlIE5nTW9kdWxlIGFzIHRoZXkgY29udGFpbiB0cmFuc2l0aXZlIGluZm9ybWF0aW9uIVxuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICBpZiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLmNsZWFyQ2FjaGVGb3IoZGlyTWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlU3VtbWFyeUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5fcGlwZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5fcGlwZVN1bW1hcnlDYWNoZS5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRW50cnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGRlZnMgPSBlbnRyeS5kZWZpbml0aW9ucy5tYXAoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gX3RoaXMuX2dldEFuaW1hdGlvblN0YXRlTWV0YWRhdGEoZGVmKTsgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YShlbnRyeS5uYW1lLCBkZWZzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5fZ2V0QW5pbWF0aW9uU3R5bGVNZXRhZGF0YSh2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEodmFsdWUuc3RhdGVOYW1lRXhwciwgc3R5bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSh2YWx1ZS5zdGF0ZUNoYW5nZUV4cHIsIHRoaXMuX2dldEFuaW1hdGlvbk1ldGFkYXRhKHZhbHVlLnN0ZXBzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0QW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEodmFsdWUub2Zmc2V0LCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0QW5pbWF0aW9uTWV0YWRhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbWF0aW9uU3R5bGVNZXRhZGF0YSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHZhbHVlLnN0ZXBzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIF90aGlzLl9nZXRBbmltYXRpb25TdHlsZU1ldGFkYXRhKGVudHJ5KTsgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICB2YXIgYW5pbWF0ZURhdGEgPSB0aGlzXG4gICAgICAgICAgICAgICAgICAuX2dldEFuaW1hdGlvbk1ldGFkYXRhKHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh2YWx1ZS50aW1pbmdzLCBhbmltYXRlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gdmFsdWUuc3RlcHMubWFwKGZ1bmN0aW9uIChzdGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0QW5pbWF0aW9uTWV0YWRhdGEoc3RlcCk7IH0pO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvbkdyb3VwTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoc3RlcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2xvYWREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh0aGlzLl9kaXJlY3RpdmVDYWNoZS5oYXMoZGlyZWN0aXZlVHlwZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXJlY3RpdmVUeXBlID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZihkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgaWYgKCFkaXJNZXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbW9kdWxlVXJsID0gc3RhdGljVHlwZU1vZHVsZVVybChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICB2YXIgY3JlYXRlRGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAodGVtcGxhdGVNZXRhKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciB2aWV3UHJvdmlkZXJzID0gW107XG4gICAgICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gW107XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGRpck1ldGEuc2VsZWN0b3I7XG4gICAgICAgICAgICAgIGlmIChkaXJNZXRhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBkaXJNZXRhLmNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLnZpZXdQcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzID0gX3RoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKGRpck1ldGEudmlld1Byb3ZpZGVycywgZW50cnlDb21wb25lbnRNZXRhZGF0YSwgXCJ2aWV3UHJvdmlkZXJzIGZvciBcXFwiXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudE1ldGFkYXRhID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KGRpck1ldGEuZW50cnlDb21wb25lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YSh0eXBlLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHR5cGUpKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZW50cnlDb21wb25lbnRNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBfdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBEaXJlY3RpdmVcbiAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIiBoYXMgbm8gc2VsZWN0b3IsIHBsZWFzZSBhZGQgaXQhXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJNZXRhLnByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVycyA9IF90aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShkaXJNZXRhLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRNZXRhZGF0YSwgXCJwcm92aWRlcnMgZm9yIFxcXCJcIiArIHN0cmluZ2lmeShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcXVlcmllcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgdmlld1F1ZXJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJNZXRhLnF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgICBxdWVyaWVzID0gX3RoaXMuX2dldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIGZhbHNlLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgIHZpZXdRdWVyaWVzID0gX3RoaXMuX2dldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIHRydWUsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICBleHBvcnRBczogZGlyTWV0YS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICAgIGlzQ29tcG9uZW50OiAhIXRlbXBsYXRlTWV0YSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLl9nZXRUeXBlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSwgbW9kdWxlVXJsKSxcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGEsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgaW5wdXRzOiBkaXJNZXRhLmlucHV0cyxcbiAgICAgICAgICAgICAgICAgIG91dHB1dHM6IGRpck1ldGEub3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgIGhvc3Q6IGRpck1ldGEuaG9zdCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50TWV0YWRhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF90aGlzLl9kaXJlY3RpdmVDYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgbWV0YSk7XG4gICAgICAgICAgICAgIF90aGlzLl9kaXJlY3RpdmVTdW1tYXJ5Q2FjaGUuc2V0KGRpcmVjdGl2ZVR5cGUsIG1ldGEudG9TdW1tYXJ5KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkaXJNZXRhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgIG1vZHVsZVVybCA9IGNvbXBvbmVudE1vZHVsZVVybCh0aGlzLl9yZWZsZWN0b3IsIGRpcmVjdGl2ZVR5cGUsIGRpck1ldGEpO1xuICAgICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVzJywgZGlyTWV0YS5zdHlsZXMpO1xuICAgICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVVcmxzJywgZGlyTWV0YS5zdHlsZVVybHMpO1xuICAgICAgICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIGRpck1ldGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICAgIHZhciBhbmltYXRpb25zID0gZGlyTWV0YS5hbmltYXRpb25zID9cbiAgICAgICAgICAgICAgICAgIGRpck1ldGEuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmdldEFuaW1hdGlvbkVudHJ5TWV0YWRhdGEoZSk7IH0pIDpcbiAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU1ldGEgPSB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLm5vcm1hbGl6ZVRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGRpcmVjdGl2ZVR5cGUsXG4gICAgICAgICAgICAgICAgICBtb2R1bGVVcmw6IG1vZHVsZVVybCxcbiAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGRpck1ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkaXJNZXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IGRpck1ldGEudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICBzdHlsZXM6IGRpck1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBkaXJNZXRhLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBkaXJNZXRhLmludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZU1ldGEuc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlRGlyZWN0aXZlTWV0YWRhdGEodGVtcGxhdGVNZXRhLnN5bmNSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlTWV0YS5hc3luY1Jlc3VsdC50aGVuKGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZGlyZWN0aXZlXG4gICAgICAgICAgICAgIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhKG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIGRpcmVjdGl2ZS5cbiAgICAgICAqIFRoaXMgYXNzdW1lcyBgbG9hZE5nTW9kdWxlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgICAqL1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmdldChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICBpZiAoIWRpck1ldGEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogZ2V0RGlyZWN0aXZlTWV0YWRhdGEgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGxvYWROZ01vZHVsZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBEaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXJNZXRhO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREaXJlY3RpdmVTdW1tYXJ5ID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgICB2YXIgZGlyU3VtbWFyeSA9IHRoaXMuX2RpcmVjdGl2ZVN1bW1hcnlDYWNoZS5nZXQoZGlyVHlwZSk7XG4gICAgICAgICAgaWYgKCFkaXJTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldERpcmVjdGl2ZVN1bW1hcnkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGxvYWROZ01vZHVsZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGltcG9ydHMgaXQuIERpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeShkaXJUeXBlKSArIFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpclN1bW1hcnk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzRGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKHR5cGUpOyB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzUGlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLl9waXBlUmVzb2x2ZXIuaXNQaXBlKHR5cGUpOyB9O1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIG1vZHVsZS5cbiAgICAgICAqIFRoaXMgYXNzdW1lcyBgbG9hZE5nTW9kdWxlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgICAqL1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5nTW9kdWxlTWV0YWRhdGEgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHZhciBtb2RNZXRhID0gdGhpcy5fbmdNb2R1bGVDYWNoZS5nZXQobW9kdWxlVHlwZSk7XG4gICAgICAgICAgaWYgKCFtb2RNZXRhKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldE5nTW9kdWxlTWV0YWRhdGEgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGxvYWROZ01vZHVsZU1ldGFkYXRhLiBNb2R1bGUgXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtb2RNZXRhO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZE5nTW9kdWxlU3VtbWFyeSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgICAvLyBUT0RPKHRib3NjaCk6IGFkZCBsb2dpYyB0byByZWFkIHN1bW1hcnkgZmlsZXMhXG4gICAgICAgICAgLy8gLSBuZWVkcyB0byBhZGQgZGlyZWN0aXZlIC8gcGlwZSBzdW1tYXJpZXMgdG8gdGhpcy5fZGlyZWN0aXZlU3VtbWFyeUNhY2hlIC9cbiAgICAgICAgICAvLyB0aGlzLl9waXBlU3VtbWFyeUNhY2hlIGFzIHdlbGwhXG4gICAgICAgICAgdmFyIG1vZHVsZU1ldGEgPSB0aGlzLl9sb2FkTmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlLCBpc1N5bmMsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm4gbW9kdWxlTWV0YSA/IG1vZHVsZU1ldGEudG9TdW1tYXJ5KCkgOiBudWxsO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogTG9hZHMgYW4gTmdNb2R1bGUgYW5kIGFsbCBvZiBpdHMgZGlyZWN0aXZlcy4gVGhpcyBpbmNsdWRlcyBsb2FkaW5nIHRoZSBleHBvcnRlZCBkaXJlY3RpdmVzIG9mXG4gICAgICAgKiBpbXBvcnRlZCBtb2R1bGVzLFxuICAgICAgICogYnV0IG5vdCBwcml2YXRlIGRpcmVjdGl2ZXMgb2YgaW1wb3J0ZWQgbW9kdWxlcy5cbiAgICAgICAqL1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmxvYWROZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYywgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgICB2YXIgbmdNb2R1bGUgPSB0aGlzLl9sb2FkTmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlLCBpc1N5bmMsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgICAgdmFyIGxvYWRpbmcgPSBuZ01vZHVsZSA/IFByb21pc2UuYWxsKG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubG9hZGluZ1Byb21pc2VzKSA6IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICByZXR1cm4geyBuZ01vZHVsZTogbmdNb2R1bGUsIGxvYWRpbmc6IGxvYWRpbmcgfTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2xvYWROZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYywgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIG1vZHVsZVR5cGUgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBjb21waWxlTWV0YSA9IHRoaXMuX25nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICAgIGlmIChjb21waWxlTWV0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZU1ldGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZXRhID0gdGhpcy5fbmdNb2R1bGVSZXNvbHZlci5yZXNvbHZlKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVjbGFyZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgICAgdmFyIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgICB2YXIgZGVjbGFyZWRQaXBlcyA9IFtdO1xuICAgICAgICAgIHZhciBpbXBvcnRlZE1vZHVsZXMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwb3J0ZWRNb2R1bGVzID0gW107XG4gICAgICAgICAgdmFyIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICB2YXIgYm9vdHN0cmFwQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIHZhciBzY2hlbWFzID0gW107XG4gICAgICAgICAgaWYgKG1ldGEuaW1wb3J0cykge1xuICAgICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5pbXBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbXBvcnRlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRlZE1vZHVsZVR5cGU7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFR5cGUoaW1wb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGltcG9ydGVkVHlwZSAmJiBpbXBvcnRlZFR5cGUubmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlV2l0aFByb3ZpZGVycyA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZVR5cGUgPSBtb2R1bGVXaXRoUHJvdmlkZXJzLm5nTW9kdWxlO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaC5hcHBseShwcm92aWRlcnMsIF90aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRzLCBcInByb3ZpZGVyIGZvciB0aGUgTmdNb2R1bGUgJ1wiICsgc3RyaW5naWZ5KGltcG9ydGVkTW9kdWxlVHlwZSkgKyBcIidcIikpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlZE1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWRNb2R1bGVTdW1tYXJ5ID0gX3RoaXMuX2xvYWROZ01vZHVsZVN1bW1hcnkoaW1wb3J0ZWRNb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0ZWRNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoaW1wb3J0ZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeShpbXBvcnRlZFR5cGUpICsgXCInIGltcG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZXMucHVzaChpbXBvcnRlZE1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnkoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXRhLmV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZXhwb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGV4cG9ydGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeShleHBvcnRlZFR5cGUpICsgXCInIGV4cG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkTW9kdWxlU3VtbWFyeSA9IF90aGlzLl9sb2FkTmdNb2R1bGVTdW1tYXJ5KGV4cG9ydGVkVHlwZSwgaXNTeW5jKTtcbiAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRlZE1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZE1vZHVsZXMucHVzaChleHBvcnRlZE1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5wdXNoKF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEoZXhwb3J0ZWRUeXBlLCBzdGF0aWNUeXBlTW9kdWxlVXJsKGV4cG9ydGVkVHlwZSkpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGU6IFRoaXMgd2lsbCBiZSBtb2RpZmllZCBsYXRlciwgc28gd2UgcmVseSBvblxuICAgICAgICAgIC8vIGdldHRpbmcgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSFcbiAgICAgICAgICB2YXIgdHJhbnNpdGl2ZU1vZHVsZSA9IHRoaXMuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgICBpZiAobWV0YS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZGVjbGFyYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5KGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyZWRJZGVudGlmaWVyID0gX3RoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YShkZWNsYXJlZFR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwoZGVjbGFyZWRUeXBlKSk7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXNTZXQuYWRkKGRlY2xhcmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzLnB1c2goZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlZERpcmVjdGl2ZXMucHVzaChkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRUeXBlVG9Nb2R1bGUoZGVjbGFyZWRUeXBlLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGluZ1Byb21pc2UgPSBfdGhpcy5fbG9hZERpcmVjdGl2ZU1ldGFkYXRhKGRlY2xhcmVkVHlwZSwgaXNTeW5jKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5sb2FkaW5nUHJvbWlzZXMucHVzaChsb2FkaW5nUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuX3BpcGVSZXNvbHZlci5pc1BpcGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUucGlwZXNTZXQuYWRkKGRlY2xhcmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgICAgZGVjbGFyZWRQaXBlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFR5cGVUb01vZHVsZShkZWNsYXJlZFR5cGUsIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2FkUGlwZU1ldGFkYXRhKGRlY2xhcmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGRlY2xhcmVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnkoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBleHBvcnRlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwb3J0ZWRQaXBlcyA9IFtdO1xuICAgICAgICAgIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWRJZCkge1xuICAgICAgICAgICAgICBpZiAodHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmhhcyhleHBvcnRlZElkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlcy5wdXNoKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zaXRpdmVNb2R1bGUucGlwZXNTZXQuaGFzKGV4cG9ydGVkSWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlcy5wdXNoKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZXhwb3J0IFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGV4cG9ydGVkSWQucmVmZXJlbmNlKSArIFwiIFwiICsgc3RyaW5naWZ5KGV4cG9ydGVkSWQucmVmZXJlbmNlKSArIFwiIGZyb20gXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIiBhcyBpdCB3YXMgbmVpdGhlciBkZWNsYXJlZCBub3IgaW1wb3J0ZWQhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gVGhlIHByb3ZpZGVycyBvZiB0aGUgbW9kdWxlIGhhdmUgdG8gZ28gbGFzdFxuICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSBvdmVyd3JpdGUgYW55IG90aGVyIHByb3ZpZGVyIHdlIGFscmVhZHkgYWRkZWQuXG4gICAgICAgICAgaWYgKG1ldGEucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoLmFwcGx5KHByb3ZpZGVycywgdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEobWV0YS5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50cywgXCJwcm92aWRlciBmb3IgdGhlIE5nTW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXRhLmVudHJ5Q29tcG9uZW50cykge1xuICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHMucHVzaC5hcHBseShlbnRyeUNvbXBvbmVudHMsIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmVudHJ5Q29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRUeXBlTWV0YWRhdGEodHlwZSwgc3RhdGljVHlwZU1vZHVsZVVybCh0eXBlKSk7IH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ldGEuYm9vdHN0cmFwKSB7XG4gICAgICAgICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5ib290c3RyYXApLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5KHR5cGUpICsgXCInIHVzZWQgaW4gdGhlIGJvb3RzdHJhcCBwcm9wZXJ0eSBvZiBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRUeXBlTWV0YWRhdGEodHlwZSwgc3RhdGljVHlwZU1vZHVsZVVybCh0eXBlKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRzLnB1c2guYXBwbHkoYm9vdHN0cmFwQ29tcG9uZW50cywgdHlwZU1ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzKTtcbiAgICAgICAgICBpZiAobWV0YS5zY2hlbWFzKSB7XG4gICAgICAgICAgICAgIHNjaGVtYXMucHVzaC5hcHBseShzY2hlbWFzLCBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5zY2hlbWFzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIChfYSA9IHRyYW5zaXRpdmVNb2R1bGUuZW50cnlDb21wb25lbnRzKS5wdXNoLmFwcGx5KF9hLCBlbnRyeUNvbXBvbmVudHMpO1xuICAgICAgICAgIChfYiA9IHRyYW5zaXRpdmVNb2R1bGUucHJvdmlkZXJzKS5wdXNoLmFwcGx5KF9iLCBwcm92aWRlcnMpO1xuICAgICAgICAgIGNvbXBpbGVNZXRhID0gbmV3IENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKG1vZHVsZVR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwobW9kdWxlVHlwZSkpLFxuICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHM6IGJvb3RzdHJhcENvbXBvbmVudHMsXG4gICAgICAgICAgICAgIHNjaGVtYXM6IHNjaGVtYXMsXG4gICAgICAgICAgICAgIGRlY2xhcmVkRGlyZWN0aXZlczogZGVjbGFyZWREaXJlY3RpdmVzLFxuICAgICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXM6IGV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgICAgZGVjbGFyZWRQaXBlczogZGVjbGFyZWRQaXBlcyxcbiAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlczogZXhwb3J0ZWRQaXBlcyxcbiAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVzOiBpbXBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICAgIGV4cG9ydGVkTW9kdWxlczogZXhwb3J0ZWRNb2R1bGVzLFxuICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlOiB0cmFuc2l0aXZlTW9kdWxlLFxuICAgICAgICAgICAgICBpZDogbWV0YS5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMucHVzaChjb21waWxlTWV0YS50b0luamVjdG9yU3VtbWFyeSgpKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLnNldChtb2R1bGVUeXBlLCBjb21waWxlTWV0YSk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVNZXRhO1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUeXBlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnZGlyZWN0aXZlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BpcGVSZXNvbHZlci5pc1BpcGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdwaXBlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIuaXNOZ01vZHVsZSh0eXBlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ21vZHVsZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlLnByb3ZpZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdwcm92aWRlcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAndmFsdWUnO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fYWRkVHlwZVRvTW9kdWxlID0gZnVuY3Rpb24gKHR5cGUsIG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICB2YXIgb2xkTW9kdWxlID0gdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgICBpZiAob2xkTW9kdWxlICYmIG9sZE1vZHVsZSAhPT0gbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVHlwZSBcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiIGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IFwiICsgc3RyaW5naWZ5KG9sZE1vZHVsZSkgKyBcIiBhbmQgXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIiEgXCIpICtcbiAgICAgICAgICAgICAgICAgIChcIlBsZWFzZSBjb25zaWRlciBtb3ZpbmcgXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIiB0byBhIGhpZ2hlciBtb2R1bGUgdGhhdCBpbXBvcnRzIFwiICsgc3RyaW5naWZ5KG9sZE1vZHVsZSkgKyBcIiBhbmQgXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIi4gXCIpICtcbiAgICAgICAgICAgICAgICAgIChcIllvdSBjYW4gYWxzbyBjcmVhdGUgYSBuZXcgTmdNb2R1bGUgdGhhdCBleHBvcnRzIGFuZCBpbmNsdWRlcyBcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiIHRoZW4gaW1wb3J0IHRoYXQgTmdNb2R1bGUgaW4gXCIgKyBzdHJpbmdpZnkob2xkTW9kdWxlKSArIFwiIGFuZCBcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5zZXQodHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUcmFuc2l0aXZlTmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChpbXBvcnRlZE1vZHVsZXMsIGV4cG9ydGVkTW9kdWxlcykge1xuICAgICAgICAgIC8vIGNvbGxlY3QgYHByb3ZpZGVyc2AgLyBgZW50cnlDb21wb25lbnRzYCBmcm9tIGFsbCBpbXBvcnRlZCBhbmQgYWxsIGV4cG9ydGVkIG1vZHVsZXNcbiAgICAgICAgICB2YXIgdHJhbnNpdGl2ZU1vZHVsZXMgPSBnZXRUcmFuc2l0aXZlSW1wb3J0ZWRNb2R1bGVzKGltcG9ydGVkTW9kdWxlcy5jb25jYXQoZXhwb3J0ZWRNb2R1bGVzKSk7XG4gICAgICAgICAgdmFyIHByb3ZpZGVycyA9IGZsYXR0ZW5BcnJheSh0cmFuc2l0aXZlTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBuZ01vZHVsZS5wcm92aWRlcnM7IH0pKTtcbiAgICAgICAgICB2YXIgZW50cnlDb21wb25lbnRzID0gZmxhdHRlbkFycmF5KHRyYW5zaXRpdmVNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlLmVudHJ5Q29tcG9uZW50czsgfSkpO1xuICAgICAgICAgIHZhciB0cmFuc2l0aXZlRXhwb3J0ZWRNb2R1bGVzID0gZ2V0VHJhbnNpdGl2ZUV4cG9ydGVkTW9kdWxlcyhpbXBvcnRlZE1vZHVsZXMpO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gZmxhdHRlbkFycmF5KHRyYW5zaXRpdmVFeHBvcnRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gbmdNb2R1bGUuZXhwb3J0ZWREaXJlY3RpdmVzOyB9KSk7XG4gICAgICAgICAgdmFyIHBpcGVzID0gZmxhdHRlbkFycmF5KHRyYW5zaXRpdmVFeHBvcnRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gbmdNb2R1bGUuZXhwb3J0ZWRQaXBlczsgfSkpO1xuICAgICAgICAgIHZhciBsb2FkaW5nUHJvbWlzZXMgPSBMaXN0V3JhcHBlci5mbGF0dGVuKHRyYW5zaXRpdmVFeHBvcnRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gbmdNb2R1bGUubG9hZGluZ1Byb21pc2VzOyB9KSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEodHJhbnNpdGl2ZU1vZHVsZXMsIHByb3ZpZGVycywgZW50cnlDb21wb25lbnRzLCBkaXJlY3RpdmVzLCBwaXBlcywgbG9hZGluZ1Byb21pc2VzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldElkZW50aWZpZXJNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlLCBtb2R1bGVVcmwpIHtcbiAgICAgICAgICB0eXBlID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiB0aGlzLnNhbml0aXplVG9rZW5OYW1lKHR5cGUpLCBtb2R1bGVVcmw6IG1vZHVsZVVybCwgcmVmZXJlbmNlOiB0eXBlIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIG1vZHVsZVVybCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YSh0eXBlLCBtb2R1bGVVcmwpO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIG5hbWU6IGlkZW50aWZpZXIubmFtZSxcbiAgICAgICAgICAgICAgbW9kdWxlVXJsOiBpZGVudGlmaWVyLm1vZHVsZVVybCxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlOiBpZGVudGlmaWVyLnJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgZGlEZXBzOiB0aGlzLl9nZXREZXBlbmRlbmNpZXNNZXRhZGF0YShpZGVudGlmaWVyLnJlZmVyZW5jZSwgZGVwZW5kZW5jaWVzKSxcbiAgICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU19WQUxVRVMuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBoYXNMaWZlY3ljbGVIb29rKGhvb2ssIGlkZW50aWZpZXIucmVmZXJlbmNlKTsgfSksXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRGYWN0b3J5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbW9kdWxlVXJsLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICAgIGZhY3RvcnkgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKGZhY3RvcnkpO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMuc2FuaXRpemVUb2tlbk5hbWUoZmFjdG9yeSksXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogbW9kdWxlVXJsLFxuICAgICAgICAgICAgICByZWZlcmVuY2U6IGZhY3RvcnksXG4gICAgICAgICAgICAgIGRpRGVwczogdGhpcy5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEoZmFjdG9yeSwgZGVwZW5kZW5jaWVzKVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBwaXBlLlxuICAgICAgICogVGhpcyBhc3N1bWVzIGBsb2FkTmdNb2R1bGVNZXRhZGF0YWAgaGFzIGJlZW4gY2FsbGVkIGZpcnN0LlxuICAgICAgICovXG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgICAgdmFyIHBpcGVNZXRhID0gdGhpcy5fcGlwZUNhY2hlLmdldChwaXBlVHlwZSk7XG4gICAgICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBnZXRQaXBlTWV0YWRhdGEgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGxvYWROZ01vZHVsZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBQaXBlIFwiICsgc3RyaW5naWZ5KHBpcGVUeXBlKSArIFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBpcGVNZXRhO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQaXBlU3VtbWFyeSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICAgIHZhciBwaXBlU3VtbWFyeSA9IHRoaXMuX3BpcGVTdW1tYXJ5Q2FjaGUuZ2V0KHBpcGVUeXBlKTtcbiAgICAgICAgICBpZiAoIXBpcGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldFBpcGVTdW1tYXJ5IGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBsb2FkTmdNb2R1bGVNZXRhZGF0YSBmb3IgYSBtb2R1bGUgdGhhdCBpbXBvcnRzIGl0LiBQaXBlIFwiICsgc3RyaW5naWZ5KHBpcGVUeXBlKSArIFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBpcGVTdW1tYXJ5O1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICAgIHBpcGVUeXBlID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZihwaXBlVHlwZSk7XG4gICAgICAgICAgdmFyIHBpcGVNZXRhID0gdGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUocGlwZVR5cGUpO1xuICAgICAgICAgIGlmICghcGlwZU1ldGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZXRhID0gbmV3IENvbXBpbGVQaXBlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEocGlwZVR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwocGlwZVR5cGUpKSxcbiAgICAgICAgICAgICAgbmFtZTogcGlwZU1ldGEubmFtZSxcbiAgICAgICAgICAgICAgcHVyZTogcGlwZU1ldGEucHVyZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX3BpcGVDYWNoZS5zZXQocGlwZVR5cGUsIG1ldGEpO1xuICAgICAgICAgIHRoaXMuX3BpcGVTdW1tYXJ5Q2FjaGUuc2V0KHBpcGVUeXBlLCBtZXRhLnRvU3VtbWFyeSgpKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldERlcGVuZGVuY2llc01ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGhhc1Vua25vd25EZXBzID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHBhcmFtcyA9IGRlcGVuZGVuY2llcyB8fCB0aGlzLl9yZWZsZWN0b3IucGFyYW1ldGVycyh0eXBlT3JGdW5jKSB8fCBbXTtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICB2YXIgaXNBdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIGlzSG9zdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgaXNTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBpc1NraXBTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciB0b2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgcGFyYW0uZm9yRWFjaChmdW5jdGlvbiAocGFyYW1FbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTa2lwU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZFR5cGUocGFyYW1FbnRyeSkgJiYgaXNCbGFuayh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNCbGFuayh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgIGhhc1Vua25vd25EZXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlOiBpc0F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgIGlzSG9zdDogaXNIb3N0LFxuICAgICAgICAgICAgICAgICAgaXNTZWxmOiBpc1NlbGYsXG4gICAgICAgICAgICAgICAgICBpc1NraXBTZWxmOiBpc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgICAgaXNPcHRpb25hbDogaXNPcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgIHRva2VuOiBfdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YSh0b2tlbilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGhhc1Vua25vd25EZXBzKSB7XG4gICAgICAgICAgICAgIHZhciBkZXBzVG9rZW5zID0gZGVwZW5kZW5jaWVzTWV0YWRhdGEubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGRlcCA/IHN0cmluZ2lmeShkZXAudG9rZW4pIDogJz8nOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZXNvbHZlIGFsbCBwYXJhbWV0ZXJzIGZvciBcIiArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArIFwiOiAoXCIgKyBkZXBzVG9rZW5zICsgXCIpLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llc01ldGFkYXRhO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VG9rZW5NZXRhZGF0YSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHRva2VuID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XG4gICAgICAgICAgdmFyIGNvbXBpbGVUb2tlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb21waWxlVG9rZW4gPSBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogdG9rZW4gfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb21waWxlVG9rZW4gPSBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5zYW5pdGl6ZVRva2VuTmFtZSh0b2tlbiksXG4gICAgICAgICAgICAgICAgICAgICAgbW9kdWxlVXJsOiBzdGF0aWNUeXBlTW9kdWxlVXJsKHRva2VuKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21waWxlVG9rZW47XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRQcm92aWRlcnNNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29tcGlsZVByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlciwgcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PSAnb2JqZWN0JyAmJiBwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgncHJvdmlkZScpKSB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlciA9IG5ldyBQcm92aWRlck1ldGEocHJvdmlkZXIucHJvdmlkZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb21waWxlUHJvdmlkZXI7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVyID0gX3RoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKHByb3ZpZGVyLCB0YXJnZXRFbnRyeUNvbXBvbmVudHMsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBQcm92aWRlck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0b2tlbk1ldGEgPSBfdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci50b2tlbik7XG4gICAgICAgICAgICAgICAgICBpZiAodG9rZW5NZXRhLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMpLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KHRhcmdldEVudHJ5Q29tcG9uZW50cywgX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlcihwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVyID0gX3RoaXMuZ2V0UHJvdmlkZXJNZXRhZGF0YShwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZFR5cGUocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICBjb21waWxlUHJvdmlkZXIgPSBfdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKHByb3ZpZGVyLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJzSW5mbyA9IHByb3ZpZGVycy5yZWR1Y2UoZnVuY3Rpb24gKHNvRmFyLCBzZWVuUHJvdmlkZXIsIHNlZW5Qcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUHJvdmlkZXJJZHggPCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiXCIgKyBzdHJpbmdpZnkoc2VlblByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiP1wiICsgc3RyaW5naWZ5KHNlZW5Qcm92aWRlcikgKyBcIj9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb0ZhcjtcbiAgICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBcIiArIChkZWJ1Z0luZm8gPyBkZWJ1Z0luZm8gOiAncHJvdmlkZXInKSArIFwiIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogW1wiICsgcHJvdmlkZXJzSW5mbyArIFwiXVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29tcGlsZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICBjb21waWxlUHJvdmlkZXJzLnB1c2goY29tcGlsZVByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBjb21waWxlUHJvdmlkZXJzO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RW50cnlDb21wb25lbnRzRnJvbVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIHZhciBjb2xsZWN0ZWRJZGVudGlmaWVycyA9IFtdO1xuICAgICAgICAgIGlmIChwcm92aWRlci51c2VGYWN0b3J5IHx8IHByb3ZpZGVyLnVzZUV4aXN0aW5nIHx8IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgdXNlVmFsdWUhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgJ211bHRpID0gdHJ1ZSchXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb252ZXJ0VG9Db21waWxlVmFsdWUocHJvdmlkZXIudXNlVmFsdWUsIGNvbGxlY3RlZElkZW50aWZpZXJzKTtcbiAgICAgICAgICBjb2xsZWN0ZWRJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIuaXNEaXJlY3RpdmUoaWRlbnRpZmllci5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgIHZhciBjb21waWxlRGVwcztcbiAgICAgICAgICB2YXIgY29tcGlsZVR5cGVNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgICAgdmFyIGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSBudWxsO1xuICAgICAgICAgIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICBjb21waWxlVHlwZU1ldGFkYXRhID0gdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKHByb3ZpZGVyLnVzZUNsYXNzLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyLnVzZUNsYXNzKSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlVHlwZU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgICBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gdGhpcy5fZ2V0RmFjdG9yeU1ldGFkYXRhKHByb3ZpZGVyLnVzZUZhY3RvcnksIHN0YXRpY1R5cGVNb2R1bGVVcmwocHJvdmlkZXIudXNlRmFjdG9yeSksIHByb3ZpZGVyLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgIGNvbXBpbGVEZXBzID0gY29tcGlsZUZhY3RvcnlNZXRhZGF0YS5kaURlcHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICB0b2tlbjogdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci50b2tlbiksXG4gICAgICAgICAgICAgIHVzZUNsYXNzOiBjb21waWxlVHlwZU1ldGFkYXRhLFxuICAgICAgICAgICAgICB1c2VWYWx1ZTogY29udmVydFRvQ29tcGlsZVZhbHVlKHByb3ZpZGVyLnVzZVZhbHVlLCBbXSksXG4gICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEsXG4gICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBwcm92aWRlci51c2VFeGlzdGluZyA/IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudXNlRXhpc3RpbmcpIDogbnVsbCxcbiAgICAgICAgICAgICAgZGVwczogY29tcGlsZURlcHMsXG4gICAgICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UXVlcmllc01ldGFkYXRhID0gZnVuY3Rpb24gKHF1ZXJpZXMsIGlzVmlld1F1ZXJ5LCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMocXVlcmllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBxdWVyeSA9IHF1ZXJpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmlzVmlld1F1ZXJ5ID09PSBpc1ZpZXdRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgcmVzLnB1c2goX3RoaXMuX2dldFF1ZXJ5TWV0YWRhdGEocXVlcnksIHByb3BlcnR5TmFtZSwgZGlyZWN0aXZlVHlwZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3F1ZXJ5VmFyQmluZGluZ3MgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKTsgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UXVlcnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChxLCBwcm9wZXJ0eU5hbWUsIHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBxLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBzZWxlY3RvcnMgPVxuICAgICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlWYXJCaW5kaW5ncyhxLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHZhck5hbWUpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghcS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29uc3RydWN0IGEgcXVlcnkgZm9yIHRoZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIlxcXCIgb2YgXFxcIlwiICsgc3RyaW5naWZ5KHR5cGVPckZ1bmMpICsgXCJcXFwiIHNpbmNlIHRoZSBxdWVyeSBzZWxlY3RvciB3YXNuJ3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZWN0b3JzID0gW3RoaXMuX2dldFRva2VuTWV0YWRhdGEocS5zZWxlY3RvcildO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVRdWVyeU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICAgIGZpcnN0OiBxLmZpcnN0LFxuICAgICAgICAgICAgICBkZXNjZW5kYW50czogcS5kZXNjZW5kYW50cywgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgIHJlYWQ6IHEucmVhZCA/IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocS5yZWFkKSA6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IE5nTW9kdWxlUmVzb2x2ZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmVSZXNvbHZlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFBpcGVSZXNvbHZlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbiAgICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZU5vcm1hbGl6ZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBnZXRUcmFuc2l0aXZlRXhwb3J0ZWRNb2R1bGVzKG1vZHVsZXMsIHRhcmdldE1vZHVsZXMsIHZpc2l0ZWRNb2R1bGVzKSB7XG4gICAgICBpZiAodGFyZ2V0TW9kdWxlcyA9PT0gdm9pZCAwKSB7IHRhcmdldE1vZHVsZXMgPSBbXTsgfVxuICAgICAgaWYgKHZpc2l0ZWRNb2R1bGVzID09PSB2b2lkIDApIHsgdmlzaXRlZE1vZHVsZXMgPSBuZXcgU2V0KCk7IH1cbiAgICAgIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGUpIHtcbiAgICAgICAgICBpZiAoIXZpc2l0ZWRNb2R1bGVzLmhhcyhuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZE1vZHVsZXMuYWRkKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgZ2V0VHJhbnNpdGl2ZUV4cG9ydGVkTW9kdWxlcyhuZ01vZHVsZS5leHBvcnRlZE1vZHVsZXMsIHRhcmdldE1vZHVsZXMsIHZpc2l0ZWRNb2R1bGVzKTtcbiAgICAgICAgICAgICAgLy8gQWRkIGFmdGVyIHJlY3Vyc2luZyBzbyBpbXBvcnRlZC9leHBvcnRlZCBtb2R1bGVzIGFyZSBiZWZvcmUgdGhlIG1vZHVsZSBpdHNlbGYuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBvdmVyd3JpdGluZyBwcm92aWRlcnMgb2YgaW1wb3J0ZWQgbW9kdWxlcyFcbiAgICAgICAgICAgICAgdGFyZ2V0TW9kdWxlcy5wdXNoKG5nTW9kdWxlKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YXJnZXRNb2R1bGVzO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRyYW5zaXRpdmVJbXBvcnRlZE1vZHVsZXMobW9kdWxlcywgdGFyZ2V0TW9kdWxlcywgdmlzaXRlZE1vZHVsZXMpIHtcbiAgICAgIGlmICh0YXJnZXRNb2R1bGVzID09PSB2b2lkIDApIHsgdGFyZ2V0TW9kdWxlcyA9IFtdOyB9XG4gICAgICBpZiAodmlzaXRlZE1vZHVsZXMgPT09IHZvaWQgMCkgeyB2aXNpdGVkTW9kdWxlcyA9IG5ldyBTZXQoKTsgfVxuICAgICAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkge1xuICAgICAgICAgIGlmICghdmlzaXRlZE1vZHVsZXMuaGFzKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICB2aXNpdGVkTW9kdWxlcy5hZGQobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB2YXIgbmVzdGVkTW9kdWxlcyA9IG5nTW9kdWxlLmltcG9ydGVkTW9kdWxlcy5jb25jYXQobmdNb2R1bGUuZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgICAgICAgZ2V0VHJhbnNpdGl2ZUltcG9ydGVkTW9kdWxlcyhuZXN0ZWRNb2R1bGVzLCB0YXJnZXRNb2R1bGVzLCB2aXNpdGVkTW9kdWxlcyk7XG4gICAgICAgICAgICAgIC8vIEFkZCBhZnRlciByZWN1cnNpbmcgc28gaW1wb3J0ZWQvZXhwb3J0ZWQgbW9kdWxlcyBhcmUgYmVmb3JlIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3Igb3ZlcndyaXRpbmcgcHJvdmlkZXJzIG9mIGltcG9ydGVkIG1vZHVsZXMhXG4gICAgICAgICAgICAgIHRhcmdldE1vZHVsZXMucHVzaChuZ01vZHVsZSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFyZ2V0TW9kdWxlcztcbiAgfVxuICBmdW5jdGlvbiBmbGF0dGVuQXJyYXkodHJlZSwgb3V0KSB7XG4gICAgICBpZiAob3V0ID09PSB2b2lkIDApIHsgb3V0ID0gW107IH1cbiAgICAgIGlmICh0cmVlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0cmVlW2ldKTtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShpdGVtLCBvdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZ1bmN0aW9uIGRlZHVwZUFycmF5KGFycmF5KSB7XG4gICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gIH1cbiAgZnVuY3Rpb24gZmxhdHRlbkFuZERlZHVwZUFycmF5KHRyZWUpIHtcbiAgICAgIHJldHVybiBkZWR1cGVBcnJheShmbGF0dGVuQXJyYXkodHJlZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGlzVmFsaWRUeXBlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNTdGF0aWNTeW1ib2wodmFsdWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuVHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RhdGljVHlwZU1vZHVsZVVybCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzU3RhdGljU3ltYm9sKHZhbHVlKSA/IHZhbHVlLmZpbGVQYXRoIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb21wb25lbnRNb2R1bGVVcmwocmVmbGVjdG9yLCB0eXBlLCBjbXBNZXRhZGF0YSkge1xuICAgICAgaWYgKGlzU3RhdGljU3ltYm9sKHR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRpY1R5cGVNb2R1bGVVcmwodHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgbW9kdWxlSWQgPSBjbXBNZXRhZGF0YS5tb2R1bGVJZDtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHNjaGVtZSA9IGdldFVybFNjaGVtZShtb2R1bGVJZCk7XG4gICAgICAgICAgcmV0dXJuIHNjaGVtZSA/IG1vZHVsZUlkIDogXCJwYWNrYWdlOlwiICsgbW9kdWxlSWQgKyBNT0RVTEVfU1VGRklYO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9kdWxlSWQgIT09IG51bGwgJiYgbW9kdWxlSWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJtb2R1bGVJZCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gXFxcIlwiICsgc3RyaW5naWZ5KHR5cGUpICsgXCJcXFwiLiBTZWUgaHR0cHM6Ly9nb28uZ2wvd0lERGlMIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcblwiKSArXG4gICAgICAgICAgICAgIFwiSWYgeW91J3JlIHVzaW5nIFdlYnBhY2sgeW91IHNob3VsZCBpbmxpbmUgdGhlIHRlbXBsYXRlIGFuZCB0aGUgc3R5bGVzLCBzZWUgaHR0cHM6Ly9nb28uZ2wvWDJKOHpjLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWZsZWN0b3IuaW1wb3J0VXJpKHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRUb0NvbXBpbGVWYWx1ZSh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpLCB0YXJnZXRJZGVudGlmaWVycyk7XG4gIH1cbiAgdmFyIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE3KF9Db21waWxlVmFsdWVDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICBpZiAoaXNTdGF0aWNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IHZhbHVlLm5hbWUsIG1vZHVsZVVybDogdmFsdWUuZmlsZVBhdGgsIHJlZmVyZW5jZTogdmFsdWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZGVudGlmaWVyID0gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyByZWZlcmVuY2U6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRJZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfQ29tcGlsZVZhbHVlQ29udmVydGVyO1xuICB9KFZhbHVlVHJhbnNmb3JtZXIpKTtcblxuICB2YXIgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeShjb21wLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5O1xuICB9KCkpO1xuICB2YXIgTmdNb2R1bGVDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCBuZ01vZHVsZUZhY3RvcnlWYXIsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnlWYXIgPSBuZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmdNb2R1bGVDb21waWxlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgTmdNb2R1bGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVyKCkge1xuICAgICAgfVxuICAgICAgTmdNb2R1bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUZpbGVOYW1lID0gaXNQcmVzZW50KG5nTW9kdWxlTWV0YS50eXBlLm1vZHVsZVVybCkgP1xuICAgICAgICAgICAgICBcImluIE5nTW9kdWxlIFwiICsgbmdNb2R1bGVNZXRhLnR5cGUubmFtZSArIFwiIGluIFwiICsgbmdNb2R1bGVNZXRhLnR5cGUubW9kdWxlVXJsIDpcbiAgICAgICAgICAgICAgXCJpbiBOZ01vZHVsZSBcIiArIG5nTW9kdWxlTWV0YS50eXBlLm5hbWU7XG4gICAgICAgICAgdmFyIHNvdXJjZUZpbGUgPSBuZXcgUGFyc2VTb3VyY2VGaWxlKCcnLCBzb3VyY2VGaWxlTmFtZSk7XG4gICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIG51bGwsIG51bGwsIG51bGwpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCBudWxsLCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgdmFyIGRlcHMgPSBbXTtcbiAgICAgICAgICB2YXIgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzID0gW107XG4gICAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gbmdNb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUuZW50cnlDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoZW50cnlDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiBlbnRyeUNvbXBvbmVudC5uYW1lIH0pO1xuICAgICAgICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmJvb3RzdHJhcENvbXBvbmVudHMuaW5kZXhPZihlbnRyeUNvbXBvbmVudCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlcHMucHVzaChuZXcgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kkMShlbnRyeUNvbXBvbmVudCwgaWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IF9JbmplY3RvckJ1aWxkZXIobmdNb2R1bGVNZXRhLCBlbnRyeUNvbXBvbmVudEZhY3RvcmllcywgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB2YXIgcHJvdmlkZXJQYXJzZXIgPSBuZXcgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyKG5nTW9kdWxlTWV0YSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIHByb3ZpZGVyUGFyc2VyLnBhcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIGJ1aWxkZXIuYWRkUHJvdmlkZXIocHJvdmlkZXIpOyB9KTtcbiAgICAgICAgICB2YXIgaW5qZWN0b3JDbGFzcyA9IGJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgICAgICB2YXIgbmdNb2R1bGVGYWN0b3J5VmFyID0gbmdNb2R1bGVNZXRhLnR5cGUubmFtZSArIFwiTmdGYWN0b3J5XCI7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeVN0bXQgPSB2YXJpYWJsZShuZ01vZHVsZUZhY3RvcnlWYXIpXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW3ZhcmlhYmxlKGluamVjdG9yQ2xhc3MubmFtZSksIGltcG9ydEV4cHIobmdNb2R1bGVNZXRhLnR5cGUpXSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpLCBbaW1wb3J0VHlwZShuZ01vZHVsZU1ldGEudHlwZSldLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgICAgdmFyIHN0bXRzID0gW2luamVjdG9yQ2xhc3MsIG5nTW9kdWxlRmFjdG9yeVN0bXRdO1xuICAgICAgICAgIGlmIChuZ01vZHVsZU1ldGEuaWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJlZ2lzdGVyRmFjdG9yeVN0bXQgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlZ2lzdGVyTW9kdWxlRmFjdG9yeUZuKSlcbiAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW2xpdGVyYWwobmdNb2R1bGVNZXRhLmlkKSwgdmFyaWFibGUobmdNb2R1bGVGYWN0b3J5VmFyKV0pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgICAgIHN0bXRzLnB1c2gocmVnaXN0ZXJGYWN0b3J5U3RtdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTmdNb2R1bGVDb21waWxlUmVzdWx0KHN0bXRzLCBuZ01vZHVsZUZhY3RvcnlWYXIsIGRlcHMpO1xuICAgICAgfTtcbiAgICAgIE5nTW9kdWxlQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgTmdNb2R1bGVDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZXI7XG4gIH0oKSk7XG4gIHZhciBfSW5qZWN0b3JCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9JbmplY3RvckJ1aWxkZXIoX25nTW9kdWxlTWV0YSwgX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzLCBfYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLCBfc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlTWV0YSA9IF9uZ01vZHVsZU1ldGE7XG4gICAgICAgICAgdGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBfZW50cnlDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgICAgdGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzID0gX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcztcbiAgICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLm1ldGhvZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmN0b3JTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2luc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cyA9IFtdO1xuICAgICAgfVxuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkUHJvdmlkZXIgPSBmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLl9nZXRQcm92aWRlclZhbHVlKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfXCIgKyByZXNvbHZlZFByb3ZpZGVyLnRva2VuLm5hbWUgKyBcIl9cIiArIHRoaXMuX2luc3RhbmNlcy5zaXplO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHJlc29sdmVkUHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyLCByZXNvbHZlZFByb3ZpZGVyLmVhZ2VyKTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlci5saWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cy5wdXNoKGluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdG9rZW5zLnB1c2gocmVzb2x2ZWRQcm92aWRlci50b2tlbik7XG4gICAgICAgICAgdGhpcy5faW5zdGFuY2VzLnNldChyZXNvbHZlZFByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGdldE1ldGhvZFN0bXRzID0gdGhpcy5fdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyRXhwciA9IF90aGlzLl9pbnN0YW5jZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSWZTdG10KEluamVjdE1ldGhvZFZhcnMkMS50b2tlbi5pZGVudGljYWwoY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pKSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQocHJvdmlkZXJFeHByKV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBtZXRob2RzID0gW1xuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2NyZWF0ZUludGVybmFsJywgW10sIHRoaXMuX2NyZWF0ZVN0bXRzLmNvbmNhdChuZXcgUmV0dXJuU3RhdGVtZW50KHRoaXMuX2luc3RhbmNlcy5nZXQodGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSkpLCBpbXBvcnRUeXBlKHRoaXMuX25nTW9kdWxlTWV0YS50eXBlKSksXG4gICAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZ2V0SW50ZXJuYWwnLCBbXG4gICAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzJDEudG9rZW4ubmFtZSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMkMS5ub3RGb3VuZFJlc3VsdC5uYW1lLCBEWU5BTUlDX1RZUEUpXG4gICAgICAgICAgICAgIF0sIGdldE1ldGhvZFN0bXRzLmNvbmNhdChbbmV3IFJldHVyblN0YXRlbWVudChJbmplY3RNZXRob2RWYXJzJDEubm90Rm91bmRSZXN1bHQpXSksIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGVzdHJveUludGVybmFsJywgW10sIHRoaXMuX2Rlc3Ryb3lTdG10cyksXG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgcGFyZW50QXJncyA9IFtcbiAgICAgICAgICAgICAgdmFyaWFibGUoSW5qZWN0b3JQcm9wcy5wYXJlbnQubmFtZSksXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IHJldHVybiBpbXBvcnRFeHByKGNvbXBvbmVudEZhY3RvcnkpOyB9KSksXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSkgeyByZXR1cm4gaW1wb3J0RXhwcihjb21wb25lbnRGYWN0b3J5KTsgfSkpXG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgaW5qQ2xhc3NOYW1lID0gdGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUubmFtZSArIFwiSW5qZWN0b3JcIjtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2xhc3NTdG10KHtcbiAgICAgICAgICAgICAgbmFtZTogaW5qQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICBjdG9yUGFyYW1zOiBbbmV3IEZuUGFyYW0oSW5qZWN0b3JQcm9wcy5wYXJlbnQubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpKV0sXG4gICAgICAgICAgICAgIHBhcmVudDogaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUluamVjdG9yKSwgW2ltcG9ydFR5cGUodGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUpXSksXG4gICAgICAgICAgICAgIHBhcmVudEFyZ3M6IHBhcmVudEFyZ3MsXG4gICAgICAgICAgICAgIGJ1aWxkZXJzOiBbeyBtZXRob2RzOiBtZXRob2RzIH0sIHRoaXNdXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2dldFByb3ZpZGVyVmFsdWUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0RGVwZW5kZW5jeShuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgdmFyIGRlcHNFeHByID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwKTsgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcHNFeHByKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXApOyB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpLmluc3RhbnRpYXRlKGRlcHNFeHByLCBpbXBvcnRUeXBlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVByb3ZpZGVyUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIGlzTXVsdGksIGlzRWFnZXIpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcjtcbiAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gbGl0ZXJhbEFycihwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICB0eXBlID0gbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwciA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXTtcbiAgICAgICAgICAgICAgdHlwZSA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXS50eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IERZTkFNSUNfVFlQRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRWFnZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwcm9wTmFtZSwgdHlwZSkpO1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGludGVybmFsRmllbGQgPSBcIl9cIiArIHByb3BOYW1lO1xuICAgICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGludGVybmFsRmllbGQsIHR5cGUpKTtcbiAgICAgICAgICAgICAgLy8gTm90ZTogRXF1YWxzIGlzIGltcG9ydGFudCBmb3IgSlMgc28gdGhhdCBpdCBhbHNvIGNoZWNrcyB0aGUgdW5kZWZpbmVkIGNhc2UhXG4gICAgICAgICAgICAgIHZhciBnZXR0ZXJTdG10cyA9IFtcbiAgICAgICAgICAgICAgICAgIG5ldyBJZlN0bXQoVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuaXNCbGFuaygpLCBbVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpXSksXG4gICAgICAgICAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KFRISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICB0aGlzLmdldHRlcnMucHVzaChuZXcgQ2xhc3NHZXR0ZXIocHJvcE5hbWUsIGdldHRlclN0bXRzLCB0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBUSElTX0VYUFIucHJvcChwcm9wTmFtZSk7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgaWYgKGRlcC5pc1ZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxpdGVyYWwoZGVwLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuICYmXG4gICAgICAgICAgICAgICAgICAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5JbmplY3RvcikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFRISVNfRVhQUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5faW5zdGFuY2VzLmdldChkZXAudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihkZXAudG9rZW4pXTtcbiAgICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzLnB1c2goTlVMTF9FWFBSKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBJbmplY3RvclByb3BzLnBhcmVudC5jYWxsTWV0aG9kKCdnZXQnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0luamVjdG9yQnVpbGRlcjtcbiAgfSgpKTtcbiAgdmFyIEluamVjdG9yUHJvcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0b3JQcm9wcygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdG9yUHJvcHMucGFyZW50ID0gVEhJU19FWFBSLnByb3AoJ3BhcmVudCcpO1xuICAgICAgcmV0dXJuIEluamVjdG9yUHJvcHM7XG4gIH0oKSk7XG4gIHZhciBJbmplY3RNZXRob2RWYXJzJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSB2YXJpYWJsZSgndG9rZW4nKTtcbiAgICAgIEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQgPSB2YXJpYWJsZSgnbm90Rm91bmRSZXN1bHQnKTtcbiAgICAgIHJldHVybiBJbmplY3RNZXRob2RWYXJzO1xuICB9KCkpO1xuXG4gIHZhciBfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUgPSAvJ3xcXFxcfFxcbnxcXHJ8XFwkL2c7XG4gIHZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xuICB2YXIgQ0FUQ0hfRVJST1JfVkFSJDIgPSB2YXJpYWJsZSgnZXJyb3InKTtcbiAgdmFyIENBVENIX1NUQUNLX1ZBUiQyID0gdmFyaWFibGUoJ3N0YWNrJyk7XG4gIHZhciBfRW1pdHRlZExpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0VtaXR0ZWRMaW5lKGluZGVudCkge1xuICAgICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfRW1pdHRlZExpbmU7XG4gIH0oKSk7XG4gIHZhciBFbWl0dGVyVmlzaXRvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRW1pdHRlclZpc2l0b3JDb250ZXh0KF9leHBvcnRlZFZhcnMsIF9pbmRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9leHBvcnRlZFZhcnMgPSBfZXhwb3J0ZWRWYXJzO1xuICAgICAgICAgIHRoaXMuX2luZGVudCA9IF9pbmRlbnQ7XG4gICAgICAgICAgdGhpcy5fY2xhc3NlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgICAgfVxuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbWl0dGVyVmlzaXRvckNvbnRleHQoZXhwb3J0ZWRWYXJzLCAwKTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJfY3VycmVudExpbmVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5pc0V4cG9ydGVkVmFyID0gZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIHRoaXMuX2V4cG9ydGVkVmFycy5pbmRleE9mKHZhck5hbWUpICE9PSAtMTsgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnRsbiA9IGZ1bmN0aW9uIChsYXN0UGFydCkge1xuICAgICAgICAgIGlmIChsYXN0UGFydCA9PT0gdm9pZCAwKSB7IGxhc3RQYXJ0ID0gJyc7IH1cbiAgICAgICAgICB0aGlzLnByaW50KGxhc3RQYXJ0LCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmxpbmVJc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudExpbmUucGFydHMubGVuZ3RoID09PSAwOyB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChwYXJ0LCBuZXdMaW5lKSB7XG4gICAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3IF9FbWl0dGVkTGluZSh0aGlzLl9pbmRlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5yZW1vdmVFbXB0eUxhc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuaW5jSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2luZGVudCsrO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmRlY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9pbmRlbnQtLTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgICB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wdXNoQ2xhc3MgPSBmdW5jdGlvbiAoY2xhenopIHsgdGhpcy5fY2xhc3Nlcy5wdXNoKGNsYXp6KTsgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucG9wQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFzc2VzLnBvcCgpOyB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENsYXNzXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMubGVuZ3RoID4gMCA/IHRoaXMuX2NsYXNzZXNbdGhpcy5fY2xhc3Nlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICAgIGlmIChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5zbGljZSgwLCBsaW5lcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgaWYgKGxpbmUucGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVJbmRlbnQobGluZS5pbmRlbnQpICsgbGluZS5wYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1pdHRlclZpc2l0b3JDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKF9lc2NhcGVEb2xsYXJJblN0cmluZ3MpIHtcbiAgICAgICAgICB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MgPSBfZXNjYXBlRG9sbGFySW5TdHJpbmdzO1xuICAgICAgfVxuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oJzsnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwicmV0dXJuIFwiKTtcbiAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKCc7Jyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiaWYgKFwiKTtcbiAgICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpIHtcIik7XG4gICAgICAgICAgdmFyIGhhc0Vsc2VDYXNlID0gaXNQcmVzZW50KHN0bXQuZmFsc2VDYXNlKSAmJiBzdG10LmZhbHNlQ2FzZS5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucmVtb3ZlRW1wdHlMYXN0TGluZSgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICAgIGlmIChoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGVsc2Uge1wiKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJ0aHJvdyBcIik7XG4gICAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZXMgPSBzdG10LmNvbW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHsgY3R4LnByaW50bG4oXCIvLyBcIiArIGxpbmUpOyB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiW1wiKTtcbiAgICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIl0gPSBcIik7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJygnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIgKyBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZ2V0QnVpbHRpbk1ldGhvZE5hbWUoZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNvbWUgYnVpbHRpbnMganVzdCBtZWFuIHRvIHNraXAgdGhlIGNhbGwuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIgKyBuYW1lICsgXCIoXCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgXCIsXCIpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgZXhwci5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIoXCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdmFyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0LmJ1aWx0aW4pKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5TdXBlcjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gJ3N1cGVyJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAndGhpcyc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9TVEFDS19WQVIkMi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gdmFyaWFibGUgXCIgKyBhc3QuYnVpbHRpbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KHZhck5hbWUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwibmV3IFwiKTtcbiAgICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChlc2NhcGVJZGVudGlmaWVyKHZhbHVlLCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoJz8gJyk7XG4gICAgICAgICAgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludCgnOiAnKTtcbiAgICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KCchJyk7XG4gICAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciBvcFN0cjtcbiAgICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz09JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz09PSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICchPSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICchPT0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnJiYnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICd8fCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnKyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJy0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnLyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJyonO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJzwnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICc8PSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICc+JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz49JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcIiArIGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIgXCIgKyBvcFN0ciArIFwiIFwiKTtcbiAgICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiLlwiKTtcbiAgICAgICAgICBjdHgucHJpbnQoYXN0Lm5hbWUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiW1wiKTtcbiAgICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiXVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgICAgY3R4LnByaW50KFwiW1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgsICcsJywgdXNlTmV3TGluZSk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludChcIl1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHVzZU5ld0xpbmUgPSBhc3QuZW50cmllcy5sZW5ndGggPiAxO1xuICAgICAgICAgIGN0eC5wcmludChcIntcIiwgdXNlTmV3TGluZSk7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoZXNjYXBlSWRlbnRpZmllcihlbnRyeVswXSwgX3RoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncywgZmFsc2UpICsgXCI6IFwiKTtcbiAgICAgICAgICAgICAgZW50cnlbMV0udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpO1xuICAgICAgICAgIH0sIGFzdC5lbnRyaWVzLCBjdHgsICcsJywgdXNlTmV3TGluZSk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludChcIn1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChuZXdMaW5lID09PSB2b2lkIDApIHsgbmV3TGluZSA9IGZhbHNlOyB9XG4gICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsT2JqZWN0cyA9IGZ1bmN0aW9uIChoYW5kbGVyLCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjdHgucHJpbnQoc2VwYXJhdG9yLCBuZXdMaW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYW5kbGVyKGV4cHJlc3Npb25zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjdHgpOyB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQWJzdHJhY3RFbWl0dGVyVmlzaXRvcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZXNjYXBlSWRlbnRpZmllcihpbnB1dCwgZXNjYXBlRG9sbGFyLCBhbHdheXNRdW90ZSkge1xuICAgICAgaWYgKGFsd2F5c1F1b3RlID09PSB2b2lkIDApIHsgYWx3YXlzUXVvdGUgPSB0cnVlOyB9XG4gICAgICBpZiAoaXNCbGFuayhpbnB1dCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBib2R5ID0gaW5wdXQucmVwbGFjZShfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBtYXRjaFtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoWzBdID09ICckJykge1xuICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlRG9sbGFyID8gJ1xcXFwkJyA6ICckJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXHInKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hbMF07XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcmVxdWlyZXNRdW90ZXMgPSBhbHdheXNRdW90ZSB8fCAhX0xFR0FMX0lERU5USUZJRVJfUkUudGVzdChib2R5KTtcbiAgICAgIHJldHVybiByZXF1aXJlc1F1b3RlcyA/IFwiJ1wiICsgYm9keSArIFwiJ1wiIDogYm9keTtcbiAgfVxuICBmdW5jdGlvbiBfY3JlYXRlSW5kZW50KGNvdW50KSB7XG4gICAgICB2YXIgcmVzID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICByZXMgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfZGVidWdNb2R1bGVVcmwgPSAnYXNzZXQ6Ly9kZWJ1Zy9saWInO1xuICBmdW5jdGlvbiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpIHtcbiAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoX2RlYnVnTW9kdWxlVXJsKTtcbiAgICAgIHZhciBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdChbXSk7XG4gICAgICB2YXIgYXN0cyA9IEFycmF5LmlzQXJyYXkoYXN0KSA/IGFzdCA6IFthc3RdO1xuICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgIGFzdC52aXNpdFN0YXRlbWVudChjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgYXN0LnZpc2l0RXhwcmVzc2lvbihjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIFR5cGUkMSkge1xuICAgICAgICAgICAgICBhc3QudmlzaXRUeXBlKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IGtub3cgaG93IHRvIHByaW50IGRlYnVnIGluZm8gZm9yIFwiICsgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdHgudG9Tb3VyY2UoKTtcbiAgfVxuICB2YXIgVHlwZVNjcmlwdEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVHlwZVNjcmlwdEVtaXR0ZXIoX2ltcG9ydEdlbmVyYXRvcikge1xuICAgICAgICAgIHRoaXMuX2ltcG9ydEdlbmVyYXRvciA9IF9pbXBvcnRHZW5lcmF0b3I7XG4gICAgICB9XG4gICAgICBUeXBlU2NyaXB0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHMgPSBmdW5jdGlvbiAobW9kdWxlVXJsLCBzdG10cywgZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IF9Uc0VtaXR0ZXJWaXNpdG9yKG1vZHVsZVVybCk7XG4gICAgICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KGV4cG9ydGVkVmFycyk7XG4gICAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY3R4KTtcbiAgICAgICAgICB2YXIgc3JjUGFydHMgPSBbXTtcbiAgICAgICAgICBjb252ZXJ0ZXIuaW1wb3J0c1dpdGhQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgsIGltcG9ydGVkTW9kdWxlVXJsKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IGNhbid0IHdyaXRlIHRoZSByZWFsIHdvcmQgZm9yIGltcG9ydCBhcyBpdCBzY3Jld3MgdXAgc3lzdGVtLmpzIGF1dG8gZGV0ZWN0aW9uLi4uXG4gICAgICAgICAgICAgIHNyY1BhcnRzLnB1c2goXCJpbXBcIiArXG4gICAgICAgICAgICAgICAgICAoXCJvcnQgKiBhcyBcIiArIHByZWZpeCArIFwiIGZyb20gJ1wiICsgX3RoaXMuX2ltcG9ydEdlbmVyYXRvci5nZXRJbXBvcnRQYXRoKG1vZHVsZVVybCwgaW1wb3J0ZWRNb2R1bGVVcmwpICsgXCInO1wiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3JjUGFydHMucHVzaChjdHgudG9Tb3VyY2UoKSk7XG4gICAgICAgICAgcmV0dXJuIHNyY1BhcnRzLmpvaW4oJ1xcbicpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUeXBlU2NyaXB0RW1pdHRlcjtcbiAgfSgpKTtcbiAgdmFyIF9Uc0VtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxOChfVHNFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIF9Uc0VtaXR0ZXJWaXNpdG9yKF9tb2R1bGVVcmwpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy5fbW9kdWxlVXJsID0gX21vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHQsIGN0eCwgZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdFR5cGUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VHlwZSA9ICdhbnknOyB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0KSkge1xuICAgICAgICAgICAgICB0LnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KGRlZmF1bHRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpICYmIGFzdC50eXBlICE9IE5VTExfVFlQRSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIoXCIgKyB2YWx1ZSArIFwiIGFzIGFueSlcIik7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgfTtcbiAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgc3RyaWN0TnVsbENoZWNrIGVuYWJsZWQgY29uc3VtZXJzIG9mIG5nYyBlbWl0LlxuICAgICAgLy8gSW4gU05DIG1vZGUsIFtdIGhhdmUgdGhlIHR5cGUgbmV2ZXJbXSwgc28gd2UgY2FzdCBoZXJlIHRvIGFueVtdLlxuICAgICAgLy8gVE9ETzogbmFycm93IHRoZSBjYXN0IHRvIGEgbW9yZSBleHBsaWNpdCB0eXBlLCBvciB1c2UgYSBwYXR0ZXJuIHRoYXQgZG9lcyBub3RcbiAgICAgIC8vIHN0YXJ0IHdpdGggW10uY29uY2F0LiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzExODQ2XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgaWYgKGFzdC5lbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJygnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICAgIGlmIChhc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcgYXMgYW55W10pJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdGhpcy5fdmlzaXRJZGVudGlmaWVyKGFzdC52YWx1ZSwgYXN0LnR5cGVQYXJhbXMsIGN0eCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiZXhwb3J0IFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkZpbmFsKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJjb25zdFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcInZhclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KFwiIFwiICsgc3RtdC5uYW1lICsgXCI6XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHN0bXQudHlwZSwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIgPSBcIik7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCIoPFwiKTtcbiAgICAgICAgICBhc3QudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCI+XCIpO1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBjdHgucHVzaENsYXNzKHN0bXQpO1xuICAgICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcImV4cG9ydCBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcImNsYXNzIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQucGFyZW50KSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgZXh0ZW5kcyBcIik7XG4gICAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnRsbihcIiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICBzdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NGaWVsZChmaWVsZCwgY3R4KTsgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSkge1xuICAgICAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzRmllbGQgPSBmdW5jdGlvbiAoZmllbGQsIGN0eCkge1xuICAgICAgICAgIGlmIChmaWVsZC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gY29tbWVudCBvdXQgYXMgYSB3b3JrYXJvdW5kIGZvciAjMTA5NjdcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiLypwcml2YXRlKi8gXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoZmllbGQubmFtZSk7XG4gICAgICAgICAgY3R4LnByaW50KCc6Jyk7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUoZmllbGQudHlwZSwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKGdldHRlciwgY3R4KSB7XG4gICAgICAgICAgaWYgKGdldHRlci5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwicHJpdmF0ZSBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcImdldCBcIiArIGdldHRlci5uYW1lICsgXCIoKVwiKTtcbiAgICAgICAgICBjdHgucHJpbnQoJzonKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZShnZXR0ZXIudHlwZSwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhnZXR0ZXIuYm9keSwgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcImNvbnN0cnVjdG9yKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgY3R4KSB7XG4gICAgICAgICAgaWYgKG1ldGhvZC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwicHJpdmF0ZSBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChtZXRob2QubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIik6XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKG1ldGhvZC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCIoXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKGFzdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKTpcIik7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUoYXN0LnR5cGUsIGN0eCwgJ3ZvaWQnKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIiA9PiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcImV4cG9ydCBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIik6XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHN0bXQudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcInRyeSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQyLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdmFyIGNhdGNoU3RtdHMgPSBbQ0FUQ0hfU1RBQ0tfVkFSJDIuc2V0KENBVENIX0VSUk9SX1ZBUiQyLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICAgIF0pXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjYXRjaFN0bXRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QnVpbHRpbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICAgIHZhciB0eXBlU3RyO1xuICAgICAgICAgIHN3aXRjaCAodHlwZS5uYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2Jvb2xlYW4nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkR5bmFtaWM6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2FueSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuSW50OlxuICAgICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLlN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYnVpbHRpbiB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KHR5cGVTdHIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsVHlwZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLm9mLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIltdXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1hcFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwie1trZXk6IHN0cmluZ106XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUudmFsdWVUeXBlLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZTpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQmluZDpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCc6Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnZpc2l0VHlwZShwYXJhbS50eXBlLCBjdHgpO1xuICAgICAgICAgIH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlUGFyYW1zLCBjdHgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiB1bmtub3duIGlkZW50aWZpZXIgXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUubW9kdWxlVXJsKSAmJiB2YWx1ZS5tb2R1bGVVcmwgIT0gdGhpcy5fbW9kdWxlVXJsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuZ2V0KHZhbHVlLm1vZHVsZVVybCk7XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiaW1wb3J0XCIgKyB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcy5zZXQodmFsdWUubW9kdWxlVXJsLCBwcmVmaXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eC5wcmludChwcmVmaXggKyBcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZS5yZWZlcmVuY2UgJiYgdmFsdWUucmVmZXJlbmNlLm1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KHZhbHVlLnJlZmVyZW5jZS5uYW1lKTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcuJyk7XG4gICAgICAgICAgICAgIGN0eC5wcmludCh2YWx1ZS5yZWZlcmVuY2UubWVtYmVycy5qb2luKCcuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KHZhbHVlLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHR5cGVQYXJhbXMpICYmIHR5cGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCI8XCIpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS52aXNpdFR5cGUoX3RoaXMsIGN0eCk7IH0sIHR5cGVQYXJhbXMsIGN0eCwgJywnKTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiPlwiKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Uc0VtaXR0ZXJWaXNpdG9yO1xuICB9KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcblxuICBmdW5jdGlvbiBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIHJlc3VsdFZhcikge1xuICAgICAgdmFyIHN0bXRzV2l0aFJldHVybiA9IHN0YXRlbWVudHMuY29uY2F0KFtuZXcgUmV0dXJuU3RhdGVtZW50KHZhcmlhYmxlKHJlc3VsdFZhcikpXSk7XG4gICAgICB2YXIgY3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KG51bGwsIG51bGwsIG51bGwsIG5ldyBNYXAoKSk7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBTdGF0ZW1lbnRJbnRlcnByZXRlcigpO1xuICAgICAgdmFyIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzV2l0aFJldHVybiwgY3R4KTtcbiAgICAgIHJldHVybiBpc1ByZXNlbnQocmVzdWx0KSA/IHJlc3VsdC52YWx1ZSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIHZhclZhbHVlcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgICB2YXIgY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQodmFyTmFtZXNbaV0sIHZhclZhbHVlc1tpXSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY2hpbGRDdHgpO1xuICAgICAgcmV0dXJuIGlzUHJlc2VudChyZXN1bHQpID8gcmVzdWx0LnZhbHVlIDogbnVsbDtcbiAgfVxuICB2YXIgX0V4ZWN1dGlvbkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0V4ZWN1dGlvbkNvbnRleHQocGFyZW50LCBpbnN0YW5jZSwgY2xhc3NOYW1lLCB2YXJzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICB9XG4gICAgICBfRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgX0V4ZWN1dGlvbkNvbnRleHQodGhpcywgdGhpcy5pbnN0YW5jZSwgdGhpcy5jbGFzc05hbWUsIG5ldyBNYXAoKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9FeGVjdXRpb25Db250ZXh0O1xuICB9KCkpO1xuICB2YXIgUmV0dXJuVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmV0dXJuVmFsdWU7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNDbGFzcyhfY2xhc3NTdG10LCBfY3R4LCBfdmlzaXRvcikge1xuICAgICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvcnMgPSB7fTtcbiAgICAgIF9jbGFzc1N0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHtcbiAgICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1tnZXR0ZXIubmFtZV0gPSB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyhbXSwgW10sIGdldHRlci5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgX2NsYXNzU3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgIHZhciBwYXJhbU5hbWVzID0gbWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1ttZXRob2QubmFtZV0gPSB7XG4gICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHBhcmFtTmFtZXMsIGFyZ3MsIG1ldGhvZC5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGN0b3JQYXJhbU5hbWVzID0gX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICB2YXIgY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICBfY2xhc3NTdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyBfdGhpc1tmaWVsZC5uYW1lXSA9IHVuZGVmaW5lZDsgfSk7XG4gICAgICAgICAgX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoY3RvclBhcmFtTmFtZXMsIGFyZ3MsIF9jbGFzc1N0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgIH07XG4gICAgICB2YXIgc3VwZXJDbGFzcyA9IF9jbGFzc1N0bXQucGFyZW50ID8gX2NsYXNzU3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKF92aXNpdG9yLCBfY3R4KSA6IE9iamVjdDtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSwgcHJvcGVydHlEZXNjcmlwdG9ycyk7XG4gICAgICByZXR1cm4gY3RvcjtcbiAgfVxuICB2YXIgU3RhdGVtZW50SW50ZXJwcmV0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhdGVtZW50SW50ZXJwcmV0ZXIoKSB7XG4gICAgICB9XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUuZGVidWdBc3QgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpOyB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIGN1cnJDdHggPSBjdHg7XG4gICAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoY3VyckN0eC52YXJzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyQ3R4LnZhcnMuc2V0KGV4cHIubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgZXhwci5uYW1lKTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB2YXJOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChhc3QuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlN1cGVyOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW5zdGFuY2UuX19wcm90b19fO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlRoaXM6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9FUlJPUl9WQVIkMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9TVEFDS19WQVIkMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIHZhcmlhYmxlIFwiICsgYXN0LmJ1aWx0aW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICAgIHdoaWxlIChjdXJyQ3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXModmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyQ3R4LnZhcnMuZ2V0KHZhck5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgdmFyTmFtZSk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJlY2VpdmVyW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZWNlaXZlcltleHByLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgdmFyIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCk7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChleHByLmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5jb25jYXQuYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuc3Vic2NyaWJlKHsgbmV4dDogYXJnc1swXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmJpbmQuYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kIFwiICsgZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXJbZXhwci5uYW1lXS5hcHBseShyZWNlaXZlciwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKHN0bXQuYXJncywgY3R4KTtcbiAgICAgICAgICB2YXIgZm5FeHByID0gc3RtdC5mbjtcbiAgICAgICAgICBpZiAoZm5FeHByIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgZm5FeHByLmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgICAgY3R4Lmluc3RhbmNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5hcHBseShjdHguaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBmbiA9IHN0bXQuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJldHVyblZhbHVlKHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGNsYXp6ID0gY3JlYXRlRHluYW1pY0NsYXNzKHN0bXQsIGN0eCwgdGhpcyk7XG4gICAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgY2xhenopO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBjb25kaXRpb24gPSBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQoc3RtdC5mYWxzZUNhc2UpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkQ3R4ID0gY3R4LmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycygpO1xuICAgICAgICAgICAgICBjaGlsZEN0eC52YXJzLnNldChDQVRDSF9FUlJPUl9WQVIkMSwgZSk7XG4gICAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX1NUQUNLX1ZBUiQxLCBlLnN0YWNrKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY2hpbGRDdHgpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdGhyb3cgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCk7XG4gICAgICAgICAgdmFyIGNsYXp6ID0gYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZXR1cm4gbmV3IChjbGF6ei5iaW5kLmFwcGx5KGNsYXp6LCBbdm9pZCAwXS5jb25jYXQoYXJncykpKSgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBhc3QudmFsdWU7IH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnJlZmVyZW5jZTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBpZiAoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQoYXN0LmZhbHNlQ2FzZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gIWFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciBwYXJhbU5hbWVzID0gYXN0LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgICByZXR1cm4gX2RlY2xhcmVGbihwYXJhbU5hbWVzLCBhc3Quc3RhdGVtZW50cywgY3R4LCB0aGlzKTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBwYXJhbU5hbWVzID0gc3RtdC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgX2RlY2xhcmVGbihwYXJhbU5hbWVzLCBzdG10LnN0YXRlbWVudHMsIGN0eCwgdGhpcykpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGxocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICAgIHZhciByaHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfTtcbiAgICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PSByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5JZGVudGljYWw6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPT09IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAhPSByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgIT09IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkFuZDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAmJiByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSB8fCByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICsgcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTWludXM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgLSByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgLyByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAqIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1vZHVsbzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAlIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIDwgcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPD0gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID4gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID49IHJocygpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcIiArIGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyW2FzdC5uYW1lXTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHZhciBwcm9wID0gYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiByZWNlaXZlcltwcm9wXTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiByZXN1bHRbZW50cnlbMF1dID1cbiAgICAgICAgICAgICAgZW50cnlbMV0udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjdHgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgc3RtdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBzdG10LnZpc2l0U3RhdGVtZW50KHRoaXMsIGN0eCk7XG4gICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3RhdGVtZW50SW50ZXJwcmV0ZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9kZWNsYXJlRm4odmFyTmFtZXMsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgYXJncywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKTtcbiAgICAgIH07XG4gIH1cbiAgdmFyIENBVENIX0VSUk9SX1ZBUiQxID0gJ2Vycm9yJztcbiAgdmFyIENBVENIX1NUQUNLX1ZBUiQxID0gJ3N0YWNrJztcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMjAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIwKEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGN0eC5wdXNoQ2xhc3Moc3RtdCk7XG4gICAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KHN0bXQubmFtZSArIFwiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXCIpO1xuICAgICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgY3R4LnByaW50bG4oXCIucHJvdG90eXBlKTtcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzR2V0dGVyKHN0bXQsIGdldHRlciwgY3R4KTsgfSk7XG4gICAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2Qoc3RtdCwgbWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgICBjdHgucG9wQ2xhc3MoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSkge1xuICAgICAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihcInZhciBzZWxmID0gdGhpcztcIik7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKHN0bXQsIGdldHRlciwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoXCIgKyBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUsICdcIiArIGdldHRlci5uYW1lICsgXCInLCB7IGdldDogZnVuY3Rpb24oKSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICBpZiAoZ2V0dGVyLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbihcInZhciBzZWxmID0gdGhpcztcIik7XG4gICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9fSk7XCIpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NNZXRob2QgPSBmdW5jdGlvbiAoc3RtdCwgbWV0aG9kLCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoc3RtdC5uYW1lICsgXCIucHJvdG90eXBlLlwiICsgbWV0aG9kLm5hbWUgKyBcIiA9IGZ1bmN0aW9uKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICBpZiAobWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbihcInZhciBzZWxmID0gdGhpcztcIik7XG4gICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9O1wiKTtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBpZiAoYXN0LmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuVGhpcykge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJ3NlbGYnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYXN0LmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3N1cGVyJyBuZWVkcyB0byBiZSBoYW5kbGVkIGF0IGEgcGFyZW50IGFzdCBub2RlLCBub3QgYXQgdGhlIHZhcmlhYmxlIGxldmVsIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcInZhciBcIiArIHN0bXQubmFtZSArIFwiID0gXCIpO1xuICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCI7XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciBmbkV4cHIgPSBleHByLmZuO1xuICAgICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBmbkV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICBjdHguY3VycmVudENsYXNzLnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiLmNhbGwodGhpc1wiKTtcbiAgICAgICAgICAgICAgaWYgKGV4cHIuYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjdHgucHJpbnQoXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwci5jYWxsKHRoaXMsIGV4cHIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbihcIik7XG4gICAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludChcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ0cnkge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifSBjYXRjaCAoXCIgKyBDQVRDSF9FUlJPUl9WQVIkMi5uYW1lICsgXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHZhciBjYXRjaFN0bXRzID0gW0NBVENIX1NUQUNLX1ZBUiQyLnNldChDQVRDSF9FUlJPUl9WQVIkMi5wcm9wKCdzdGFjaycpKS50b0RlY2xTdG10KG51bGwsIFtcbiAgICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICAgICAgICBdKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgY3R4KSB7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBjdHgucHJpbnQocGFyYW0ubmFtZSk7IH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgICAgbmFtZSA9ICdjb25jYXQnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgICAgbmFtZSA9ICdzdWJzY3JpYmUnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgbmFtZSA9ICdiaW5kJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yO1xuICB9KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGV2YWxFeHByZXNzaW9uKHNvdXJjZVVybCwgZXhwciwgZGVjbGFyYXRpb25zLCB2YXJzKSB7XG4gICAgICB2YXIgZm5Cb2R5ID0gZGVjbGFyYXRpb25zICsgXCJcXG5yZXR1cm4gXCIgKyBleHByICsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgc291cmNlVXJsO1xuICAgICAgdmFyIGZuQXJnTmFtZXMgPSBbXTtcbiAgICAgIHZhciBmbkFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgYXJnTmFtZSBpbiB2YXJzKSB7XG4gICAgICAgICAgZm5BcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICAgIGZuQXJnVmFsdWVzLnB1c2godmFyc1thcmdOYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBbdm9pZCAwXS5jb25jYXQoZm5BcmdOYW1lcy5jb25jYXQoZm5Cb2R5KSkpKSgpLmFwcGx5KHZvaWQgMCwgZm5BcmdWYWx1ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGppdFN0YXRlbWVudHMoc291cmNlVXJsLCBzdGF0ZW1lbnRzLCByZXN1bHRWYXIpIHtcbiAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgSml0RW1pdHRlclZpc2l0b3IoKTtcbiAgICAgIHZhciBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdChbcmVzdWx0VmFyXSk7XG4gICAgICBjb252ZXJ0ZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGN0eCk7XG4gICAgICByZXR1cm4gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsLCByZXN1bHRWYXIsIGN0eC50b1NvdXJjZSgpLCBjb252ZXJ0ZXIuZ2V0QXJncygpKTtcbiAgfVxuICB2YXIgSml0RW1pdHRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE5KEppdEVtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSml0RW1pdHRlclZpc2l0b3IoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzID0gW107XG4gICAgICAgICAgdGhpcy5fZXZhbEFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgSml0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEFyZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZhbEFyZ05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFt0aGlzLl9ldmFsQXJnTmFtZXNbaV1dID0gdGhpcy5fZXZhbEFyZ1ZhbHVlc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhc3QudmFsdWUucmVmZXJlbmNlO1xuICAgICAgICAgIHZhciBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgaWYgKGlkID09PSAtMSkge1xuICAgICAgICAgICAgICBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICB0aGlzLl9ldmFsQXJnVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gaXNQcmVzZW50KGFzdC52YWx1ZS5uYW1lKSA/IHNhbml0aXplSWRlbnRpZmllcihhc3QudmFsdWUubmFtZSkgOiAndmFsJztcbiAgICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goc2FuaXRpemVJZGVudGlmaWVyKFwiaml0X1wiICsgbmFtZV8xICsgaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KHRoaXMuX2V2YWxBcmdOYW1lc1tpZF0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBKaXRFbWl0dGVyVmlzaXRvcjtcbiAgfShBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8qKlxuICAgKiBUaGlzIGZpbGUgaXMgYSBwb3J0IG9mIHNoYWRvd0NTUyBmcm9tIHdlYmNvbXBvbmVudHMuanMgdG8gVHlwZVNjcmlwdC5cbiAgICpcbiAgICogUGxlYXNlIG1ha2Ugc3VyZSB0byBrZWVwIHRvIGVkaXRzIGluIHN5bmMgd2l0aCB0aGUgc291cmNlIGZpbGUuXG4gICAqXG4gICAqIFNvdXJjZTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL2Jsb2IvNGVmZWNkN2UwZS9zcmMvU2hhZG93Q1NTL1NoYWRvd0NTUy5qc1xuICAgKlxuICAgKiBUaGUgb3JpZ2luYWwgZmlsZSBsZXZlbCBjb21tZW50IGlzIHJlcHJvZHVjZWQgYmVsb3dcbiAgICovXG4gIC8qXG4gICAgVGhpcyBpcyBhIGxpbWl0ZWQgc2hpbSBmb3IgU2hhZG93RE9NIGNzcyBzdHlsaW5nLlxuICAgIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvd2ViY29tcG9uZW50cy9yYXctZmlsZS90aXAvc3BlYy9zaGFkb3cvaW5kZXguaHRtbCNzdHlsZXNcblxuICAgIFRoZSBpbnRlbnRpb24gaGVyZSBpcyB0byBzdXBwb3J0IG9ubHkgdGhlIHN0eWxpbmcgZmVhdHVyZXMgd2hpY2ggY2FuIGJlXG4gICAgcmVsYXRpdmVseSBzaW1wbHkgaW1wbGVtZW50ZWQuIFRoZSBnb2FsIGlzIHRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIHRoZVxuICAgIG1vc3Qgb2J2aW91cyBwaXRmYWxscyBhbmQgZG8gc28gd2l0aG91dCBjb21wcm9taXNpbmcgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbiAgICBGb3IgU2hhZG93RE9NIHN0eWxpbmcgdGhhdCdzIG5vdCBjb3ZlcmVkIGhlcmUsIGEgc2V0IG9mIGJlc3QgcHJhY3RpY2VzXG4gICAgY2FuIGJlIHByb3ZpZGVkIHRoYXQgc2hvdWxkIGFsbG93IHVzZXJzIHRvIGFjY29tcGxpc2ggbW9yZSBjb21wbGV4IHN0eWxpbmcuXG5cbiAgICBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiBzcGVjaWZpYyBTaGFkb3dET00gc3R5bGluZyBmZWF0dXJlcyBhbmQgYSBicmllZlxuICAgIGRpc2N1c3Npb24gb2YgdGhlIGFwcHJvYWNoIHVzZWQgdG8gc2hpbS5cblxuICAgIFNoaW1tZWQgZmVhdHVyZXM6XG5cbiAgICAqIDpob3N0LCA6aG9zdC1jb250ZXh0OiBTaGFkb3dET00gYWxsb3dzIHN0eWxpbmcgb2YgdGhlIHNoYWRvd1Jvb3QncyBob3N0XG4gICAgZWxlbWVudCB1c2luZyB0aGUgOmhvc3QgcnVsZS4gVG8gc2hpbSB0aGlzIGZlYXR1cmUsIHRoZSA6aG9zdCBzdHlsZXMgYXJlXG4gICAgcmVmb3JtYXR0ZWQgYW5kIHByZWZpeGVkIHdpdGggYSBnaXZlbiBzY29wZSBuYW1lIGFuZCBwcm9tb3RlZCB0byBhXG4gICAgZG9jdW1lbnQgbGV2ZWwgc3R5bGVzaGVldC5cbiAgICBGb3IgZXhhbXBsZSwgZ2l2ZW4gYSBzY29wZSBuYW1lIG9mIC5mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGJlY29tZXM6XG5cbiAgICAgIC5mb28ge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICB9XG5cbiAgICAqIGVuY2Fwc3VsYXRpb246IFN0eWxlcyBkZWZpbmVkIHdpdGhpbiBTaGFkb3dET00sIGFwcGx5IG9ubHkgdG9cbiAgICBkb20gaW5zaWRlIHRoZSBTaGFkb3dET00uIFBvbHltZXIgdXNlcyBvbmUgb2YgdHdvIHRlY2huaXF1ZXMgdG8gaW1wbGVtZW50XG4gICAgdGhpcyBmZWF0dXJlLlxuXG4gICAgQnkgZGVmYXVsdCwgcnVsZXMgYXJlIHByZWZpeGVkIHdpdGggdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZVxuICAgIGFzIGEgZGVzY2VuZGFudCBzZWxlY3Rvci4gVGhpcyBlbnN1cmVzIHN0eWxpbmcgZG9lcyBub3QgbGVhayBvdXQgb2YgdGhlICd0b3AnXG4gICAgb2YgdGhlIGVsZW1lbnQncyBTaGFkb3dET00uIEZvciBleGFtcGxlLFxuXG4gICAgZGl2IHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB9XG5cbiAgICBiZWNvbWVzOlxuXG4gICAgeC1mb28gZGl2IHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB9XG5cbiAgICBiZWNvbWVzOlxuXG5cbiAgICBBbHRlcm5hdGl2ZWx5LCBpZiBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5zdHJpY3RTdHlsaW5nIGlzIHNldCB0byB0cnVlIHRoZW5cbiAgICBzZWxlY3RvcnMgYXJlIHNjb3BlZCBieSBhZGRpbmcgYW4gYXR0cmlidXRlIHNlbGVjdG9yIHN1ZmZpeCB0byBlYWNoXG4gICAgc2ltcGxlIHNlbGVjdG9yIHRoYXQgY29udGFpbnMgdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZS4gRWFjaCBlbGVtZW50XG4gICAgaW4gdGhlIGVsZW1lbnQncyBTaGFkb3dET00gdGVtcGxhdGUgaXMgYWxzbyBnaXZlbiB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICAgIFRodXMsIHRoZXNlIHJ1bGVzIG1hdGNoIG9ubHkgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBzY29wZSBhdHRyaWJ1dGUuXG4gICAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiB4LWZvbywgYSBydWxlIGxpa2UgdGhpczpcblxuICAgICAgZGl2IHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB9XG5cbiAgICBiZWNvbWVzOlxuXG4gICAgICBkaXZbeC1mb29dIHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB9XG5cbiAgICBOb3RlIHRoYXQgZWxlbWVudHMgdGhhdCBhcmUgZHluYW1pY2FsbHkgYWRkZWQgdG8gYSBzY29wZSBtdXN0IGhhdmUgdGhlIHNjb3BlXG4gICAgc2VsZWN0b3IgYWRkZWQgdG8gdGhlbSBtYW51YWxseS5cblxuICAgICogdXBwZXIvbG93ZXIgYm91bmQgZW5jYXBzdWxhdGlvbjogU3R5bGVzIHdoaWNoIGFyZSBkZWZpbmVkIG91dHNpZGUgYVxuICAgIHNoYWRvd1Jvb3Qgc2hvdWxkIG5vdCBjcm9zcyB0aGUgU2hhZG93RE9NIGJvdW5kYXJ5IGFuZCBzaG91bGQgbm90IGFwcGx5XG4gICAgaW5zaWRlIGEgc2hhZG93Um9vdC5cblxuICAgIFRoaXMgc3R5bGluZyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIFNvbWUgcG9zc2libGUgd2F5cyB0byBkbyB0aGlzIHRoYXRcbiAgICB3ZXJlIHJlamVjdGVkIGR1ZSB0byBjb21wbGV4aXR5IGFuZC9vciBwZXJmb3JtYW5jZSBjb25jZXJucyBpbmNsdWRlOiAoMSkgcmVzZXRcbiAgICBldmVyeSBwb3NzaWJsZSBwcm9wZXJ0eSBmb3IgZXZlcnkgcG9zc2libGUgc2VsZWN0b3IgZm9yIGEgZ2l2ZW4gc2NvcGUgbmFtZTtcbiAgICAoMikgcmUtaW1wbGVtZW50IGNzcyBpbiBqYXZhc2NyaXB0LlxuXG4gICAgQXMgYW4gYWx0ZXJuYXRpdmUsIHVzZXJzIHNob3VsZCBtYWtlIHN1cmUgdG8gdXNlIHNlbGVjdG9yc1xuICAgIHNwZWNpZmljIHRvIHRoZSBzY29wZSBpbiB3aGljaCB0aGV5IGFyZSB3b3JraW5nLlxuXG4gICAgKiA6OmRpc3RyaWJ1dGVkOiBUaGlzIGJlaGF2aW9yIGlzIG5vdCBlbXVsYXRlZC4gSXQncyBvZnRlbiBub3QgbmVjZXNzYXJ5XG4gICAgdG8gc3R5bGUgdGhlIGNvbnRlbnRzIG9mIGEgc3BlY2lmaWMgaW5zZXJ0aW9uIHBvaW50IGFuZCBpbnN0ZWFkLCBkZXNjZW5kYW50c1xuICAgIG9mIHRoZSBob3N0IGVsZW1lbnQgY2FuIGJlIHN0eWxlZCBzZWxlY3RpdmVseS4gVXNlcnMgY2FuIGFsc28gY3JlYXRlIGFuXG4gICAgZXh0cmEgbm9kZSBhcm91bmQgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBzdHlsZSB0aGF0IG5vZGUncyBjb250ZW50c1xuICAgIHZpYSBkZXNjZW5kZW50IHNlbGVjdG9ycy4gRm9yIGV4YW1wbGUsIHdpdGggYSBzaGFkb3dSb290IGxpa2UgdGhpczpcblxuICAgICAgPHN0eWxlPlxuICAgICAgICA6OmNvbnRlbnQoZGl2KSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPGNvbnRlbnQ+PC9jb250ZW50PlxuXG4gICAgY291bGQgYmVjb21lOlxuXG4gICAgICA8c3R5bGU+XG4gICAgICAgIC8gKkBwb2x5ZmlsbCAuY29udGVudC1jb250YWluZXIgZGl2ICogL1xuICAgICAgICA6OmNvbnRlbnQoZGl2KSB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnQtY29udGFpbmVyXCI+XG4gICAgICAgIDxjb250ZW50PjwvY29udGVudD5cbiAgICAgIDwvZGl2PlxuXG4gICAgTm90ZSB0aGUgdXNlIG9mIEBwb2x5ZmlsbCBpbiB0aGUgY29tbWVudCBhYm92ZSBhIFNoYWRvd0RPTSBzcGVjaWZpYyBzdHlsZVxuICAgIGRlY2xhcmF0aW9uLiBUaGlzIGlzIGEgZGlyZWN0aXZlIHRvIHRoZSBzdHlsaW5nIHNoaW0gdG8gdXNlIHRoZSBzZWxlY3RvclxuICAgIGluIGNvbW1lbnRzIGluIGxpZXUgb2YgdGhlIG5leHQgc2VsZWN0b3Igd2hlbiBydW5uaW5nIHVuZGVyIHBvbHlmaWxsLlxuICAqL1xuICB2YXIgU2hhZG93Q3NzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNoYWRvd0NzcygpIHtcbiAgICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICogU2hpbSBzb21lIGNzc1RleHQgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IuIFJldHVybnMgY3NzVGV4dCB0aGF0IGNhblxuICAgICAgKiBiZSBpbmNsdWRlZCBpbiB0aGUgZG9jdW1lbnQgdmlhIFdlYkNvbXBvbmVudHMuU2hhZG93Q1NTLmFkZENzc1RvRG9jdW1lbnQoY3NzKS5cbiAgICAgICpcbiAgICAgICogV2hlbiBzdHJpY3RTdHlsaW5nIGlzIHRydWU6XG4gICAgICAqIC0gc2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIHRoZSBob3N0LFxuICAgICAgKiAtIGhvc3RTZWxlY3RvciBpcyB0aGUgYXR0cmlidXRlIGFkZGVkIHRvIHRoZSBob3N0IGl0c2VsZi5cbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLnNoaW1Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoaG9zdFNlbGVjdG9yID09PSB2b2lkIDApIHsgaG9zdFNlbGVjdG9yID0gJyc7IH1cbiAgICAgICAgICB2YXIgc291cmNlTWFwcGluZ1VybCA9IGV4dHJhY3RTb3VyY2VNYXBwaW5nVXJsKGNzc1RleHQpO1xuICAgICAgICAgIGNzc1RleHQgPSBzdHJpcENvbW1lbnRzKGNzc1RleHQpO1xuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnREaXJlY3RpdmVzKGNzc1RleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zY29wZUNzc1RleHQoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3RvcikgKyBzb3VyY2VNYXBwaW5nVXJsO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGNvbnZlcnQgbmF0aXZlIFNoYWRvd0RPTSBydWxlcyB0aGF0IHdpbGwgdHJpcFxuICAgICAgICogdXAgdGhlIGNzcyBwYXJzZXI7IHdlIHJlbHkgb24gZGVjb3JhdGluZyB0aGUgc3R5bGVzaGVldCB3aXRoIGluZXJ0IHJ1bGVzLlxuICAgICAgICpcbiAgICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgICAqXG4gICAgICAgKiBwb2x5ZmlsbC1uZXh0LXNlbGVjdG9yIHsgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7IH1cbiAgICAgICAqIDo6Y29udGVudCBtZW51LWl0ZW0ge1xuICAgICAgICpcbiAgICAgICAqIHRvIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7XG4gICAgICAgKlxuICAgICAgKiovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50TmV4dFNlbGVjdG9yUmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIG1bX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1bMl0gKyAneyc7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICAgKlxuICAgICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAgICpcbiAgICAgICAqIHBvbHlmaWxsLXJ1bGUge1xuICAgICAgICogICBjb250ZW50OiAnOmhvc3QgbWVudS1pdGVtJztcbiAgICAgICAqIC4uLlxuICAgICAgICogfVxuICAgICAgICpcbiAgICAgICAqIHRvIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7Li4ufVxuICAgICAgICpcbiAgICAgICoqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxSdWxlc0luQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnRSdWxlUmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIG1bX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsxXSwgJycpLnJlcGxhY2UobVsyXSwgJycpO1xuICAgICAgICAgICAgICByZXR1cm4gbVs0XSArIHJ1bGU7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgLyogRW5zdXJlIHN0eWxlcyBhcmUgc2NvcGVkLiBQc2V1ZG8tc2NvcGluZyB0YWtlcyBhIHJ1bGUgbGlrZTpcbiAgICAgICAqXG4gICAgICAgKiAgLmZvbyB7Li4uIH1cbiAgICAgICAqXG4gICAgICAgKiAgYW5kIGNvbnZlcnRzIHRoaXMgdG9cbiAgICAgICAqXG4gICAgICAgKiAgc2NvcGVOYW1lIC5mb28geyAuLi4gfVxuICAgICAgKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgdW5zY29wZWRSdWxlcyA9IHRoaXMuX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgICAgLy8gcmVwbGFjZSA6aG9zdCBhbmQgOmhvc3QtY29udGV4dCAtc2hhZG93Y3NzaG9zdCBhbmQgLXNoYWRvd2Nzc2hvc3QgcmVzcGVjdGl2ZWx5XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdChjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMoY3NzVGV4dCk7XG4gICAgICAgICAgaWYgKHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX3Njb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzc1RleHQgPSBjc3NUZXh0ICsgJ1xcbicgKyB1bnNjb3BlZFJ1bGVzO1xuICAgICAgICAgIHJldHVybiBjc3NUZXh0LnRyaW0oKTtcbiAgICAgIH07XG4gICAgICAvKlxuICAgICAgICogUHJvY2VzcyBzdHlsZXMgdG8gYWRkIHJ1bGVzIHdoaWNoIHdpbGwgb25seSBhcHBseSB1bmRlciB0aGUgcG9seWZpbGxcbiAgICAgICAqIGFuZCBkbyBub3QgcHJvY2VzcyB2aWEgQ1NTT00uIChDU1NPTSBpcyBkZXN0cnVjdGl2ZSB0byBydWxlcyBvbiByYXJlXG4gICAgICAgKiBvY2Nhc2lvbnMsIGUuZy4gLXdlYmtpdC1jYWxjIG9uIFNhZmFyaS4pXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICAgKlxuICAgICAgICogQHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUge1xuICAgICAgICogICBjb250ZW50OiAnbWVudS1pdGVtJztcbiAgICAgICAqIC4uLiB9XG4gICAgICAgKlxuICAgICAgICogdG8gdGhpczpcbiAgICAgICAqXG4gICAgICAgKiBtZW51LWl0ZW0gey4uLn1cbiAgICAgICAqXG4gICAgICAqKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICAgIHZhciBtO1xuICAgICAgICAgIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG0gPSBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmV4ZWMoY3NzVGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBydWxlID0gbVswXS5yZXBsYWNlKG1bMl0sICcnKS5yZXBsYWNlKG1bMV0sIG1bNF0pO1xuICAgICAgICAgICAgICByICs9IHJ1bGUgKyAnXFxuXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QoLmZvbykgPiAuYmFyIHsgfVxuICAgICAgICpcbiAgICAgICAqIHRvXG4gICAgICAgKlxuICAgICAgICogLmZvbzxzY29wZU5hbWU+ID4gLmJhclxuICAgICAgKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3QgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcbiAgICAgIH07XG4gICAgICAvKlxuICAgICAgICogY29udmVydCBhIHJ1bGUgbGlrZSA6aG9zdC1jb250ZXh0KC5mb28pID4gLmJhciB7IH1cbiAgICAgICAqXG4gICAgICAgKiB0b1xuICAgICAgICpcbiAgICAgICAqIC5mb288c2NvcGVOYW1lPiA+IC5iYXIsIC5mb28gc2NvcGVOYW1lID4gLmJhciB7IH1cbiAgICAgICAqXG4gICAgICAgKiBhbmRcbiAgICAgICAqXG4gICAgICAgKiA6aG9zdC1jb250ZXh0KC5mb286aG9zdCkgLmJhciB7IC4uLiB9XG4gICAgICAgKlxuICAgICAgICogdG9cbiAgICAgICAqXG4gICAgICAgKiAuZm9vPHNjb3BlTmFtZT4gLmJhciB7IC4uLiB9XG4gICAgICAqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUsIHRoaXMuX2NvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIpO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvblJ1bGUgPSBmdW5jdGlvbiAoY3NzVGV4dCwgcmVnRXhwLCBwYXJ0UmVwbGFjZXIpIHtcbiAgICAgICAgICAvLyBtWzFdID0gOmhvc3QoLWNvbnRleHQpLCBtWzJdID0gY29udGVudHMgb2YgKCksIG1bM10gcmVzdCBvZiBydWxlXG4gICAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShyZWdFeHAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIG1bX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IG1bMl0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwYXJ0c1tpXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiByLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yICsgbVszXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIgPSBmdW5jdGlvbiAoaG9zdCwgcGFydCwgc3VmZml4KSB7XG4gICAgICAgICAgaWYgKHBhcnQuaW5kZXhPZihfcG9seWZpbGxIb3N0KSA+IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIoaG9zdCwgcGFydCwgc3VmZml4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArICcsICcgKyBwYXJ0ICsgJyAnICsgaG9zdCArIHN1ZmZpeDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29sb25Ib3N0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICAgIHJldHVybiBob3N0ICsgcGFydC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3QsICcnKSArIHN1ZmZpeDtcbiAgICAgIH07XG4gICAgICAvKlxuICAgICAgICogQ29udmVydCBjb21iaW5hdG9ycyBsaWtlIDo6c2hhZG93IGFuZCBwc2V1ZG8tZWxlbWVudHMgbGlrZSA6OmNvbnRlbnRcbiAgICAgICAqIGJ5IHJlcGxhY2luZyB3aXRoIHNwYWNlLlxuICAgICAgKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIHJldHVybiBfc2hhZG93RE9NU2VsZWN0b3JzUmUucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhdHRlcm4pIHsgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKHBhdHRlcm4sICcgJyk7IH0sIGNzc1RleHQpO1xuICAgICAgfTtcbiAgICAgIC8vIGNoYW5nZSBhIHNlbGVjdG9yIGxpa2UgJ2RpdicgdG8gJ25hbWUgZGl2J1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc1J1bGVzKGNzc1RleHQsIGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gcnVsZS5jb250ZW50O1xuICAgICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPSAnQCcpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID1cbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2NvcGVTZWxlY3RvcihydWxlLnNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IsIF90aGlzLnN0cmljdFN0eWxpbmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQG1lZGlhJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAc3VwcG9ydHMnKSB8fFxuICAgICAgICAgICAgICAgICAgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAcGFnZScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQGRvY3VtZW50JykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBfdGhpcy5fc2NvcGVTZWxlY3RvcnMocnVsZS5jb250ZW50LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ3NzUnVsZShzZWxlY3RvciwgY29udGVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBzdHJpY3QpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudHJpbSgpLnNwbGl0KF9zaGFkb3dEZWVwU2VsZWN0b3JzKTsgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGVlcFBhcnRzKSB7XG4gICAgICAgICAgICAgIHZhciBzaGFsbG93UGFydCA9IGRlZXBQYXJ0c1swXSwgb3RoZXJQYXJ0cyA9IGRlZXBQYXJ0cy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgdmFyIGFwcGx5U2NvcGUgPSBmdW5jdGlvbiAoc2hhbGxvd1BhcnQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3RvcikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gW2FwcGx5U2NvcGUoc2hhbGxvd1BhcnQpXS5jb25jYXQob3RoZXJQYXJ0cykuam9pbignICcpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3NlbGVjdG9yTmVlZHNTY29waW5nID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIHJlID0gdGhpcy5fbWFrZVNjb3BlTWF0Y2hlcihzY29wZVNlbGVjdG9yKTtcbiAgICAgICAgICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX21ha2VTY29wZU1hdGNoZXIgPSBmdW5jdGlvbiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBscmUgPSAvXFxbL2c7XG4gICAgICAgICAgdmFyIHJyZSA9IC9cXF0vZztcbiAgICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGxyZSwgJ1xcXFxbJykucmVwbGFjZShycmUsICdcXFxcXScpO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeKCcgKyBzY29wZVNlbGVjdG9yICsgJyknICsgX3NlbGVjdG9yUmVTdWZmaXgsICdtJyk7XG4gICAgICB9O1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgICAvLyBEaWZmZXJlbmNlIGZyb20gd2ViY29tcG9uZW50cy5qczogc2NvcGVTZWxlY3RvciBjb3VsZCBub3QgYmUgYW4gYXJyYXlcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgfTtcbiAgICAgIC8vIHNjb3BlIHZpYSBuYW1lIGFuZCBbaXM9bmFtZV1cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgLy8gSW4gQW5kcm9pZCBicm93c2VyLCB0aGUgbGFzdEluZGV4IGlzIG5vdCByZXNldCB3aGVuIHRoZSByZWdleCBpcyB1c2VkIGluIFN0cmluZy5yZXBsYWNlKClcbiAgICAgICAgICBfcG9seWZpbGxIb3N0UmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICBpZiAoX3BvbHlmaWxsSG9zdFJlLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIHZhciByZXBsYWNlQnlfMSA9IHRoaXMuc3RyaWN0U3R5bGluZyA/IFwiW1wiICsgaG9zdFNlbGVjdG9yICsgXCJdXCIgOiBzY29wZVNlbGVjdG9yO1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSwgZnVuY3Rpb24gKGhuYywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8oW146XSopKDoqKSguKikvLCBmdW5jdGlvbiAoXywgYmVmb3JlLCBjb2xvbiwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlICsgcmVwbGFjZUJ5XzEgKyBjb2xvbiArIGFmdGVyO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeV8xICsgJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcjtcbiAgICAgIH07XG4gICAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcbiAgICAgIC8vIGUuZy4gLmZvby5iYXIgPiAuem90IGJlY29tZXMgLmZvb1tuYW1lXS5iYXJbbmFtZV0gPiAuem90W25hbWVdICAvKiogQGludGVybmFsICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGlzUmUgPSAvXFxbaXM9KFteXFxdXSopXFxdL2c7XG4gICAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnWycgKyBzY29wZVNlbGVjdG9yICsgJ10nO1xuICAgICAgICAgIHZhciBfc2NvcGVTZWxlY3RvclBhcnQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICB2YXIgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgICBpZiAoIXNjb3BlZFApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlZFAgPSBfdGhpcy5fYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlKHAsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyByZW1vdmUgOmhvc3Qgc2luY2UgaXQgc2hvdWxkIGJlIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICB2YXIgdCA9IHAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsICcnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHQubWF0Y2goLyhbXjpdKikoOiopKC4qKS8pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlZFAgPSBtYXRjaGVzWzFdICsgYXR0ck5hbWUgKyBtYXRjaGVzWzJdICsgbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlZFA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgc2FmZUNvbnRlbnQgPSBuZXcgU2FmZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICBzZWxlY3RvciA9IHNhZmVDb250ZW50LmNvbnRlbnQoKTtcbiAgICAgICAgICB2YXIgc2NvcGVkU2VsZWN0b3IgPSAnJztcbiAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHJlcztcbiAgICAgICAgICB2YXIgc2VwID0gLyggfD58XFwrfH4oPyE9KSlcXHMqL2c7XG4gICAgICAgICAgdmFyIHNjb3BlQWZ0ZXIgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpO1xuICAgICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgICB2YXIgcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgICAvLyBpZiBhIHNlbGVjdG9yIGFwcGVhcnMgYmVmb3JlIDpob3N0LWNvbnRleHQgaXQgc2hvdWxkIG5vdCBiZSBzaGltbWVkIGFzIGl0XG4gICAgICAgICAgICAgIC8vIG1hdGNoZXMgb24gYW5jZXN0b3IgZWxlbWVudHMgYW5kIG5vdCBvbiBlbGVtZW50cyBpbiB0aGUgaG9zdCdzIHNoYWRvd1xuICAgICAgICAgICAgICB2YXIgc2NvcGVkUGFydCA9IHN0YXJ0SW5kZXggPj0gc2NvcGVBZnRlciA/IF9zY29wZVNlbGVjdG9yUGFydChwYXJ0KSA6IHBhcnQ7XG4gICAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNjb3BlZFBhcnQgKyBcIiBcIiArIHNlcGFyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gc2VwLmxhc3RJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gX3Njb3BlU2VsZWN0b3JQYXJ0KHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KSk7XG4gICAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzIHdpdGggdGhlaXIgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgcmV0dXJuIHNhZmVDb250ZW50LnJlc3RvcmUoc2NvcGVkU2VsZWN0b3IpO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKF9jb2xvbkhvc3RDb250ZXh0UmUsIF9wb2x5ZmlsbEhvc3RDb250ZXh0KVxuICAgICAgICAgICAgICAucmVwbGFjZShfY29sb25Ib3N0UmUsIF9wb2x5ZmlsbEhvc3QpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTaGFkb3dDc3M7XG4gIH0oKSk7XG4gIHZhciBTYWZlU2VsZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU2FmZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IFtdO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIC8vIFJlcGxhY2VzIGF0dHJpYnV0ZSBzZWxlY3RvcnMgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICAgICAgLy8gVGhlIFdTIGluIFthdHRyPVwidmEgbHVlXCJdIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBhIHNlbGVjdG9yIHNlcGFyYXRvci5cbiAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLyhcXFtbXlxcXV0qXFxdKS9nLCBmdW5jdGlvbiAoXywga2VlcCkge1xuICAgICAgICAgICAgICB2YXIgcmVwbGFjZUJ5ID0gXCJfX3BoLVwiICsgX3RoaXMuaW5kZXggKyBcIl9fXCI7XG4gICAgICAgICAgICAgIF90aGlzLnBsYWNlaG9sZGVycy5wdXNoKGtlZXApO1xuICAgICAgICAgICAgICBfdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZUJ5O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgICAvLyBXUyBhbmQgXCIrXCIgd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIHNlbGVjdG9yIHNlcGFyYXRvcnMuXG4gICAgICAgICAgdGhpcy5fY29udGVudCA9IHNlbGVjdG9yLnJlcGxhY2UoLyg6bnRoLVstXFx3XSspKFxcKFteKV0rXFwpKS9nLCBmdW5jdGlvbiAoXywgcHNldWRvLCBleHApIHtcbiAgICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgICBfdGhpcy5wbGFjZWhvbGRlcnMucHVzaChleHApO1xuICAgICAgICAgICAgICBfdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgU2FmZVNlbGVjdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoL19fcGgtKFxcZCspX18vZywgZnVuY3Rpb24gKHBoLCBpbmRleCkgeyByZXR1cm4gX3RoaXMucGxhY2Vob2xkZXJzWytpbmRleF07IH0pO1xuICAgICAgfTtcbiAgICAgIFNhZmVTZWxlY3Rvci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7IH07XG4gICAgICByZXR1cm4gU2FmZVNlbGVjdG9yO1xuICB9KCkpO1xuICB2YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj8oWydcIl0pKC4qPylcXDFbO1xcc10qfShbXntdKj8pey9naW07XG4gIHZhciBfY3NzQ29udGVudFJ1bGVSZSA9IC8ocG9seWZpbGwtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbiAgdmFyIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUgPSAvKHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG4gIHZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0JztcbiAgLy8gbm90ZTogOmhvc3QtY29udGV4dCBwcmUtcHJvY2Vzc2VkIHRvIC1zaGFkb3djc3Nob3N0Y29udGV4dC5cbiAgdmFyIF9wb2x5ZmlsbEhvc3RDb250ZXh0ID0gJy1zaGFkb3djc3Njb250ZXh0JztcbiAgdmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXG4gICAgICAnKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8nICtcbiAgICAgICcpXFxcXCkpPyhbXix7XSopJztcbiAgdmFyIF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xuICB2YXIgX2Nzc0NvbG9uSG9zdENvbnRleHRSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdENvbnRleHQgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbiAgdmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgPSBfcG9seWZpbGxIb3N0ICsgJy1uby1jb21iaW5hdG9yJztcbiAgdmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSA9IC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yKFteXFxzXSopLztcbiAgdmFyIF9zaGFkb3dET01TZWxlY3RvcnNSZSA9IFtcbiAgICAgIC86OnNoYWRvdy9nLFxuICAgICAgLzo6Y29udGVudC9nLFxuICAgICAgLy8gRGVwcmVjYXRlZCBzZWxlY3RvcnNcbiAgICAgIC9cXC9zaGFkb3ctZGVlcFxcLy9nLFxuICAgICAgL1xcL3NoYWRvd1xcLy9nLFxuICBdO1xuICB2YXIgX3NoYWRvd0RlZXBTZWxlY3RvcnMgPSAvKD86Pj4+KXwoPzpcXC9kZWVwXFwvKS9nO1xuICB2YXIgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1xcWy4sezpdW1xcXFxzXFxcXFNdKik/JCc7XG4gIHZhciBfcG9seWZpbGxIb3N0UmUgPSAvLXNoYWRvd2Nzc2hvc3QvZ2ltO1xuICB2YXIgX2NvbG9uSG9zdFJlID0gLzpob3N0L2dpbTtcbiAgdmFyIF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XG4gIHZhciBfY29tbWVudFJlID0gL1xcL1xcKlxccypbXFxzXFxTXSo/XFwqXFwvL2c7XG4gIGZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKF9jb21tZW50UmUsICcnKTtcbiAgfVxuICAvLyBhbGwgY29tbWVudHMgZXhjZXB0IGlubGluZSBzb3VyY2UgbWFwcGluZ1xuICB2YXIgX3NvdXJjZU1hcHBpbmdVcmxSZSA9IC9cXC9cXCpcXHMqI1xccypzb3VyY2VNYXBwaW5nVVJMPVtcXHNcXFNdKz9cXCpcXC8vO1xuICBmdW5jdGlvbiBleHRyYWN0U291cmNlTWFwcGluZ1VybChpbnB1dCkge1xuICAgICAgdmFyIG1hdGNoZXIgPSBpbnB1dC5tYXRjaChfc291cmNlTWFwcGluZ1VybFJlKTtcbiAgICAgIHJldHVybiBtYXRjaGVyID8gbWF0Y2hlclswXSA6ICcnO1xuICB9XG4gIHZhciBfcnVsZVJlID0gLyhcXHMqKShbXjtcXHtcXH1dKz8pKFxccyopKCg/OnslQkxPQ0slfT9cXHMqOz8pfCg/Olxccyo7KSkvZztcbiAgdmFyIF9jdXJseVJlID0gLyhbe31dKS9nO1xuICB2YXIgT1BFTl9DVVJMWSA9ICd7JztcbiAgdmFyIENMT1NFX0NVUkxZID0gJ30nO1xuICB2YXIgQkxPQ0tfUExBQ0VIT0xERVIgPSAnJUJMT0NLJSc7XG4gIHZhciBDc3NSdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDc3NSdWxlO1xuICB9KCkpO1xuICBmdW5jdGlvbiBwcm9jZXNzUnVsZXMoaW5wdXQsIHJ1bGVDYWxsYmFjaykge1xuICAgICAgdmFyIGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xuICAgICAgdmFyIG5leHRCbG9ja0luZGV4ID0gMDtcbiAgICAgIHJldHVybiBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBtWzJdO1xuICAgICAgICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgICAgICAgdmFyIHN1ZmZpeCA9IG1bNF07XG4gICAgICAgICAgdmFyIGNvbnRlbnRQcmVmaXggPSAnJztcbiAgICAgICAgICBpZiAoc3VmZml4ICYmIHN1ZmZpeC5zdGFydHNXaXRoKCd7JyArIEJMT0NLX1BMQUNFSE9MREVSKSkge1xuICAgICAgICAgICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICAgICAgICAgIHN1ZmZpeCA9IHN1ZmZpeC5zdWJzdHJpbmcoQkxPQ0tfUExBQ0VIT0xERVIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgIGNvbnRlbnRQcmVmaXggPSAneyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBydWxlID0gcnVsZUNhbGxiYWNrKG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSk7XG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyBtWzFdICsgcnVsZS5zZWxlY3RvciArIG1bM10gKyBjb250ZW50UHJlZml4ICsgcnVsZS5jb250ZW50ICsgc3VmZml4O1xuICAgICAgfSk7XG4gIH1cbiAgdmFyIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKGVzY2FwZWRTdHJpbmcsIGJsb2Nrcykge1xuICAgICAgICAgIHRoaXMuZXNjYXBlZFN0cmluZyA9IGVzY2FwZWRTdHJpbmc7XG4gICAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3M7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGVzY2FwZUJsb2NrcyhpbnB1dCkge1xuICAgICAgdmFyIGlucHV0UGFydHMgPSBpbnB1dC5zcGxpdChfY3VybHlSZSk7XG4gICAgICB2YXIgcmVzdWx0UGFydHMgPSBbXTtcbiAgICAgIHZhciBlc2NhcGVkQmxvY2tzID0gW107XG4gICAgICB2YXIgYnJhY2tldENvdW50ID0gMDtcbiAgICAgIHZhciBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgcGFydEluZGV4ID0gMDsgcGFydEluZGV4IDwgaW5wdXRQYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgaWYgKHBhcnQgPT0gQ0xPU0VfQ1VSTFkpIHtcbiAgICAgICAgICAgICAgYnJhY2tldENvdW50LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChicmFja2V0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydCA9PSBPUEVOX0NVUkxZKSB7XG4gICAgICAgICAgICAgIGJyYWNrZXRDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3MocmVzdWx0UGFydHMuam9pbignJyksIGVzY2FwZWRCbG9ja3MpO1xuICB9XG5cbiAgdmFyIENPTVBPTkVOVF9WQVJJQUJMRSA9ICclQ09NUCUnO1xuICB2YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICB2YXIgQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICB2YXIgU3R5bGVzQ29tcGlsZURlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3R5bGVzQ29tcGlsZURlcGVuZGVuY3kobW9kdWxlVXJsLCBpc1NoaW1tZWQsIHZhbHVlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLmlzU2hpbW1lZCA9IGlzU2hpbW1lZDtcbiAgICAgICAgICB0aGlzLnZhbHVlUGxhY2Vob2xkZXIgPSB2YWx1ZVBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xuICB9KCkpO1xuICB2YXIgU3R5bGVzQ29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZXNDb21waWxlUmVzdWx0KGNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHMpIHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudFN0eWxlc2hlZXQgPSBjb21wb25lbnRTdHlsZXNoZWV0O1xuICAgICAgICAgIHRoaXMuZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGV4dGVybmFsU3R5bGVzaGVldHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3R5bGVzQ29tcGlsZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVkU3R5bGVzaGVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlZFN0eWxlc2hlZXQoc3RhdGVtZW50cywgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMsIGlzU2hpbW1lZCwgbWV0YSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy5zdHlsZXNWYXIgPSBzdHlsZXNWYXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgICAgdGhpcy5pc1NoaW1tZWQgPSBpc1NoaW1tZWQ7XG4gICAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlZFN0eWxlc2hlZXQ7XG4gIH0oKSk7XG4gIHZhciBTdHlsZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0eWxlQ29tcGlsZXIoX3VybFJlc29sdmVyKSB7XG4gICAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5fc2hhZG93Q3NzID0gbmV3IFNoYWRvd0NzcygpO1xuICAgICAgfVxuICAgICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IFtdO1xuICAgICAgICAgIHZhciBjb21wb25lbnRTdHlsZXNoZWV0ID0gdGhpcy5fY29tcGlsZVN0eWxlcyhjb21wLCBuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHN0eWxlczogY29tcC50ZW1wbGF0ZS5zdHlsZXMsXG4gICAgICAgICAgICAgIHN0eWxlVXJsczogY29tcC50ZW1wbGF0ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogY29tcC50eXBlLm1vZHVsZVVybFxuICAgICAgICAgIH0pLCB0cnVlKTtcbiAgICAgICAgICBjb21wLnRlbXBsYXRlLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBpbGVkU3R5bGVzaGVldCA9IF90aGlzLl9jb21waWxlU3R5bGVzKGNvbXAsIHN0eWxlc2hlZXRNZXRhLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHMucHVzaChjb21waWxlZFN0eWxlc2hlZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgU3R5bGVzQ29tcGlsZVJlc3VsdChjb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzKTtcbiAgICAgIH07XG4gICAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVN0eWxlcyA9IGZ1bmN0aW9uIChjb21wLCBzdHlsZXNoZWV0LCBpc0NvbXBvbmVudFN0eWxlc2hlZXQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzaGltID0gY29tcC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkO1xuICAgICAgICAgIHZhciBzdHlsZUV4cHJlc3Npb25zID0gc3R5bGVzaGVldC5zdHlsZXMubWFwKGZ1bmN0aW9uIChwbGFpblN0eWxlKSB7IHJldHVybiBsaXRlcmFsKF90aGlzLl9zaGltSWZOZWVkZWQocGxhaW5TdHlsZSwgc2hpbSkpOyB9KTtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0LnN0eWxlVXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZ2V0U3R5bGVzVmFyTmFtZShudWxsKSB9KTtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobmV3IFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KHN0eWxlc2hlZXQuc3R5bGVVcmxzW2ldLCBzaGltLCBpZGVudGlmaWVyKSk7XG4gICAgICAgICAgICAgIHN0eWxlRXhwcmVzc2lvbnMucHVzaChuZXcgRXh0ZXJuYWxFeHByKGlkZW50aWZpZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3R5bGVzIHZhcmlhYmxlIGNvbnRhaW5zIHBsYWluIHN0cmluZ3MgYW5kIGFycmF5cyBvZiBvdGhlciBzdHlsZXMgYXJyYXlzIChyZWN1cnNpdmUpLFxuICAgICAgICAgIC8vIHNvIHdlIHNldCBpdHMgdHlwZSB0byBkeW5hbWljLlxuICAgICAgICAgIHZhciBzdHlsZXNWYXIgPSBnZXRTdHlsZXNWYXJOYW1lKGlzQ29tcG9uZW50U3R5bGVzaGVldCA/IGNvbXAgOiBudWxsKTtcbiAgICAgICAgICB2YXIgc3RtdCA9IHZhcmlhYmxlKHN0eWxlc1ZhcilcbiAgICAgICAgICAgICAgLnNldChsaXRlcmFsQXJyKHN0eWxlRXhwcmVzc2lvbnMsIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlZFN0eWxlc2hlZXQoW3N0bXRdLCBzdHlsZXNWYXIsIGRlcGVuZGVuY2llcywgc2hpbSwgc3R5bGVzaGVldCk7XG4gICAgICB9O1xuICAgICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX3NoaW1JZk5lZWRlZCA9IGZ1bmN0aW9uIChzdHlsZSwgc2hpbSkge1xuICAgICAgICAgIHJldHVybiBzaGltID8gdGhpcy5fc2hhZG93Q3NzLnNoaW1Dc3NUZXh0KHN0eWxlLCBDT05URU5UX0FUVFIsIEhPU1RfQVRUUikgOiBzdHlsZTtcbiAgICAgIH07XG4gICAgICBTdHlsZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFN0eWxlQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBVcmxSZXNvbHZlciwgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gU3R5bGVDb21waWxlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZ2V0U3R5bGVzVmFyTmFtZShjb21wb25lbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBcInN0eWxlc1wiO1xuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgIHJlc3VsdCArPSBcIl9cIiArIGNvbXBvbmVudC50eXBlLm5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGludGVybmFsIG1vZHVsZSBvZiB0aGUgQW5ndWxhciBjb21waWxlciB0aGF0IGJlZ2lucyB3aXRoIGNvbXBvbmVudCB0eXBlcyxcbiAgICogZXh0cmFjdHMgdGVtcGxhdGVzLCBhbmQgZXZlbnR1YWxseSBwcm9kdWNlcyBhIGNvbXBpbGVkIHZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgKiByZWFkeSBmb3IgbGlua2luZyBpbnRvIGFuIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAc2VjdXJpdHkgIFdoZW4gY29tcGlsaW5nIHRlbXBsYXRlcyBhdCBydW50aW1lLCB5b3UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgZW50aXJlIHRlbXBsYXRlIGNvbWVzXG4gICAqIGZyb20gYSB0cnVzdGVkIHNvdXJjZS4gQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYSB0ZW1wbGF0ZSBjb3VsZCBleHBvc2UgeW91clxuICAgKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuICBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gICAqL1xuICB2YXIgUnVudGltZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJ1bnRpbWVDb21waWxlcihfaW5qZWN0b3IsIF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX2RpcmVjdGl2ZVdyYXBwZXJDb21waWxlciwgX2NvbXBpbGVyQ29uZmlnLCBfYW5pbWF0aW9uUGFyc2VyKSB7XG4gICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciA9IF9tZXRhZGF0YVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3N0eWxlQ29tcGlsZXIgPSBfc3R5bGVDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIgPSBfZGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVyQ29uZmlnID0gX2NvbXBpbGVyQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblBhcnNlciA9IF9hbmltYXRpb25QYXJzZXI7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWREaXJlY3RpdmVXcmFwcGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbXBpbGVyID0gbmV3IEFuaW1hdGlvbkNvbXBpbGVyKCk7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMobW9kdWxlVHlwZSwgdHJ1ZSkuc3luY1Jlc3VsdDtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzKG1vZHVsZVR5cGUsIGZhbHNlKS5hc3luY1Jlc3VsdDtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzKG1vZHVsZVR5cGUsIHRydWUpLnN5bmNSZXN1bHQ7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMobW9kdWxlVHlwZSwgZmFsc2UpLmFzeW5jUmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGxvYWRpbmdQcm9taXNlID0gdGhpcy5fbG9hZE1vZHVsZXMobW9kdWxlVHlwZSwgaXNTeW5jKTtcbiAgICAgICAgICB2YXIgY3JlYXRlUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5fY29tcGlsZUNvbXBvbmVudHMobW9kdWxlVHlwZSwgbnVsbCk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGlsZU1vZHVsZShtb2R1bGVUeXBlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQoY3JlYXRlUmVzdWx0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQobnVsbCwgbG9hZGluZ1Byb21pc2UudGhlbihjcmVhdGVSZXN1bHQpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbG9hZGluZ1Byb21pc2UgPSB0aGlzLl9sb2FkTW9kdWxlcyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgIHZhciBjcmVhdGVSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRzKG1vZHVsZVR5cGUsIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfY29yZS5Nb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzKF90aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpLCBjb21wb25lbnRGYWN0b3JpZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChjcmVhdGVSZXN1bHQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChudWxsLCBsb2FkaW5nUHJvbWlzZS50aGVuKGNyZWF0ZVJlc3VsdCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9sb2FkTW9kdWxlcyA9IGZ1bmN0aW9uIChtYWluTW9kdWxlLCBpc1N5bmMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZU1ldGFkYXRhKG1haW5Nb2R1bGUsIGlzU3luYyksIG5nTW9kdWxlID0gX2EubmdNb2R1bGUsIGxvYWRpbmcgPSBfYS5sb2FkaW5nO1xuICAgICAgICAgIGxvYWRpbmdQcm9taXNlcy5wdXNoKGxvYWRpbmcpO1xuICAgICAgICAgIC8vIE5vdGU6IHRoZSBsb2FkaW5nUHJvbWlzZSBmb3IgYSBtb2R1bGUgb25seSBpbmNsdWRlcyB0aGUgbG9hZGluZyBvZiB0aGUgZXhwb3J0ZWQgZGlyZWN0aXZlc1xuICAgICAgICAgIC8vIG9mIGltcG9ydGVkIG1vZHVsZXMuXG4gICAgICAgICAgLy8gSG93ZXZlciwgZm9yIHJ1bnRpbWUgY29tcGlsYXRpb24sIHdlIHdhbnQgdG8gdHJhbnNpdGl2ZWx5IGNvbXBpbGUgYWxsIG1vZHVsZXMsXG4gICAgICAgICAgLy8gc28gd2UgYWxzbyBuZWVkIHRvIGNhbGwgbG9hZE5nTW9kdWxlTWV0YWRhdGEgZm9yIGFsbCBuZXN0ZWQgbW9kdWxlcy5cbiAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICAgIGxvYWRpbmdQcm9taXNlcy5wdXNoKF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSwgaXNTeW5jKVxuICAgICAgICAgICAgICAgICAgLmxvYWRpbmcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeSA9IHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5nZXQobW9kdWxlVHlwZSk7XG4gICAgICAgICAgaWYgKCFuZ01vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgdmFyIG1vZHVsZU1ldGFfMSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgLy8gQWx3YXlzIHByb3ZpZGUgYSBib3VuZCBDb21waWxlclxuICAgICAgICAgICAgICB2YXIgZXh0cmFQcm92aWRlcnMgPSBbdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQcm92aWRlck1ldGFkYXRhKG5ldyBQcm92aWRlck1ldGEoX2FuZ3VsYXJfY29yZS5Db21waWxlciwgeyB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTW9kdWxlQm91bmRDb21waWxlcihfdGhpcywgbW9kdWxlTWV0YV8xLnR5cGUucmVmZXJlbmNlKTsgfSB9KSldO1xuICAgICAgICAgICAgICB2YXIgY29tcGlsZVJlc3VsdCA9IHRoaXMuX25nTW9kdWxlQ29tcGlsZXIuY29tcGlsZShtb2R1bGVNZXRhXzEsIGV4dHJhUHJvdmlkZXJzKTtcbiAgICAgICAgICAgICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICAgICAgICBkZXAucGxhY2Vob2xkZXIucmVmZXJlbmNlID1cbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXNzZXJ0Q29tcG9uZW50S25vd24oZGVwLmNvbXAucmVmZXJlbmNlLCB0cnVlKS5wcm94eUNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICBkZXAucGxhY2Vob2xkZXIubmFtZSA9IFwiY29tcEZhY3RvcnlfXCIgKyBkZXAuY29tcC5uYW1lO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgICAgIG5nTW9kdWxlRmFjdG9yeSA9XG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0U3RhdGVtZW50cyhjb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIGNvbXBpbGVSZXN1bHQubmdNb2R1bGVGYWN0b3J5VmFyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5nTW9kdWxlRmFjdG9yeSA9IGppdFN0YXRlbWVudHMoXCIvXCIgKyBtb2R1bGVNZXRhXzEudHlwZS5uYW1lICsgXCIvbW9kdWxlLm5nZmFjdG9yeS5qc1wiLCBjb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIGNvbXBpbGVSZXN1bHQubmdNb2R1bGVGYWN0b3J5VmFyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9jb21waWxlZE5nTW9kdWxlQ2FjaGUuc2V0KG1vZHVsZU1ldGFfMS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGVGYWN0b3J5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5nTW9kdWxlRmFjdG9yeTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICovXG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChtYWluTW9kdWxlLCBhbGxDb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBuZ01vZHVsZSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtYWluTW9kdWxlKTtcbiAgICAgICAgICB2YXIgbW9kdWxlQnlEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgIHZhciBsb2NhbE1vZHVsZU1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kdWxlU3VtbWFyeS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlySWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgbW9kdWxlQnlEaXJlY3RpdmUuc2V0KGRpcklkZW50aWZpZXIucmVmZXJlbmNlLCBsb2NhbE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgdmFyIGRpck1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fY29tcGlsZURpcmVjdGl2ZVdyYXBwZXIoZGlyTWV0YSwgbG9jYWxNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZShkaXJNZXRhLCBsb2NhbE1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsQ29tcG9uZW50RmFjdG9yaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShkaXJNZXRhLnR5cGUucmVmZXJlbmNlLCBsb2NhbE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKHRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ29tcG9uZW50RmFjdG9yaWVzLnB1c2godGVtcGxhdGUucHJveHlDb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbE1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgdmFyIGxvY2FsTW9kdWxlTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobG9jYWxNb2R1bGVTdW1tYXJ5LnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgbG9jYWxNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGlyTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcklkZW50aWZpZXIucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gbW9kdWxlQnlEaXJlY3RpdmUuZ2V0KGVudHJ5Q29tcG9uZW50VHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUucmVmZXJlbmNlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZU1ldGEgPSBtb2R1bGVCeURpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUucmVmZXJlbmNlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW1wbGF0ZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVUZW1wbGF0ZSh0ZW1wbGF0ZSk7IH0pO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGVGb3IodHlwZSk7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICAgIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUgPSBmdW5jdGlvbiAoY29tcFR5cGUsIG5nTW9kdWxlKSB7XG4gICAgICAgICAgaWYgKCFuZ01vZHVsZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgbm90IHBhcnQgb2YgYW55IE5nTW9kdWxlIG9yIHRoZSBtb2R1bGUgaGFzIG5vdCBiZWVuIGltcG9ydGVkIGludG8geW91ciBtb2R1bGUuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBUeXBlKTtcbiAgICAgICAgICBpZiAoIWNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShjb21wVHlwZSk7XG4gICAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICAgIHZhciBob3N0TWV0YSA9IGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhKTtcbiAgICAgICAgICAgICAgY29tcGlsZWRUZW1wbGF0ZSA9IG5ldyBDb21waWxlZFRlbXBsYXRlKHRydWUsIGNvbXBNZXRhLnNlbGVjdG9yLCBjb21wTWV0YS50eXBlLCBob3N0TWV0YSwgbmdNb2R1bGUsIFtjb21wTWV0YS50eXBlXSk7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuc2V0KGNvbXBUeXBlLCBjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgbmdNb2R1bGUpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgICBjb21waWxlZFRlbXBsYXRlID0gbmV3IENvbXBpbGVkVGVtcGxhdGUoZmFsc2UsIGNvbXBNZXRhLnNlbGVjdG9yLCBjb21wTWV0YS50eXBlLCBjb21wTWV0YSwgbmdNb2R1bGUsIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5zZXQoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UsIGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9hc3NlcnRDb21wb25lbnRLbm93biA9IGZ1bmN0aW9uIChjb21wVHlwZSwgaXNIb3N0KSB7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSBpc0hvc3QgPyB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmdldChjb21wVHlwZSkgOlxuICAgICAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBUeXBlKTtcbiAgICAgICAgICBpZiAoIWNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogQ29tcGlsZWQgdmlldyBmb3IgY29tcG9uZW50IFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIChob3N0OiBcIiArIGlzSG9zdCArIFwiKSBkb2VzIG5vdCBleGlzdCFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2Fzc2VydERpcmVjdGl2ZVdyYXBwZXIgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICAgIHZhciBkaXJXcmFwcGVyID0gdGhpcy5fY29tcGlsZWREaXJlY3RpdmVXcmFwcGVyQ2FjaGUuZ2V0KGRpclR5cGUpO1xuICAgICAgICAgIGlmICghZGlyV3JhcHBlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBEaXJlY3RpdmUgd3JhcHBlciBmb3IgXCIgKyBzdHJpbmdpZnkoZGlyVHlwZSkgKyBcIiBoYXMgbm90IGJlZW4gY29tcGlsZWQhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlyV3JhcHBlcjtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlRGlyZWN0aXZlV3JhcHBlciA9IGZ1bmN0aW9uIChkaXJNZXRhLCBtb2R1bGVNZXRhKSB7XG4gICAgICAgICAgdmFyIGNvbXBpbGVSZXN1bHQgPSB0aGlzLl9kaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIuY29tcGlsZShkaXJNZXRhKTtcbiAgICAgICAgICB2YXIgc3RhdGVtZW50cyA9IGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cztcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlV3JhcHBlckNsYXNzO1xuICAgICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZVdyYXBwZXJDbGFzcyA9IGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5kaXJXcmFwcGVyQ2xhc3NWYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlV3JhcHBlckNsYXNzID0gaml0U3RhdGVtZW50cyhcIi9cIiArIG1vZHVsZU1ldGEudHlwZS5uYW1lICsgXCIvXCIgKyBkaXJNZXRhLnR5cGUubmFtZSArIFwiL3dyYXBwZXIubmdmYWN0b3J5LmpzXCIsIHN0YXRlbWVudHMsIGNvbXBpbGVSZXN1bHQuZGlyV3JhcHBlckNsYXNzVmFyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWREaXJlY3RpdmVXcmFwcGVyQ2FjaGUuc2V0KGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIGRpcmVjdGl2ZVdyYXBwZXJDbGFzcyk7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodGVtcGxhdGUuaXNDb21waWxlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb21wTWV0YSA9IHRlbXBsYXRlLmNvbXBNZXRhO1xuICAgICAgICAgIHZhciBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdmFyIHN0eWxlc0NvbXBpbGVSZXN1bHQgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgIHN0eWxlc0NvbXBpbGVSZXN1bHQuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybC5zZXQoci5tZXRhLm1vZHVsZVVybCwgcik7IH0pO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHN0eWxlc0NvbXBpbGVSZXN1bHQuY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICB2YXIgcGFyc2VkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvblBhcnNlci5wYXJzZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSB0ZW1wbGF0ZS5kaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVTdW1tYXJ5KGRpci5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICB2YXIgcGlwZXMgPSB0ZW1wbGF0ZS5uZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzLm1hcChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZVN1bW1hcnkocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICB2YXIgcGFyc2VkVGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCB0ZW1wbGF0ZS5uZ01vZHVsZS5zY2hlbWFzLCBjb21wTWV0YS50eXBlLm5hbWUpO1xuICAgICAgICAgIHZhciBjb21waWxlZEFuaW1hdGlvbnMgPSB0aGlzLl9hbmltYXRpb25Db21waWxlci5jb21waWxlKGNvbXBNZXRhLnR5cGUubmFtZSwgcGFyc2VkQW5pbWF0aW9ucyk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVSZXN1bHQgPSB0aGlzLl92aWV3Q29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChjb21wTWV0YSwgcGFyc2VkVGVtcGxhdGUsIHZhcmlhYmxlKHN0eWxlc0NvbXBpbGVSZXN1bHQuY29tcG9uZW50U3R5bGVzaGVldC5zdHlsZXNWYXIpLCBwaXBlcywgY29tcGlsZWRBbmltYXRpb25zKTtcbiAgICAgICAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgdmFyIGRlcFRlbXBsYXRlO1xuICAgICAgICAgICAgICBpZiAoZGVwIGluc3RhbmNlb2YgVmlld0NsYXNzRGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHZmZCA9IGRlcDtcbiAgICAgICAgICAgICAgICAgIGRlcFRlbXBsYXRlID0gX3RoaXMuX2Fzc2VydENvbXBvbmVudEtub3duKHZmZC5jb21wLnJlZmVyZW5jZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgdmZkLnBsYWNlaG9sZGVyLnJlZmVyZW5jZSA9IGRlcFRlbXBsYXRlLnByb3h5Vmlld0NsYXNzO1xuICAgICAgICAgICAgICAgICAgdmZkLnBsYWNlaG9sZGVyLm5hbWUgPSBcIlZpZXdfXCIgKyB2ZmQuY29tcC5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRlcCBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2ZkID0gZGVwO1xuICAgICAgICAgICAgICAgICAgZGVwVGVtcGxhdGUgPSBfdGhpcy5fYXNzZXJ0Q29tcG9uZW50S25vd24oY2ZkLmNvbXAucmVmZXJlbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIGNmZC5wbGFjZWhvbGRlci5yZWZlcmVuY2UgPSBkZXBUZW1wbGF0ZS5wcm94eUNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIubmFtZSA9IFwiY29tcEZhY3RvcnlfXCIgKyBjZmQuY29tcC5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRlcCBpbnN0YW5jZW9mIERpcmVjdGl2ZVdyYXBwZXJEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZHdkID0gZGVwO1xuICAgICAgICAgICAgICAgICAgZHdkLnBsYWNlaG9sZGVyLnJlZmVyZW5jZSA9IF90aGlzLl9hc3NlcnREaXJlY3RpdmVXcmFwcGVyKGR3ZC5kaXIucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gKF9hID0gc3R5bGVzQ29tcGlsZVJlc3VsdC5jb21wb25lbnRTdHlsZXNoZWV0LnN0YXRlbWVudHMpLmNvbmNhdC5hcHBseShfYSwgY29tcGlsZWRBbmltYXRpb25zLm1hcChmdW5jdGlvbiAoY2EpIHsgcmV0dXJuIGNhLnN0YXRlbWVudHM7IH0pKVxuICAgICAgICAgICAgICAuY29uY2F0KGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgICAgdmFyIHZpZXdDbGFzcztcbiAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgICB2aWV3Q2xhc3MgPSBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGNvbXBpbGVSZXN1bHQudmlld0NsYXNzVmFyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZpZXdDbGFzcyA9IGppdFN0YXRlbWVudHMoXCIvXCIgKyB0ZW1wbGF0ZS5uZ01vZHVsZS50eXBlLm5hbWUgKyBcIi9cIiArIHRlbXBsYXRlLmNvbXBUeXBlLm5hbWUgKyBcIi9cIiArICh0ZW1wbGF0ZS5pc0hvc3QgPyAnaG9zdCcgOiAnY29tcG9uZW50JykgKyBcIi5uZ2ZhY3RvcnkuanNcIiwgc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC52aWV3Q2xhc3NWYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wbGF0ZS5jb21waWxlZCh2aWV3Q2xhc3MpO1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXAsIGkpIHtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZENvbXBpbGVSZXN1bHQgPSBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuZ2V0KGRlcC5tb2R1bGVVcmwpO1xuICAgICAgICAgICAgICB2YXIgbmVzdGVkU3R5bGVzQXJyID0gX3RoaXMuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdChuZXN0ZWRDb21waWxlUmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpO1xuICAgICAgICAgICAgICBkZXAudmFsdWVQbGFjZWhvbGRlci5yZWZlcmVuY2UgPSBuZXN0ZWRTdHlsZXNBcnI7XG4gICAgICAgICAgICAgIGRlcC52YWx1ZVBsYWNlaG9sZGVyLm5hbWUgPSBcImltcG9ydGVkU3R5bGVzXCIgKyBpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0U3RhdGVtZW50cyhyZXN1bHQuc3RhdGVtZW50cywgcmVzdWx0LnN0eWxlc1Zhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaml0U3RhdGVtZW50cyhcIi9cIiArIHJlc3VsdC5tZXRhLm1vZHVsZVVybCArIFwiLmNzcy5qc1wiLCByZXN1bHQuc3RhdGVtZW50cywgcmVzdWx0LnN0eWxlc1Zhcik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBSdW50aW1lQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCB9LFxuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBUZW1wbGF0ZVBhcnNlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFN0eWxlQ29tcGlsZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBWaWV3Q29tcGlsZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBOZ01vZHVsZUNvbXBpbGVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgICAgICAgeyB0eXBlOiBBbmltYXRpb25QYXJzZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFJ1bnRpbWVDb21waWxlcjtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVkVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZWRUZW1wbGF0ZShpc0hvc3QsIHNlbGVjdG9yLCBjb21wVHlwZSwgY29tcE1ldGEsIG5nTW9kdWxlLCBkaXJlY3RpdmVzKSB7XG4gICAgICAgICAgdGhpcy5pc0hvc3QgPSBpc0hvc3Q7XG4gICAgICAgICAgdGhpcy5jb21wVHlwZSA9IGNvbXBUeXBlO1xuICAgICAgICAgIHRoaXMuY29tcE1ldGEgPSBjb21wTWV0YTtcbiAgICAgICAgICB0aGlzLm5nTW9kdWxlID0gbmdNb2R1bGU7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgICB0aGlzLl92aWV3Q2xhc3MgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaXNDb21waWxlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB0aGlzLnByb3h5Vmlld0NsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIXNlbGYuX3ZpZXdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogQ29tcGlsZWRUZW1wbGF0ZSBmb3IgXCIgKyBzdHJpbmdpZnkoc2VsZi5jb21wVHlwZSkgKyBcIiBpcyBub3QgY29tcGlsZWQgeWV0IVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fdmlld0NsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnByb3h5Q29tcG9uZW50RmFjdG9yeSA9IGlzSG9zdCA/XG4gICAgICAgICAgICAgIG5ldyBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIHRoaXMucHJveHlWaWV3Q2xhc3MsIGNvbXBUeXBlLnJlZmVyZW5jZSkgOlxuICAgICAgICAgICAgICBudWxsO1xuICAgICAgfVxuICAgICAgQ29tcGlsZWRUZW1wbGF0ZS5wcm90b3R5cGUuY29tcGlsZWQgPSBmdW5jdGlvbiAodmlld0NsYXNzKSB7XG4gICAgICAgICAgdGhpcy5fdmlld0NsYXNzID0gdmlld0NsYXNzO1xuICAgICAgICAgIHRoaXMucHJveHlWaWV3Q2xhc3MucHJvdG90eXBlID0gdmlld0NsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlZFRlbXBsYXRlO1xuICB9KCkpO1xuICBmdW5jdGlvbiBhc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgICAgaWYgKCFtZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgbWV0YS50eXBlLm5hbWUgKyBcIicgYmVjYXVzZSBpdCBpcyBub3QgYSBjb21wb25lbnQuXCIpO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBDb21waWxlcmAgYnkgZGVsZWdhdGluZyB0byB0aGUgUnVudGltZUNvbXBpbGVyIHVzaW5nIGEga25vd24gbW9kdWxlLlxuICAgKi9cbiAgdmFyIE1vZHVsZUJvdW5kQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTW9kdWxlQm91bmRDb21waWxlcihfZGVsZWdhdGUsIF9uZ01vZHVsZSkge1xuICAgICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlID0gX25nTW9kdWxlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLCBcIl9pbmplY3RvclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pbmplY3RvcjsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVTeW5jKG1vZHVsZVR5cGUpO1xuICAgICAgfTtcbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBc3luYyhtb2R1bGVUeXBlKTtcbiAgICAgIH07XG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMobW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMobW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDbGVhcnMgYWxsIGNhY2hlc1xuICAgICAgICovXG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kZWxlZ2F0ZS5jbGVhckNhY2hlKCk7IH07XG4gICAgICAvKipcbiAgICAgICAqIENsZWFycyB0aGUgY2FjaGUgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQvbmdNb2R1bGUuXG4gICAgICAgKi9cbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkgeyB0aGlzLl9kZWxlZ2F0ZS5jbGVhckNhY2hlRm9yKHR5cGUpOyB9O1xuICAgICAgcmV0dXJuIE1vZHVsZUJvdW5kQ29tcGlsZXI7XG4gIH0oKSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vXG4gIC8vICAgICAgICBETyBOT1QgRURJVCBUSElTIExJU1QgT0YgU0VDVVJJVFkgU0VOU0lUSVZFIFBST1BFUlRJRVMgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY2ggb3V0IHRvIG1wcm9ic3QgZm9yIGRldGFpbHMuXG4gIC8vXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLyoqIE1hcCBmcm9tIHRhZ05hbWV8cHJvcGVydHlOYW1lIFNlY3VyaXR5Q29udGV4dC4gUHJvcGVydGllcyBhcHBseWluZyB0byBhbGwgdGFncyB1c2UgJyonLiAqL1xuICB2YXIgU0VDVVJJVFlfU0NIRU1BID0ge307XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dChjdHgsIHNwZWNzKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIHNwZWNzXzEgPSBzcGVjczsgX2kgPCBzcGVjc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBzcGVjID0gc3BlY3NfMVtfaV07XG4gICAgICAgICAgU0VDVVJJVFlfU0NIRU1BW3NwZWMudG9Mb3dlckNhc2UoKV0gPSBjdHg7XG4gICAgICB9XG4gIH1cbiAgLy8gQ2FzZSBpcyBpbnNpZ25pZmljYW50IGJlbG93LCBhbGwgZWxlbWVudCBhbmQgYXR0cmlidXRlIG5hbWVzIGFyZSBsb3dlci1jYXNlZCBmb3IgbG9va3VwLlxuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuSFRNTCwgW1xuICAgICAgJ2lmcmFtZXxzcmNkb2MnLFxuICAgICAgJyp8aW5uZXJIVE1MJyxcbiAgICAgICcqfG91dGVySFRNTCcsXG4gIF0pO1xuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuU1RZTEUsIFsnKnxzdHlsZSddKTtcbiAgLy8gTkI6IG5vIFNDUklQVCBjb250ZXh0cyBoZXJlLCB0aGV5IGFyZSBuZXZlciBhbGxvd2VkIGR1ZSB0byB0aGUgcGFyc2VyIHN0cmlwcGluZyB0aGVtLlxuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuVVJMLCBbXG4gICAgICAnKnxmb3JtQWN0aW9uJywgJ2FyZWF8aHJlZicsICdhcmVhfHBpbmcnLCAnYXVkaW98c3JjJywgJ2F8aHJlZicsXG4gICAgICAnYXxwaW5nJywgJ2Jsb2NrcXVvdGV8Y2l0ZScsICdib2R5fGJhY2tncm91bmQnLCAnZGVsfGNpdGUnLCAnZm9ybXxhY3Rpb24nLFxuICAgICAgJ2ltZ3xzcmMnLCAnaW1nfHNyY3NldCcsICdpbnB1dHxzcmMnLCAnaW5zfGNpdGUnLCAncXxjaXRlJyxcbiAgICAgICdzb3VyY2V8c3JjJywgJ3NvdXJjZXxzcmNzZXQnLCAndHJhY2t8c3JjJywgJ3ZpZGVvfHBvc3RlcicsICd2aWRlb3xzcmMnLFxuICBdKTtcbiAgcmVnaXN0ZXJDb250ZXh0KF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgW1xuICAgICAgJ2FwcGxldHxjb2RlJyxcbiAgICAgICdhcHBsZXR8Y29kZWJhc2UnLFxuICAgICAgJ2Jhc2V8aHJlZicsXG4gICAgICAnZW1iZWR8c3JjJyxcbiAgICAgICdmcmFtZXxzcmMnLFxuICAgICAgJ2hlYWR8cHJvZmlsZScsXG4gICAgICAnaHRtbHxtYW5pZmVzdCcsXG4gICAgICAnaWZyYW1lfHNyYycsXG4gICAgICAnbGlua3xocmVmJyxcbiAgICAgICdtZWRpYXxzcmMnLFxuICAgICAgJ29iamVjdHxjb2RlYmFzZScsXG4gICAgICAnb2JqZWN0fGRhdGEnLFxuICAgICAgJ3NjcmlwdHxzcmMnLFxuICBdKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMjEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBCT09MRUFOID0gJ2Jvb2xlYW4nO1xuICB2YXIgTlVNQkVSID0gJ251bWJlcic7XG4gIHZhciBTVFJJTkcgPSAnc3RyaW5nJztcbiAgdmFyIE9CSkVDVCA9ICdvYmplY3QnO1xuICAvKipcbiAgICogVGhpcyBhcnJheSByZXByZXNlbnRzIHRoZSBET00gc2NoZW1hLiBJdCBlbmNvZGVzIGluaGVyaXRhbmNlLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLlxuICAgKlxuICAgKiAjIyBPdmVydmlld1xuICAgKlxuICAgKiBFYWNoIGxpbmUgcmVwcmVzZW50cyBvbmUga2luZCBvZiBlbGVtZW50LiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGFuZCBwcm9wZXJ0aWVzIGFyZSBqb2luZWRcbiAgICogdXNpbmcgYGVsZW1lbnRfaW5oZXJpdGFuY2V8cHJvcGVydGllc2Agc3ludGF4LlxuICAgKlxuICAgKiAjIyBFbGVtZW50IEluaGVyaXRhbmNlXG4gICAqXG4gICAqIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgY2FuIGJlIGZ1cnRoZXIgc3ViZGl2aWRlZCBhcyBgZWxlbWVudDEsZWxlbWVudDIsLi4uXnBhcmVudEVsZW1lbnRgLlxuICAgKiBIZXJlIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFdmVyeSBlbGVtZW50IGluIHRoZSBsaXN0XG4gICAqIGhhcyBpZGVudGljYWwgcHJvcGVydGllcy5cbiAgICpcbiAgICogQW4gYGVsZW1lbnRgIG1heSBpbmhlcml0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIGBwYXJlbnRFbGVtZW50YCBJZiBubyBgXnBhcmVudEVsZW1lbnRgIGlzXG4gICAqIHNwZWNpZmllZCB0aGVuIGBcIlwiYCAoYmxhbmspIGVsZW1lbnQgaXMgYXNzdW1lZC5cbiAgICpcbiAgICogTk9URTogVGhlIGJsYW5rIGVsZW1lbnQgaW5oZXJpdHMgZnJvbSByb290IGBbRWxlbWVudF1gIGVsZW1lbnQsIHRoZSBzdXBlciBlbGVtZW50IG9mIGFsbFxuICAgKiBlbGVtZW50cy5cbiAgICpcbiAgICogTk9URSBhbiBlbGVtZW50IHByZWZpeCBzdWNoIGFzIGA6c3ZnOmAgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyB0byB0aGUgc2NoZW1hLlxuICAgKlxuICAgKiAjIyBQcm9wZXJ0aWVzXG4gICAqXG4gICAqIEVhY2ggZWxlbWVudCBoYXMgYSBzZXQgb2YgcHJvcGVydGllcyBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFYWNoIHByb3BlcnR5IGNhbiBiZSBwcmVmaXhlZFxuICAgKiBieSBhIHNwZWNpYWwgY2hhcmFjdGVyIGRlc2lnbmF0aW5nIGl0cyB0eXBlOlxuICAgKlxuICAgKiAtIChubyBwcmVmaXgpOiBwcm9wZXJ0eSBpcyBhIHN0cmluZy5cbiAgICogLSBgKmA6IHByb3BlcnR5IHJlcHJlc2VudHMgYW4gZXZlbnQuXG4gICAqIC0gYCFgOiBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4uXG4gICAqIC0gYCNgOiBwcm9wZXJ0eSBpcyBhIG51bWJlci5cbiAgICogLSBgJWA6IHByb3BlcnR5IGlzIGFuIG9iamVjdC5cbiAgICpcbiAgICogIyMgUXVlcnlcbiAgICpcbiAgICogVGhlIGNsYXNzIGNyZWF0ZXMgYW4gaW50ZXJuYWwgc3F1YXMgcmVwcmVzZW50YXRpb24gd2hpY2ggYWxsb3dzIHRvIGVhc2lseSBhbnN3ZXIgdGhlIHF1ZXJ5IG9mXG4gICAqIGlmIGEgZ2l2ZW4gcHJvcGVydHkgZXhpc3Qgb24gYSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBOT1RFOiBXZSBkb24ndCB5ZXQgc3VwcG9ydCBxdWVyeWluZyBmb3IgdHlwZXMgb3IgZXZlbnRzLlxuICAgKiBOT1RFOiBUaGlzIHNjaGVtYSBpcyBhdXRvIGV4dHJhY3RlZCBmcm9tIGBzY2hlbWFfZXh0cmFjdG9yLnRzYCBsb2NhdGVkIGluIHRoZSB0ZXN0IGZvbGRlcixcbiAgICogICAgICAgc2VlIGRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeV9zcGVjLnRzXG4gICAqL1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy9cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIERPIE5PVCBFRElUIFRISVMgRE9NIFNDSEVNQSBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuICAvL1xuICAvLyBOZXdseSBhZGRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgc2VjdXJpdHkgcmV2aWV3ZWQgYW5kIGFzc2lnbmVkIGFuIGFwcHJvcHJpYXRlIFNlY3VyaXR5Q29udGV4dCBpblxuICAvLyBkb21fc2VjdXJpdHlfc2NoZW1hLnRzLiBSZWFjaCBvdXQgdG8gbXByb2JzdCAmIHJqYW1ldCBmb3IgZGV0YWlscy5cbiAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgU0NIRU1BID0gW1xuICAgICAgJ1tFbGVtZW50XXx0ZXh0Q29udGVudCwlY2xhc3NMaXN0LGNsYXNzTmFtZSxpZCxpbm5lckhUTUwsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmNvcHksKmN1dCwqcGFzdGUsKnNlYXJjaCwqc2VsZWN0c3RhcnQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJIVE1MLCNzY3JvbGxMZWZ0LCNzY3JvbGxUb3AnLFxuICAgICAgJ1tIVE1MRWxlbWVudF1eW0VsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY29weSwqY3VlY2hhbmdlLCpjdXQsKmRibGNsaWNrLCpkcmFnLCpkcmFnZW5kLCpkcmFnZW50ZXIsKmRyYWdsZWF2ZSwqZHJhZ292ZXIsKmRyYWdzdGFydCwqZHJvcCwqZHVyYXRpb25jaGFuZ2UsKmVtcHRpZWQsKmVuZGVkLCplcnJvciwqZm9jdXMsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKm1lc3NhZ2UsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCpwYXN0ZSwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlYXJjaCwqc2Vla2VkLCpzZWVraW5nLCpzZWxlY3QsKnNlbGVjdHN0YXJ0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCwqd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwqd2Via2l0ZnVsbHNjcmVlbmVycm9yLCp3aGVlbCxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAgICdhYmJyLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiLGJkaSxiZG8sY2l0ZSxjb2RlLGRkLGRmbixkdCxlbSxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGksa2JkLG1haW4sbWFyayxuYXYsbm9zY3JpcHQscmIscnAscnQscnRjLHJ1YnkscyxzYW1wLHNlY3Rpb24sc21hbGwsc3Ryb25nLHN1YixzdXAsdSx2YXIsd2JyXltIVE1MRWxlbWVudF18YWNjZXNzS2V5LGNvbnRlbnRFZGl0YWJsZSxkaXIsIWRyYWdnYWJsZSwhaGlkZGVuLGlubmVyVGV4dCxsYW5nLCphYm9ydCwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjb3B5LCpjdWVjaGFuZ2UsKmN1dCwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbWVzc2FnZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKm1vemZ1bGxzY3JlZW5jaGFuZ2UsKm1vemZ1bGxzY3JlZW5lcnJvciwqbW96cG9pbnRlcmxvY2tjaGFuZ2UsKm1venBvaW50ZXJsb2NrZXJyb3IsKnBhc3RlLCpwYXVzZSwqcGxheSwqcGxheWluZywqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2VhcmNoLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2VsZWN0c3RhcnQsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsKndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IsKndlYmdsY29udGV4dGxvc3QsKndlYmdsY29udGV4dHJlc3RvcmVkLCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVyVGV4dCwhc3BlbGxjaGVjaywlc3R5bGUsI3RhYkluZGV4LHRpdGxlLCF0cmFuc2xhdGUnLFxuICAgICAgJ21lZGlhXltIVE1MRWxlbWVudF18IWF1dG9wbGF5LCFjb250cm9scywlY3Jvc3NPcmlnaW4sI2N1cnJlbnRUaW1lLCFkZWZhdWx0TXV0ZWQsI2RlZmF1bHRQbGF5YmFja1JhdGUsIWRpc2FibGVSZW1vdGVQbGF5YmFjaywhbG9vcCwhbXV0ZWQsKmVuY3J5cHRlZCwjcGxheWJhY2tSYXRlLHByZWxvYWQsc3JjLCVzcmNPYmplY3QsI3ZvbHVtZScsXG4gICAgICAnOnN2ZzpeW0hUTUxFbGVtZW50XXwqYWJvcnQsKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICAgJzpzdmc6Z3JhcGhpY3NeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmFuaW1hdGlvbl46c3ZnOnwqYmVnaW4sKmVuZCwqcmVwZWF0JyxcbiAgICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgICAnOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9uXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpncmFkaWVudF46c3ZnOnwnLFxuICAgICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6dGV4dFBvc2l0aW9uaW5nXjpzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAgICdhXltIVE1MRWxlbWVudF18Y2hhcnNldCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsaHJlZmxhbmcsbmFtZSxwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHJldixzZWFyY2gsc2hhcGUsdGFyZ2V0LHRleHQsdHlwZSx1c2VybmFtZScsXG4gICAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3ksc2VhcmNoLHNoYXBlLHRhcmdldCx1c2VybmFtZScsXG4gICAgICAnYXVkaW9ebWVkaWF8JyxcbiAgICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAgICdiYXNlXltIVE1MRWxlbWVudF18aHJlZix0YXJnZXQnLFxuICAgICAgJ2JvZHleW0hUTUxFbGVtZW50XXxhTGluayxiYWNrZ3JvdW5kLGJnQ29sb3IsbGluaywqYmVmb3JldW5sb2FkLCpibHVyLCplcnJvciwqZm9jdXMsKmhhc2hjaGFuZ2UsKmxhbmd1YWdlY2hhbmdlLCpsb2FkLCptZXNzYWdlLCpvZmZsaW5lLCpvbmxpbmUsKnBhZ2VoaWRlLCpwYWdlc2hvdywqcG9wc3RhdGUsKnJlamVjdGlvbmhhbmRsZWQsKnJlc2l6ZSwqc2Nyb2xsLCpzdG9yYWdlLCp1bmhhbmRsZWRyZWplY3Rpb24sKnVubG9hZCx0ZXh0LHZMaW5rJyxcbiAgICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAgICdjYW52YXNeW0hUTUxFbGVtZW50XXwjaGVpZ2h0LCN3aWR0aCcsXG4gICAgICAnY29udGVudF5bSFRNTEVsZW1lbnRdfHNlbGVjdCcsXG4gICAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgICAnZGF0YWxpc3ReW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ2RldGFpbHNeW0hUTUxFbGVtZW50XXwhb3BlbicsXG4gICAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICAgJ2Rpcl5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAgICdkaXZeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgICAnZmllbGRzZXReW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbmFtZScsXG4gICAgICAnZm9udF5bSFRNTEVsZW1lbnRdfGNvbG9yLGZhY2Usc2l6ZScsXG4gICAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgICAnZnJhbWVeW0hUTUxFbGVtZW50XXxmcmFtZUJvcmRlcixsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSwhbm9SZXNpemUsc2Nyb2xsaW5nLHNyYycsXG4gICAgICAnZnJhbWVzZXReW0hUTUxFbGVtZW50XXxjb2xzLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHJvd3MnLFxuICAgICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgICAnaGVhZF5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnaDEsaDIsaDMsaDQsaDUsaDZeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICAgJ2lmcmFtZV5bSFRNTEVsZW1lbnRdfGFsaWduLCFhbGxvd0Z1bGxzY3JlZW4sZnJhbWVCb3JkZXIsaGVpZ2h0LGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLHJlZmVycmVyUG9saWN5LCVzYW5kYm94LHNjcm9sbGluZyxzcmMsc3JjZG9jLHdpZHRoJyxcbiAgICAgICdpbWdeW0hUTUxFbGVtZW50XXxhbGlnbixhbHQsYm9yZGVyLCVjcm9zc09yaWdpbiwjaGVpZ2h0LCNoc3BhY2UsIWlzTWFwLGxvbmdEZXNjLGxvd3NyYyxuYW1lLHJlZmVycmVyUG9saWN5LHNpemVzLHNyYyxzcmNzZXQsdXNlTWFwLCN2c3BhY2UsI3dpZHRoJyxcbiAgICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgICAna2V5Z2VuXltIVE1MRWxlbWVudF18IWF1dG9mb2N1cyxjaGFsbGVuZ2UsIWRpc2FibGVkLGtleXR5cGUsbmFtZScsXG4gICAgICAnbGleW0hUTUxFbGVtZW50XXx0eXBlLCN2YWx1ZScsXG4gICAgICAnbGFiZWxeW0hUTUxFbGVtZW50XXxodG1sRm9yJyxcbiAgICAgICdsZWdlbmReW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAnbGlua15bSFRNTEVsZW1lbnRdfGFzLGNoYXJzZXQsJWNyb3NzT3JpZ2luLCFkaXNhYmxlZCxocmVmLGhyZWZsYW5nLGludGVncml0eSxtZWRpYSxyZWwsJXJlbExpc3QscmV2LCVzaXplcyx0YXJnZXQsdHlwZScsXG4gICAgICAnbWFwXltIVE1MRWxlbWVudF18bmFtZScsXG4gICAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgICAnbWVudV5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAgICdtZXRhXltIVE1MRWxlbWVudF18Y29udGVudCxodHRwRXF1aXYsbmFtZSxzY2hlbWUnLFxuICAgICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAgICdpbnMsZGVsXltIVE1MRWxlbWVudF18Y2l0ZSxkYXRlVGltZScsXG4gICAgICAnb2xeW0hUTUxFbGVtZW50XXwhY29tcGFjdCwhcmV2ZXJzZWQsI3N0YXJ0LHR5cGUnLFxuICAgICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgICAnb3B0Z3JvdXBeW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbGFiZWwnLFxuICAgICAgJ29wdGlvbl5bSFRNTEVsZW1lbnRdfCFkZWZhdWx0U2VsZWN0ZWQsIWRpc2FibGVkLGxhYmVsLCFzZWxlY3RlZCx0ZXh0LHZhbHVlJyxcbiAgICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgICAncF5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdwYXJhbV5bSFRNTEVsZW1lbnRdfG5hbWUsdHlwZSx2YWx1ZSx2YWx1ZVR5cGUnLFxuICAgICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3ByZV5bSFRNTEVsZW1lbnRdfCN3aWR0aCcsXG4gICAgICAncHJvZ3Jlc3NeW0hUTUxFbGVtZW50XXwjbWF4LCN2YWx1ZScsXG4gICAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3NjcmlwdF5bSFRNTEVsZW1lbnRdfCFhc3luYyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGVmZXIsZXZlbnQsaHRtbEZvcixpbnRlZ3JpdHksc3JjLHRleHQsdHlwZScsXG4gICAgICAnc2VsZWN0XltIVE1MRWxlbWVudF18IWF1dG9mb2N1cywhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICAgJ3NoYWRvd15bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnc291cmNlXltIVE1MRWxlbWVudF18bWVkaWEsc2l6ZXMsc3JjLHNyY3NldCx0eXBlJyxcbiAgICAgICdzcGFuXltIVE1MRWxlbWVudF18JyxcbiAgICAgICdzdHlsZV5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxtZWRpYSx0eXBlJyxcbiAgICAgICdjYXB0aW9uXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICAgJ3RoLHRkXltIVE1MRWxlbWVudF18YWJicixhbGlnbixheGlzLGJnQ29sb3IsY2gsY2hPZmYsI2NvbFNwYW4saGVhZGVycyxoZWlnaHQsIW5vV3JhcCwjcm93U3BhbixzY29wZSx2QWxpZ24sd2lkdGgnLFxuICAgICAgJ2NvbCxjb2xncm91cF5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLCNzcGFuLHZBbGlnbix3aWR0aCcsXG4gICAgICAndGFibGVeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGJvcmRlciwlY2FwdGlvbixjZWxsUGFkZGluZyxjZWxsU3BhY2luZyxmcmFtZSxydWxlcyxzdW1tYXJ5LCV0Rm9vdCwldEhlYWQsd2lkdGgnLFxuICAgICAgJ3RyXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixjaCxjaE9mZix2QWxpZ24nLFxuICAgICAgJ3Rmb290LHRoZWFkLHRib2R5XltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsdkFsaWduJyxcbiAgICAgICd0ZW1wbGF0ZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAndGV4dGFyZWFeW0hUTUxFbGVtZW50XXxhdXRvY2FwaXRhbGl6ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAgICd0aXRsZV5bSFRNTEVsZW1lbnRdfHRleHQnLFxuICAgICAgJ3RyYWNrXltIVE1MRWxlbWVudF18IWRlZmF1bHQsa2luZCxsYWJlbCxzcmMsc3JjbGFuZycsXG4gICAgICAndWxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCx0eXBlJyxcbiAgICAgICd1bmtub3duXltIVE1MRWxlbWVudF18JyxcbiAgICAgICd2aWRlb15tZWRpYXwjaGVpZ2h0LHBvc3Rlciwjd2lkdGgnLFxuICAgICAgJzpzdmc6YV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzphbmltYXRlXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgICAnOnN2ZzphbmltYXRlTW90aW9uXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgICAnOnN2ZzphbmltYXRlVHJhbnNmb3JtXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgICAnOnN2ZzpjaXJjbGVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6Y2xpcFBhdGheOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6Y3Vyc29yXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpkZWZzXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOmRlc2NeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmRpc2NhcmReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmVsbGlwc2VeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6ZmVCbGVuZF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb2xvck1hdHJpeF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb21wb25lbnRUcmFuc2Zlcl46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb21wb3NpdGVeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlQ29udm9sdmVNYXRyaXheOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlRGlmZnVzZUxpZ2h0aW5nXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZURpc3BsYWNlbWVudE1hcF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVEaXN0YW50TGlnaHReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlRHJvcFNoYWRvd146c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVGbG9vZF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVGdW5jQV46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAgICc6c3ZnOmZlRnVuY0JeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgICAnOnN2ZzpmZUZ1bmNHXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICAgJzpzdmc6ZmVGdW5jUl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAgICc6c3ZnOmZlR2F1c3NpYW5CbHVyXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUltYWdlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU1lcmdlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU1lcmdlTm9kZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVNb3JwaG9sb2d5Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU9mZnNldF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVQb2ludExpZ2h0Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZVNwZWN1bGFyTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlU3BvdExpZ2h0Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZVRpbGVeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlVHVyYnVsZW5jZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmlsdGVyXjpzdmc6fCcsXG4gICAgICAnOnN2Zzpmb3JlaWduT2JqZWN0Xjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOmdeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6aW1hZ2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpsaW5lYXJHcmFkaWVudF46c3ZnOmdyYWRpZW50fCcsXG4gICAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICAgJzpzdmc6bWFya2VyXjpzdmc6fCcsXG4gICAgICAnOnN2ZzptYXNrXjpzdmc6fCcsXG4gICAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICAgJzpzdmc6cGF0aF46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpwYXR0ZXJuXjpzdmc6fCcsXG4gICAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOnBvbHlsaW5lXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOnJhZGlhbEdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6c3ZnXjpzdmc6Z3JhcGhpY3N8I2N1cnJlbnRTY2FsZSwjem9vbUFuZFBhbicsXG4gICAgICAnOnN2ZzpzY3JpcHReOnN2Zzp8dHlwZScsXG4gICAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOnN0b3BeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOnN0eWxlXjpzdmc6fCFkaXNhYmxlZCxtZWRpYSx0aXRsZSx0eXBlJyxcbiAgICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzpzeW1ib2xeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOnRzcGFuXjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgICAnOnN2Zzp0ZXh0UGF0aF46c3ZnOnRleHRDb250ZW50fCcsXG4gICAgICAnOnN2Zzp0aXRsZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOnZpZXdeOnN2Zzp8I3pvb21BbmRQYW4nLFxuICAgICAgJ2RhdGFeW0hUTUxFbGVtZW50XXx2YWx1ZScsXG4gICAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICAgJ3N1bW1hcnleW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3RpbWVeW0hUTUxFbGVtZW50XXxkYXRlVGltZScsXG4gIF07XG4gIHZhciBfQVRUUl9UT19QUk9QID0ge1xuICAgICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgICAnZm9yJzogJ2h0bWxGb3InLFxuICAgICAgJ2Zvcm1hY3Rpb24nOiAnZm9ybUFjdGlvbicsXG4gICAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXG4gICAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxuICAgICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4JyxcbiAgfTtcbiAgdmFyIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMjEoRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hID0ge307XG4gICAgICAgICAgU0NIRU1BLmZvckVhY2goZnVuY3Rpb24gKGVuY29kZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0ge307XG4gICAgICAgICAgICAgIHZhciBfYSA9IGVuY29kZWRUeXBlLnNwbGl0KCd8JyksIHN0clR5cGUgPSBfYVswXSwgc3RyUHJvcGVydGllcyA9IF9hWzFdO1xuICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHN0clByb3BlcnRpZXMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgdmFyIF9iID0gc3RyVHlwZS5zcGxpdCgnXicpLCB0eXBlTmFtZXMgPSBfYlswXSwgc3VwZXJOYW1lID0gX2JbMV07XG4gICAgICAgICAgICAgIHR5cGVOYW1lcy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gX3RoaXMuX3NjaGVtYVt0YWcudG9Mb3dlckNhc2UoKV0gPSB0eXBlOyB9KTtcbiAgICAgICAgICAgICAgdmFyIHN1cGVyVHlwZSA9IHN1cGVyTmFtZSAmJiBfdGhpcy5fc2NoZW1hW3N1cGVyTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgaWYgKHN1cGVyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3VwZXJUeXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHR5cGVbcHJvcF0gPSBzdXBlclR5cGVbcHJvcF07IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHlldCBzdXBwb3J0IGV2ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGV2ZXIgYWxsb3dpbmcgdG8gYmluZCB0byBldmVudHMsIEdPIFRIUk9VR0ggQSBTRUNVUklUWSBSRVZJRVcsIGFsbG93aW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxtb3N0IGNlcnRhaW5seSBpbnRyb2R1Y2UgYmFkIFhTUyB2dWxuZXJhYmlsaXRpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBFVkVOVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IEJPT0xFQU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBOVU1CRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBPQkpFQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHldID0gU1RSSU5HO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBfYW5ndWxhcl9jb3JlLk5PX0VSUk9SU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnbmctY29udGFpbmVyJyB8fCB0YWdOYW1lID09PSAnbmctY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gX2FuZ3VsYXJfY29yZS5DVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDYW4ndCB0ZWxsIG5vdyBhcyB3ZSBkb24ndCBrbm93IHdoaWNoIHByb3BlcnRpZXMgYSBjdXN0b20gZWxlbWVudCB3aWxsIGdldFxuICAgICAgICAgICAgICAgICAgLy8gb25jZSBpdCBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50UHJvcGVydGllcyA9IHRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuX3NjaGVtYVsndW5rbm93biddO1xuICAgICAgICAgIHJldHVybiAhIWVsZW1lbnRQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc0VsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gX2FuZ3VsYXJfY29yZS5OT19FUlJPUlNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ25nLWNvbnRhaW5lcicgfHwgdGFnTmFtZSA9PT0gJ25nLWNvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gX2FuZ3VsYXJfY29yZS5DVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gISF0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIHNlY3VyaXR5Q29udGV4dCByZXR1cm5zIHRoZSBzZWN1cml0eSBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGdpdmVuIERPTSB0YWcuXG4gICAgICAgKlxuICAgICAgICogVGFnIGFuZCBwcm9wZXJ0eSBuYW1lIGFyZSBzdGF0aWNhbGx5IGtub3duIGFuZCBjYW5ub3QgY2hhbmdlIGF0IHJ1bnRpbWUsIGkuZS4gaXQgaXMgbm90XG4gICAgICAgKiBwb3NzaWJsZSB0byBiaW5kIGEgdmFsdWUgaW50byBhIGNoYW5naW5nIGF0dHJpYnV0ZSBvciB0YWcgbmFtZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZmlsdGVyaW5nIGlzIHdoaXRlIGxpc3QgYmFzZWQuIEFsbCBhdHRyaWJ1dGVzIGluIHRoZSBzY2hlbWEgYWJvdmUgYXJlIGFzc3VtZWQgdG8gaGF2ZSB0aGVcbiAgICAgICAqICdOT05FJyBzZWN1cml0eSBjb250ZXh0LCBpLmUuIHRoYXQgdGhleSBhcmUgc2FmZSBpbmVydCBzdHJpbmcgdmFsdWVzLiBPbmx5IHNwZWNpZmljIHdlbGwga25vd25cbiAgICAgICAqIGF0dGFjayB2ZWN0b3JzIGFyZSBhc3NpZ25lZCB0aGVpciBhcHByb3ByaWF0ZSBjb250ZXh0LlxuICAgICAgICovXG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBpZiAoaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgLy8gTkI6IEZvciBzZWN1cml0eSBwdXJwb3NlcywgdXNlIHRoZSBtYXBwZWQgcHJvcGVydHkgbmFtZSwgbm90IHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgICAgICAgICAgcHJvcE5hbWUgPSB0aGlzLmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGNvbXBhcmlzb25zIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBzbyB0aGF0IGNhc2UgZGlmZmVyZW5jZXMgYmV0d2VlbiBhdHRyaWJ1dGUgYW5kXG4gICAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGN0eCA9IFNFQ1VSSVRZX1NDSEVNQVt0YWdOYW1lICsgJ3wnICsgcHJvcE5hbWVdO1xuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BWycqfCcgKyBwcm9wTmFtZV07XG4gICAgICAgICAgcmV0dXJuIGN0eCA/IGN0eCA6IF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU7XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRNYXBwZWRQcm9wTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkgeyByZXR1cm4gX0FUVFJfVE9fUFJPUFtwcm9wTmFtZV0gfHwgcHJvcE5hbWU7IH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICduZy1jb21wb25lbnQnOyB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgICAgdmFyIG1zZyA9IChcIkJpbmRpbmcgdG8gZXZlbnQgcHJvcGVydHkgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIikgK1xuICAgICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKSArXG4gICAgICAgICAgICAgICAgICAoXCJcXG5JZiAnXCIgKyBuYW1lICsgXCInIGlzIGEgZGlyZWN0aXZlIGlucHV0LCBtYWtlIHN1cmUgdGhlIGRpcmVjdGl2ZSBpcyBpbXBvcnRlZCBieSB0aGVcIikgK1xuICAgICAgICAgICAgICAgICAgXCIgY3VycmVudCBtb2R1bGUuXCI7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgICB2YXIgbXNnID0gKFwiQmluZGluZyB0byBldmVudCBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIikgK1xuICAgICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIG1zZzogbXNnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZmFsc2UgfTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5hbGxLbm93bkVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NjaGVtYSk7IH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wTmFtZSk7XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5ub3JtYWxpemVBbmltYXRpb25TdHlsZVZhbHVlID0gZnVuY3Rpb24gKGNhbWVsQ2FzZVByb3AsIHVzZXJQcm92aWRlZFByb3AsIHZhbCkge1xuICAgICAgICAgIHZhciB1bml0ID0gJyc7XG4gICAgICAgICAgdmFyIHN0clZhbCA9IHZhbC50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICB2YXIgZXJyb3JNc2cgPSBudWxsO1xuICAgICAgICAgIGlmIChfaXNQaXhlbERpbWVuc2lvblN0eWxlKGNhbWVsQ2FzZVByb3ApICYmIHZhbCAhPT0gMCAmJiB2YWwgIT09ICcwJykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbEFuZFN1ZmZpeE1hdGNoID0gdmFsLm1hdGNoKC9eWystXT9bXFxkXFwuXSsoW2Etel0qKSQvKTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWxBbmRTdWZmaXhNYXRjaCAmJiB2YWxBbmRTdWZmaXhNYXRjaFsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnID0gXCJQbGVhc2UgcHJvdmlkZSBhIENTUyB1bml0IHZhbHVlIGZvciBcIiArIHVzZXJQcm92aWRlZFByb3AgKyBcIjpcIiArIHZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyb3JNc2csIHZhbHVlOiBzdHJWYWwgKyB1bml0IH07XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgfShFbGVtZW50U2NoZW1hUmVnaXN0cnkpKTtcbiAgZnVuY3Rpb24gX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShwcm9wKSB7XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICBjYXNlICdtaW5XaWR0aCc6XG4gICAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgICBjYXNlICdtYXhXaWR0aCc6XG4gICAgICAgICAgY2FzZSAnbWF4SGVpZ2h0JzpcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGNhc2UgJ2ZvbnRTaXplJzpcbiAgICAgICAgICBjYXNlICdvdXRsaW5lV2lkdGgnOlxuICAgICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICAgIGNhc2UgJ3BhZGRpbmdUb3AnOlxuICAgICAgICAgIGNhc2UgJ3BhZGRpbmdMZWZ0JzpcbiAgICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgICBjYXNlICdwYWRkaW5nUmlnaHQnOlxuICAgICAgICAgIGNhc2UgJ21hcmdpblRvcCc6XG4gICAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgICAgY2FzZSAnbWFyZ2luQm90dG9tJzpcbiAgICAgICAgICBjYXNlICdtYXJnaW5SaWdodCc6XG4gICAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgICBjYXNlICdib3JkZXJXaWR0aCc6XG4gICAgICAgICAgY2FzZSAnYm9yZGVyVG9wV2lkdGgnOlxuICAgICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgICAgY2FzZSAnYm9yZGVyUmlnaHRXaWR0aCc6XG4gICAgICAgICAgY2FzZSAnYm9yZGVyQm90dG9tV2lkdGgnOlxuICAgICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICB2YXIgX05PX1JFU09VUkNFX0xPQURFUiA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlc291cmNlTG9hZGVyIGltcGxlbWVudGF0aW9uIGhhcyBiZWVuIHByb3ZpZGVkLiBDYW4ndCByZWFkIHRoZSB1cmwgXFxcIlwiICsgdXJsICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICB9O1xuICAvKipcbiAgICogQSBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgcHJvdmlkZSBgUnVudGltZUNvbXBpbGVyYCBhbmQgaXRzIGRlcGVuZGVuY2llcyB0byB1c2UgZm9yXG4gICAqIHRlbXBsYXRlIGNvbXBpbGF0aW9uLlxuICAgKi9cbiAgdmFyIENPTVBJTEVSX1BST1ZJREVSUyA9IFtcbiAgICAgIHsgcHJvdmlkZTogUmVmbGVjdG9yLCB1c2VWYWx1ZTogcmVmbGVjdG9yIH0sXG4gICAgICB7IHByb3ZpZGU6IFJlZmxlY3RvclJlYWRlciwgdXNlRXhpc3Rpbmc6IFJlZmxlY3RvciB9LFxuICAgICAgeyBwcm92aWRlOiBSZXNvdXJjZUxvYWRlciwgdXNlVmFsdWU6IF9OT19SRVNPVVJDRV9MT0FERVIgfSxcbiAgICAgIENvbnNvbGUsXG4gICAgICBMZXhlcixcbiAgICAgIFBhcnNlcixcbiAgICAgIEh0bWxQYXJzZXIsXG4gICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogSTE4Tkh0bWxQYXJzZXIsXG4gICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcnNlciwgdHJhbnNsYXRpb25zLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJMThOSHRtbFBhcnNlcihwYXJzZXIsIHRyYW5zbGF0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlcHM6IFtcbiAgICAgICAgICAgICAgSHRtbFBhcnNlcixcbiAgICAgICAgICAgICAgW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdChfYW5ndWxhcl9jb3JlLlRSQU5TTEFUSU9OUyldLFxuICAgICAgICAgICAgICBbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0KF9hbmd1bGFyX2NvcmUuVFJBTlNMQVRJT05TX0ZPUk1BVCldLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBUZW1wbGF0ZVBhcnNlcixcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIsXG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlcixcbiAgICAgIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIsXG4gICAgICBTdHlsZUNvbXBpbGVyLFxuICAgICAgVmlld0NvbXBpbGVyLFxuICAgICAgTmdNb2R1bGVDb21waWxlcixcbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcixcbiAgICAgIHsgcHJvdmlkZTogQ29tcGlsZXJDb25maWcsIHVzZVZhbHVlOiBuZXcgQ29tcGlsZXJDb25maWcoKSB9LFxuICAgICAgUnVudGltZUNvbXBpbGVyLFxuICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkNvbXBpbGVyLCB1c2VFeGlzdGluZzogUnVudGltZUNvbXBpbGVyIH0sXG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksXG4gICAgICB7IHByb3ZpZGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgdXNlRXhpc3Rpbmc6IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSB9LFxuICAgICAgVXJsUmVzb2x2ZXIsXG4gICAgICBEaXJlY3RpdmVSZXNvbHZlcixcbiAgICAgIFBpcGVSZXNvbHZlcixcbiAgICAgIE5nTW9kdWxlUmVzb2x2ZXIsXG4gICAgICBBbmltYXRpb25QYXJzZXJcbiAgXTtcbiAgdmFyIFJ1bnRpbWVDb21waWxlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUnVudGltZUNvbXBpbGVyRmFjdG9yeShkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gW3tcbiAgICAgICAgICAgICAgICAgIHVzZURlYnVnOiBfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpLFxuICAgICAgICAgICAgICAgICAgdXNlSml0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWRcbiAgICAgICAgICAgICAgfV0uY29uY2F0KGRlZmF1bHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIFJ1bnRpbWVDb21waWxlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUNvbXBpbGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBbXTsgfVxuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX21lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucy5jb25jYXQob3B0aW9ucykpO1xuICAgICAgICAgIHZhciBpbmplY3RvciA9IF9hbmd1bGFyX2NvcmUuUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAgICAgICAgICBDT01QSUxFUl9QUk9WSURFUlMsIHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbXBpbGVyQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZXJDb25maWcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgZXhwbGljaXQgdmFsdWVzIGZyb20gdGhlIGNvbXBpbGVyIG9wdGlvbnMgb3ZlcndyaXRlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYXBwIHByb3ZpZGVycy4gRS5nLiBpbXBvcnRhbnQgZm9yIHRoZSB0ZXN0aW5nIHBsYXRmb3JtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5EZWJ1Z0luZm86IG1lcmdlZE9wdGlvbnMudXNlRGVidWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUppdDogbWVyZ2VkT3B0aW9ucy51c2VKaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBtZXJnZWRPcHRpb25zLmRlZmF1bHRFbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dCaW5kaW5nVXBkYXRlOiBtZXJnZWRPcHRpb25zLnVzZURlYnVnXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZGVwczogW11cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5wcm92aWRlcnNcbiAgICAgICAgICBdKTtcbiAgICAgICAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KF9hbmd1bGFyX2NvcmUuQ29tcGlsZXIpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlckZhY3RvcnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUnVudGltZUNvbXBpbGVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuQ09NUElMRVJfT1BUSU9OUyxdIH0sXSB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBSdW50aW1lQ29tcGlsZXJGYWN0b3J5O1xuICB9KCkpO1xuICBmdW5jdGlvbiBfaW5pdFJlZmxlY3RvcigpIHtcbiAgICAgIHJlZmxlY3Rvci5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gbmV3IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKTtcbiAgfVxuICAvKipcbiAgICogQSBwbGF0Zm9ybSB0aGF0IGluY2x1ZGVkIGNvcmVQbGF0Zm9ybSBhbmQgdGhlIGNvbXBpbGVyLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICB2YXIgcGxhdGZvcm1Db3JlRHluYW1pYyA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvcmUucGxhdGZvcm1Db3JlLCAnY29yZUR5bmFtaWMnLCBbXG4gICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuQ09NUElMRVJfT1BUSU9OUywgdXNlVmFsdWU6IHt9LCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkNvbXBpbGVyRmFjdG9yeSwgdXNlQ2xhc3M6IFJ1bnRpbWVDb21waWxlckZhY3RvcnkgfSxcbiAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JTklUSUFMSVpFUiwgdXNlVmFsdWU6IF9pbml0UmVmbGVjdG9yLCBtdWx0aTogdHJ1ZSB9LFxuICBdKTtcbiAgZnVuY3Rpb24gX21lcmdlT3B0aW9ucyhvcHRpb25zQXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHVzZURlYnVnOiBfbGFzdERlZmluZWQob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMudXNlRGVidWc7IH0pKSxcbiAgICAgICAgICB1c2VKaXQ6IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy51c2VKaXQ7IH0pKSxcbiAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLmRlZmF1bHRFbmNhcHN1bGF0aW9uOyB9KSksXG4gICAgICAgICAgcHJvdmlkZXJzOiBfbWVyZ2VBcnJheXMob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMucHJvdmlkZXJzOyB9KSlcbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX2xhc3REZWZpbmVkKGFyZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIF9tZXJnZUFycmF5cyhwYXJ0cykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gcGFydCAmJiByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHBhcnQpOyB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8vIGFzc2V0OjxwYWNrYWdlLW5hbWU+LzxyZWFsbT4vPHBhdGgtdG8tbW9kdWxlPlxuICB2YXIgX0FTU0VUX1VSTF9SRSA9IC9hc3NldDooW15cXC9dKylcXC8oW15cXC9dKylcXC8oLispLztcbiAgLyoqXG4gICAqIEludGVyZmFjZSB0aGF0IGRlZmluZXMgaG93IGltcG9ydCBzdGF0ZW1lbnRzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICB2YXIgSW1wb3J0R2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEltcG9ydEdlbmVyYXRvcigpIHtcbiAgICAgIH1cbiAgICAgIEltcG9ydEdlbmVyYXRvci5wYXJzZUFzc2V0VXJsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gQXNzZXRVcmwucGFyc2UodXJsKTsgfTtcbiAgICAgIHJldHVybiBJbXBvcnRHZW5lcmF0b3I7XG4gIH0oKSk7XG4gIHZhciBBc3NldFVybCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBc3NldFVybChwYWNrYWdlTmFtZSwgZmlyc3RMZXZlbERpciwgbW9kdWxlUGF0aCkge1xuICAgICAgICAgIHRoaXMucGFja2FnZU5hbWUgPSBwYWNrYWdlTmFtZTtcbiAgICAgICAgICB0aGlzLmZpcnN0TGV2ZWxEaXIgPSBmaXJzdExldmVsRGlyO1xuICAgICAgICAgIHRoaXMubW9kdWxlUGF0aCA9IG1vZHVsZVBhdGg7XG4gICAgICB9XG4gICAgICBBc3NldFVybC5wYXJzZSA9IGZ1bmN0aW9uICh1cmwsIGFsbG93Tm9uTWF0Y2hpbmcpIHtcbiAgICAgICAgICBpZiAoYWxsb3dOb25NYXRjaGluZyA9PT0gdm9pZCAwKSB7IGFsbG93Tm9uTWF0Y2hpbmcgPSB0cnVlOyB9XG4gICAgICAgICAgdmFyIG1hdGNoID0gdXJsLm1hdGNoKF9BU1NFVF9VUkxfUkUpO1xuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEFzc2V0VXJsKG1hdGNoWzFdLCBtYXRjaFsyXSwgbWF0Y2hbM10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWxsb3dOb25NYXRjaGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXJsIFwiICsgdXJsICsgXCIgaXMgbm90IGEgdmFsaWQgYXNzZXQ6IHVybFwiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQXNzZXRVcmw7XG4gIH0oKSk7XG5cbiAgZXhwb3J0cy5URU1QTEFURV9UUkFOU0ZPUk1TID0gVEVNUExBVEVfVFJBTlNGT1JNUztcbiAgZXhwb3J0cy5Db21waWxlckNvbmZpZyA9IENvbXBpbGVyQ29uZmlnO1xuICBleHBvcnRzLlJlbmRlclR5cGVzID0gUmVuZGVyVHlwZXM7XG4gIGV4cG9ydHMuUnVudGltZUNvbXBpbGVyID0gUnVudGltZUNvbXBpbGVyO1xuICBleHBvcnRzLkRpcmVjdGl2ZVJlc29sdmVyID0gRGlyZWN0aXZlUmVzb2x2ZXI7XG4gIGV4cG9ydHMuUGlwZVJlc29sdmVyID0gUGlwZVJlc29sdmVyO1xuICBleHBvcnRzLk5nTW9kdWxlUmVzb2x2ZXIgPSBOZ01vZHVsZVJlc29sdmVyO1xuICBleHBvcnRzLkRFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICBleHBvcnRzLkludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnO1xuICBleHBvcnRzLk5nTW9kdWxlQ29tcGlsZXIgPSBOZ01vZHVsZUNvbXBpbGVyO1xuICBleHBvcnRzLkRpcmVjdGl2ZVdyYXBwZXJDb21waWxlciA9IERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcjtcbiAgZXhwb3J0cy5WaWV3Q29tcGlsZXIgPSBWaWV3Q29tcGlsZXI7XG4gIGV4cG9ydHMuQW5pbWF0aW9uUGFyc2VyID0gQW5pbWF0aW9uUGFyc2VyO1xuICBleHBvcnRzLlRleHRBc3QgPSBUZXh0QXN0O1xuICBleHBvcnRzLkJvdW5kVGV4dEFzdCA9IEJvdW5kVGV4dEFzdDtcbiAgZXhwb3J0cy5BdHRyQXN0ID0gQXR0ckFzdDtcbiAgZXhwb3J0cy5Cb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0O1xuICBleHBvcnRzLkJvdW5kRXZlbnRBc3QgPSBCb3VuZEV2ZW50QXN0O1xuICBleHBvcnRzLlJlZmVyZW5jZUFzdCA9IFJlZmVyZW5jZUFzdDtcbiAgZXhwb3J0cy5WYXJpYWJsZUFzdCA9IFZhcmlhYmxlQXN0O1xuICBleHBvcnRzLkVsZW1lbnRBc3QgPSBFbGVtZW50QXN0O1xuICBleHBvcnRzLkVtYmVkZGVkVGVtcGxhdGVBc3QgPSBFbWJlZGRlZFRlbXBsYXRlQXN0O1xuICBleHBvcnRzLkJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xuICBleHBvcnRzLkRpcmVjdGl2ZUFzdCA9IERpcmVjdGl2ZUFzdDtcbiAgZXhwb3J0cy5Qcm92aWRlckFzdCA9IFByb3ZpZGVyQXN0O1xuICBleHBvcnRzLk5nQ29udGVudEFzdCA9IE5nQ29udGVudEFzdDtcbiAgZXhwb3J0cy50ZW1wbGF0ZVZpc2l0QWxsID0gdGVtcGxhdGVWaXNpdEFsbDtcbiAgZXhwb3J0cy5Db21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllciA9IENvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhID0gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhID0gQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhID0gQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEgPSBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSA9IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlUHJvdmlkZXJNZXRhZGF0YSA9IENvbXBpbGVQcm92aWRlck1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSBDb21waWxlRmFjdG9yeU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVUb2tlbk1ldGFkYXRhID0gQ29tcGlsZVRva2VuTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZVR5cGVNZXRhZGF0YSA9IENvbXBpbGVUeXBlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZVF1ZXJ5TWV0YWRhdGEgPSBDb21waWxlUXVlcnlNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlU3R5bGVzaGVldE1ldGFkYXRhID0gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YTtcbiAgZXhwb3J0cy5jcmVhdGVIb3N0Q29tcG9uZW50TWV0YSA9IGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhO1xuICBleHBvcnRzLkNvbXBpbGVQaXBlTWV0YWRhdGEgPSBDb21waWxlUGlwZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG4gIGV4cG9ydHMuVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhO1xuICBleHBvcnRzLnJlbW92ZUlkZW50aWZpZXJEdXBsaWNhdGVzID0gcmVtb3ZlSWRlbnRpZmllckR1cGxpY2F0ZXM7XG4gIGV4cG9ydHMuaXNTdGF0aWNTeW1ib2wgPSBpc1N0YXRpY1N5bWJvbDtcbiAgZXhwb3J0cy5Qcm92aWRlck1ldGEgPSBQcm92aWRlck1ldGE7XG4gIGV4cG9ydHMuU291cmNlTW9kdWxlID0gU291cmNlTW9kdWxlO1xuICBleHBvcnRzLmFuYWx5emVOZ01vZHVsZXMgPSBhbmFseXplTmdNb2R1bGVzO1xuICBleHBvcnRzLk9mZmxpbmVDb21waWxlciA9IE9mZmxpbmVDb21waWxlcjtcbiAgZXhwb3J0cy5jcmVhdGVVcmxSZXNvbHZlcldpdGhvdXRQYWNrYWdlUHJlZml4ID0gY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeDtcbiAgZXhwb3J0cy5jcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyID0gY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcjtcbiAgZXhwb3J0cy5ERUZBVUxUX1BBQ0tBR0VfVVJMX1BST1ZJREVSID0gREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUjtcbiAgZXhwb3J0cy5VcmxSZXNvbHZlciA9IFVybFJlc29sdmVyO1xuICBleHBvcnRzLmdldFVybFNjaGVtZSA9IGdldFVybFNjaGVtZTtcbiAgZXhwb3J0cy5SZXNvdXJjZUxvYWRlciA9IFJlc291cmNlTG9hZGVyO1xuICBleHBvcnRzLkNPTVBJTEVSX1BST1ZJREVSUyA9IENPTVBJTEVSX1BST1ZJREVSUztcbiAgZXhwb3J0cy5SdW50aW1lQ29tcGlsZXJGYWN0b3J5ID0gUnVudGltZUNvbXBpbGVyRmFjdG9yeTtcbiAgZXhwb3J0cy5wbGF0Zm9ybUNvcmVEeW5hbWljID0gcGxhdGZvcm1Db3JlRHluYW1pYztcbiAgZXhwb3J0cy5FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBFbGVtZW50U2NoZW1hUmVnaXN0cnk7XG4gIGV4cG9ydHMuSTE4Tkh0bWxQYXJzZXIgPSBJMThOSHRtbFBhcnNlcjtcbiAgZXhwb3J0cy5NZXNzYWdlQnVuZGxlID0gTWVzc2FnZUJ1bmRsZTtcbiAgZXhwb3J0cy5YbGlmZiA9IFhsaWZmO1xuICBleHBvcnRzLlhtYiA9IFhtYjtcbiAgZXhwb3J0cy5YdGIgPSBYdGI7XG4gIGV4cG9ydHMuRGlyZWN0aXZlTm9ybWFsaXplciA9IERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gIGV4cG9ydHMuTGV4ZXIgPSBMZXhlcjtcbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuICBleHBvcnRzLkVPRiA9IEVPRjtcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG4gIGV4cG9ydHMuaXNRdW90ZSA9IGlzUXVvdGU7XG4gIGV4cG9ydHMuU3BsaXRJbnRlcnBvbGF0aW9uID0gU3BsaXRJbnRlcnBvbGF0aW9uO1xuICBleHBvcnRzLlRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0ID0gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLl9QYXJzZUFTVCA9IF9QYXJzZUFTVDtcbiAgZXhwb3J0cy5Db21waWxlTWV0YWRhdGFSZXNvbHZlciA9IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyO1xuICBleHBvcnRzLkh0bWxQYXJzZXIgPSBIdG1sUGFyc2VyO1xuICBleHBvcnRzLlBhcnNlVHJlZVJlc3VsdCA9IFBhcnNlVHJlZVJlc3VsdDtcbiAgZXhwb3J0cy5UcmVlRXJyb3IgPSBUcmVlRXJyb3I7XG4gIGV4cG9ydHMuSW1wb3J0R2VuZXJhdG9yID0gSW1wb3J0R2VuZXJhdG9yO1xuICBleHBvcnRzLkFzc2V0VXJsID0gQXNzZXRVcmw7XG4gIGV4cG9ydHMuZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQgPSBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdDtcbiAgZXhwb3J0cy5UeXBlU2NyaXB0RW1pdHRlciA9IFR5cGVTY3JpcHRFbWl0dGVyO1xuICBleHBvcnRzLlBhcnNlTG9jYXRpb24gPSBQYXJzZUxvY2F0aW9uO1xuICBleHBvcnRzLlBhcnNlU291cmNlRmlsZSA9IFBhcnNlU291cmNlRmlsZTtcbiAgZXhwb3J0cy5QYXJzZVNvdXJjZVNwYW4gPSBQYXJzZVNvdXJjZVNwYW47XG4gIGV4cG9ydHMuUGFyc2VFcnJvciA9IFBhcnNlRXJyb3I7XG4gIGV4cG9ydHMuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xuICBleHBvcnRzLkNzc1NlbGVjdG9yID0gQ3NzU2VsZWN0b3I7XG4gIGV4cG9ydHMuU2VsZWN0b3JNYXRjaGVyID0gU2VsZWN0b3JNYXRjaGVyO1xuICBleHBvcnRzLlNlbGVjdG9yTGlzdENvbnRleHQgPSBTZWxlY3Rvckxpc3RDb250ZXh0O1xuICBleHBvcnRzLlNlbGVjdG9yQ29udGV4dCA9IFNlbGVjdG9yQ29udGV4dDtcbiAgZXhwb3J0cy5TdHlsZXNDb21waWxlRGVwZW5kZW5jeSA9IFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xuICBleHBvcnRzLlN0eWxlc0NvbXBpbGVSZXN1bHQgPSBTdHlsZXNDb21waWxlUmVzdWx0O1xuICBleHBvcnRzLkNvbXBpbGVkU3R5bGVzaGVldCA9IENvbXBpbGVkU3R5bGVzaGVldDtcbiAgZXhwb3J0cy5TdHlsZUNvbXBpbGVyID0gU3R5bGVDb21waWxlcjtcbiAgZXhwb3J0cy5UZW1wbGF0ZVBhcnNlRXJyb3IgPSBUZW1wbGF0ZVBhcnNlRXJyb3I7XG4gIGV4cG9ydHMuVGVtcGxhdGVQYXJzZVJlc3VsdCA9IFRlbXBsYXRlUGFyc2VSZXN1bHQ7XG4gIGV4cG9ydHMuVGVtcGxhdGVQYXJzZXIgPSBUZW1wbGF0ZVBhcnNlcjtcbiAgZXhwb3J0cy5zcGxpdENsYXNzZXMgPSBzcGxpdENsYXNzZXM7XG4gIGV4cG9ydHMucmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMgPSByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcztcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.2.0\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(23), __webpack_require__(2)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));\n}(this, function (exports,_angular_common,_angular_core) { 'use strict';\n\n    var DebugDomRootRenderer = _angular_core.__core_private__.DebugDomRootRenderer;\n    var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;\n\n    var _NoOpAnimationDriver = (function () {\n        function _NoOpAnimationDriver() {\n        }\n        _NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            return new NoOpAnimationPlayer();\n        };\n        return _NoOpAnimationDriver;\n    }());\n    /**\n     * @experimental\n     */\n    var AnimationDriver = (function () {\n        function AnimationDriver() {\n        }\n        AnimationDriver.NOOP = new _NoOpAnimationDriver();\n        return AnimationDriver;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var global$1 = globalScope;\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    global$1.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj != null;\n    }\n    function isBlank(obj) {\n        return obj == null;\n    }\n    function stringify(token) {\n        if (typeof token === 'string') {\n            return token;\n        }\n        if (token == null) {\n            return '' + token;\n        }\n        if (token.overriddenName) {\n            return token.overriddenName;\n        }\n        if (token.name) {\n            return token.name;\n        }\n        var res = token.toString();\n        var newLineIndex = res.indexOf('\\n');\n        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n    }\n    function setValueOnPath(global, path, value) {\n        var parts = path.split('.');\n        var obj = global;\n        while (parts.length > 1) {\n            var name_1 = parts.shift();\n            if (obj.hasOwnProperty(name_1) && obj[name_1] != null) {\n                obj = obj[name_1];\n            }\n            else {\n                obj = obj[name_1] = {};\n            }\n        }\n        if (obj === undefined || obj === null) {\n            obj = {};\n        }\n        obj[parts.shift()] = value;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var _DOM = null;\n    function getDOM() {\n        return _DOM;\n    }\n    function setRootDomAdapter(adapter) {\n        if (!_DOM) {\n            _DOM = adapter;\n        }\n    }\n    /* tslint:disable:requireParameterType */\n    /**\n     * Provides DOM operations in an environment-agnostic way.\n     *\n     * @security Tread carefully! Interacting with the DOM directly is dangerous and\n     * can introduce XSS risks.\n     */\n    var DomAdapter = (function () {\n        function DomAdapter() {\n            this.resourceLoaderType = null;\n        }\n        Object.defineProperty(DomAdapter.prototype, \"attrToPropMap\", {\n            /**\n             * Maps attribute names to their corresponding property names for cases\n             * where attribute name doesn't match property name.\n             */\n            get: function () { return this._attrToPropMap; },\n            set: function (value) { this._attrToPropMap = value; },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        return DomAdapter;\n    }());\n\n    var WebAnimationsPlayer = (function () {\n        function WebAnimationsPlayer(element, keyframes, options) {\n            this.element = element;\n            this.keyframes = keyframes;\n            this.options = options;\n            this._onDoneFns = [];\n            this._onStartFns = [];\n            this._initialized = false;\n            this._finished = false;\n            this._started = false;\n            this._destroyed = false;\n            this.parentPlayer = null;\n            this._duration = options['duration'];\n        }\n        WebAnimationsPlayer.prototype._onFinish = function () {\n            if (!this._finished) {\n                this._finished = true;\n                this._onDoneFns.forEach(function (fn) { return fn(); });\n                this._onDoneFns = [];\n            }\n        };\n        WebAnimationsPlayer.prototype.init = function () {\n            var _this = this;\n            if (this._initialized)\n                return;\n            this._initialized = true;\n            var keyframes = this.keyframes.map(function (styles) {\n                var formattedKeyframe = {};\n                Object.keys(styles).forEach(function (prop) {\n                    var value = styles[prop];\n                    formattedKeyframe[prop] = value == _angular_core.AUTO_STYLE ? _computeStyle(_this.element, prop) : value;\n                });\n                return formattedKeyframe;\n            });\n            this._player = this._triggerWebAnimation(this.element, keyframes, this.options);\n            // this is required so that the player doesn't start to animate right away\n            this._resetDomPlayerState();\n            this._player.addEventListener('finish', function () { return _this._onFinish(); });\n        };\n        /** @internal */\n        WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {\n            return element.animate(keyframes, options);\n        };\n        Object.defineProperty(WebAnimationsPlayer.prototype, \"domPlayer\", {\n            get: function () { return this._player; },\n            enumerable: true,\n            configurable: true\n        });\n        WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };\n        WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };\n        WebAnimationsPlayer.prototype.play = function () {\n            this.init();\n            if (!this.hasStarted()) {\n                this._onStartFns.forEach(function (fn) { return fn(); });\n                this._onStartFns = [];\n                this._started = true;\n            }\n            this._player.play();\n        };\n        WebAnimationsPlayer.prototype.pause = function () {\n            this.init();\n            this._player.pause();\n        };\n        WebAnimationsPlayer.prototype.finish = function () {\n            this.init();\n            this._onFinish();\n            this._player.finish();\n        };\n        WebAnimationsPlayer.prototype.reset = function () {\n            this._resetDomPlayerState();\n            this._destroyed = false;\n            this._finished = false;\n            this._started = false;\n        };\n        WebAnimationsPlayer.prototype._resetDomPlayerState = function () { this._player.cancel(); };\n        WebAnimationsPlayer.prototype.restart = function () {\n            this.reset();\n            this.play();\n        };\n        WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };\n        WebAnimationsPlayer.prototype.destroy = function () {\n            if (!this._destroyed) {\n                this._resetDomPlayerState();\n                this._onFinish();\n                this._destroyed = true;\n            }\n        };\n        Object.defineProperty(WebAnimationsPlayer.prototype, \"totalTime\", {\n            get: function () { return this._duration; },\n            enumerable: true,\n            configurable: true\n        });\n        WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };\n        WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };\n        return WebAnimationsPlayer;\n    }());\n    function _computeStyle(element, prop) {\n        return getDOM().getComputedStyle(element)[prop];\n    }\n\n    var WebAnimationsDriver = (function () {\n        function WebAnimationsDriver() {\n        }\n        WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            var formattedSteps = [];\n            var startingStyleLookup = {};\n            if (isPresent(startingStyles) && startingStyles.styles.length > 0) {\n                startingStyleLookup = _populateStyles(element, startingStyles, {});\n                startingStyleLookup['offset'] = 0;\n                formattedSteps.push(startingStyleLookup);\n            }\n            keyframes.forEach(function (keyframe) {\n                var data = _populateStyles(element, keyframe.styles, startingStyleLookup);\n                data['offset'] = keyframe.offset;\n                formattedSteps.push(data);\n            });\n            // this is a special case when only styles are applied as an\n            // animation. When this occurs we want to animate from start to\n            // end with the same values. Removing the offset and having only\n            // start/end values is suitable enough for the web-animations API\n            if (formattedSteps.length == 1) {\n                var start = formattedSteps[0];\n                start['offset'] = null;\n                formattedSteps = [start, start];\n            }\n            var playerOptions = {\n                'duration': duration,\n                'delay': delay,\n                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`\n            };\n            // we check for this to avoid having a null|undefined value be present\n            // for the easing (which results in an error for certain browsers #9752)\n            if (easing) {\n                playerOptions['easing'] = easing;\n            }\n            return new WebAnimationsPlayer(element, formattedSteps, playerOptions);\n        };\n        return WebAnimationsDriver;\n    }());\n    function _populateStyles(element, styles, defaultStyles) {\n        var data = {};\n        styles.styles.forEach(function (entry) { Object.keys(entry).forEach(function (prop) { data[prop] = entry[prop]; }); });\n        Object.keys(defaultStyles).forEach(function (prop) {\n            if (!isPresent(data[prop])) {\n                data[prop] = defaultStyles[prop];\n            }\n        });\n        return data;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Provides DOM operations in any browser environment.\n     *\n     * @security Tread carefully! Interacting with the DOM directly is dangerous and\n     * can introduce XSS risks.\n     */\n    var GenericBrowserDomAdapter = (function (_super) {\n        __extends$1(GenericBrowserDomAdapter, _super);\n        function GenericBrowserDomAdapter() {\n            var _this = this;\n            _super.call(this);\n            this._animationPrefix = null;\n            this._transitionEnd = null;\n            try {\n                var element_1 = this.createElement('div', this.defaultDoc());\n                if (isPresent(this.getStyle(element_1, 'animationName'))) {\n                    this._animationPrefix = '';\n                }\n                else {\n                    var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n                    for (var i = 0; i < domPrefixes.length; i++) {\n                        if (isPresent(this.getStyle(element_1, domPrefixes[i] + 'AnimationName'))) {\n                            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';\n                            break;\n                        }\n                    }\n                }\n                var transEndEventNames_1 = {\n                    WebkitTransition: 'webkitTransitionEnd',\n                    MozTransition: 'transitionend',\n                    OTransition: 'oTransitionEnd otransitionend',\n                    transition: 'transitionend'\n                };\n                Object.keys(transEndEventNames_1).forEach(function (key) {\n                    if (isPresent(_this.getStyle(element_1, key))) {\n                        _this._transitionEnd = transEndEventNames_1[key];\n                    }\n                });\n            }\n            catch (e) {\n                this._animationPrefix = null;\n                this._transitionEnd = null;\n            }\n        }\n        GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };\n        GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {\n            el.href = href == null ? baseUrl : baseUrl + '/../' + href;\n        };\n        GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };\n        GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {\n            return typeof this.defaultDoc().body.createShadowRoot === 'function';\n        };\n        GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };\n        GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };\n        GenericBrowserDomAdapter.prototype.supportsAnimation = function () {\n            return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);\n        };\n        return GenericBrowserDomAdapter;\n    }(DomAdapter));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var _attrToPropMap = {\n        'class': 'className',\n        'innerHtml': 'innerHTML',\n        'readonly': 'readOnly',\n        'tabindex': 'tabIndex',\n    };\n    var DOM_KEY_LOCATION_NUMPAD = 3;\n    // Map to convert some key or keyIdentifier values to what will be returned by getEventKey\n    var _keyMap = {\n        // The following values are here for cross-browser compatibility and to match the W3C standard\n        // cf http://www.w3.org/TR/DOM-Level-3-Events-key/\n        '\\b': 'Backspace',\n        '\\t': 'Tab',\n        '\\x7F': 'Delete',\n        '\\x1B': 'Escape',\n        'Del': 'Delete',\n        'Esc': 'Escape',\n        'Left': 'ArrowLeft',\n        'Right': 'ArrowRight',\n        'Up': 'ArrowUp',\n        'Down': 'ArrowDown',\n        'Menu': 'ContextMenu',\n        'Scroll': 'ScrollLock',\n        'Win': 'OS'\n    };\n    // There is a bug in Chrome for numeric keypad keys:\n    // https://code.google.com/p/chromium/issues/detail?id=155654\n    // 1, 2, 3 ... are reported as A, B, C ...\n    var _chromeNumKeyPadMap = {\n        'A': '1',\n        'B': '2',\n        'C': '3',\n        'D': '4',\n        'E': '5',\n        'F': '6',\n        'G': '7',\n        'H': '8',\n        'I': '9',\n        'J': '*',\n        'K': '+',\n        'M': '-',\n        'N': '.',\n        'O': '/',\n        '\\x60': '0',\n        '\\x90': 'NumLock'\n    };\n    /**\n     * A `DomAdapter` powered by full browser DOM APIs.\n     *\n     * @security Tread carefully! Interacting with the DOM directly is dangerous and\n     * can introduce XSS risks.\n     */\n    /* tslint:disable:requireParameterType */\n    var BrowserDomAdapter = (function (_super) {\n        __extends(BrowserDomAdapter, _super);\n        function BrowserDomAdapter() {\n            _super.apply(this, arguments);\n        }\n        BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };\n        BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };\n        BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };\n        BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };\n        BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };\n        BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { (_a = el)[methodName].apply(_a, args); var _a; };\n        // TODO(tbosch): move this into a separate environment class once we have it\n        BrowserDomAdapter.prototype.logError = function (error) {\n            if (window.console) {\n                (window.console.error || window.console.log)(error);\n            }\n        };\n        BrowserDomAdapter.prototype.log = function (error) {\n            if (window.console) {\n                window.console.log && window.console.log(error);\n            }\n        };\n        BrowserDomAdapter.prototype.logGroup = function (error) {\n            if (window.console) {\n                window.console.group && window.console.group(error);\n                this.logError(error);\n            }\n        };\n        BrowserDomAdapter.prototype.logGroupEnd = function () {\n            if (window.console) {\n                window.console.groupEnd && window.console.groupEnd();\n            }\n        };\n        Object.defineProperty(BrowserDomAdapter.prototype, \"attrToPropMap\", {\n            get: function () { return _attrToPropMap; },\n            enumerable: true,\n            configurable: true\n        });\n        BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };\n        BrowserDomAdapter.prototype.querySelector = function (el, selector) {\n            return el.querySelector(selector);\n        };\n        BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };\n        BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };\n        BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {\n            el.addEventListener(evt, listener, false);\n            // Needed to follow Dart's subscription semantic, until fix of\n            // https://code.google.com/p/dart/issues/detail?id=17406\n            return function () { el.removeEventListener(evt, listener, false); };\n        };\n        BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };\n        BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {\n            var evt = document.createEvent('MouseEvent');\n            evt.initEvent(eventType, true, true);\n            return evt;\n        };\n        BrowserDomAdapter.prototype.createEvent = function (eventType) {\n            var evt = document.createEvent('Event');\n            evt.initEvent(eventType, true, true);\n            return evt;\n        };\n        BrowserDomAdapter.prototype.preventDefault = function (evt) {\n            evt.preventDefault();\n            evt.returnValue = false;\n        };\n        BrowserDomAdapter.prototype.isPrevented = function (evt) {\n            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;\n        };\n        BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };\n        BrowserDomAdapter.prototype.getTemplateContent = function (el) {\n            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;\n        };\n        BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };\n        BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };\n        BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };\n        BrowserDomAdapter.prototype.type = function (node) { return node.type; };\n        BrowserDomAdapter.prototype.content = function (node) {\n            if (this.hasProperty(node, 'content')) {\n                return node.content;\n            }\n            else {\n                return node;\n            }\n        };\n        BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };\n        BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };\n        BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };\n        BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };\n        BrowserDomAdapter.prototype.childNodesAsList = function (el) {\n            var childNodes = el.childNodes;\n            var res = new Array(childNodes.length);\n            for (var i = 0; i < childNodes.length; i++) {\n                res[i] = childNodes[i];\n            }\n            return res;\n        };\n        BrowserDomAdapter.prototype.clearNodes = function (el) {\n            while (el.firstChild) {\n                el.removeChild(el.firstChild);\n            }\n        };\n        BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };\n        BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };\n        BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };\n        BrowserDomAdapter.prototype.remove = function (node) {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n            return node;\n        };\n        BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };\n        BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) {\n            nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); });\n        };\n        BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };\n        BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };\n        BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };\n        BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };\n        BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };\n        BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };\n        BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };\n        BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };\n        BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };\n        BrowserDomAdapter.prototype.createTemplate = function (html) {\n            var t = document.createElement('template');\n            t.innerHTML = html;\n            return t;\n        };\n        BrowserDomAdapter.prototype.createElement = function (tagName, doc) {\n            if (doc === void 0) { doc = document; }\n            return doc.createElement(tagName);\n        };\n        BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {\n            if (doc === void 0) { doc = document; }\n            return doc.createElementNS(ns, tagName);\n        };\n        BrowserDomAdapter.prototype.createTextNode = function (text, doc) {\n            if (doc === void 0) { doc = document; }\n            return doc.createTextNode(text);\n        };\n        BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {\n            if (doc === void 0) { doc = document; }\n            var el = doc.createElement('SCRIPT');\n            el.setAttribute(attrName, attrValue);\n            return el;\n        };\n        BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {\n            if (doc === void 0) { doc = document; }\n            var style = doc.createElement('style');\n            this.appendChild(style, this.createTextNode(css));\n            return style;\n        };\n        BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };\n        BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };\n        BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };\n        BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };\n        BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {\n            return element.getElementsByClassName(name);\n        };\n        BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {\n            return element.getElementsByTagName(name);\n        };\n        BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };\n        BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };\n        BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };\n        BrowserDomAdapter.prototype.hasClass = function (element, className) {\n            return element.classList.contains(className);\n        };\n        BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {\n            element.style[styleName] = styleValue;\n        };\n        BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {\n            // IE requires '' instead of null\n            // see https://github.com/angular/angular/issues/7916\n            element.style[stylename] = '';\n        };\n        BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };\n        BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {\n            if (styleValue === void 0) { styleValue = null; }\n            var value = this.getStyle(element, styleName) || '';\n            return styleValue ? value == styleValue : value.length > 0;\n        };\n        BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };\n        BrowserDomAdapter.prototype.attributeMap = function (element) {\n            var res = new Map();\n            var elAttrs = element.attributes;\n            for (var i = 0; i < elAttrs.length; i++) {\n                var attrib = elAttrs[i];\n                res.set(attrib.name, attrib.value);\n            }\n            return res;\n        };\n        BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {\n            return element.hasAttribute(attribute);\n        };\n        BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {\n            return element.hasAttributeNS(ns, attribute);\n        };\n        BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {\n            return element.getAttribute(attribute);\n        };\n        BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {\n            return element.getAttributeNS(ns, name);\n        };\n        BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };\n        BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {\n            element.setAttributeNS(ns, name, value);\n        };\n        BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };\n        BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {\n            element.removeAttributeNS(ns, name);\n        };\n        BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };\n        BrowserDomAdapter.prototype.createHtmlDocument = function () {\n            return document.implementation.createHTMLDocument('fakeTitle');\n        };\n        BrowserDomAdapter.prototype.defaultDoc = function () { return document; };\n        BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {\n            try {\n                return el.getBoundingClientRect();\n            }\n            catch (e) {\n                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };\n            }\n        };\n        BrowserDomAdapter.prototype.getTitle = function () { return document.title; };\n        BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };\n        BrowserDomAdapter.prototype.elementMatches = function (n, selector) {\n            if (n instanceof HTMLElement) {\n                return n.matches && n.matches(selector) ||\n                    n.msMatchesSelector && n.msMatchesSelector(selector) ||\n                    n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n            }\n            return false;\n        };\n        BrowserDomAdapter.prototype.isTemplateElement = function (el) {\n            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';\n        };\n        BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };\n        BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };\n        BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };\n        BrowserDomAdapter.prototype.hasShadowRoot = function (node) {\n            return isPresent(node.shadowRoot) && node instanceof HTMLElement;\n        };\n        BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };\n        BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };\n        BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };\n        BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };\n        BrowserDomAdapter.prototype.getEventKey = function (event) {\n            var key = event.key;\n            if (isBlank(key)) {\n                key = event.keyIdentifier;\n                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\n                // Safari cf\n                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\n                if (isBlank(key)) {\n                    return 'Unidentified';\n                }\n                if (key.startsWith('U+')) {\n                    key = String.fromCharCode(parseInt(key.substring(2), 16));\n                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\n                        // There is a bug in Chrome for numeric keypad keys:\n                        // https://code.google.com/p/chromium/issues/detail?id=155654\n                        // 1, 2, 3 ... are reported as A, B, C ...\n                        key = _chromeNumKeyPadMap[key];\n                    }\n                }\n            }\n            return _keyMap[key] || key;\n        };\n        BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {\n            if (target === 'window') {\n                return window;\n            }\n            if (target === 'document') {\n                return document;\n            }\n            if (target === 'body') {\n                return document.body;\n            }\n        };\n        BrowserDomAdapter.prototype.getHistory = function () { return window.history; };\n        BrowserDomAdapter.prototype.getLocation = function () { return window.location; };\n        BrowserDomAdapter.prototype.getBaseHref = function () {\n            var href = getBaseElementHref();\n            return isBlank(href) ? null : relativePath(href);\n        };\n        BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };\n        BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };\n        BrowserDomAdapter.prototype.setData = function (element, name, value) {\n            this.setAttribute(element, 'data-' + name, value);\n        };\n        BrowserDomAdapter.prototype.getData = function (element, name) {\n            return this.getAttribute(element, 'data-' + name);\n        };\n        BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };\n        // TODO(tbosch): move this into a separate environment class once we have it\n        BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { setValueOnPath(global$1, path, value); };\n        BrowserDomAdapter.prototype.supportsWebAnimation = function () {\n            return typeof Element.prototype['animate'] === 'function';\n        };\n        BrowserDomAdapter.prototype.performanceNow = function () {\n            // performance.now() is not available in all browsers, see\n            // http://caniuse.com/#search=performance.now\n            return window.performance && window.performance.now ? window.performance.now() :\n                new Date().getTime();\n        };\n        BrowserDomAdapter.prototype.supportsCookies = function () { return true; };\n        BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };\n        BrowserDomAdapter.prototype.setCookie = function (name, value) {\n            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does\n            // not clear other cookies.\n            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n        };\n        return BrowserDomAdapter;\n    }(GenericBrowserDomAdapter));\n    var baseElement = null;\n    function getBaseElementHref() {\n        if (!baseElement) {\n            baseElement = document.querySelector('base');\n            if (!baseElement) {\n                return null;\n            }\n        }\n        return baseElement.getAttribute('href');\n    }\n    // based on urlUtils.js in AngularJS 1\n    var urlParsingNode;\n    function relativePath(url) {\n        if (!urlParsingNode) {\n            urlParsingNode = document.createElement('a');\n        }\n        urlParsingNode.setAttribute('href', url);\n        return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname;\n    }\n    function parseCookieValue(cookieStr, name) {\n        name = encodeURIComponent(name);\n        for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {\n            var cookie = _a[_i];\n            var eqIndex = cookie.indexOf('=');\n            var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];\n            if (cookieName.trim() === name) {\n                return decodeURIComponent(cookieValue);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function supportsState() {\n        return !!window.history.pushState;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * `PlatformLocation` encapsulates all of the direct calls to platform APIs.\n     * This class should not be used directly by an application developer. Instead, use\n     * {@link Location}.\n     */\n    var BrowserPlatformLocation = (function (_super) {\n        __extends$2(BrowserPlatformLocation, _super);\n        function BrowserPlatformLocation() {\n            _super.call(this);\n            this._init();\n        }\n        // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it\n        /** @internal */\n        BrowserPlatformLocation.prototype._init = function () {\n            this._location = getDOM().getLocation();\n            this._history = getDOM().getHistory();\n        };\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"location\", {\n            get: function () { return this._location; },\n            enumerable: true,\n            configurable: true\n        });\n        BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return getDOM().getBaseHref(); };\n        BrowserPlatformLocation.prototype.onPopState = function (fn) {\n            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);\n        };\n        BrowserPlatformLocation.prototype.onHashChange = function (fn) {\n            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);\n        };\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"pathname\", {\n            get: function () { return this._location.pathname; },\n            set: function (newPath) { this._location.pathname = newPath; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"search\", {\n            get: function () { return this._location.search; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BrowserPlatformLocation.prototype, \"hash\", {\n            get: function () { return this._location.hash; },\n            enumerable: true,\n            configurable: true\n        });\n        BrowserPlatformLocation.prototype.pushState = function (state, title, url) {\n            if (supportsState()) {\n                this._history.pushState(state, title, url);\n            }\n            else {\n                this._location.hash = url;\n            }\n        };\n        BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {\n            if (supportsState()) {\n                this._history.replaceState(state, title, url);\n            }\n            else {\n                this._location.hash = url;\n            }\n        };\n        BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };\n        BrowserPlatformLocation.prototype.back = function () { this._history.back(); };\n        BrowserPlatformLocation.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        BrowserPlatformLocation.ctorParameters = [];\n        return BrowserPlatformLocation;\n    }(_angular_common.PlatformLocation));\n\n    var BrowserGetTestability = (function () {\n        function BrowserGetTestability() {\n        }\n        BrowserGetTestability.init = function () { _angular_core.setTestabilityGetter(new BrowserGetTestability()); };\n        BrowserGetTestability.prototype.addToWindow = function (registry) {\n            global$1.getAngularTestability = function (elem, findInAncestors) {\n                if (findInAncestors === void 0) { findInAncestors = true; }\n                var testability = registry.findTestabilityInTree(elem, findInAncestors);\n                if (testability == null) {\n                    throw new Error('Could not find testability for element.');\n                }\n                return testability;\n            };\n            global$1.getAllAngularTestabilities = function () { return registry.getAllTestabilities(); };\n            global$1.getAllAngularRootElements = function () { return registry.getAllRootElements(); };\n            var whenAllStable = function (callback /** TODO #9100 */) {\n                var testabilities = global$1.getAllAngularTestabilities();\n                var count = testabilities.length;\n                var didWork = false;\n                var decrement = function (didWork_ /** TODO #9100 */) {\n                    didWork = didWork || didWork_;\n                    count--;\n                    if (count == 0) {\n                        callback(didWork);\n                    }\n                };\n                testabilities.forEach(function (testability /** TODO #9100 */) {\n                    testability.whenStable(decrement);\n                });\n            };\n            if (!global$1['frameworkStabilizers']) {\n                global$1['frameworkStabilizers'] = [];\n            }\n            global$1['frameworkStabilizers'].push(whenAllStable);\n        };\n        BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\n            if (elem == null) {\n                return null;\n            }\n            var t = registry.getTestability(elem);\n            if (isPresent(t)) {\n                return t;\n            }\n            else if (!findInAncestors) {\n                return null;\n            }\n            if (getDOM().isShadowRoot(elem)) {\n                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);\n            }\n            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);\n        };\n        return BrowserGetTestability;\n    }());\n\n    /**\n     * A service that can be used to get and set the title of a current HTML document.\n     *\n     * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)\n     * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n     * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n     * title value.\n     *\n     * @experimental\n     */\n    var Title = (function () {\n        function Title() {\n        }\n        /**\n         * Get the title of the current HTML document.\n         * @returns {string}\n         */\n        Title.prototype.getTitle = function () { return getDOM().getTitle(); };\n        /**\n         * Set the title of the current HTML document.\n         * @param newTitle\n         */\n        Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(newTitle); };\n        return Title;\n    }());\n\n    /**\n     * Wraps Javascript Objects\n     */\n    var StringMapWrapper = (function () {\n        function StringMapWrapper() {\n        }\n        StringMapWrapper.merge = function (m1, m2) {\n            var m = {};\n            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n                var k = _a[_i];\n                m[k] = m1[k];\n            }\n            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n                var k = _c[_b];\n                m[k] = m2[k];\n            }\n            return m;\n        };\n        StringMapWrapper.equals = function (m1, m2) {\n            var k1 = Object.keys(m1);\n            var k2 = Object.keys(m2);\n            if (k1.length != k2.length) {\n                return false;\n            }\n            for (var i = 0; i < k1.length; i++) {\n                var key = k1[i];\n                if (m1[key] !== m2[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return StringMapWrapper;\n    }());\n\n    /**\n     * A DI Token representing the main rendering context. In a browser this is the DOM Document.\n     *\n     * Note: Document might not be available in the Application Context when Application and Rendering\n     * Contexts are not the same (e.g. when running the application into a Web Worker).\n     *\n     * @stable\n     */\n    var DOCUMENT = new _angular_core.OpaqueToken('DocumentToken');\n\n    /**\n     * @stable\n     */\n    var EVENT_MANAGER_PLUGINS = new _angular_core.OpaqueToken('EventManagerPlugins');\n    /**\n     * @stable\n     */\n    var EventManager = (function () {\n        function EventManager(plugins, _zone) {\n            var _this = this;\n            this._zone = _zone;\n            this._eventNameToPlugin = new Map();\n            plugins.forEach(function (p) { return p.manager = _this; });\n            this._plugins = plugins.slice().reverse();\n        }\n        EventManager.prototype.addEventListener = function (element, eventName, handler) {\n            var plugin = this._findPluginFor(eventName);\n            return plugin.addEventListener(element, eventName, handler);\n        };\n        EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {\n            var plugin = this._findPluginFor(eventName);\n            return plugin.addGlobalEventListener(target, eventName, handler);\n        };\n        EventManager.prototype.getZone = function () { return this._zone; };\n        /** @internal */\n        EventManager.prototype._findPluginFor = function (eventName) {\n            var plugin = this._eventNameToPlugin.get(eventName);\n            if (plugin) {\n                return plugin;\n            }\n            var plugins = this._plugins;\n            for (var i = 0; i < plugins.length; i++) {\n                var plugin_1 = plugins[i];\n                if (plugin_1.supports(eventName)) {\n                    this._eventNameToPlugin.set(eventName, plugin_1);\n                    return plugin_1;\n                }\n            }\n            throw new Error(\"No event manager plugin found for event \" + eventName);\n        };\n        EventManager.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        EventManager.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },\n            { type: _angular_core.NgZone, },\n        ];\n        return EventManager;\n    }());\n    var EventManagerPlugin = (function () {\n        function EventManagerPlugin() {\n        }\n        EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {\n            var target = getDOM().getGlobalEventTarget(element);\n            if (!target) {\n                throw new Error(\"Unsupported event target \" + target + \" for event \" + eventName);\n            }\n            return this.addEventListener(target, eventName, handler);\n        };\n        ;\n        return EventManagerPlugin;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var SharedStylesHost = (function () {\n        function SharedStylesHost() {\n            /** @internal */\n            this._styles = [];\n            /** @internal */\n            this._stylesSet = new Set();\n        }\n        SharedStylesHost.prototype.addStyles = function (styles) {\n            var _this = this;\n            var additions = [];\n            styles.forEach(function (style) {\n                if (!_this._stylesSet.has(style)) {\n                    _this._stylesSet.add(style);\n                    _this._styles.push(style);\n                    additions.push(style);\n                }\n            });\n            this.onStylesAdded(additions);\n        };\n        SharedStylesHost.prototype.onStylesAdded = function (additions) { };\n        SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };\n        SharedStylesHost.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        SharedStylesHost.ctorParameters = [];\n        return SharedStylesHost;\n    }());\n    var DomSharedStylesHost = (function (_super) {\n        __extends$4(DomSharedStylesHost, _super);\n        function DomSharedStylesHost(doc) {\n            _super.call(this);\n            this._hostNodes = new Set();\n            this._hostNodes.add(doc.head);\n        }\n        /** @internal */\n        DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {\n            for (var i = 0; i < styles.length; i++) {\n                var styleEl = document.createElement('style');\n                styleEl.textContent = styles[i];\n                host.appendChild(styleEl);\n            }\n        };\n        DomSharedStylesHost.prototype.addHost = function (hostNode) {\n            this._addStylesToHost(this._styles, hostNode);\n            this._hostNodes.add(hostNode);\n        };\n        DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };\n        DomSharedStylesHost.prototype.onStylesAdded = function (additions) {\n            var _this = this;\n            this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });\n        };\n        DomSharedStylesHost.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomSharedStylesHost.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },\n        ];\n        return DomSharedStylesHost;\n    }(SharedStylesHost));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var NAMESPACE_URIS = {\n        'xlink': 'http://www.w3.org/1999/xlink',\n        'svg': 'http://www.w3.org/2000/svg',\n        'xhtml': 'http://www.w3.org/1999/xhtml'\n    };\n    var TEMPLATE_COMMENT_TEXT = 'template bindings={}';\n    var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;\n    var DomRootRenderer = (function () {\n        function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver, appId) {\n            this.document = document;\n            this.eventManager = eventManager;\n            this.sharedStylesHost = sharedStylesHost;\n            this.animationDriver = animationDriver;\n            this.appId = appId;\n            this.registeredComponents = new Map();\n        }\n        DomRootRenderer.prototype.renderComponent = function (componentProto) {\n            var renderer = this.registeredComponents.get(componentProto.id);\n            if (!renderer) {\n                renderer = new DomRenderer(this, componentProto, this.animationDriver, this.appId + \"-\" + componentProto.id);\n                this.registeredComponents.set(componentProto.id, renderer);\n            }\n            return renderer;\n        };\n        return DomRootRenderer;\n    }());\n    var DomRootRenderer_ = (function (_super) {\n        __extends$3(DomRootRenderer_, _super);\n        function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver, appId) {\n            _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver, appId);\n        }\n        DomRootRenderer_.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomRootRenderer_.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },\n            { type: EventManager, },\n            { type: DomSharedStylesHost, },\n            { type: AnimationDriver, },\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.APP_ID,] },] },\n        ];\n        return DomRootRenderer_;\n    }(DomRootRenderer));\n    var DIRECT_DOM_RENDERER = {\n        remove: function (node) {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        },\n        appendChild: function (node, parent) { parent.appendChild(node); },\n        insertBefore: function (node, refNode) { refNode.parentNode.insertBefore(node, refNode); },\n        nextSibling: function (node) { return node.nextSibling; },\n        parentElement: function (node) { return node.parentNode; }\n    };\n    var DomRenderer = (function () {\n        function DomRenderer(_rootRenderer, componentProto, _animationDriver, styleShimId) {\n            this._rootRenderer = _rootRenderer;\n            this.componentProto = componentProto;\n            this._animationDriver = _animationDriver;\n            this.directRenderer = DIRECT_DOM_RENDERER;\n            this._styles = flattenStyles(styleShimId, componentProto.styles, []);\n            if (componentProto.encapsulation !== _angular_core.ViewEncapsulation.Native) {\n                this._rootRenderer.sharedStylesHost.addStyles(this._styles);\n            }\n            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Emulated) {\n                this._contentAttr = shimContentAttribute(styleShimId);\n                this._hostAttr = shimHostAttribute(styleShimId);\n            }\n            else {\n                this._contentAttr = null;\n                this._hostAttr = null;\n            }\n        }\n        DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {\n            var el;\n            if (typeof selectorOrNode === 'string') {\n                el = this._rootRenderer.document.querySelector(selectorOrNode);\n                if (!el) {\n                    throw new Error(\"The selector \\\"\" + selectorOrNode + \"\\\" did not match any elements\");\n                }\n            }\n            else {\n                el = selectorOrNode;\n            }\n            while (el.firstChild) {\n                el.removeChild(el.firstChild);\n            }\n            return el;\n        };\n        DomRenderer.prototype.createElement = function (parent, name, debugInfo) {\n            var el;\n            if (isNamespaced(name)) {\n                var nsAndName = splitNamespace(name);\n                el = document.createElementNS((NAMESPACE_URIS)[nsAndName[0]], nsAndName[1]);\n            }\n            else {\n                el = document.createElement(name);\n            }\n            if (this._contentAttr) {\n                el.setAttribute(this._contentAttr, '');\n            }\n            if (parent) {\n                parent.appendChild(el);\n            }\n            return el;\n        };\n        DomRenderer.prototype.createViewRoot = function (hostElement) {\n            var nodesParent;\n            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native) {\n                nodesParent = hostElement.createShadowRoot();\n                this._rootRenderer.sharedStylesHost.addHost(nodesParent);\n                for (var i = 0; i < this._styles.length; i++) {\n                    var styleEl = document.createElement('style');\n                    styleEl.textContent = this._styles[i];\n                    nodesParent.appendChild(styleEl);\n                }\n            }\n            else {\n                if (this._hostAttr) {\n                    hostElement.setAttribute(this._hostAttr, '');\n                }\n                nodesParent = hostElement;\n            }\n            return nodesParent;\n        };\n        DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {\n            var comment = document.createComment(TEMPLATE_COMMENT_TEXT);\n            if (parentElement) {\n                parentElement.appendChild(comment);\n            }\n            return comment;\n        };\n        DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {\n            var node = document.createTextNode(value);\n            if (parentElement) {\n                parentElement.appendChild(node);\n            }\n            return node;\n        };\n        DomRenderer.prototype.projectNodes = function (parentElement, nodes) {\n            if (!parentElement)\n                return;\n            appendNodes(parentElement, nodes);\n        };\n        DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };\n        DomRenderer.prototype.detachView = function (viewRootNodes) {\n            for (var i = 0; i < viewRootNodes.length; i++) {\n                var node = viewRootNodes[i];\n                if (node.parentNode) {\n                    node.parentNode.removeChild(node);\n                }\n            }\n        };\n        DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {\n            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native && hostElement) {\n                this._rootRenderer.sharedStylesHost.removeHost(hostElement.shadowRoot);\n            }\n        };\n        DomRenderer.prototype.listen = function (renderElement, name, callback) {\n            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));\n        };\n        DomRenderer.prototype.listenGlobal = function (target, name, callback) {\n            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));\n        };\n        DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {\n            renderElement[propertyName] = propertyValue;\n        };\n        DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {\n            var attrNs;\n            var attrNameWithoutNs = attributeName;\n            if (isNamespaced(attributeName)) {\n                var nsAndName = splitNamespace(attributeName);\n                attrNameWithoutNs = nsAndName[1];\n                attributeName = nsAndName[0] + ':' + nsAndName[1];\n                attrNs = NAMESPACE_URIS[nsAndName[0]];\n            }\n            if (isPresent(attributeValue)) {\n                if (attrNs) {\n                    renderElement.setAttributeNS(attrNs, attributeName, attributeValue);\n                }\n                else {\n                    renderElement.setAttribute(attributeName, attributeValue);\n                }\n            }\n            else {\n                if (isPresent(attrNs)) {\n                    renderElement.removeAttributeNS(attrNs, attrNameWithoutNs);\n                }\n                else {\n                    renderElement.removeAttribute(attributeName);\n                }\n            }\n        };\n        DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {\n            if (renderElement.nodeType === Node.COMMENT_NODE) {\n                var existingBindings = renderElement.nodeValue.replace(/\\n/g, '').match(TEMPLATE_BINDINGS_EXP);\n                var parsedBindings = JSON.parse(existingBindings[1]);\n                parsedBindings[propertyName] = propertyValue;\n                renderElement.nodeValue =\n                    TEMPLATE_COMMENT_TEXT.replace('{}', JSON.stringify(parsedBindings, null, 2));\n            }\n            else {\n                this.setElementAttribute(renderElement, propertyName, propertyValue);\n            }\n        };\n        DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {\n            if (isAdd) {\n                renderElement.classList.add(className);\n            }\n            else {\n                renderElement.classList.remove(className);\n            }\n        };\n        DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {\n            if (isPresent(styleValue)) {\n                renderElement.style[styleName] = stringify(styleValue);\n            }\n            else {\n                // IE requires '' instead of null\n                // see https://github.com/angular/angular/issues/7916\n                renderElement.style[styleName] = '';\n            }\n        };\n        DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {\n            renderElement[methodName].apply(renderElement, args);\n        };\n        DomRenderer.prototype.setText = function (renderNode, text) { renderNode.nodeValue = text; };\n        DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {\n            return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);\n        };\n        return DomRenderer;\n    }());\n    function moveNodesAfterSibling(sibling, nodes) {\n        var parent = sibling.parentNode;\n        if (nodes.length > 0 && parent) {\n            var nextSibling = sibling.nextSibling;\n            if (nextSibling) {\n                for (var i = 0; i < nodes.length; i++) {\n                    parent.insertBefore(nodes[i], nextSibling);\n                }\n            }\n            else {\n                for (var i = 0; i < nodes.length; i++) {\n                    parent.appendChild(nodes[i]);\n                }\n            }\n        }\n    }\n    function appendNodes(parent, nodes) {\n        for (var i = 0; i < nodes.length; i++) {\n            parent.appendChild(nodes[i]);\n        }\n    }\n    function decoratePreventDefault(eventHandler) {\n        return function (event) {\n            var allowDefaultBehavior = eventHandler(event);\n            if (allowDefaultBehavior === false) {\n                // TODO(tbosch): move preventDefault into event plugins...\n                event.preventDefault();\n                event.returnValue = false;\n            }\n        };\n    }\n    var COMPONENT_REGEX = /%COMP%/g;\n    var COMPONENT_VARIABLE = '%COMP%';\n    var HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\n    var CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\n    function shimContentAttribute(componentShortId) {\n        return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n    }\n    function shimHostAttribute(componentShortId) {\n        return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n    }\n    function flattenStyles(compId, styles, target) {\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            if (Array.isArray(style)) {\n                flattenStyles(compId, style, target);\n            }\n            else {\n                style = style.replace(COMPONENT_REGEX, compId);\n                target.push(style);\n            }\n        }\n        return target;\n    }\n    var NS_PREFIX_RE = /^:([^:]+):(.+)$/;\n    function isNamespaced(name) {\n        return name[0] === ':';\n    }\n    function splitNamespace(name) {\n        var match = name.match(NS_PREFIX_RE);\n        return [match[1], match[2]];\n    }\n\n    var CORE_TOKENS = {\n        'ApplicationRef': _angular_core.ApplicationRef,\n        'NgZone': _angular_core.NgZone\n    };\n    var INSPECT_GLOBAL_NAME = 'ng.probe';\n    var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';\n    /**\n     * Returns a {@link DebugElement} for the given native DOM element, or\n     * null if the given native element does not have an Angular view associated\n     * with it.\n     */\n    function inspectNativeElement(element /** TODO #9100 */) {\n        return _angular_core.getDebugNode(element);\n    }\n    /**\n     * @experimental\n     */\n    var NgProbeToken = (function () {\n        function NgProbeToken(name, token) {\n            this.name = name;\n            this.token = token;\n        }\n        return NgProbeToken;\n    }());\n    function _createConditionalRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {\n        if (_angular_core.isDevMode()) {\n            return _createRootRenderer(rootRenderer, extraTokens);\n        }\n        return rootRenderer;\n    }\n    function _createRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {\n        getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);\n        getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, StringMapWrapper.merge(CORE_TOKENS, _ngProbeTokensToMap(extraTokens || [])));\n        return new DebugDomRootRenderer(rootRenderer);\n    }\n    function _ngProbeTokensToMap(tokens) {\n        return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});\n    }\n    /**\n     * Providers which support debugging Angular applications (e.g. via `ng.probe`).\n     */\n    var ELEMENT_PROBE_PROVIDERS = [{\n            provide: _angular_core.RootRenderer,\n            useFactory: _createConditionalRootRenderer,\n            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]\n        }];\n    var ELEMENT_PROBE_PROVIDERS_PROD_MODE = [{\n            provide: _angular_core.RootRenderer,\n            useFactory: _createRootRenderer,\n            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]\n        }];\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$5 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var DomEventsPlugin = (function (_super) {\n        __extends$5(DomEventsPlugin, _super);\n        function DomEventsPlugin() {\n            _super.apply(this, arguments);\n        }\n        // This plugin should come last in the list of plugins, because it accepts all\n        // events.\n        DomEventsPlugin.prototype.supports = function (eventName) { return true; };\n        DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {\n            element.addEventListener(eventName, handler, false);\n            return function () { return element.removeEventListener(eventName, handler, false); };\n        };\n        DomEventsPlugin.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomEventsPlugin.ctorParameters = [];\n        return DomEventsPlugin;\n    }(EventManagerPlugin));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$6 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var EVENT_NAMES = {\n        // pan\n        'pan': true,\n        'panstart': true,\n        'panmove': true,\n        'panend': true,\n        'pancancel': true,\n        'panleft': true,\n        'panright': true,\n        'panup': true,\n        'pandown': true,\n        // pinch\n        'pinch': true,\n        'pinchstart': true,\n        'pinchmove': true,\n        'pinchend': true,\n        'pinchcancel': true,\n        'pinchin': true,\n        'pinchout': true,\n        // press\n        'press': true,\n        'pressup': true,\n        // rotate\n        'rotate': true,\n        'rotatestart': true,\n        'rotatemove': true,\n        'rotateend': true,\n        'rotatecancel': true,\n        // swipe\n        'swipe': true,\n        'swipeleft': true,\n        'swiperight': true,\n        'swipeup': true,\n        'swipedown': true,\n        // tap\n        'tap': true,\n    };\n    /**\n     * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure\n     * Hammer gestures.\n     *\n     * @experimental\n     */\n    var HAMMER_GESTURE_CONFIG = new _angular_core.OpaqueToken('HammerGestureConfig');\n    /**\n     * @experimental\n     */\n    var HammerGestureConfig = (function () {\n        function HammerGestureConfig() {\n            this.events = [];\n            this.overrides = {};\n        }\n        HammerGestureConfig.prototype.buildHammer = function (element) {\n            var mc = new Hammer(element);\n            mc.get('pinch').set({ enable: true });\n            mc.get('rotate').set({ enable: true });\n            for (var eventName in this.overrides) {\n                mc.get(eventName).set(this.overrides[eventName]);\n            }\n            return mc;\n        };\n        HammerGestureConfig.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        HammerGestureConfig.ctorParameters = [];\n        return HammerGestureConfig;\n    }());\n    var HammerGesturesPlugin = (function (_super) {\n        __extends$6(HammerGesturesPlugin, _super);\n        function HammerGesturesPlugin(_config) {\n            _super.call(this);\n            this._config = _config;\n        }\n        HammerGesturesPlugin.prototype.supports = function (eventName) {\n            if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n                return false;\n            }\n            if (!window.Hammer) {\n                throw new Error(\"Hammer.js is not loaded, can not bind \" + eventName + \" event\");\n            }\n            return true;\n        };\n        HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {\n            var _this = this;\n            var zone = this.manager.getZone();\n            eventName = eventName.toLowerCase();\n            return zone.runOutsideAngular(function () {\n                // Creating the manager bind events, must be done outside of angular\n                var mc = _this._config.buildHammer(element);\n                var callback = function (eventObj) {\n                    zone.runGuarded(function () { handler(eventObj); });\n                };\n                mc.on(eventName, callback);\n                return function () { return mc.off(eventName, callback); };\n            });\n        };\n        HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };\n        HammerGesturesPlugin.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        HammerGesturesPlugin.ctorParameters = [\n            { type: HammerGestureConfig, decorators: [{ type: _angular_core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },\n        ];\n        return HammerGesturesPlugin;\n    }(EventManagerPlugin));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$7 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];\n    var MODIFIER_KEY_GETTERS = {\n        'alt': function (event) { return event.altKey; },\n        'control': function (event) { return event.ctrlKey; },\n        'meta': function (event) { return event.metaKey; },\n        'shift': function (event) { return event.shiftKey; }\n    };\n    /**\n     * @experimental\n     */\n    var KeyEventsPlugin = (function (_super) {\n        __extends$7(KeyEventsPlugin, _super);\n        function KeyEventsPlugin() {\n            _super.call(this);\n        }\n        KeyEventsPlugin.prototype.supports = function (eventName) { return KeyEventsPlugin.parseEventName(eventName) != null; };\n        KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {\n            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);\n            var outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());\n            return this.manager.getZone().runOutsideAngular(function () {\n                return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);\n            });\n        };\n        KeyEventsPlugin.parseEventName = function (eventName) {\n            var parts = eventName.toLowerCase().split('.');\n            var domEventName = parts.shift();\n            if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {\n                return null;\n            }\n            var key = KeyEventsPlugin._normalizeKey(parts.pop());\n            var fullKey = '';\n            MODIFIER_KEYS.forEach(function (modifierName) {\n                var index = parts.indexOf(modifierName);\n                if (index > -1) {\n                    parts.splice(index, 1);\n                    fullKey += modifierName + '.';\n                }\n            });\n            fullKey += key;\n            if (parts.length != 0 || key.length === 0) {\n                // returning null instead of throwing to let another plugin process the event\n                return null;\n            }\n            var result = {};\n            result['domEventName'] = domEventName;\n            result['fullKey'] = fullKey;\n            return result;\n        };\n        KeyEventsPlugin.getEventFullKey = function (event) {\n            var fullKey = '';\n            var key = getDOM().getEventKey(event);\n            key = key.toLowerCase();\n            if (key === ' ') {\n                key = 'space'; // for readability\n            }\n            else if (key === '.') {\n                key = 'dot'; // because '.' is used as a separator in event names\n            }\n            MODIFIER_KEYS.forEach(function (modifierName) {\n                if (modifierName != key) {\n                    var modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n                    if (modifierGetter(event)) {\n                        fullKey += modifierName + '.';\n                    }\n                }\n            });\n            fullKey += key;\n            return fullKey;\n        };\n        KeyEventsPlugin.eventCallback = function (fullKey, handler, zone) {\n            return function (event /** TODO #9100 */) {\n                if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {\n                    zone.runGuarded(function () { return handler(event); });\n                }\n            };\n        };\n        /** @internal */\n        KeyEventsPlugin._normalizeKey = function (keyName) {\n            // TODO: switch to a Map if the mapping grows too much\n            switch (keyName) {\n                case 'esc':\n                    return 'escape';\n                default:\n                    return keyName;\n            }\n        };\n        KeyEventsPlugin.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        KeyEventsPlugin.ctorParameters = [];\n        return KeyEventsPlugin;\n    }(EventManagerPlugin));\n\n    /**\n     * A pattern that recognizes a commonly useful subset of URLs that are safe.\n     *\n     * This regular expression matches a subset of URLs that will not cause script\n     * execution if used in URL context within a HTML document. Specifically, this\n     * regular expression matches if (comment from here on and regex copied from\n     * Soy's EscapingConventions):\n     * (1) Either a protocol in a whitelist (http, https, mailto or ftp).\n     * (2) or no protocol.  A protocol must be followed by a colon. The below\n     *     allows that by allowing colons only after one of the characters [/?#].\n     *     A colon after a hash (#) must be in the fragment.\n     *     Otherwise, a colon after a (?) must be in a query.\n     *     Otherwise, a colon after a single solidus (/) must be in a path.\n     *     Otherwise, a colon after a double solidus (//) must be in the authority\n     *     (before port).\n     *\n     * The pattern disallows &, used in HTML entity declarations before\n     * one of the characters in [/?#]. This disallows HTML entities used in the\n     * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n     * It also disallows HTML entities in the first path part of a relative path,\n     * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n     * that. More importantly, it disallows masking of a colon,\n     * e.g. \"javascript&#58;...\".\n     *\n     * This regular expression was taken from the Closure sanitization library.\n     */\n    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */\n    var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n    function sanitizeUrl(url) {\n        url = String(url);\n        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))\n            return url;\n        if (_angular_core.isDevMode()) {\n            getDOM().log(\"WARNING: sanitizing unsafe URL value \" + url + \" (see http://g.co/ng/security#xss)\");\n        }\n        return 'unsafe:' + url;\n    }\n    function sanitizeSrcset(srcset) {\n        srcset = String(srcset);\n        return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');\n    }\n\n    /** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */\n    var inertElement = null;\n    /** Lazily initialized to make sure the DOM adapter gets set before use. */\n    var DOM = null;\n    /** Returns an HTML element that is guaranteed to not execute code when creating elements in it. */\n    function getInertElement() {\n        if (inertElement)\n            return inertElement;\n        DOM = getDOM();\n        // Prefer using <template> element if supported.\n        var templateEl = DOM.createElement('template');\n        if ('content' in templateEl)\n            return templateEl;\n        var doc = DOM.createHtmlDocument();\n        inertElement = DOM.querySelector(doc, 'body');\n        if (inertElement == null) {\n            // usually there should be only one body element in the document, but IE doesn't have any, so we\n            // need to create one.\n            var html = DOM.createElement('html', doc);\n            inertElement = DOM.createElement('body', doc);\n            DOM.appendChild(html, inertElement);\n            DOM.appendChild(doc, html);\n        }\n        return inertElement;\n    }\n    function tagSet(tags) {\n        var res = {};\n        for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {\n            var t = _a[_i];\n            res[t] = true;\n        }\n        return res;\n    }\n    function merge() {\n        var sets = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            sets[_i - 0] = arguments[_i];\n        }\n        var res = {};\n        for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {\n            var s = sets_1[_a];\n            for (var v in s) {\n                if (s.hasOwnProperty(v))\n                    res[v] = true;\n            }\n        }\n        return res;\n    }\n    // Good source of info about elements and attributes\n    // http://dev.w3.org/html5/spec/Overview.html#semantics\n    // http://simon.html5.org/html-elements\n    // Safe Void Elements - HTML5\n    // http://dev.w3.org/html5/spec/Overview.html#void-elements\n    var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n    // Elements that you can, intentionally, leave open (and which close themselves)\n    // http://dev.w3.org/html5/spec/Overview.html#optional-tags\n    var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\n    var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\n    var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n    // Safe Block Elements - HTML5\n    var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +\n        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n    // Inline Elements - HTML5\n    var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +\n        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\n    var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n    // Attributes that have href and hence need to be sanitized\n    var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\n    // Attributes that have special href set hence need to be sanitized\n    var SRCSET_ATTRS = tagSet('srcset');\n    var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\n        'valign,value,vspace,width');\n    // NB: This currently conciously doesn't support SVG. SVG sanitization has had several security\n    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n    // innerHTML is required, SVG attributes should be added here.\n    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n    // can be sanitized, but they increase security surface area without a legitimate use case, so they\n    // are left out here.\n    var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);\n    /**\n     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n     * attributes.\n     */\n    var SanitizingHtmlSerializer = (function () {\n        function SanitizingHtmlSerializer() {\n            // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n            // because characters were re-encoded.\n            this.sanitizedSomething = false;\n            this.buf = [];\n        }\n        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {\n            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n            // However this code never accesses properties off of `document` before deleting its contents\n            // again, so it shouldn't be vulnerable to DOM clobbering.\n            var current = el.firstChild;\n            while (current) {\n                if (DOM.isElementNode(current)) {\n                    this.startElement(current);\n                }\n                else if (DOM.isTextNode(current)) {\n                    this.chars(DOM.nodeValue(current));\n                }\n                else {\n                    // Strip non-element, non-text nodes.\n                    this.sanitizedSomething = true;\n                }\n                if (DOM.firstChild(current)) {\n                    current = DOM.firstChild(current);\n                    continue;\n                }\n                while (current) {\n                    // Leaving the element. Walk up and to the right, closing tags as we go.\n                    if (DOM.isElementNode(current)) {\n                        this.endElement(current);\n                    }\n                    if (DOM.nextSibling(current)) {\n                        current = DOM.nextSibling(current);\n                        break;\n                    }\n                    current = DOM.parentElement(current);\n                }\n            }\n            return this.buf.join('');\n        };\n        SanitizingHtmlSerializer.prototype.startElement = function (element) {\n            var _this = this;\n            var tagName = DOM.nodeName(element).toLowerCase();\n            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n                this.sanitizedSomething = true;\n                return;\n            }\n            this.buf.push('<');\n            this.buf.push(tagName);\n            DOM.attributeMap(element).forEach(function (value, attrName) {\n                var lower = attrName.toLowerCase();\n                if (!VALID_ATTRS.hasOwnProperty(lower)) {\n                    _this.sanitizedSomething = true;\n                    return;\n                }\n                // TODO(martinprobst): Special case image URIs for data:image/...\n                if (URI_ATTRS[lower])\n                    value = sanitizeUrl(value);\n                if (SRCSET_ATTRS[lower])\n                    value = sanitizeSrcset(value);\n                _this.buf.push(' ');\n                _this.buf.push(attrName);\n                _this.buf.push('=\"');\n                _this.buf.push(encodeEntities(value));\n                _this.buf.push('\"');\n            });\n            this.buf.push('>');\n        };\n        SanitizingHtmlSerializer.prototype.endElement = function (current) {\n            var tagName = DOM.nodeName(current).toLowerCase();\n            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n                this.buf.push('</');\n                this.buf.push(tagName);\n                this.buf.push('>');\n            }\n        };\n        SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };\n        return SanitizingHtmlSerializer;\n    }());\n    // Regular Expressions for parsing tags and attributes\n    var SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    // ! to ~ is the ASCII range.\n    var NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n    /**\n     * Escapes all potentially dangerous characters, so that the\n     * resulting string can be safely inserted into attribute or\n     * element text.\n     * @param value\n     * @returns {string} escaped text\n     */\n    function encodeEntities(value) {\n        return value.replace(/&/g, '&amp;')\n            .replace(SURROGATE_PAIR_REGEXP, function (match) {\n            var hi = match.charCodeAt(0);\n            var low = match.charCodeAt(1);\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n        })\n            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;');\n    }\n    /**\n     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').\n     *\n     * This is undesirable since we don't want to allow any of these custom attributes. This method\n     * strips them all.\n     */\n    function stripCustomNsAttrs(el) {\n        DOM.attributeMap(el).forEach(function (_, attrName) {\n            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n                DOM.removeAttribute(el, attrName);\n            }\n        });\n        for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {\n            var n = _a[_i];\n            if (DOM.isElementNode(n))\n                stripCustomNsAttrs(n);\n        }\n    }\n    /**\n     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n     * the DOM in a browser environment.\n     */\n    function sanitizeHtml(unsafeHtmlInput) {\n        try {\n            var containerEl = getInertElement();\n            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n            var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n            var mXSSAttempts = 5;\n            var parsedHtml = unsafeHtml;\n            do {\n                if (mXSSAttempts === 0) {\n                    throw new Error('Failed to sanitize html because the input is unstable');\n                }\n                mXSSAttempts--;\n                unsafeHtml = parsedHtml;\n                DOM.setInnerHTML(containerEl, unsafeHtml);\n                if (DOM.defaultDoc().documentMode) {\n                    // strip custom-namespaced attributes on IE<=11\n                    stripCustomNsAttrs(containerEl);\n                }\n                parsedHtml = DOM.getInnerHTML(containerEl);\n            } while (unsafeHtml !== parsedHtml);\n            var sanitizer = new SanitizingHtmlSerializer();\n            var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);\n            // Clear out the body element.\n            var parent_1 = DOM.getTemplateContent(containerEl) || containerEl;\n            for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {\n                var child = _a[_i];\n                DOM.removeChild(parent_1, child);\n            }\n            if (_angular_core.isDevMode() && sanitizer.sanitizedSomething) {\n                DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');\n            }\n            return safeHtml;\n        }\n        catch (e) {\n            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n            inertElement = null;\n            throw e;\n        }\n    }\n\n    /**\n     * Regular expression for safe style values.\n     *\n     * Quotes (\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\n     *\n     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\n     * font-family) and hence could allow multiple values to get injected, but that should pose no risk\n     * of XSS.\n     *\n     * The function expression checks only for XSS safety, not for CSS validity.\n     *\n     * This regular expression was taken from the Closure sanitization library, and augmented for\n     * transformation values.\n     */\n    var VALUES = '[-,.\"\\'%_!# a-zA-Z0-9]+';\n    var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';\n    var COLOR_FNS = '(?:rgb|hsl)a?';\n    var FN_ARGS = '\\\\([-0-9.%, a-zA-Z]+\\\\)';\n    var SAFE_STYLE_VALUE = new RegExp(\"^(\" + VALUES + \"|(?:\" + TRANSFORMATION_FNS + \"|\" + COLOR_FNS + \")\" + FN_ARGS + \")$\", 'g');\n    /**\n     * Matches a `url(...)` value with an arbitrary argument as long as it does\n     * not contain parentheses.\n     *\n     * The URL value still needs to be sanitized separately.\n     *\n     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\n     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\n     * by observing whether scroll bars are displayed, or character ranges used by a font face\n     * definition.\n     *\n     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\n     * binding a URL value without further cooperation from the page will cause an information leak, and\n     * if so, it is just a leak, not a full blown XSS vulnerability.\n     *\n     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\n     * code is permissive and allows URLs that sanitize otherwise.\n     */\n    var URL_RE = /^url\\(([^)]+)\\)$/;\n    /**\n     * Checks that quotes (\" and ') are properly balanced inside a string. Assumes\n     * that neither escape (\\) nor any other character that could result in\n     * breaking out of a string parsing context are allowed;\n     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\n     *\n     * This code was taken from the Closure sanitization library.\n     */\n    function hasBalancedQuotes(value) {\n        var outsideSingle = true;\n        var outsideDouble = true;\n        for (var i = 0; i < value.length; i++) {\n            var c = value.charAt(i);\n            if (c === '\\'' && outsideDouble) {\n                outsideSingle = !outsideSingle;\n            }\n            else if (c === '\"' && outsideSingle) {\n                outsideDouble = !outsideDouble;\n            }\n        }\n        return outsideSingle && outsideDouble;\n    }\n    /**\n     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\n     * value) and returns a value that is safe to use in a browser environment.\n     */\n    function sanitizeStyle(value) {\n        value = String(value).trim(); // Make sure it's actually a string.\n        if (!value)\n            return '';\n        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\n        // reasoning behind this.\n        var urlMatch = value.match(URL_RE);\n        if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||\n            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\n            return value; // Safe style values.\n        }\n        if (_angular_core.isDevMode()) {\n            getDOM().log(\"WARNING: sanitizing unsafe style value \" + value + \" (see http://g.co/ng/security#xss).\");\n        }\n        return 'unsafe';\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$8 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n     * values to be safe to use in the different DOM contexts.\n     *\n     * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n     * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n     * the website.\n     *\n     * In specific situations, it might be necessary to disable sanitization, for example if the\n     * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n     * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n     * methods, and then binding to that value from the template.\n     *\n     * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n     * Cross Site Scripting (XSS) security bug!\n     *\n     * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n     * close as possible to the source of the value, to make it easy to verify no security bug is\n     * created by its use.\n     *\n     * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n     * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n     * code. The sanitizer leaves safe values intact.\n     *\n     * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n     * sanitization for the value passed in. Carefully check and audit all values and code paths going\n     * into this call. Make sure any user data is appropriately escaped for this security context.\n     * For more detail, see the [Security Guide](http://g.co/ng/security).\n     *\n     * @stable\n     */\n    var DomSanitizer = (function () {\n        function DomSanitizer() {\n        }\n        return DomSanitizer;\n    }());\n    var DomSanitizerImpl = (function (_super) {\n        __extends$8(DomSanitizerImpl, _super);\n        function DomSanitizerImpl() {\n            _super.apply(this, arguments);\n        }\n        DomSanitizerImpl.prototype.sanitize = function (ctx, value) {\n            if (value == null)\n                return null;\n            switch (ctx) {\n                case _angular_core.SecurityContext.NONE:\n                    return value;\n                case _angular_core.SecurityContext.HTML:\n                    if (value instanceof SafeHtmlImpl)\n                        return value.changingThisBreaksApplicationSecurity;\n                    this.checkNotSafeValue(value, 'HTML');\n                    return sanitizeHtml(String(value));\n                case _angular_core.SecurityContext.STYLE:\n                    if (value instanceof SafeStyleImpl)\n                        return value.changingThisBreaksApplicationSecurity;\n                    this.checkNotSafeValue(value, 'Style');\n                    return sanitizeStyle(value);\n                case _angular_core.SecurityContext.SCRIPT:\n                    if (value instanceof SafeScriptImpl)\n                        return value.changingThisBreaksApplicationSecurity;\n                    this.checkNotSafeValue(value, 'Script');\n                    throw new Error('unsafe value used in a script context');\n                case _angular_core.SecurityContext.URL:\n                    if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {\n                        // Allow resource URLs in URL contexts, they are strictly more trusted.\n                        return value.changingThisBreaksApplicationSecurity;\n                    }\n                    this.checkNotSafeValue(value, 'URL');\n                    return sanitizeUrl(String(value));\n                case _angular_core.SecurityContext.RESOURCE_URL:\n                    if (value instanceof SafeResourceUrlImpl) {\n                        return value.changingThisBreaksApplicationSecurity;\n                    }\n                    this.checkNotSafeValue(value, 'ResourceURL');\n                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\n                default:\n                    throw new Error(\"Unexpected SecurityContext \" + ctx + \" (see http://g.co/ng/security#xss)\");\n            }\n        };\n        DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {\n            if (value instanceof SafeValueImpl) {\n                throw new Error((\"Required a safe \" + expectedType + \", got a \" + value.getTypeName() + \" \") +\n                    \"(see http://g.co/ng/security#xss)\");\n            }\n        };\n        DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };\n        DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {\n            return new SafeResourceUrlImpl(value);\n        };\n        DomSanitizerImpl.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        DomSanitizerImpl.ctorParameters = [];\n        return DomSanitizerImpl;\n    }(DomSanitizer));\n    var SafeValueImpl = (function () {\n        function SafeValueImpl(changingThisBreaksApplicationSecurity) {\n            this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n            // empty\n        }\n        SafeValueImpl.prototype.toString = function () {\n            return (\"SafeValue must use [property]=binding: \" + this.changingThisBreaksApplicationSecurity) +\n                \" (see http://g.co/ng/security#xss)\";\n        };\n        return SafeValueImpl;\n    }());\n    var SafeHtmlImpl = (function (_super) {\n        __extends$8(SafeHtmlImpl, _super);\n        function SafeHtmlImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };\n        return SafeHtmlImpl;\n    }(SafeValueImpl));\n    var SafeStyleImpl = (function (_super) {\n        __extends$8(SafeStyleImpl, _super);\n        function SafeStyleImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };\n        return SafeStyleImpl;\n    }(SafeValueImpl));\n    var SafeScriptImpl = (function (_super) {\n        __extends$8(SafeScriptImpl, _super);\n        function SafeScriptImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };\n        return SafeScriptImpl;\n    }(SafeValueImpl));\n    var SafeUrlImpl = (function (_super) {\n        __extends$8(SafeUrlImpl, _super);\n        function SafeUrlImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };\n        return SafeUrlImpl;\n    }(SafeValueImpl));\n    var SafeResourceUrlImpl = (function (_super) {\n        __extends$8(SafeResourceUrlImpl, _super);\n        function SafeResourceUrlImpl() {\n            _super.apply(this, arguments);\n        }\n        SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };\n        return SafeResourceUrlImpl;\n    }(SafeValueImpl));\n\n    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [\n        { provide: _angular_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },\n        { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation }\n    ];\n    /**\n     * @security Replacing built-in sanitization providers exposes the application to XSS risks.\n     * Attacker-controlled data introduced by an unsanitized provider could expose your\n     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n     * @experimental\n     */\n    var BROWSER_SANITIZATION_PROVIDERS = [\n        { provide: _angular_core.Sanitizer, useExisting: DomSanitizer },\n        { provide: DomSanitizer, useClass: DomSanitizerImpl },\n    ];\n    /**\n     * @stable\n     */\n    var platformBrowser = _angular_core.createPlatformFactory(_angular_core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n    function initDomAdapter() {\n        BrowserDomAdapter.makeCurrent();\n        BrowserGetTestability.init();\n    }\n    function errorHandler() {\n        return new _angular_core.ErrorHandler();\n    }\n    function _document() {\n        return getDOM().defaultDoc();\n    }\n    function _resolveDefaultAnimationDriver() {\n        if (getDOM().supportsWebAnimation()) {\n            return new WebAnimationsDriver();\n        }\n        return AnimationDriver.NOOP;\n    }\n    /**\n     * The ng module for the browser.\n     *\n     * @stable\n     */\n    var BrowserModule = (function () {\n        function BrowserModule(parentModule) {\n            if (parentModule) {\n                throw new Error(\"BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.\");\n            }\n        }\n        BrowserModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        providers: [\n                            BROWSER_SANITIZATION_PROVIDERS, { provide: _angular_core.ErrorHandler, useFactory: errorHandler, deps: [] },\n                            { provide: DOCUMENT, useFactory: _document, deps: [] },\n                            { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },\n                            { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },\n                            { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },\n                            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },\n                            { provide: DomRootRenderer, useClass: DomRootRenderer_ },\n                            { provide: _angular_core.RootRenderer, useExisting: DomRootRenderer },\n                            { provide: SharedStylesHost, useExisting: DomSharedStylesHost },\n                            { provide: AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost,\n                            _angular_core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Title\n                        ],\n                        exports: [_angular_common.CommonModule, _angular_core.ApplicationModule]\n                    },] },\n        ];\n        /** @nocollapse */\n        BrowserModule.ctorParameters = [\n            { type: BrowserModule, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf },] },\n        ];\n        return BrowserModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * JS version of browser APIs. This library can only run in the browser.\n     */\n    var win = typeof window !== 'undefined' && window || {};\n\n    var ChangeDetectionPerfRecord = (function () {\n        function ChangeDetectionPerfRecord(msPerTick, numTicks) {\n            this.msPerTick = msPerTick;\n            this.numTicks = numTicks;\n        }\n        return ChangeDetectionPerfRecord;\n    }());\n    /**\n     * Entry point for all Angular debug tools. This object corresponds to the `ng`\n     * global variable accessible in the dev console.\n     */\n    var AngularTools = (function () {\n        function AngularTools(ref) {\n            this.profiler = new AngularProfiler(ref);\n        }\n        return AngularTools;\n    }());\n    /**\n     * Entry point for all Angular profiling-related debug tools. This object\n     * corresponds to the `ng.profiler` in the dev console.\n     */\n    var AngularProfiler = (function () {\n        function AngularProfiler(ref) {\n            this.appRef = ref.injector.get(_angular_core.ApplicationRef);\n        }\n        /**\n         * Exercises change detection in a loop and then prints the average amount of\n         * time in milliseconds how long a single round of change detection takes for\n         * the current state of the UI. It runs a minimum of 5 rounds for a minimum\n         * of 500 milliseconds.\n         *\n         * Optionally, a user may pass a `config` parameter containing a map of\n         * options. Supported options are:\n         *\n         * `record` (boolean) - causes the profiler to record a CPU profile while\n         * it exercises the change detector. Example:\n         *\n         * ```\n         * ng.profiler.timeChangeDetection({record: true})\n         * ```\n         */\n        AngularProfiler.prototype.timeChangeDetection = function (config) {\n            var record = config && config['record'];\n            var profileName = 'Change Detection';\n            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened\n            var isProfilerAvailable = isPresent(win.console.profile);\n            if (record && isProfilerAvailable) {\n                win.console.profile(profileName);\n            }\n            var start = getDOM().performanceNow();\n            var numTicks = 0;\n            while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {\n                this.appRef.tick();\n                numTicks++;\n            }\n            var end = getDOM().performanceNow();\n            if (record && isProfilerAvailable) {\n                // need to cast to <any> because type checker thinks there's no argument\n                // while in fact there is:\n                //\n                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd\n                win.console.profileEnd(profileName);\n            }\n            var msPerTick = (end - start) / numTicks;\n            win.console.log(\"ran \" + numTicks + \" change detection cycles\");\n            win.console.log(msPerTick.toFixed(2) + \" ms per check\");\n            return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n        };\n        return AngularProfiler;\n    }());\n\n    var context = global$1;\n    /**\n     * Enabled Angular 2 debug tools that are accessible via your browser's\n     * developer console.\n     *\n     * Usage:\n     *\n     * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n     * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n     * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n     *    then hit Enter.\n     *\n     * @experimental All debugging apis are currently experimental.\n     */\n    function enableDebugTools(ref) {\n        Object.assign(context.ng, new AngularTools(ref));\n        return ref;\n    }\n    /**\n     * Disables Angular 2 tools.\n     *\n     * @experimental All debugging apis are currently experimental.\n     */\n    function disableDebugTools() {\n        delete context.ng.profiler;\n    }\n\n    /**\n     * Predicates for use with {@link DebugElement}'s query functions.\n     *\n     * @experimental All debugging apis are currently experimental.\n     */\n    var By = (function () {\n        function By() {\n        }\n        /**\n         * Match all elements.\n         *\n         * ## Example\n         *\n         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n         */\n        By.all = function () { return function (debugElement) { return true; }; };\n        /**\n         * Match elements by the given CSS selector.\n         *\n         * ## Example\n         *\n         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n         */\n        By.css = function (selector) {\n            return function (debugElement) {\n                return isPresent(debugElement.nativeElement) ?\n                    getDOM().elementMatches(debugElement.nativeElement, selector) :\n                    false;\n            };\n        };\n        /**\n         * Match elements that have the given directive present.\n         *\n         * ## Example\n         *\n         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n         */\n        By.directive = function (type) {\n            return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };\n        };\n        return By;\n    }());\n\n    var __platform_browser_private__ = {\n        BrowserPlatformLocation: BrowserPlatformLocation,\n        DomAdapter: DomAdapter,\n        BrowserDomAdapter: BrowserDomAdapter,\n        BrowserGetTestability: BrowserGetTestability,\n        getDOM: getDOM,\n        setRootDomAdapter: setRootDomAdapter,\n        DomRootRenderer_: DomRootRenderer_,\n        DomRootRenderer: DomRootRenderer,\n        NAMESPACE_URIS: NAMESPACE_URIS,\n        shimContentAttribute: shimContentAttribute,\n        shimHostAttribute: shimHostAttribute,\n        flattenStyles: flattenStyles,\n        splitNamespace: splitNamespace,\n        isNamespaced: isNamespaced,\n        DomSharedStylesHost: DomSharedStylesHost,\n        SharedStylesHost: SharedStylesHost,\n        ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,\n        DomEventsPlugin: DomEventsPlugin,\n        KeyEventsPlugin: KeyEventsPlugin,\n        HammerGesturesPlugin: HammerGesturesPlugin,\n        initDomAdapter: initDomAdapter,\n        INTERNAL_BROWSER_PLATFORM_PROVIDERS: INTERNAL_BROWSER_PLATFORM_PROVIDERS,\n        BROWSER_SANITIZATION_PROVIDERS: BROWSER_SANITIZATION_PROVIDERS,\n        WebAnimationsDriver: WebAnimationsDriver\n    };\n\n    exports.BrowserModule = BrowserModule;\n    exports.platformBrowser = platformBrowser;\n    exports.Title = Title;\n    exports.disableDebugTools = disableDebugTools;\n    exports.enableDebugTools = enableDebugTools;\n    exports.AnimationDriver = AnimationDriver;\n    exports.By = By;\n    exports.NgProbeToken = NgProbeToken;\n    exports.DOCUMENT = DOCUMENT;\n    exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;\n    exports.EventManager = EventManager;\n    exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;\n    exports.HammerGestureConfig = HammerGestureConfig;\n    exports.DomSanitizer = DomSanitizer;\n    exports.__platform_browser_private__ = __platform_browser_private__;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qcz8wMTcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkRBQTZEO0FBQ3RHLENBQUMseURBQXlEOztBQUUxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QixFQUFFO0FBQzVELG1DQUFtQyw2QkFBNkIsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsOEJBQThCLGlDQUFpQyxhQUFhLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNENBQTRDLHlEQUF5RDtBQUNyRztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEciLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMi4wXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvbW1vbicsICdAYW5ndWxhci9jb3JlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyID0gZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlciB8fCB7fSksZ2xvYmFsLm5nLmNvbW1vbixnbG9iYWwubmcuY29yZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb21tb24sX2FuZ3VsYXJfY29yZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRGVidWdEb21Sb290UmVuZGVyZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uRGVidWdEb21Sb290UmVuZGVyZXI7XG4gICAgdmFyIE5vT3BBbmltYXRpb25QbGF5ZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTm9PcEFuaW1hdGlvblBsYXllcjtcblxuICAgIHZhciBfTm9PcEFuaW1hdGlvbkRyaXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9Ob09wQW5pbWF0aW9uRHJpdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIF9Ob09wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vT3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9Ob09wQW5pbWF0aW9uRHJpdmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25Ecml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQW5pbWF0aW9uRHJpdmVyLk5PT1AgPSBuZXcgX05vT3BBbmltYXRpb25Ecml2ZXIoKTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkRyaXZlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIGdsb2JhbCQxID0gZ2xvYmFsU2NvcGU7XG4gICAgLy8gVE9ETzogcmVtb3ZlIGNhbGxzIHRvIGFzc2VydCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4gICAgLy8gTm90ZTogQ2FuJ3QganVzdCBleHBvcnQgdGhpcyBhbmQgaW1wb3J0IGluIGluIG90aGVyIGZpbGVzXG4gICAgLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbiAgICBnbG9iYWwkMS5hc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIFRPRE86IHRvIGJlIGZpeGVkIHByb3Blcmx5IHZpYSAjMjgzMCwgbm9vcCBmb3Igbm93XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ub3ZlcnJpZGRlbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWVPblBhdGgoZ2xvYmFsLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBvYmogPSBnbG9iYWw7XG4gICAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZV8xKSAmJiBvYmpbbmFtZV8xXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqW25hbWVfMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbbmFtZV8xXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9ialtwYXJ0cy5zaGlmdCgpXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX0RPTSA9IG51bGw7XG4gICAgZnVuY3Rpb24gZ2V0RE9NKCkge1xuICAgICAgICByZXR1cm4gX0RPTTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Um9vdERvbUFkYXB0ZXIoYWRhcHRlcikge1xuICAgICAgICBpZiAoIV9ET00pIHtcbiAgICAgICAgICAgIF9ET00gPSBhZGFwdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlOnJlcXVpcmVQYXJhbWV0ZXJUeXBlICovXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgRE9NIG9wZXJhdGlvbnMgaW4gYW4gZW52aXJvbm1lbnQtYWdub3N0aWMgd2F5LlxuICAgICAqXG4gICAgICogQHNlY3VyaXR5IFRyZWFkIGNhcmVmdWxseSEgSW50ZXJhY3Rpbmcgd2l0aCB0aGUgRE9NIGRpcmVjdGx5IGlzIGRhbmdlcm91cyBhbmRcbiAgICAgKiBjYW4gaW50cm9kdWNlIFhTUyByaXNrcy5cbiAgICAgKi9cbiAgICB2YXIgRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERvbUFkYXB0ZXIoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTG9hZGVyVHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvbUFkYXB0ZXIucHJvdG90eXBlLCBcImF0dHJUb1Byb3BNYXBcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXBzIGF0dHJpYnV0ZSBuYW1lcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzIGZvciBjYXNlc1xuICAgICAgICAgICAgICogd2hlcmUgYXR0cmlidXRlIG5hbWUgZG9lc24ndCBtYXRjaCBwcm9wZXJ0eSBuYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2F0dHJUb1Byb3BNYXA7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9hdHRyVG9Qcm9wTWFwID0gdmFsdWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIDtcbiAgICAgICAgcmV0dXJuIERvbUFkYXB0ZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBXZWJBbmltYXRpb25zUGxheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IG9wdGlvbnNbJ2R1cmF0aW9uJ107XG4gICAgICAgIH1cbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIga2V5ZnJhbWVzID0gdGhpcy5rZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkS2V5ZnJhbWUgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRLZXlmcmFtZVtwcm9wXSA9IHZhbHVlID09IF9hbmd1bGFyX2NvcmUuQVVUT19TVFlMRSA/IF9jb21wdXRlU3R5bGUoX3RoaXMuZWxlbWVudCwgcHJvcCkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVkS2V5ZnJhbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllciA9IHRoaXMuX3RyaWdnZXJXZWJBbmltYXRpb24odGhpcy5lbGVtZW50LCBrZXlmcmFtZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IHN0YXJ0IHRvIGFuaW1hdGUgcmlnaHQgYXdheVxuICAgICAgICAgICAgdGhpcy5fcmVzZXREb21QbGF5ZXJTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbkZpbmlzaCgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fdHJpZ2dlcldlYkFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLCBcImRvbVBsYXllclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYXllcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5wbGF5KCk7XG4gICAgICAgIH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLmZpbmlzaCgpO1xuICAgICAgICB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RG9tUGxheWVyU3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX3Jlc2V0RG9tUGxheWVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllci5jYW5jZWwoKTsgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXREb21QbGF5ZXJTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLCBcInRvdGFsVGltZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2R1cmF0aW9uOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocCkgeyB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgPSBwICogdGhpcy50b3RhbFRpbWU7IH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyLmN1cnJlbnRUaW1lIC8gdGhpcy50b3RhbFRpbWU7IH07XG4gICAgICAgIHJldHVybiBXZWJBbmltYXRpb25zUGxheWVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX2NvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBnZXRET00oKS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3Byb3BdO1xuICAgIH1cblxuICAgIHZhciBXZWJBbmltYXRpb25zRHJpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV2ViQW5pbWF0aW9uc0RyaXZlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBXZWJBbmltYXRpb25zRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkU3RlcHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFydGluZ1N0eWxlTG9va3VwID0ge307XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0YXJ0aW5nU3R5bGVzKSAmJiBzdGFydGluZ1N0eWxlcy5zdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nU3R5bGVMb29rdXAgPSBfcG9wdWxhdGVTdHlsZXMoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIHt9KTtcbiAgICAgICAgICAgICAgICBzdGFydGluZ1N0eWxlTG9va3VwWydvZmZzZXQnXSA9IDA7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RlcHMucHVzaChzdGFydGluZ1N0eWxlTG9va3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX3BvcHVsYXRlU3R5bGVzKGVsZW1lbnQsIGtleWZyYW1lLnN0eWxlcywgc3RhcnRpbmdTdHlsZUxvb2t1cCk7XG4gICAgICAgICAgICAgICAgZGF0YVsnb2Zmc2V0J10gPSBrZXlmcmFtZS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RlcHMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVuIG9ubHkgc3R5bGVzIGFyZSBhcHBsaWVkIGFzIGFuXG4gICAgICAgICAgICAvLyBhbmltYXRpb24uIFdoZW4gdGhpcyBvY2N1cnMgd2Ugd2FudCB0byBhbmltYXRlIGZyb20gc3RhcnQgdG9cbiAgICAgICAgICAgIC8vIGVuZCB3aXRoIHRoZSBzYW1lIHZhbHVlcy4gUmVtb3ZpbmcgdGhlIG9mZnNldCBhbmQgaGF2aW5nIG9ubHlcbiAgICAgICAgICAgIC8vIHN0YXJ0L2VuZCB2YWx1ZXMgaXMgc3VpdGFibGUgZW5vdWdoIGZvciB0aGUgd2ViLWFuaW1hdGlvbnMgQVBJXG4gICAgICAgICAgICBpZiAoZm9ybWF0dGVkU3RlcHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBmb3JtYXR0ZWRTdGVwc1swXTtcbiAgICAgICAgICAgICAgICBzdGFydFsnb2Zmc2V0J10gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFN0ZXBzID0gW3N0YXJ0LCBzdGFydF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGxheWVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAnZHVyYXRpb24nOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAnZGVsYXknOiBkZWxheSxcbiAgICAgICAgICAgICAgICAnZmlsbCc6ICdib3RoJyAvLyB3ZSB1c2UgYGJvdGhgIGJlY2F1c2UgaXQgYWxsb3dzIGZvciBzdHlsaW5nIGF0IDAlIHRvIHdvcmsgd2l0aCBgZGVsYXlgXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gd2UgY2hlY2sgZm9yIHRoaXMgdG8gYXZvaWQgaGF2aW5nIGEgbnVsbHx1bmRlZmluZWQgdmFsdWUgYmUgcHJlc2VudFxuICAgICAgICAgICAgLy8gZm9yIHRoZSBlYXNpbmcgKHdoaWNoIHJlc3VsdHMgaW4gYW4gZXJyb3IgZm9yIGNlcnRhaW4gYnJvd3NlcnMgIzk3NTIpXG4gICAgICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICAgICAgcGxheWVyT3B0aW9uc1snZWFzaW5nJ10gPSBlYXNpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkFuaW1hdGlvbnNQbGF5ZXIoZWxlbWVudCwgZm9ybWF0dGVkU3RlcHMsIHBsYXllck9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gV2ViQW5pbWF0aW9uc0RyaXZlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9wb3B1bGF0ZVN0eWxlcyhlbGVtZW50LCBzdHlsZXMsIGRlZmF1bHRTdHlsZXMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgc3R5bGVzLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBkYXRhW3Byb3BdID0gZW50cnlbcHJvcF07IH0pOyB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdFN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoZGF0YVtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW3Byb3BdID0gZGVmYXVsdFN0eWxlc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbnkgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBzZWN1cml0eSBUcmVhZCBjYXJlZnVsbHkhIEludGVyYWN0aW5nIHdpdGggdGhlIERPTSBkaXJlY3RseSBpcyBkYW5nZXJvdXMgYW5kXG4gICAgICogY2FuIGludHJvZHVjZSBYU1Mgcmlza3MuXG4gICAgICovXG4gICAgdmFyIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudF8xID0gdGhpcy5jcmVhdGVFbGVtZW50KCdkaXYnLCB0aGlzLmRlZmF1bHREb2MoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmdldFN0eWxlKGVsZW1lbnRfMSwgJ2FuaW1hdGlvbk5hbWUnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbVByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZ2V0U3R5bGUoZWxlbWVudF8xLCBkb21QcmVmaXhlc1tpXSArICdBbmltYXRpb25OYW1lJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gJy0nICsgZG9tUHJlZml4ZXNbaV0udG9Mb3dlckNhc2UoKSArICctJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzXzEgPSB7XG4gICAgICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgICAgICAgICAgICAgTW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgICAgICAgICAgICAgICBPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0cmFuc0VuZEV2ZW50TmFtZXNfMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoX3RoaXMuZ2V0U3R5bGUoZWxlbWVudF8xLCBrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zaXRpb25FbmQgPSB0cmFuc0VuZEV2ZW50TmFtZXNfMVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXREaXN0cmlidXRlZE5vZGVzID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5nZXREaXN0cmlidXRlZE5vZGVzKCk7IH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVzb2x2ZUFuZFNldEhyZWYgPSBmdW5jdGlvbiAoZWwsIGJhc2VVcmwsIGhyZWYpIHtcbiAgICAgICAgICAgIGVsLmhyZWYgPSBocmVmID09IG51bGwgPyBiYXNlVXJsIDogYmFzZVVybCArICcvLi4vJyArIGhyZWY7XG4gICAgICAgIH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNET01FdmVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzTmF0aXZlU2hhZG93RE9NID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmRlZmF1bHREb2MoKS5ib2R5LmNyZWF0ZVNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uUHJlZml4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYW5pbWF0aW9uUHJlZml4ID8gdGhpcy5fYW5pbWF0aW9uUHJlZml4IDogJyc7IH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmQgPyB0aGlzLl90cmFuc2l0aW9uRW5kIDogJyc7IH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2FuaW1hdGlvblByZWZpeCkgJiYgaXNQcmVzZW50KHRoaXMuX3RyYW5zaXRpb25FbmQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyO1xuICAgIH0oRG9tQWRhcHRlcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgX2F0dHJUb1Byb3BNYXAgPSB7XG4gICAgICAgICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICAgICAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXG4gICAgICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG4gICAgfTtcbiAgICB2YXIgRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgPSAzO1xuICAgIC8vIE1hcCB0byBjb252ZXJ0IHNvbWUga2V5IG9yIGtleUlkZW50aWZpZXIgdmFsdWVzIHRvIHdoYXQgd2lsbCBiZSByZXR1cm5lZCBieSBnZXRFdmVudEtleVxuICAgIHZhciBfa2V5TWFwID0ge1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgaGVyZSBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGFuZCB0byBtYXRjaCB0aGUgVzNDIHN0YW5kYXJkXG4gICAgICAgIC8vIGNmIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy1rZXkvXG4gICAgICAgICdcXGInOiAnQmFja3NwYWNlJyxcbiAgICAgICAgJ1xcdCc6ICdUYWInLFxuICAgICAgICAnXFx4N0YnOiAnRGVsZXRlJyxcbiAgICAgICAgJ1xceDFCJzogJ0VzY2FwZScsXG4gICAgICAgICdEZWwnOiAnRGVsZXRlJyxcbiAgICAgICAgJ0VzYyc6ICdFc2NhcGUnLFxuICAgICAgICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAgICAgICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICAgICAgICdVcCc6ICdBcnJvd1VwJyxcbiAgICAgICAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgICAgICAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAgICAgICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAgICAgICAnV2luJzogJ09TJ1xuICAgIH07XG4gICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gQ2hyb21lIGZvciBudW1lcmljIGtleXBhZCBrZXlzOlxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTU2NTRcbiAgICAvLyAxLCAyLCAzIC4uLiBhcmUgcmVwb3J0ZWQgYXMgQSwgQiwgQyAuLi5cbiAgICB2YXIgX2Nocm9tZU51bUtleVBhZE1hcCA9IHtcbiAgICAgICAgJ0EnOiAnMScsXG4gICAgICAgICdCJzogJzInLFxuICAgICAgICAnQyc6ICczJyxcbiAgICAgICAgJ0QnOiAnNCcsXG4gICAgICAgICdFJzogJzUnLFxuICAgICAgICAnRic6ICc2JyxcbiAgICAgICAgJ0cnOiAnNycsXG4gICAgICAgICdIJzogJzgnLFxuICAgICAgICAnSSc6ICc5JyxcbiAgICAgICAgJ0onOiAnKicsXG4gICAgICAgICdLJzogJysnLFxuICAgICAgICAnTSc6ICctJyxcbiAgICAgICAgJ04nOiAnLicsXG4gICAgICAgICdPJzogJy8nLFxuICAgICAgICAnXFx4NjAnOiAnMCcsXG4gICAgICAgICdcXHg5MCc6ICdOdW1Mb2NrJ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBgRG9tQWRhcHRlcmAgcG93ZXJlZCBieSBmdWxsIGJyb3dzZXIgRE9NIEFQSXMuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgVHJlYWQgY2FyZWZ1bGx5ISBJbnRlcmFjdGluZyB3aXRoIHRoZSBET00gZGlyZWN0bHkgaXMgZGFuZ2Vyb3VzIGFuZFxuICAgICAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICAgICAqL1xuICAgIC8qIHRzbGludDpkaXNhYmxlOnJlcXVpcmVQYXJhbWV0ZXJUeXBlICovXG4gICAgdmFyIEJyb3dzZXJEb21BZGFwdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEJyb3dzZXJEb21BZGFwdGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCcm93c2VyRG9tQWRhcHRlcigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUh0bWwpIHsgdGhyb3cgbmV3IEVycm9yKCdwYXJzZSBub3QgaW1wbGVtZW50ZWQnKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIubWFrZUN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7IHNldFJvb3REb21BZGFwdGVyKG5ldyBCcm93c2VyRG9tQWRhcHRlcigpKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsgcmV0dXJuIG5hbWUgaW4gZWxlbWVudDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkgeyBlbFtuYW1lXSA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgcmV0dXJuIGVsW25hbWVdOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGVsLCBtZXRob2ROYW1lLCBhcmdzKSB7IChfYSA9IGVsKVttZXRob2ROYW1lXS5hcHBseShfYSwgYXJncyk7IHZhciBfYTsgfTtcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHRoaXMgaW50byBhIHNlcGFyYXRlIGVudmlyb25tZW50IGNsYXNzIG9uY2Ugd2UgaGF2ZSBpdFxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgICh3aW5kb3cuY29uc29sZS5lcnJvciB8fCB3aW5kb3cuY29uc29sZS5sb2cpKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nICYmIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZ3JvdXAgJiYgd2luZG93LmNvbnNvbGUuZ3JvdXAoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXBFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5ncm91cEVuZCAmJiB3aW5kb3cuY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLCBcImF0dHJUb1Byb3BNYXBcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfYXR0clRvUHJvcE1hcDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHsgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZWwsIGV2dCwgbGlzdGVuZXIpIHsgZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGxpc3RlbmVyLCBmYWxzZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5vbkFuZENhbmNlbCA9IGZ1bmN0aW9uIChlbCwgZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBOZWVkZWQgdG8gZm9sbG93IERhcnQncyBzdWJzY3JpcHRpb24gc2VtYW50aWMsIHVudGlsIGZpeCBvZlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXJ0L2lzc3Vlcy9kZXRhaWw/aWQ9MTc0MDZcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChlbCwgZXZ0KSB7IGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZU1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1ByZXZlbnRlZCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgIHJldHVybiBldnQuZGVmYXVsdFByZXZlbnRlZCB8fCBpc1ByZXNlbnQoZXZ0LnJldHVyblZhbHVlKSAmJiAhZXZ0LnJldHVyblZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5pbm5lckhUTUw7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUZW1wbGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29udGVudCcgaW4gZWwgJiYgZWwgaW5zdGFuY2VvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID8gZWwuY29udGVudCA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRPdXRlckhUTUwgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLm91dGVySFRNTDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm5vZGVOYW1lID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZU5hbWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5ub2RlVmFsdWUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVmFsdWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudHlwZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzUHJvcGVydHkobm9kZSwgJ2NvbnRlbnQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmZpcnN0Q2hpbGQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmZpcnN0Q2hpbGQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5uZXh0U2libGluZyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwubmV4dFNpYmxpbmc7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wYXJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5wYXJlbnROb2RlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2hpbGROb2RlcyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2hpbGROb2RlczsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNoaWxkTm9kZXNBc0xpc3QgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gZWwuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jbGVhck5vZGVzID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwuYXBwZW5kQ2hpbGQobm9kZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5yZW1vdmVDaGlsZChub2RlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlcGxhY2VDaGlsZCA9IGZ1bmN0aW9uIChlbCwgbmV3Q2hpbGQsIG9sZENoaWxkKSB7IGVsLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBlbCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnNlcnRBbGxCZWZvcmUgPSBmdW5jdGlvbiAoZWwsIG5vZGVzKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7IHJldHVybiBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCBlbCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgZWwubmV4dFNpYmxpbmcpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC5pbm5lckhUTUwgPSB2YWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnRleHRDb250ZW50OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwudGV4dENvbnRlbnQgPSB2YWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC52YWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC52YWx1ZSA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2hlY2tlZDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldENoZWNrZWQgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLmNoZWNrZWQgPSB2YWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVRlbXBsYXRlID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgICAgIHQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBkb2MpIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudE5TID0gZnVuY3Rpb24gKG5zLCB0YWdOYW1lLCBkb2MpIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZ05hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGV4dE5vZGUgPSBmdW5jdGlvbiAodGV4dCwgZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVTY3JpcHRUYWcgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIGF0dHJWYWx1ZSwgZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cbiAgICAgICAgICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdTQ1JJUFQnKTtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChjc3MsIGRvYykge1xuICAgICAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3R5bGUsIHRoaXMuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jcmVhdGVTaGFkb3dSb290KCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRTaGFkb3dSb290ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5zaGFkb3dSb290OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SG9zdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuaG9zdDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKHRydWUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWxlbWVudC5jbGFzc0xpc3QsIDApOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7IGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7IGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZVN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlbmFtZSkge1xuICAgICAgICAgICAgLy8gSUUgcmVxdWlyZXMgJycgaW5zdGVhZCBvZiBudWxsXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNzkxNlxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZW5hbWVdID0gJyc7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZW5hbWUpIHsgcmV0dXJuIGVsZW1lbnQuc3R5bGVbc3R5bGVuYW1lXTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc1N0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IHZvaWQgMCkgeyBzdHlsZVZhbHVlID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRTdHlsZShlbGVtZW50LCBzdHlsZU5hbWUpIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlVmFsdWUgPyB2YWx1ZSA9PSBzdHlsZVZhbHVlIDogdmFsdWUubGVuZ3RoID4gMDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnRhZ05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC50YWdOYW1lOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlTWFwID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB2YXIgZWxBdHRycyA9IGVsZW1lbnQuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxBdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWIgPSBlbEF0dHJzW2ldO1xuICAgICAgICAgICAgICAgIHJlcy5zZXQoYXR0cmliLm5hbWUsIGF0dHJpYi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBucywgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGVOUyhucywgYXR0cmlidXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZU5TKG5zLCBuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkgeyBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBucywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUpIHsgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBuYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnRlbXBsYXRlQXdhcmVSb290ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiB0aGlzLmlzVGVtcGxhdGVFbGVtZW50KGVsKSA/IHRoaXMuY29udGVudChlbCkgOiBlbDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUh0bWxEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ2Zha2VUaXRsZScpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZGVmYXVsdERvYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnRpdGxlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAobmV3VGl0bGUpIHsgZG9jdW1lbnQudGl0bGUgPSBuZXdUaXRsZSB8fCAnJzsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmVsZW1lbnRNYXRjaGVzID0gZnVuY3Rpb24gKG4sIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4ubWF0Y2hlcyAmJiBuLm1hdGNoZXMoc2VsZWN0b3IpIHx8XG4gICAgICAgICAgICAgICAgICAgIG4ubXNNYXRjaGVzU2VsZWN0b3IgJiYgbi5tc01hdGNoZXNTZWxlY3RvcihzZWxlY3RvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgbi53ZWJraXRNYXRjaGVzU2VsZWN0b3IgJiYgbi53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGVsLm5vZGVOYW1lID09ICdURU1QTEFURSc7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1RleHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkNPTU1FTlRfTk9ERTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNTaGFkb3dSb290ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQobm9kZS5zaGFkb3dSb290KSAmJiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1NoYWRvd1Jvb3QgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbXBvcnRJbnRvRG9jID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGRvY3VtZW50LmltcG9ydE5vZGUodGhpcy50ZW1wbGF0ZUF3YXJlUm9vdChub2RlKSwgdHJ1ZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hZG9wdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZG9jdW1lbnQuYWRvcHROb2RlKG5vZGUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SHJlZiA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuaHJlZjsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEV2ZW50S2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtleSA9IGV2ZW50LmtleUlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgLy8ga2V5SWRlbnRpZmllciBpcyBkZWZpbmVkIGluIHRoZSBvbGQgZHJhZnQgb2YgRE9NIExldmVsIDMgRXZlbnRzIGltcGxlbWVudGVkIGJ5IENocm9tZSBhbmRcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgY2ZcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA3L1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDA3MTIyMS9ldmVudHMuaHRtbCNFdmVudHMtS2V5Ym9hcmRFdmVudHMtSW50ZXJmYWNlc1xuICAgICAgICAgICAgICAgIGlmIChpc0JsYW5rKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdVbmlkZW50aWZpZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ1UrJykpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChrZXkuc3Vic3RyaW5nKDIpLCAxNikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubG9jYXRpb24gPT09IERPTV9LRVlfTE9DQVRJT05fTlVNUEFEICYmIF9jaHJvbWVOdW1LZXlQYWRNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gQ2hyb21lIGZvciBudW1lcmljIGtleXBhZCBrZXlzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE1NTY1NFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSwgMiwgMyAuLi4gYXJlIHJlcG9ydGVkIGFzIEEsIEIsIEMgLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBfY2hyb21lTnVtS2V5UGFkTWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2tleU1hcFtrZXldIHx8IGtleTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEdsb2JhbEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5oaXN0b3J5OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cubG9jYXRpb247IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBocmVmID0gZ2V0QmFzZUVsZW1lbnRIcmVmKCk7XG4gICAgICAgICAgICByZXR1cm4gaXNCbGFuayhocmVmKSA/IG51bGwgOiByZWxhdGl2ZVBhdGgoaHJlZik7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZXNldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkgeyBiYXNlRWxlbWVudCA9IG51bGw7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRVc2VyQWdlbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLScgKyBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS0nICsgbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7IH07XG4gICAgICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSB0aGlzIGludG8gYSBzZXBhcmF0ZSBlbnZpcm9ubWVudCBjbGFzcyBvbmNlIHdlIGhhdmUgaXRcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldEdsb2JhbFZhciA9IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkgeyBzZXRWYWx1ZU9uUGF0aChnbG9iYWwkMSwgcGF0aCwgdmFsdWUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNXZWJBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlWydhbmltYXRlJ10gPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHBlcmZvcm1hbmNlLm5vdygpIGlzIG5vdCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzLCBzZWVcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBlcmZvcm1hbmNlLm5vd1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDpcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzQ29va2llcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDb29raWUgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcGFyc2VDb29raWVWYWx1ZShkb2N1bWVudC5jb29raWUsIG5hbWUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0Q29va2llID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBkb2N1bWVudC5jb29raWUgaXMgbWFnaWNhbCwgYXNzaWduaW5nIGludG8gaXQgYXNzaWducy9vdmVycmlkZXMgb25lIGNvb2tpZSB2YWx1ZSwgYnV0IGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBjbGVhciBvdGhlciBjb29raWVzLlxuICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJyb3dzZXJEb21BZGFwdGVyO1xuICAgIH0oR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyKSk7XG4gICAgdmFyIGJhc2VFbGVtZW50ID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRCYXNlRWxlbWVudEhyZWYoKSB7XG4gICAgICAgIGlmICghYmFzZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgICAgICAgaWYgKCFiYXNlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICB9XG4gICAgLy8gYmFzZWQgb24gdXJsVXRpbHMuanMgaW4gQW5ndWxhckpTIDFcbiAgICB2YXIgdXJsUGFyc2luZ05vZGU7XG4gICAgZnVuY3Rpb24gcmVsYXRpdmVQYXRoKHVybCkge1xuICAgICAgICBpZiAoIXVybFBhcnNpbmdOb2RlKSB7XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgfVxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpO1xuICAgICAgICByZXR1cm4gKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/IHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNvb2tpZVZhbHVlKGNvb2tpZVN0ciwgbmFtZSkge1xuICAgICAgICBuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29va2llU3RyLnNwbGl0KCc7Jyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29va2llID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGVxSW5kZXggPSBjb29raWUuaW5kZXhPZignPScpO1xuICAgICAgICAgICAgdmFyIF9iID0gZXFJbmRleCA9PSAtMSA/IFtjb29raWUsICcnXSA6IFtjb29raWUuc2xpY2UoMCwgZXFJbmRleCksIGNvb2tpZS5zbGljZShlcUluZGV4ICsgMSldLCBjb29raWVOYW1lID0gX2JbMF0sIGNvb2tpZVZhbHVlID0gX2JbMV07XG4gICAgICAgICAgICBpZiAoY29va2llTmFtZS50cmltKCkgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VwcG9ydHNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgUGxhdGZvcm1Mb2NhdGlvbmAgZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgZGlyZWN0IGNhbGxzIHRvIHBsYXRmb3JtIEFQSXMuXG4gICAgICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkgYnkgYW4gYXBwbGljYXRpb24gZGV2ZWxvcGVyLiBJbnN0ZWFkLCB1c2VcbiAgICAgKiB7QGxpbmsgTG9jYXRpb259LlxuICAgICAqL1xuICAgIHZhciBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQyKEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgbW92ZWQgdG8gaXRzIG93biBtZXRob2Qgc28gdGhhdCBgTW9ja1BsYXRmb3JtTG9jYXRpb25TdHJhdGVneWAgY2FuIG92ZXJ3cml0ZSBpdFxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uID0gZ2V0RE9NKCkuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkgPSBnZXRET00oKS5nZXRIaXN0b3J5KCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwibG9jYXRpb25cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5nZXRCYXNlSHJlZkZyb21ET00gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRET00oKS5nZXRCYXNlSHJlZigpOyB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZ2V0RE9NKCkuZ2V0R2xvYmFsRXZlbnRUYXJnZXQoJ3dpbmRvdycpLmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZm4sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLm9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZ2V0RE9NKCkuZ2V0R2xvYmFsRXZlbnRUYXJnZXQoJ3dpbmRvdycpLmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmbiwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInBhdGhuYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbG9jYXRpb24ucGF0aG5hbWU7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQYXRoKSB7IHRoaXMuX2xvY2F0aW9uLnBhdGhuYW1lID0gbmV3UGF0aDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwic2VhcmNoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbG9jYXRpb24uc2VhcmNoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJoYXNoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbG9jYXRpb24uaGFzaDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhdGlvbi5oYXNoID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYXRpb24uaGFzaCA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hpc3RvcnkuZm9yd2FyZCgpOyB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5iYWNrKCk7IH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24uY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uO1xuICAgIH0oX2FuZ3VsYXJfY29tbW9uLlBsYXRmb3JtTG9jYXRpb24pKTtcblxuICAgIHZhciBCcm93c2VyR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCcm93c2VyR2V0VGVzdGFiaWxpdHkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQnJvd3NlckdldFRlc3RhYmlsaXR5LmluaXQgPSBmdW5jdGlvbiAoKSB7IF9hbmd1bGFyX2NvcmUuc2V0VGVzdGFiaWxpdHlHZXR0ZXIobmV3IEJyb3dzZXJHZXRUZXN0YWJpbGl0eSgpKTsgfTtcbiAgICAgICAgQnJvd3NlckdldFRlc3RhYmlsaXR5LnByb3RvdHlwZS5hZGRUb1dpbmRvdyA9IGZ1bmN0aW9uIChyZWdpc3RyeSkge1xuICAgICAgICAgICAgZ2xvYmFsJDEuZ2V0QW5ndWxhclRlc3RhYmlsaXR5ID0gZnVuY3Rpb24gKGVsZW0sIGZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIGlmIChmaW5kSW5BbmNlc3RvcnMgPT09IHZvaWQgMCkgeyBmaW5kSW5BbmNlc3RvcnMgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RhYmlsaXR5ID0gcmVnaXN0cnkuZmluZFRlc3RhYmlsaXR5SW5UcmVlKGVsZW0sIGZpbmRJbkFuY2VzdG9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0ZXN0YWJpbGl0eSBmb3IgZWxlbWVudC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3RhYmlsaXR5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbCQxLmdldEFsbEFuZ3VsYXJUZXN0YWJpbGl0aWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnaXN0cnkuZ2V0QWxsVGVzdGFiaWxpdGllcygpOyB9O1xuICAgICAgICAgICAgZ2xvYmFsJDEuZ2V0QWxsQW5ndWxhclJvb3RFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ2lzdHJ5LmdldEFsbFJvb3RFbGVtZW50cygpOyB9O1xuICAgICAgICAgICAgdmFyIHdoZW5BbGxTdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdGFiaWxpdGllcyA9IGdsb2JhbCQxLmdldEFsbEFuZ3VsYXJUZXN0YWJpbGl0aWVzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGVzdGFiaWxpdGllcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGRpZFdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50ID0gZnVuY3Rpb24gKGRpZFdvcmtfIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFdvcmsgPSBkaWRXb3JrIHx8IGRpZFdvcmtfO1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGlkV29yayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRlc3RhYmlsaXRpZXMuZm9yRWFjaChmdW5jdGlvbiAodGVzdGFiaWxpdHkgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdGFiaWxpdHkud2hlblN0YWJsZShkZWNyZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghZ2xvYmFsJDFbJ2ZyYW1ld29ya1N0YWJpbGl6ZXJzJ10pIHtcbiAgICAgICAgICAgICAgICBnbG9iYWwkMVsnZnJhbWV3b3JrU3RhYmlsaXplcnMnXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmFsJDFbJ2ZyYW1ld29ya1N0YWJpbGl6ZXJzJ10ucHVzaCh3aGVuQWxsU3RhYmxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckdldFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kVGVzdGFiaWxpdHlJblRyZWUgPSBmdW5jdGlvbiAocmVnaXN0cnksIGVsZW0sIGZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSByZWdpc3RyeS5nZXRUZXN0YWJpbGl0eShlbGVtKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRET00oKS5pc1NoYWRvd1Jvb3QoZWxlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kVGVzdGFiaWxpdHlJblRyZWUocmVnaXN0cnksIGdldERPTSgpLmdldEhvc3QoZWxlbSksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRlc3RhYmlsaXR5SW5UcmVlKHJlZ2lzdHJ5LCBnZXRET00oKS5wYXJlbnRFbGVtZW50KGVsZW0pLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJyb3dzZXJHZXRUZXN0YWJpbGl0eTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXJ2aWNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGFuZCBzZXQgdGhlIHRpdGxlIG9mIGEgY3VycmVudCBIVE1MIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogU2luY2UgYW4gQW5ndWxhciAyIGFwcGxpY2F0aW9uIGNhbid0IGJlIGJvb3RzdHJhcHBlZCBvbiB0aGUgZW50aXJlIEhUTUwgZG9jdW1lbnQgKGA8aHRtbD5gIHRhZylcbiAgICAgKiBpdCBpcyBub3QgcG9zc2libGUgdG8gYmluZCB0byB0aGUgYHRleHRgIHByb3BlcnR5IG9mIHRoZSBgSFRNTFRpdGxlRWxlbWVudGAgZWxlbWVudHNcbiAgICAgKiAocmVwcmVzZW50aW5nIHRoZSBgPHRpdGxlPmAgdGFnKS4gSW5zdGVhZCwgdGhpcyBzZXJ2aWNlIGNhbiBiZSB1c2VkIHRvIHNldCBhbmQgZ2V0IHRoZSBjdXJyZW50XG4gICAgICogdGl0bGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFRpdGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGl0bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgSFRNTCBkb2N1bWVudC5cbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIFRpdGxlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldERPTSgpLmdldFRpdGxlKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICAgICAqIEBwYXJhbSBuZXdUaXRsZVxuICAgICAgICAgKi9cbiAgICAgICAgVGl0bGUucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKG5ld1RpdGxlKSB7IGdldERPTSgpLnNldFRpdGxlKG5ld1RpdGxlKTsgfTtcbiAgICAgICAgcmV0dXJuIFRpdGxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBKYXZhc2NyaXB0IE9iamVjdHNcbiAgICAgKi9cbiAgICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ01hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMobTEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgICAgdmFyIGsyID0gT2JqZWN0LmtleXMobTIpO1xuICAgICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgREkgVG9rZW4gcmVwcmVzZW50aW5nIHRoZSBtYWluIHJlbmRlcmluZyBjb250ZXh0LiBJbiBhIGJyb3dzZXIgdGhpcyBpcyB0aGUgRE9NIERvY3VtZW50LlxuICAgICAqXG4gICAgICogTm90ZTogRG9jdW1lbnQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiB0aGUgQXBwbGljYXRpb24gQ29udGV4dCB3aGVuIEFwcGxpY2F0aW9uIGFuZCBSZW5kZXJpbmdcbiAgICAgKiBDb250ZXh0cyBhcmUgbm90IHRoZSBzYW1lIChlLmcuIHdoZW4gcnVubmluZyB0aGUgYXBwbGljYXRpb24gaW50byBhIFdlYiBXb3JrZXIpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBET0NVTUVOVCA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdEb2N1bWVudFRva2VuJyk7XG5cbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEVWRU5UX01BTkFHRVJfUExVR0lOUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdFdmVudE1hbmFnZXJQbHVnaW5zJyk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFdmVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIocGx1Z2lucywgX3pvbmUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgICAgICB0aGlzLl9ldmVudE5hbWVUb1BsdWdpbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5tYW5hZ2VyID0gX3RoaXM7IH0pO1xuICAgICAgICAgICAgdGhpcy5fcGx1Z2lucyA9IHBsdWdpbnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuX2ZpbmRQbHVnaW5Gb3IoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW4uYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFpvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl96b25lOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuX2ZpbmRQbHVnaW5Gb3IgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5fZXZlbnROYW1lVG9QbHVnaW4uZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwbHVnaW5zID0gdGhpcy5fcGx1Z2lucztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5fMSA9IHBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbl8xLnN1cHBvcnRzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnROYW1lVG9QbHVnaW4uc2V0KGV2ZW50TmFtZSwgcGx1Z2luXzEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgbWFuYWdlciBwbHVnaW4gZm91bmQgZm9yIGV2ZW50IFwiICsgZXZlbnROYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRXZlbnRNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtFVkVOVF9NQU5BR0VSX1BMVUdJTlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBFdmVudE1hbmFnZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgRXZlbnRNYW5hZ2VyUGx1Z2luID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyUGx1Z2luKCkge1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZXZlbnQgdGFyZ2V0IFwiICsgdGFyZ2V0ICsgXCIgZm9yIGV2ZW50IFwiICsgZXZlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICA7XG4gICAgICAgIHJldHVybiBFdmVudE1hbmFnZXJQbHVnaW47XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgU2hhcmVkU3R5bGVzSG9zdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNoYXJlZFN0eWxlc0hvc3QoKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMgPSBbXTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3N0eWxlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBTaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5hZGRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc3R5bGVzU2V0LmhhcyhzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlc1NldC5hZGQoc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVzLnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChzdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uU3R5bGVzQWRkZWQoYWRkaXRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IGZ1bmN0aW9uIChhZGRpdGlvbnMpIHsgfTtcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuZ2V0QWxsU3R5bGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3R5bGVzOyB9O1xuICAgICAgICBTaGFyZWRTdHlsZXNIb3N0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gU2hhcmVkU3R5bGVzSG9zdDtcbiAgICB9KCkpO1xuICAgIHZhciBEb21TaGFyZWRTdHlsZXNIb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoRG9tU2hhcmVkU3R5bGVzSG9zdCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRG9tU2hhcmVkU3R5bGVzSG9zdChkb2MpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faG9zdE5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5faG9zdE5vZGVzLmFkZChkb2MuaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5fYWRkU3R5bGVzVG9Ib3N0ID0gZnVuY3Rpb24gKHN0eWxlcywgaG9zdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgc3R5bGVFbC50ZXh0Q29udGVudCA9IHN0eWxlc1tpXTtcbiAgICAgICAgICAgICAgICBob3N0LmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5hZGRIb3N0ID0gZnVuY3Rpb24gKGhvc3ROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTdHlsZXNUb0hvc3QodGhpcy5fc3R5bGVzLCBob3N0Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuYWRkKGhvc3ROb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUucmVtb3ZlSG9zdCA9IGZ1bmN0aW9uIChob3N0Tm9kZSkgeyB0aGlzLl9ob3N0Tm9kZXMuZGVsZXRlKGhvc3ROb2RlKTsgfTtcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IGZ1bmN0aW9uIChhZGRpdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdE5vZGUpIHsgX3RoaXMuX2FkZFN0eWxlc1RvSG9zdChhZGRpdGlvbnMsIGhvc3ROb2RlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVNoYXJlZFN0eWxlc0hvc3QuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERvbVNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgfShTaGFyZWRTdHlsZXNIb3N0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIE5BTUVTUEFDRV9VUklTID0ge1xuICAgICAgICAneGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgICAgICdzdmcnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAneGh0bWwnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCdcbiAgICB9O1xuICAgIHZhciBURU1QTEFURV9DT01NRU5UX1RFWFQgPSAndGVtcGxhdGUgYmluZGluZ3M9e30nO1xuICAgIHZhciBURU1QTEFURV9CSU5ESU5HU19FWFAgPSAvXnRlbXBsYXRlIGJpbmRpbmdzPSguKikkLztcbiAgICB2YXIgRG9tUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9tUm9vdFJlbmRlcmVyKGRvY3VtZW50LCBldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGlvbkRyaXZlciwgYXBwSWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0ID0gc2hhcmVkU3R5bGVzSG9zdDtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRHJpdmVyID0gYW5pbWF0aW9uRHJpdmVyO1xuICAgICAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkQ29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBEb21Sb290UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRQcm90bykge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZWdpc3RlcmVkQ29tcG9uZW50cy5nZXQoY29tcG9uZW50UHJvdG8uaWQpO1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IERvbVJlbmRlcmVyKHRoaXMsIGNvbXBvbmVudFByb3RvLCB0aGlzLmFuaW1hdGlvbkRyaXZlciwgdGhpcy5hcHBJZCArIFwiLVwiICsgY29tcG9uZW50UHJvdG8uaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZENvbXBvbmVudHMuc2V0KGNvbXBvbmVudFByb3RvLmlkLCByZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEb21Sb290UmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgRG9tUm9vdFJlbmRlcmVyXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKERvbVJvb3RSZW5kZXJlcl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbVJvb3RSZW5kZXJlcl8oX2RvY3VtZW50LCBfZXZlbnRNYW5hZ2VyLCBzaGFyZWRTdHlsZXNIb3N0LCBhbmltYXRpb25Ecml2ZXIsIGFwcElkKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfZG9jdW1lbnQsIF9ldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGlvbkRyaXZlciwgYXBwSWQpO1xuICAgICAgICB9XG4gICAgICAgIERvbVJvb3RSZW5kZXJlcl8uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21Sb290UmVuZGVyZXJfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogRXZlbnRNYW5hZ2VyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBEb21TaGFyZWRTdHlsZXNIb3N0LCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBbmltYXRpb25Ecml2ZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkFQUF9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRG9tUm9vdFJlbmRlcmVyXztcbiAgICB9KERvbVJvb3RSZW5kZXJlcikpO1xuICAgIHZhciBESVJFQ1RfRE9NX1JFTkRFUkVSID0ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRDaGlsZDogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkgeyBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7IH0sXG4gICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKG5vZGUsIHJlZk5vZGUpIHsgcmVmTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCByZWZOb2RlKTsgfSxcbiAgICAgICAgbmV4dFNpYmxpbmc6IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5leHRTaWJsaW5nOyB9LFxuICAgICAgICBwYXJlbnRFbGVtZW50OiBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJlbnROb2RlOyB9XG4gICAgfTtcbiAgICB2YXIgRG9tUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb21SZW5kZXJlcihfcm9vdFJlbmRlcmVyLCBjb21wb25lbnRQcm90bywgX2FuaW1hdGlvbkRyaXZlciwgc3R5bGVTaGltSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlciA9IF9yb290UmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFByb3RvID0gY29tcG9uZW50UHJvdG87XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25Ecml2ZXIgPSBfYW5pbWF0aW9uRHJpdmVyO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RSZW5kZXJlciA9IERJUkVDVF9ET01fUkVOREVSRVI7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMgPSBmbGF0dGVuU3R5bGVzKHN0eWxlU2hpbUlkLCBjb21wb25lbnRQcm90by5zdHlsZXMsIFtdKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRQcm90by5lbmNhcHN1bGF0aW9uICE9PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LmFkZFN0eWxlcyh0aGlzLl9zdHlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UHJvdG8uZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRBdHRyID0gc2hpbUNvbnRlbnRBdHRyaWJ1dGUoc3R5bGVTaGltSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvc3RBdHRyID0gc2hpbUhvc3RBdHRyaWJ1dGUoc3R5bGVTaGltSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudEF0dHIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvc3RBdHRyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuX3Jvb3RSZW5kZXJlci5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzZWxlY3RvciBcXFwiXCIgKyBzZWxlY3Rvck9yTm9kZSArIFwiXFxcIiBkaWQgbm90IG1hdGNoIGFueSBlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IHNlbGVjdG9yT3JOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciBlbDtcbiAgICAgICAgICAgIGlmIChpc05hbWVzcGFjZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnNBbmROYW1lID0gc3BsaXROYW1lc3BhY2UobmFtZSk7XG4gICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoKE5BTUVTUEFDRV9VUklTKVtuc0FuZE5hbWVbMF1dLCBuc0FuZE5hbWVbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRBdHRyKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKHRoaXMuX2NvbnRlbnRBdHRyLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVZpZXdSb290ID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgbm9kZXNQYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRQcm90by5lbmNhcHN1bGF0aW9uID09PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIG5vZGVzUGFyZW50ID0gaG9zdEVsZW1lbnQuY3JlYXRlU2hhZG93Um9vdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LmFkZEhvc3Qobm9kZXNQYXJlbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVFbC50ZXh0Q29udGVudCA9IHRoaXMuX3N0eWxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNQYXJlbnQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvc3RBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLl9ob3N0QXR0ciwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2Rlc1BhcmVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzUGFyZW50O1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoVEVNUExBVEVfQ09NTUVOVF9URVhUKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjb21tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYXBwZW5kTm9kZXMocGFyZW50RWxlbWVudCwgbm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoVmlld0FmdGVyID0gZnVuY3Rpb24gKG5vZGUsIHZpZXdSb290Tm9kZXMpIHsgbW92ZU5vZGVzQWZ0ZXJTaWJsaW5nKG5vZGUsIHZpZXdSb290Tm9kZXMpOyB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuZGV0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdSb290Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZpZXdSb290Tm9kZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveVZpZXcgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQsIHZpZXdBbGxOb2Rlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UHJvdG8uZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUgJiYgaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIuc2hhcmVkU3R5bGVzSG9zdC5yZW1vdmVIb3N0KGhvc3RFbGVtZW50LnNoYWRvd1Jvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFJlbmRlcmVyLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHJlbmRlckVsZW1lbnQsIG5hbWUsIGRlY29yYXRlUHJldmVudERlZmF1bHQoY2FsbGJhY2spKTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmxpc3Rlbkdsb2JhbCA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFJlbmRlcmVyLmV2ZW50TWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKHRhcmdldCwgbmFtZSwgZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChjYWxsYmFjaykpO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgcmVuZGVyRWxlbWVudFtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBhdHRyTnM7XG4gICAgICAgICAgICB2YXIgYXR0ck5hbWVXaXRob3V0TnMgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgaWYgKGlzTmFtZXNwYWNlZChhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBuc0FuZE5hbWUgPSBzcGxpdE5hbWVzcGFjZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZVdpdGhvdXROcyA9IG5zQW5kTmFtZVsxXTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gbnNBbmROYW1lWzBdICsgJzonICsgbnNBbmROYW1lWzFdO1xuICAgICAgICAgICAgICAgIGF0dHJOcyA9IE5BTUVTUEFDRV9VUklTW25zQW5kTmFtZVswXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyTnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhhdHRyTnMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGF0dHJOcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTnMsIGF0dHJOYW1lV2l0aG91dE5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocmVuZGVyRWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdCaW5kaW5ncyA9IHJlbmRlckVsZW1lbnQubm9kZVZhbHVlLnJlcGxhY2UoL1xcbi9nLCAnJykubWF0Y2goVEVNUExBVEVfQklORElOR1NfRVhQKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkQmluZGluZ3MgPSBKU09OLnBhcnNlKGV4aXN0aW5nQmluZGluZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHBhcnNlZEJpbmRpbmdzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQubm9kZVZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgVEVNUExBVEVfQ09NTUVOVF9URVhULnJlcGxhY2UoJ3t9JywgSlNPTi5zdHJpbmdpZnkocGFyc2VkQmluZGluZ3MsIG51bGwsIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudEF0dHJpYnV0ZShyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudENsYXNzID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSwgaXNBZGQpIHtcbiAgICAgICAgICAgIGlmIChpc0FkZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyRWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3RyaW5naWZ5KHN0eWxlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgcmVxdWlyZXMgJycgaW5zdGVhZCBvZiBudWxsXG4gICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzc5MTZcbiAgICAgICAgICAgICAgICByZW5kZXJFbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICAgICAgcmVuZGVyRWxlbWVudFttZXRob2ROYW1lXS5hcHBseShyZW5kZXJFbGVtZW50LCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAocmVuZGVyTm9kZSwgdGV4dCkgeyByZW5kZXJOb2RlLm5vZGVWYWx1ZSA9IHRleHQ7IH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uRHJpdmVyLmFuaW1hdGUoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRG9tUmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBtb3ZlTm9kZXNBZnRlclNpYmxpbmcoc2libGluZywgbm9kZXMpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHNpYmxpbmcucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDAgJiYgcGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGVzW2ldLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmROb2RlcyhwYXJlbnQsIG5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGFsbG93RGVmYXVsdEJlaGF2aW9yID0gZXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhbGxvd0RlZmF1bHRCZWhhdmlvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHRib3NjaCk6IG1vdmUgcHJldmVudERlZmF1bHQgaW50byBldmVudCBwbHVnaW5zLi4uXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgQ09NUE9ORU5UX1JFR0VYID0gLyVDT01QJS9nO1xuICAgIHZhciBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbiAgICB2YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICAgIHZhciBDT05URU5UX0FUVFIgPSBcIl9uZ2NvbnRlbnQtXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XG4gICAgZnVuY3Rpb24gc2hpbUNvbnRlbnRBdHRyaWJ1dGUoY29tcG9uZW50U2hvcnRJZCkge1xuICAgICAgICByZXR1cm4gQ09OVEVOVF9BVFRSLnJlcGxhY2UoQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRTaG9ydElkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50U2hvcnRJZCkge1xuICAgICAgICByZXR1cm4gSE9TVF9BVFRSLnJlcGxhY2UoQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRTaG9ydElkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhjb21wSWQsIHN0eWxlcywgdGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBmbGF0dGVuU3R5bGVzKGNvbXBJZCwgc3R5bGUsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlLnJlcGxhY2UoQ09NUE9ORU5UX1JFR0VYLCBjb21wSWQpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICB2YXIgTlNfUFJFRklYX1JFID0gL146KFteOl0rKTooLispJC87XG4gICAgZnVuY3Rpb24gaXNOYW1lc3BhY2VkKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVbMF0gPT09ICc6JztcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXROYW1lc3BhY2UobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKE5TX1BSRUZJWF9SRSk7XG4gICAgICAgIHJldHVybiBbbWF0Y2hbMV0sIG1hdGNoWzJdXTtcbiAgICB9XG5cbiAgICB2YXIgQ09SRV9UT0tFTlMgPSB7XG4gICAgICAgICdBcHBsaWNhdGlvblJlZic6IF9hbmd1bGFyX2NvcmUuQXBwbGljYXRpb25SZWYsXG4gICAgICAgICdOZ1pvbmUnOiBfYW5ndWxhcl9jb3JlLk5nWm9uZVxuICAgIH07XG4gICAgdmFyIElOU1BFQ1RfR0xPQkFMX05BTUUgPSAnbmcucHJvYmUnO1xuICAgIHZhciBDT1JFX1RPS0VOU19HTE9CQUxfTkFNRSA9ICduZy5jb3JlVG9rZW5zJztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIERlYnVnRWxlbWVudH0gZm9yIHRoZSBnaXZlbiBuYXRpdmUgRE9NIGVsZW1lbnQsIG9yXG4gICAgICogbnVsbCBpZiB0aGUgZ2l2ZW4gbmF0aXZlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBBbmd1bGFyIHZpZXcgYXNzb2NpYXRlZFxuICAgICAqIHdpdGggaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdE5hdGl2ZUVsZW1lbnQoZWxlbWVudCAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICByZXR1cm4gX2FuZ3VsYXJfY29yZS5nZXREZWJ1Z05vZGUoZWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdQcm9iZVRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdQcm9iZVRva2VuKG5hbWUsIHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZ1Byb2JlVG9rZW47XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY3JlYXRlQ29uZGl0aW9uYWxSb290UmVuZGVyZXIocm9vdFJlbmRlcmVyIC8qKiBUT0RPICM5MTAwICovLCBleHRyYVRva2Vucykge1xuICAgICAgICBpZiAoX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb290UmVuZGVyZXIocm9vdFJlbmRlcmVyLCBleHRyYVRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RSZW5kZXJlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIgLyoqIFRPRE8gIzkxMDAgKi8sIGV4dHJhVG9rZW5zKSB7XG4gICAgICAgIGdldERPTSgpLnNldEdsb2JhbFZhcihJTlNQRUNUX0dMT0JBTF9OQU1FLCBpbnNwZWN0TmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGdldERPTSgpLnNldEdsb2JhbFZhcihDT1JFX1RPS0VOU19HTE9CQUxfTkFNRSwgU3RyaW5nTWFwV3JhcHBlci5tZXJnZShDT1JFX1RPS0VOUywgX25nUHJvYmVUb2tlbnNUb01hcChleHRyYVRva2VucyB8fCBbXSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z0RvbVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbmdQcm9iZVRva2Vuc1RvTWFwKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgdCkgeyByZXR1cm4gKHByZXZbdC5uYW1lXSA9IHQudG9rZW4sIHByZXYpOyB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyB3aGljaCBzdXBwb3J0IGRlYnVnZ2luZyBBbmd1bGFyIGFwcGxpY2F0aW9ucyAoZS5nLiB2aWEgYG5nLnByb2JlYCkuXG4gICAgICovXG4gICAgdmFyIEVMRU1FTlRfUFJPQkVfUFJPVklERVJTID0gW3tcbiAgICAgICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogX2NyZWF0ZUNvbmRpdGlvbmFsUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgZGVwczogW0RvbVJvb3RSZW5kZXJlciwgW05nUHJvYmVUb2tlbiwgbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKV1dXG4gICAgICAgIH1dO1xuICAgIHZhciBFTEVNRU5UX1BST0JFX1BST1ZJREVSU19QUk9EX01PREUgPSBbe1xuICAgICAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5Sb290UmVuZGVyZXIsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBfY3JlYXRlUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgZGVwczogW0RvbVJvb3RSZW5kZXJlciwgW05nUHJvYmVUb2tlbiwgbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKV1dXG4gICAgICAgIH1dO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBEb21FdmVudHNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNShEb21FdmVudHNQbHVnaW4sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbUV2ZW50c1BsdWdpbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcGx1Z2luIHNob3VsZCBjb21lIGxhc3QgaW4gdGhlIGxpc3Qgb2YgcGx1Z2lucywgYmVjYXVzZSBpdCBhY2NlcHRzIGFsbFxuICAgICAgICAvLyBldmVudHMuXG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICBEb21FdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBEb21FdmVudHNQbHVnaW4uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21FdmVudHNQbHVnaW4uY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIERvbUV2ZW50c1BsdWdpbjtcbiAgICB9KEV2ZW50TWFuYWdlclBsdWdpbikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBFVkVOVF9OQU1FUyA9IHtcbiAgICAgICAgLy8gcGFuXG4gICAgICAgICdwYW4nOiB0cnVlLFxuICAgICAgICAncGFuc3RhcnQnOiB0cnVlLFxuICAgICAgICAncGFubW92ZSc6IHRydWUsXG4gICAgICAgICdwYW5lbmQnOiB0cnVlLFxuICAgICAgICAncGFuY2FuY2VsJzogdHJ1ZSxcbiAgICAgICAgJ3BhbmxlZnQnOiB0cnVlLFxuICAgICAgICAncGFucmlnaHQnOiB0cnVlLFxuICAgICAgICAncGFudXAnOiB0cnVlLFxuICAgICAgICAncGFuZG93bic6IHRydWUsXG4gICAgICAgIC8vIHBpbmNoXG4gICAgICAgICdwaW5jaCc6IHRydWUsXG4gICAgICAgICdwaW5jaHN0YXJ0JzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNobW92ZSc6IHRydWUsXG4gICAgICAgICdwaW5jaGVuZCc6IHRydWUsXG4gICAgICAgICdwaW5jaGNhbmNlbCc6IHRydWUsXG4gICAgICAgICdwaW5jaGluJzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNob3V0JzogdHJ1ZSxcbiAgICAgICAgLy8gcHJlc3NcbiAgICAgICAgJ3ByZXNzJzogdHJ1ZSxcbiAgICAgICAgJ3ByZXNzdXAnOiB0cnVlLFxuICAgICAgICAvLyByb3RhdGVcbiAgICAgICAgJ3JvdGF0ZSc6IHRydWUsXG4gICAgICAgICdyb3RhdGVzdGFydCc6IHRydWUsXG4gICAgICAgICdyb3RhdGVtb3ZlJzogdHJ1ZSxcbiAgICAgICAgJ3JvdGF0ZWVuZCc6IHRydWUsXG4gICAgICAgICdyb3RhdGVjYW5jZWwnOiB0cnVlLFxuICAgICAgICAvLyBzd2lwZVxuICAgICAgICAnc3dpcGUnOiB0cnVlLFxuICAgICAgICAnc3dpcGVsZWZ0JzogdHJ1ZSxcbiAgICAgICAgJ3N3aXBlcmlnaHQnOiB0cnVlLFxuICAgICAgICAnc3dpcGV1cCc6IHRydWUsXG4gICAgICAgICdzd2lwZWRvd24nOiB0cnVlLFxuICAgICAgICAvLyB0YXBcbiAgICAgICAgJ3RhcCc6IHRydWUsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERJIHRva2VuIHRoYXQgeW91IGNhbiB1c2UgdG8gcHJvdmlkZXtAbGluayBIYW1tZXJHZXN0dXJlQ29uZmlnfSB0byBBbmd1bGFyLiBVc2UgaXQgdG8gY29uZmlndXJlXG4gICAgICogSGFtbWVyIGdlc3R1cmVzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBIQU1NRVJfR0VTVFVSRV9DT05GSUcgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignSGFtbWVyR2VzdHVyZUNvbmZpZycpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSGFtbWVyR2VzdHVyZUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEhhbW1lckdlc3R1cmVDb25maWcoKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdmVycmlkZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBIYW1tZXJHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5idWlsZEhhbW1lciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgbWMgPSBuZXcgSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgbWMuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIG1jLmdldCgncm90YXRlJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMub3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgbWMuZ2V0KGV2ZW50TmFtZSkuc2V0KHRoaXMub3ZlcnJpZGVzW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1jO1xuICAgICAgICB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlQ29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSGFtbWVyR2VzdHVyZUNvbmZpZy5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSGFtbWVyR2VzdHVyZUNvbmZpZztcbiAgICB9KCkpO1xuICAgIHZhciBIYW1tZXJHZXN0dXJlc1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEhhbW1lckdlc3R1cmVzUGx1Z2luLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBIYW1tZXJHZXN0dXJlc1BsdWdpbihfY29uZmlnKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFFVkVOVF9OQU1FUy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUudG9Mb3dlckNhc2UoKSkgJiYgIXRoaXMuaXNDdXN0b21FdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuSGFtbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFtbWVyLmpzIGlzIG5vdCBsb2FkZWQsIGNhbiBub3QgYmluZCBcIiArIGV2ZW50TmFtZSArIFwiIGV2ZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB6b25lID0gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKTtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0aW5nIHRoZSBtYW5hZ2VyIGJpbmQgZXZlbnRzLCBtdXN0IGJlIGRvbmUgb3V0c2lkZSBvZiBhbmd1bGFyXG4gICAgICAgICAgICAgICAgdmFyIG1jID0gX3RoaXMuX2NvbmZpZy5idWlsZEhhbW1lcihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgem9uZS5ydW5HdWFyZGVkKGZ1bmN0aW9uICgpIHsgaGFuZGxlcihldmVudE9iaik7IH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWMub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1jLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTsgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5wcm90b3R5cGUuaXNDdXN0b21FdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIHRoaXMuX2NvbmZpZy5ldmVudHMuaW5kZXhPZihldmVudE5hbWUpID4gLTE7IH07XG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEhhbW1lckdlc3R1cmVDb25maWcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbSEFNTUVSX0dFU1RVUkVfQ09ORklHLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBIYW1tZXJHZXN0dXJlc1BsdWdpbjtcbiAgICB9KEV2ZW50TWFuYWdlclBsdWdpbikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBNT0RJRklFUl9LRVlTID0gWydhbHQnLCAnY29udHJvbCcsICdtZXRhJywgJ3NoaWZ0J107XG4gICAgdmFyIE1PRElGSUVSX0tFWV9HRVRURVJTID0ge1xuICAgICAgICAnYWx0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5hbHRLZXk7IH0sXG4gICAgICAgICdjb250cm9sJzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5jdHJsS2V5OyB9LFxuICAgICAgICAnbWV0YSc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubWV0YUtleTsgfSxcbiAgICAgICAgJ3NoaWZ0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5zaGlmdEtleTsgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBLZXlFdmVudHNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhLZXlFdmVudHNQbHVnaW4sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEtleUV2ZW50c1BsdWdpbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIEtleUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiBLZXlFdmVudHNQbHVnaW4ucGFyc2VFdmVudE5hbWUoZXZlbnROYW1lKSAhPSBudWxsOyB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkRXZlbnQgPSBLZXlFdmVudHNQbHVnaW4ucGFyc2VFdmVudE5hbWUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHZhciBvdXRzaWRlSGFuZGxlciA9IEtleUV2ZW50c1BsdWdpbi5ldmVudENhbGxiYWNrKHBhcnNlZEV2ZW50WydmdWxsS2V5J10sIGhhbmRsZXIsIHRoaXMubWFuYWdlci5nZXRab25lKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRab25lKCkucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRET00oKS5vbkFuZENhbmNlbChlbGVtZW50LCBwYXJzZWRFdmVudFsnZG9tRXZlbnROYW1lJ10sIG91dHNpZGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4ucGFyc2VFdmVudE5hbWUgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFyIGRvbUV2ZW50TmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoKHBhcnRzLmxlbmd0aCA9PT0gMCkgfHwgIShkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXl1cCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2V5ID0gS2V5RXZlbnRzUGx1Z2luLl9ub3JtYWxpemVLZXkocGFydHMucG9wKCkpO1xuICAgICAgICAgICAgdmFyIGZ1bGxLZXkgPSAnJztcbiAgICAgICAgICAgIE1PRElGSUVSX0tFWVMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFydHMuaW5kZXhPZihtb2RpZmllck5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxLZXkgKz0gbW9kaWZpZXJOYW1lICsgJy4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVsbEtleSArPSBrZXk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9IDAgfHwga2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybmluZyBudWxsIGluc3RlYWQgb2YgdGhyb3dpbmcgdG8gbGV0IGFub3RoZXIgcGx1Z2luIHByb2Nlc3MgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICByZXN1bHRbJ2RvbUV2ZW50TmFtZSddID0gZG9tRXZlbnROYW1lO1xuICAgICAgICAgICAgcmVzdWx0WydmdWxsS2V5J10gPSBmdWxsS2V5O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmdldEV2ZW50RnVsbEtleSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGZ1bGxLZXkgPSAnJztcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRET00oKS5nZXRFdmVudEtleShldmVudCk7XG4gICAgICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGtleSA9ICdzcGFjZSc7IC8vIGZvciByZWFkYWJpbGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSAnZG90JzsgLy8gYmVjYXVzZSAnLicgaXMgdXNlZCBhcyBhIHNlcGFyYXRvciBpbiBldmVudCBuYW1lc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTU9ESUZJRVJfS0VZUy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJOYW1lICE9IGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZXJHZXR0ZXIgPSBNT0RJRklFUl9LRVlfR0VUVEVSU1ttb2RpZmllck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJHZXR0ZXIoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsS2V5ICs9IG1vZGlmaWVyTmFtZSArICcuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVsbEtleSArPSBrZXk7XG4gICAgICAgICAgICByZXR1cm4gZnVsbEtleTtcbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZnVsbEtleSwgaGFuZGxlciwgem9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChLZXlFdmVudHNQbHVnaW4uZ2V0RXZlbnRGdWxsS2V5KGV2ZW50KSA9PT0gZnVsbEtleSkge1xuICAgICAgICAgICAgICAgICAgICB6b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFuZGxlcihldmVudCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLl9ub3JtYWxpemVLZXkgPSBmdW5jdGlvbiAoa2V5TmFtZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogc3dpdGNoIHRvIGEgTWFwIGlmIHRoZSBtYXBwaW5nIGdyb3dzIHRvbyBtdWNoXG4gICAgICAgICAgICBzd2l0Y2ggKGtleU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdlc2MnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2VzY2FwZSc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEtleUV2ZW50c1BsdWdpbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEtleUV2ZW50c1BsdWdpbi5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gS2V5RXZlbnRzUGx1Z2luO1xuICAgIH0oRXZlbnRNYW5hZ2VyUGx1Z2luKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4gICAgICpcbiAgICAgKiBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzIGEgc3Vic2V0IG9mIFVSTHMgdGhhdCB3aWxsIG5vdCBjYXVzZSBzY3JpcHRcbiAgICAgKiBleGVjdXRpb24gaWYgdXNlZCBpbiBVUkwgY29udGV4dCB3aXRoaW4gYSBIVE1MIGRvY3VtZW50LiBTcGVjaWZpY2FsbHksIHRoaXNcbiAgICAgKiByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hlcyBpZiAoY29tbWVudCBmcm9tIGhlcmUgb24gYW5kIHJlZ2V4IGNvcGllZCBmcm9tXG4gICAgICogU295J3MgRXNjYXBpbmdDb252ZW50aW9ucyk6XG4gICAgICogKDEpIEVpdGhlciBhIHByb3RvY29sIGluIGEgd2hpdGVsaXN0IChodHRwLCBodHRwcywgbWFpbHRvIG9yIGZ0cCkuXG4gICAgICogKDIpIG9yIG5vIHByb3RvY29sLiAgQSBwcm90b2NvbCBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgY29sb24uIFRoZSBiZWxvd1xuICAgICAqICAgICBhbGxvd3MgdGhhdCBieSBhbGxvd2luZyBjb2xvbnMgb25seSBhZnRlciBvbmUgb2YgdGhlIGNoYXJhY3RlcnMgWy8/I10uXG4gICAgICogICAgIEEgY29sb24gYWZ0ZXIgYSBoYXNoICgjKSBtdXN0IGJlIGluIHRoZSBmcmFnbWVudC5cbiAgICAgKiAgICAgT3RoZXJ3aXNlLCBhIGNvbG9uIGFmdGVyIGEgKD8pIG11c3QgYmUgaW4gYSBxdWVyeS5cbiAgICAgKiAgICAgT3RoZXJ3aXNlLCBhIGNvbG9uIGFmdGVyIGEgc2luZ2xlIHNvbGlkdXMgKC8pIG11c3QgYmUgaW4gYSBwYXRoLlxuICAgICAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSBkb3VibGUgc29saWR1cyAoLy8pIG11c3QgYmUgaW4gdGhlIGF1dGhvcml0eVxuICAgICAqICAgICAoYmVmb3JlIHBvcnQpLlxuICAgICAqXG4gICAgICogVGhlIHBhdHRlcm4gZGlzYWxsb3dzICYsIHVzZWQgaW4gSFRNTCBlbnRpdHkgZGVjbGFyYXRpb25zIGJlZm9yZVxuICAgICAqIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBpbiBbLz8jXS4gVGhpcyBkaXNhbGxvd3MgSFRNTCBlbnRpdGllcyB1c2VkIGluIHRoZVxuICAgICAqIHByb3RvY29sIG5hbWUsIHdoaWNoIHNob3VsZCBuZXZlciBoYXBwZW4sIGUuZy4gXCJoJiMxMTY7dHBcIiBmb3IgXCJodHRwXCIuXG4gICAgICogSXQgYWxzbyBkaXNhbGxvd3MgSFRNTCBlbnRpdGllcyBpbiB0aGUgZmlyc3QgcGF0aCBwYXJ0IG9mIGEgcmVsYXRpdmUgcGF0aCxcbiAgICAgKiBlLmcuIFwiZm9vJmx0O2Jhci9iYXpcIi4gIE91ciBleGlzdGluZyBlc2NhcGluZyBmdW5jdGlvbnMgc2hvdWxkIG5vdCBwcm9kdWNlXG4gICAgICogdGhhdC4gTW9yZSBpbXBvcnRhbnRseSwgaXQgZGlzYWxsb3dzIG1hc2tpbmcgb2YgYSBjb2xvbixcbiAgICAgKiBlLmcuIFwiamF2YXNjcmlwdCYjNTg7Li4uXCIuXG4gICAgICpcbiAgICAgKiBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB3YXMgdGFrZW4gZnJvbSB0aGUgQ2xvc3VyZSBzYW5pdGl6YXRpb24gbGlicmFyeS5cbiAgICAgKi9cbiAgICB2YXIgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGUpOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvZ2k7XG4gICAgLyoqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvIHR5cGVzLiAqL1xuICAgIHZhciBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW2EtejAtOStcXC9dKz0qJC9pO1xuICAgIGZ1bmN0aW9uIHNhbml0aXplVXJsKHVybCkge1xuICAgICAgICB1cmwgPSBTdHJpbmcodXJsKTtcbiAgICAgICAgaWYgKHVybC5tYXRjaChTQUZFX1VSTF9QQVRURVJOKSB8fCB1cmwubWF0Y2goREFUQV9VUkxfUEFUVEVSTikpXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICBpZiAoX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgZ2V0RE9NKCkubG9nKFwiV0FSTklORzogc2FuaXRpemluZyB1bnNhZmUgVVJMIHZhbHVlIFwiICsgdXJsICsgXCIgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndW5zYWZlOicgKyB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhbml0aXplU3Jjc2V0KHNyY3NldCkge1xuICAgICAgICBzcmNzZXQgPSBTdHJpbmcoc3Jjc2V0KTtcbiAgICAgICAgcmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoc3Jjc2V0KSB7IHJldHVybiBzYW5pdGl6ZVVybChzcmNzZXQudHJpbSgpKTsgfSkuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICAvKiogQSA8Ym9keT4gZWxlbWVudCB0aGF0IGNhbiBiZSBzYWZlbHkgdXNlZCB0byBwYXJzZSB1bnRydXN0ZWQgSFRNTC4gTGF6aWx5IGluaXRpYWxpemVkIGJlbG93LiAqL1xuICAgIHZhciBpbmVydEVsZW1lbnQgPSBudWxsO1xuICAgIC8qKiBMYXppbHkgaW5pdGlhbGl6ZWQgdG8gbWFrZSBzdXJlIHRoZSBET00gYWRhcHRlciBnZXRzIHNldCBiZWZvcmUgdXNlLiAqL1xuICAgIHZhciBET00gPSBudWxsO1xuICAgIC8qKiBSZXR1cm5zIGFuIEhUTUwgZWxlbWVudCB0aGF0IGlzIGd1YXJhbnRlZWQgdG8gbm90IGV4ZWN1dGUgY29kZSB3aGVuIGNyZWF0aW5nIGVsZW1lbnRzIGluIGl0LiAqL1xuICAgIGZ1bmN0aW9uIGdldEluZXJ0RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKGluZXJ0RWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBpbmVydEVsZW1lbnQ7XG4gICAgICAgIERPTSA9IGdldERPTSgpO1xuICAgICAgICAvLyBQcmVmZXIgdXNpbmcgPHRlbXBsYXRlPiBlbGVtZW50IGlmIHN1cHBvcnRlZC5cbiAgICAgICAgdmFyIHRlbXBsYXRlRWwgPSBET00uY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKCdjb250ZW50JyBpbiB0ZW1wbGF0ZUVsKVxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlRWw7XG4gICAgICAgIHZhciBkb2MgPSBET00uY3JlYXRlSHRtbERvY3VtZW50KCk7XG4gICAgICAgIGluZXJ0RWxlbWVudCA9IERPTS5xdWVyeVNlbGVjdG9yKGRvYywgJ2JvZHknKTtcbiAgICAgICAgaWYgKGluZXJ0RWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB1c3VhbGx5IHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBib2R5IGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LCBidXQgSUUgZG9lc24ndCBoYXZlIGFueSwgc28gd2VcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY3JlYXRlIG9uZS5cbiAgICAgICAgICAgIHZhciBodG1sID0gRE9NLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnLCBkb2MpO1xuICAgICAgICAgICAgaW5lcnRFbGVtZW50ID0gRE9NLmNyZWF0ZUVsZW1lbnQoJ2JvZHknLCBkb2MpO1xuICAgICAgICAgICAgRE9NLmFwcGVuZENoaWxkKGh0bWwsIGluZXJ0RWxlbWVudCk7XG4gICAgICAgICAgICBET00uYXBwZW5kQ2hpbGQoZG9jLCBodG1sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5lcnRFbGVtZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YWdTZXQodGFncykge1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0YWdzLnNwbGl0KCcsJyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdCA9IF9hW19pXTtcbiAgICAgICAgICAgIHJlc1t0XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgICAgIHZhciBzZXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBzZXRzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBzZXRzXzEgPSBzZXRzOyBfYSA8IHNldHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gc2V0c18xW19hXTtcbiAgICAgICAgICAgIGZvciAodmFyIHYgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChzLmhhc093blByb3BlcnR5KHYpKVxuICAgICAgICAgICAgICAgICAgICByZXNbdl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8vIEdvb2Qgc291cmNlIG9mIGluZm8gYWJvdXQgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXNcbiAgICAvLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjc2VtYW50aWNzXG4gICAgLy8gaHR0cDovL3NpbW9uLmh0bWw1Lm9yZy9odG1sLWVsZW1lbnRzXG4gICAgLy8gU2FmZSBWb2lkIEVsZW1lbnRzIC0gSFRNTDVcbiAgICAvLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdm9pZC1lbGVtZW50c1xuICAgIHZhciBWT0lEX0VMRU1FTlRTID0gdGFnU2V0KCdhcmVhLGJyLGNvbCxocixpbWcsd2JyJyk7XG4gICAgLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbiAgICAvLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjb3B0aW9uYWwtdGFnc1xuICAgIHZhciBPUFRJT05BTF9FTkRfVEFHX0JMT0NLX0VMRU1FTlRTID0gdGFnU2V0KCdjb2xncm91cCxkZCxkdCxsaSxwLHRib2R5LHRkLHRmb290LHRoLHRoZWFkLHRyJyk7XG4gICAgdmFyIE9QVElPTkFMX0VORF9UQUdfSU5MSU5FX0VMRU1FTlRTID0gdGFnU2V0KCdycCxydCcpO1xuICAgIHZhciBPUFRJT05BTF9FTkRfVEFHX0VMRU1FTlRTID0gbWVyZ2UoT1BUSU9OQUxfRU5EX1RBR19JTkxJTkVfRUxFTUVOVFMsIE9QVElPTkFMX0VORF9UQUdfQkxPQ0tfRUxFTUVOVFMpO1xuICAgIC8vIFNhZmUgQmxvY2sgRWxlbWVudHMgLSBIVE1MNVxuICAgIHZhciBCTE9DS19FTEVNRU5UUyA9IG1lcmdlKE9QVElPTkFMX0VORF9UQUdfQkxPQ0tfRUxFTUVOVFMsIHRhZ1NldCgnYWRkcmVzcyxhcnRpY2xlLCcgK1xuICAgICAgICAnYXNpZGUsYmxvY2txdW90ZSxjYXB0aW9uLGNlbnRlcixkZWwsZGV0YWlscyxkaWFsb2csZGlyLGRpdixkbCxmaWd1cmUsZmlnY2FwdGlvbixmb290ZXIsaDEsaDIsaDMsaDQsaDUsJyArXG4gICAgICAgICdoNixoZWFkZXIsaGdyb3VwLGhyLGlucyxtYWluLG1hcCxtZW51LG5hdixvbCxwcmUsc2VjdGlvbixzdW1tYXJ5LHRhYmxlLHVsJykpO1xuICAgIC8vIElubGluZSBFbGVtZW50cyAtIEhUTUw1XG4gICAgdmFyIElOTElORV9FTEVNRU5UUyA9IG1lcmdlKE9QVElPTkFMX0VORF9UQUdfSU5MSU5FX0VMRU1FTlRTLCB0YWdTZXQoJ2EsYWJicixhY3JvbnltLGF1ZGlvLGIsJyArXG4gICAgICAgICdiZGksYmRvLGJpZyxicixjaXRlLGNvZGUsZGVsLGRmbixlbSxmb250LGksaW1nLGlucyxrYmQsbGFiZWwsbWFwLG1hcmsscGljdHVyZSxxLHJ1YnkscnAscnQscywnICtcbiAgICAgICAgJ3NhbXAsc21hbGwsc291cmNlLHNwYW4sc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHRpbWUsdHJhY2ssdHQsdSx2YXIsdmlkZW8nKSk7XG4gICAgdmFyIFZBTElEX0VMRU1FTlRTID0gbWVyZ2UoVk9JRF9FTEVNRU5UUywgQkxPQ0tfRUxFTUVOVFMsIElOTElORV9FTEVNRU5UUywgT1BUSU9OQUxfRU5EX1RBR19FTEVNRU5UUyk7XG4gICAgLy8gQXR0cmlidXRlcyB0aGF0IGhhdmUgaHJlZiBhbmQgaGVuY2UgbmVlZCB0byBiZSBzYW5pdGl6ZWRcbiAgICB2YXIgVVJJX0FUVFJTID0gdGFnU2V0KCdiYWNrZ3JvdW5kLGNpdGUsaHJlZixpdGVtdHlwZSxsb25nZGVzYyxwb3N0ZXIsc3JjLHhsaW5rOmhyZWYnKTtcbiAgICAvLyBBdHRyaWJ1dGVzIHRoYXQgaGF2ZSBzcGVjaWFsIGhyZWYgc2V0IGhlbmNlIG5lZWQgdG8gYmUgc2FuaXRpemVkXG4gICAgdmFyIFNSQ1NFVF9BVFRSUyA9IHRhZ1NldCgnc3Jjc2V0Jyk7XG4gICAgdmFyIEhUTUxfQVRUUlMgPSB0YWdTZXQoJ2FiYnIsYWNjZXNza2V5LGFsaWduLGFsdCxhdXRvcGxheSxheGlzLGJnY29sb3IsYm9yZGVyLGNlbGxwYWRkaW5nLGNlbGxzcGFjaW5nLGNsYXNzLGNsZWFyLGNvbG9yLGNvbHMsY29sc3BhbiwnICtcbiAgICAgICAgJ2NvbXBhY3QsY29udHJvbHMsY29vcmRzLGRhdGV0aW1lLGRlZmF1bHQsZGlyLGRvd25sb2FkLGZhY2UsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhyZWZsYW5nLGhzcGFjZSwnICtcbiAgICAgICAgJ2lzbWFwLGl0ZW1zY29wZSxpdGVtcHJvcCxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9vcCxtZWRpYSxtdXRlZCxub2hyZWYsbm93cmFwLG9wZW4scHJlbG9hZCxyZWwscmV2LHJvbGUscm93cyxyb3dzcGFuLHJ1bGVzLCcgK1xuICAgICAgICAnc2NvcGUsc2Nyb2xsaW5nLHNoYXBlLHNpemUsc2l6ZXMsc3BhbixzcmNsYW5nLHN0YXJ0LHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCwnICtcbiAgICAgICAgJ3ZhbGlnbix2YWx1ZSx2c3BhY2Usd2lkdGgnKTtcbiAgICAvLyBOQjogVGhpcyBjdXJyZW50bHkgY29uY2lvdXNseSBkb2Vzbid0IHN1cHBvcnQgU1ZHLiBTVkcgc2FuaXRpemF0aW9uIGhhcyBoYWQgc2V2ZXJhbCBzZWN1cml0eVxuICAgIC8vIGlzc3VlcyBpbiB0aGUgcGFzdCwgc28gaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUgaXQgb3V0IGlmIHBvc3NpYmxlLiBJZiBzdXBwb3J0IGZvciBiaW5kaW5nIFNWRyB2aWFcbiAgICAvLyBpbm5lckhUTUwgaXMgcmVxdWlyZWQsIFNWRyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhZGRlZCBoZXJlLlxuICAgIC8vIE5COiBTYW5pdGl6YXRpb24gZG9lcyBub3QgYWxsb3cgPGZvcm0+IGVsZW1lbnRzIG9yIG90aGVyIGFjdGl2ZSBlbGVtZW50cyAoPGJ1dHRvbj4gZXRjKS4gVGhvc2VcbiAgICAvLyBjYW4gYmUgc2FuaXRpemVkLCBidXQgdGhleSBpbmNyZWFzZSBzZWN1cml0eSBzdXJmYWNlIGFyZWEgd2l0aG91dCBhIGxlZ2l0aW1hdGUgdXNlIGNhc2UsIHNvIHRoZXlcbiAgICAvLyBhcmUgbGVmdCBvdXQgaGVyZS5cbiAgICB2YXIgVkFMSURfQVRUUlMgPSBtZXJnZShVUklfQVRUUlMsIFNSQ1NFVF9BVFRSUywgSFRNTF9BVFRSUyk7XG4gICAgLyoqXG4gICAgICogU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyIHNlcmlhbGl6ZXMgYSBET00gZnJhZ21lbnQsIHN0cmlwcGluZyBvdXQgYW55IHVuc2FmZSBlbGVtZW50cyBhbmQgdW5zYWZlXG4gICAgICogYXR0cmlidXRlcy5cbiAgICAgKi9cbiAgICB2YXIgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyKCkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB0cmFjayBpZiBzb21ldGhpbmcgd2FzIHN0cmlwcGVkLCB0byBhdm9pZCBhY2NpZGVudGFsbHkgd2FybmluZyBvZiBzYW5pdGl6YXRpb24ganVzdFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBjaGFyYWN0ZXJzIHdlcmUgcmUtZW5jb2RlZC5cbiAgICAgICAgICAgIHRoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFNhbml0aXppbmdIdG1sU2VyaWFsaXplci5wcm90b3R5cGUuc2FuaXRpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW5ub3QgdXNlIGEgVHJlZVdhbGtlciwgYXMgaXQgaGFzIHRvIHJ1biBvbiBBbmd1bGFyJ3MgdmFyaW91cyBET00gYWRhcHRlcnMuXG4gICAgICAgICAgICAvLyBIb3dldmVyIHRoaXMgY29kZSBuZXZlciBhY2Nlc3NlcyBwcm9wZXJ0aWVzIG9mZiBvZiBgZG9jdW1lbnRgIGJlZm9yZSBkZWxldGluZyBpdHMgY29udGVudHNcbiAgICAgICAgICAgIC8vIGFnYWluLCBzbyBpdCBzaG91bGRuJ3QgYmUgdnVsbmVyYWJsZSB0byBET00gY2xvYmJlcmluZy5cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKERPTS5pc0VsZW1lbnROb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFbGVtZW50KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChET00uaXNUZXh0Tm9kZShjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJzKERPTS5ub2RlVmFsdWUoY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgbm9uLWVsZW1lbnQsIG5vbi10ZXh0IG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbml0aXplZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChET00uZmlyc3RDaGlsZChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gRE9NLmZpcnN0Q2hpbGQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWF2aW5nIHRoZSBlbGVtZW50LiBXYWxrIHVwIGFuZCB0byB0aGUgcmlnaHQsIGNsb3NpbmcgdGFncyBhcyB3ZSBnby5cbiAgICAgICAgICAgICAgICAgICAgaWYgKERPTS5pc0VsZW1lbnROb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZEVsZW1lbnQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKERPTS5uZXh0U2libGluZyhjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IERPTS5uZXh0U2libGluZyhjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBET00ucGFyZW50RWxlbWVudChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWYuam9pbignJyk7XG4gICAgICAgIH07XG4gICAgICAgIFNhbml0aXppbmdIdG1sU2VyaWFsaXplci5wcm90b3R5cGUuc3RhcnRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IERPTS5ub2RlTmFtZShlbGVtZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCFWQUxJRF9FTEVNRU5UUy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCc8Jyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKHRhZ05hbWUpO1xuICAgICAgICAgICAgRE9NLmF0dHJpYnV0ZU1hcChlbGVtZW50KS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgYXR0ck5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXIgPSBhdHRyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmICghVkFMSURfQVRUUlMuaGFzT3duUHJvcGVydHkobG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNhbml0aXplZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiBTcGVjaWFsIGNhc2UgaW1hZ2UgVVJJcyBmb3IgZGF0YTppbWFnZS8uLi5cbiAgICAgICAgICAgICAgICBpZiAoVVJJX0FUVFJTW2xvd2VyXSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVVybCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKFNSQ1NFVF9BVFRSU1tsb3dlcl0pXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVTcmNzZXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1Zi5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1Zi5wdXNoKCc9XCInKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5idWYucHVzaChlbmNvZGVFbnRpdGllcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1Zi5wdXNoKCdcIicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCc+Jyk7XG4gICAgICAgIH07XG4gICAgICAgIFNhbml0aXppbmdIdG1sU2VyaWFsaXplci5wcm90b3R5cGUuZW5kRWxlbWVudCA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IERPTS5ub2RlTmFtZShjdXJyZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKFZBTElEX0VMRU1FTlRTLmhhc093blByb3BlcnR5KHRhZ05hbWUpICYmICFWT0lEX0VMRU1FTlRTLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWYucHVzaCgnPC8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJz4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5jaGFycyA9IGZ1bmN0aW9uIChjaGFycyAvKiogVE9ETyAjOTEwMCAqLykgeyB0aGlzLmJ1Zi5wdXNoKGVuY29kZUVudGl0aWVzKGNoYXJzKSk7IH07XG4gICAgICAgIHJldHVybiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXI7XG4gICAgfSgpKTtcbiAgICAvLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbiAgICB2YXIgU1VSUk9HQVRFX1BBSVJfUkVHRVhQID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcbiAgICAvLyAhIHRvIH4gaXMgdGhlIEFTQ0lJIHJhbmdlLlxuICAgIHZhciBOT05fQUxQSEFOVU1FUklDX1JFR0VYUCA9IC8oW15cXCMtfiB8IV0pL2c7XG4gICAgLyoqXG4gICAgICogRXNjYXBlcyBhbGwgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGNoYXJhY3RlcnMsIHNvIHRoYXQgdGhlXG4gICAgICogcmVzdWx0aW5nIHN0cmluZyBjYW4gYmUgc2FmZWx5IGluc2VydGVkIGludG8gYXR0cmlidXRlIG9yXG4gICAgICogZWxlbWVudCB0ZXh0LlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgdGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZUVudGl0aWVzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZShTVVJST0dBVEVfUEFJUl9SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGhpID0gbWF0Y2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHZhciBsb3cgPSBtYXRjaC5jaGFyQ29kZUF0KDEpO1xuICAgICAgICAgICAgcmV0dXJuICcmIycgKyAoKChoaSAtIDB4RDgwMCkgKiAweDQwMCkgKyAobG93IC0gMHhEQzAwKSArIDB4MTAwMDApICsgJzsnO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gJyYjJyArIG1hdGNoLmNoYXJDb2RlQXQoMCkgKyAnOyc7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIElFOS0xMSBjb21lcyBhY3Jvc3MgYW4gdW5rbm93biBuYW1lc3BhY2VkIGF0dHJpYnV0ZSBlLmcuICd4bGluazpmb28nIGl0IGFkZHMgJ3htbG5zOm5zMSdcbiAgICAgKiBhdHRyaWJ1dGUgdG8gZGVjbGFyZSBuczEgbmFtZXNwYWNlIGFuZCBwcmVmaXhlcyB0aGUgYXR0cmlidXRlIHdpdGggJ25zMScgKGUuZy4gJ25zMTp4bGluazpmb28nKS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdW5kZXNpcmFibGUgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBhbGxvdyBhbnkgb2YgdGhlc2UgY3VzdG9tIGF0dHJpYnV0ZXMuIFRoaXMgbWV0aG9kXG4gICAgICogc3RyaXBzIHRoZW0gYWxsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwQ3VzdG9tTnNBdHRycyhlbCkge1xuICAgICAgICBET00uYXR0cmlidXRlTWFwKGVsKS5mb3JFYWNoKGZ1bmN0aW9uIChfLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09PSAneG1sbnM6bnMxJyB8fCBhdHRyTmFtZS5pbmRleE9mKCduczE6JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBET00ucmVtb3ZlQXR0cmlidXRlKGVsLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gRE9NLmNoaWxkTm9kZXNBc0xpc3QoZWwpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG4gPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoRE9NLmlzRWxlbWVudE5vZGUobikpXG4gICAgICAgICAgICAgICAgc3RyaXBDdXN0b21Oc0F0dHJzKG4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhbml0aXplcyB0aGUgZ2l2ZW4gdW5zYWZlLCB1bnRydXN0ZWQgSFRNTCBmcmFnbWVudCwgYW5kIHJldHVybnMgSFRNTCB0ZXh0IHRoYXQgaXMgc2FmZSB0byBhZGQgdG9cbiAgICAgKiB0aGUgRE9NIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbElucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWwgPSBnZXRJbmVydEVsZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB1bnNhZmVIdG1sIGlzIGFjdHVhbGx5IGEgc3RyaW5nIChUeXBlU2NyaXB0IHR5cGVzIGFyZSBub3QgZW5mb3JjZWQgYXQgcnVudGltZSkuXG4gICAgICAgICAgICB2YXIgdW5zYWZlSHRtbCA9IHVuc2FmZUh0bWxJbnB1dCA/IFN0cmluZyh1bnNhZmVIdG1sSW5wdXQpIDogJyc7XG4gICAgICAgICAgICAvLyBtWFNTIHByb3RlY3Rpb24uIFJlcGVhdGVkbHkgcGFyc2UgdGhlIGRvY3VtZW50IHRvIG1ha2Ugc3VyZSBpdCBzdGFiaWxpemVzLCBzbyB0aGF0IGEgYnJvd3NlclxuICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIGF1dG8tY29ycmVjdCBpbmNvcnJlY3QgSFRNTCBjYW5ub3QgY2F1c2UgZm9ybWVybHkgaW5lcnQgSFRNTCB0byBiZWNvbWUgZGFuZ2Vyb3VzLlxuICAgICAgICAgICAgdmFyIG1YU1NBdHRlbXB0cyA9IDU7XG4gICAgICAgICAgICB2YXIgcGFyc2VkSHRtbCA9IHVuc2FmZUh0bWw7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKG1YU1NBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYW5pdGl6ZSBodG1sIGJlY2F1c2UgdGhlIGlucHV0IGlzIHVuc3RhYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1YU1NBdHRlbXB0cy0tO1xuICAgICAgICAgICAgICAgIHVuc2FmZUh0bWwgPSBwYXJzZWRIdG1sO1xuICAgICAgICAgICAgICAgIERPTS5zZXRJbm5lckhUTUwoY29udGFpbmVyRWwsIHVuc2FmZUh0bWwpO1xuICAgICAgICAgICAgICAgIGlmIChET00uZGVmYXVsdERvYygpLmRvY3VtZW50TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCBjdXN0b20tbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIG9uIElFPD0xMVxuICAgICAgICAgICAgICAgICAgICBzdHJpcEN1c3RvbU5zQXR0cnMoY29udGFpbmVyRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWRIdG1sID0gRE9NLmdldElubmVySFRNTChjb250YWluZXJFbCk7XG4gICAgICAgICAgICB9IHdoaWxlICh1bnNhZmVIdG1sICE9PSBwYXJzZWRIdG1sKTtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZXIgPSBuZXcgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyKCk7XG4gICAgICAgICAgICB2YXIgc2FmZUh0bWwgPSBzYW5pdGl6ZXIuc2FuaXRpemVDaGlsZHJlbihET00uZ2V0VGVtcGxhdGVDb250ZW50KGNvbnRhaW5lckVsKSB8fCBjb250YWluZXJFbCk7XG4gICAgICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGJvZHkgZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IERPTS5nZXRUZW1wbGF0ZUNvbnRlbnQoY29udGFpbmVyRWwpIHx8IGNvbnRhaW5lckVsO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IERPTS5jaGlsZE5vZGVzQXNMaXN0KHBhcmVudF8xKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgRE9NLnJlbW92ZUNoaWxkKHBhcmVudF8xLCBjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSAmJiBzYW5pdGl6ZXIuc2FuaXRpemVkU29tZXRoaW5nKSB7XG4gICAgICAgICAgICAgICAgRE9NLmxvZygnV0FSTklORzogc2FuaXRpemluZyBIVE1MIHN0cmlwcGVkIHNvbWUgY29udGVudCAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcykuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FmZUh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYW55dGhpbmcgZ29lcyB3cm9uZywgY2xlYXIgb3V0IGluZXJ0RWxlbWVudCB0byByZXNldCB0aGUgZW50aXJlIERPTSBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICBpbmVydEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3Igc2FmZSBzdHlsZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBRdW90ZXMgKFwiIGFuZCAnKSBhcmUgYWxsb3dlZCwgYnV0IGEgY2hlY2sgbXVzdCBiZSBkb25lIGVsc2V3aGVyZSB0byBlbnN1cmUgdGhleSdyZSBiYWxhbmNlZC5cbiAgICAgKlxuICAgICAqICcsJyBhbGxvd3MgbXVsdGlwbGUgdmFsdWVzIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBzYW1lIHByb3BlcnR5IChlLmcuIGJhY2tncm91bmQtYXR0YWNobWVudCBvclxuICAgICAqIGZvbnQtZmFtaWx5KSBhbmQgaGVuY2UgY291bGQgYWxsb3cgbXVsdGlwbGUgdmFsdWVzIHRvIGdldCBpbmplY3RlZCwgYnV0IHRoYXQgc2hvdWxkIHBvc2Ugbm8gcmlza1xuICAgICAqIG9mIFhTUy5cbiAgICAgKlxuICAgICAqIFRoZSBmdW5jdGlvbiBleHByZXNzaW9uIGNoZWNrcyBvbmx5IGZvciBYU1Mgc2FmZXR5LCBub3QgZm9yIENTUyB2YWxpZGl0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LCBhbmQgYXVnbWVudGVkIGZvclxuICAgICAqIHRyYW5zZm9ybWF0aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgVkFMVUVTID0gJ1stLC5cIlxcJyVfISMgYS16QS1aMC05XSsnO1xuICAgIHZhciBUUkFOU0ZPUk1BVElPTl9GTlMgPSAnKD86bWF0cml4fHRyYW5zbGF0ZXxzY2FsZXxyb3RhdGV8c2tld3xwZXJzcGVjdGl2ZSkoPzpYfFl8M2QpPyc7XG4gICAgdmFyIENPTE9SX0ZOUyA9ICcoPzpyZ2J8aHNsKWE/JztcbiAgICB2YXIgRk5fQVJHUyA9ICdcXFxcKFstMC05LiUsIGEtekEtWl0rXFxcXCknO1xuICAgIHZhciBTQUZFX1NUWUxFX1ZBTFVFID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBWQUxVRVMgKyBcInwoPzpcIiArIFRSQU5TRk9STUFUSU9OX0ZOUyArIFwifFwiICsgQ09MT1JfRk5TICsgXCIpXCIgKyBGTl9BUkdTICsgXCIpJFwiLCAnZycpO1xuICAgIC8qKlxuICAgICAqIE1hdGNoZXMgYSBgdXJsKC4uLilgIHZhbHVlIHdpdGggYW4gYXJiaXRyYXJ5IGFyZ3VtZW50IGFzIGxvbmcgYXMgaXQgZG9lc1xuICAgICAqIG5vdCBjb250YWluIHBhcmVudGhlc2VzLlxuICAgICAqXG4gICAgICogVGhlIFVSTCB2YWx1ZSBzdGlsbCBuZWVkcyB0byBiZSBzYW5pdGl6ZWQgc2VwYXJhdGVseS5cbiAgICAgKlxuICAgICAqIGB1cmwoLi4uKWAgdmFsdWVzIGFyZSBhIHZlcnkgY29tbW9uIHVzZSBjYXNlLCBlLmcuIGZvciBgYmFja2dyb3VuZC1pbWFnZWAuIFdpdGggY2FyZWZ1bGx5IGNyYWZ0ZWRcbiAgICAgKiBDU1Mgc3R5bGUgcnVsZXMsIGl0IGlzIHBvc3NpYmxlIHRvIGNvbnN0cnVjdCBhbiBpbmZvcm1hdGlvbiBsZWFrIHdpdGggYHVybGAgdmFsdWVzIGluIENTUywgZS5nLlxuICAgICAqIGJ5IG9ic2VydmluZyB3aGV0aGVyIHNjcm9sbCBiYXJzIGFyZSBkaXNwbGF5ZWQsIG9yIGNoYXJhY3RlciByYW5nZXMgdXNlZCBieSBhIGZvbnQgZmFjZVxuICAgICAqIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBBbmd1bGFyIG9ubHkgYWxsb3dzIGJpbmRpbmcgQ1NTIHZhbHVlcyAoYXMgb3Bwb3NlZCB0byBlbnRpcmUgQ1NTIHJ1bGVzKSwgc28gaXQgaXMgdW5saWtlbHkgdGhhdFxuICAgICAqIGJpbmRpbmcgYSBVUkwgdmFsdWUgd2l0aG91dCBmdXJ0aGVyIGNvb3BlcmF0aW9uIGZyb20gdGhlIHBhZ2Ugd2lsbCBjYXVzZSBhbiBpbmZvcm1hdGlvbiBsZWFrLCBhbmRcbiAgICAgKiBpZiBzbywgaXQgaXMganVzdCBhIGxlYWssIG5vdCBhIGZ1bGwgYmxvd24gWFNTIHZ1bG5lcmFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBHaXZlbiB0aGUgY29tbW9uIHVzZSBjYXNlLCBsb3cgbGlrZWxpaG9vZCBvZiBhdHRhY2sgdmVjdG9yLCBhbmQgbG93IGltcGFjdCBvZiBhbiBhdHRhY2ssIHRoaXNcbiAgICAgKiBjb2RlIGlzIHBlcm1pc3NpdmUgYW5kIGFsbG93cyBVUkxzIHRoYXQgc2FuaXRpemUgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHZhciBVUkxfUkUgPSAvXnVybFxcKChbXildKylcXCkkLztcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhhdCBxdW90ZXMgKFwiIGFuZCAnKSBhcmUgcHJvcGVybHkgYmFsYW5jZWQgaW5zaWRlIGEgc3RyaW5nLiBBc3N1bWVzXG4gICAgICogdGhhdCBuZWl0aGVyIGVzY2FwZSAoXFwpIG5vciBhbnkgb3RoZXIgY2hhcmFjdGVyIHRoYXQgY291bGQgcmVzdWx0IGluXG4gICAgICogYnJlYWtpbmcgb3V0IG9mIGEgc3RyaW5nIHBhcnNpbmcgY29udGV4dCBhcmUgYWxsb3dlZDtcbiAgICAgKiBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI3N0cmluZy10b2tlbi1kaWFncmFtLlxuICAgICAqXG4gICAgICogVGhpcyBjb2RlIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0JhbGFuY2VkUXVvdGVzKHZhbHVlKSB7XG4gICAgICAgIHZhciBvdXRzaWRlU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgdmFyIG91dHNpZGVEb3VibGUgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHZhbHVlLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFwnJyAmJiBvdXRzaWRlRG91YmxlKSB7XG4gICAgICAgICAgICAgICAgb3V0c2lkZVNpbmdsZSA9ICFvdXRzaWRlU2luZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1wiJyAmJiBvdXRzaWRlU2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgb3V0c2lkZURvdWJsZSA9ICFvdXRzaWRlRG91YmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRzaWRlU2luZ2xlICYmIG91dHNpZGVEb3VibGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhbml0aXplcyB0aGUgZ2l2ZW4gdW50cnVzdGVkIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZSAoaS5lLiBub3QgYW4gZW50aXJlIG9iamVjdCwganVzdCBhIHNpbmdsZVxuICAgICAqIHZhbHVlKSBhbmQgcmV0dXJucyBhIHZhbHVlIHRoYXQgaXMgc2FmZSB0byB1c2UgaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplU3R5bGUodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpLnRyaW0oKTsgLy8gTWFrZSBzdXJlIGl0J3MgYWN0dWFsbHkgYSBzdHJpbmcuXG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIC8vIFNpbmdsZSB1cmwoLi4uKSB2YWx1ZXMgYXJlIHN1cHBvcnRlZCwgYnV0IG9ubHkgZm9yIFVSTHMgdGhhdCBzYW5pdGl6ZSBjbGVhbmx5LiBTZWUgYWJvdmUgZm9yXG4gICAgICAgIC8vIHJlYXNvbmluZyBiZWhpbmQgdGhpcy5cbiAgICAgICAgdmFyIHVybE1hdGNoID0gdmFsdWUubWF0Y2goVVJMX1JFKTtcbiAgICAgICAgaWYgKCh1cmxNYXRjaCAmJiBzYW5pdGl6ZVVybCh1cmxNYXRjaFsxXSkgPT09IHVybE1hdGNoWzFdKSB8fFxuICAgICAgICAgICAgdmFsdWUubWF0Y2goU0FGRV9TVFlMRV9WQUxVRSkgJiYgaGFzQmFsYW5jZWRRdW90ZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7IC8vIFNhZmUgc3R5bGUgdmFsdWVzLlxuICAgICAgICB9XG4gICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBnZXRET00oKS5sb2coXCJXQVJOSU5HOiBzYW5pdGl6aW5nIHVuc2FmZSBzdHlsZSB2YWx1ZSBcIiArIHZhbHVlICsgXCIgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3Vuc2FmZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvbVNhbml0aXplciBoZWxwcyBwcmV2ZW50aW5nIENyb3NzIFNpdGUgU2NyaXB0aW5nIFNlY3VyaXR5IGJ1Z3MgKFhTUykgYnkgc2FuaXRpemluZ1xuICAgICAqIHZhbHVlcyB0byBiZSBzYWZlIHRvIHVzZSBpbiB0aGUgZGlmZmVyZW50IERPTSBjb250ZXh0cy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGJpbmRpbmcgYSBVUkwgaW4gYW4gYDxhIFtocmVmXT1cInNvbWVWYWx1ZVwiPmAgaHlwZXJsaW5rLCBgc29tZVZhbHVlYCB3aWxsIGJlXG4gICAgICogc2FuaXRpemVkIHNvIHRoYXQgYW4gYXR0YWNrZXIgY2Fubm90IGluamVjdCBlLmcuIGEgYGphdmFzY3JpcHQ6YCBVUkwgdGhhdCB3b3VsZCBleGVjdXRlIGNvZGUgb25cbiAgICAgKiB0aGUgd2Vic2l0ZS5cbiAgICAgKlxuICAgICAqIEluIHNwZWNpZmljIHNpdHVhdGlvbnMsIGl0IG1pZ2h0IGJlIG5lY2Vzc2FyeSB0byBkaXNhYmxlIHNhbml0aXphdGlvbiwgZm9yIGV4YW1wbGUgaWYgdGhlXG4gICAgICogYXBwbGljYXRpb24gZ2VudWluZWx5IG5lZWRzIHRvIHByb2R1Y2UgYSBgamF2YXNjcmlwdDpgIHN0eWxlIGxpbmsgd2l0aCBhIGR5bmFtaWMgdmFsdWUgaW4gaXQuXG4gICAgICogVXNlcnMgY2FuIGJ5cGFzcyBzZWN1cml0eSBieSBjb25zdHJ1Y3RpbmcgYSB2YWx1ZSB3aXRoIG9uZSBvZiB0aGUgYGJ5cGFzc1NlY3VyaXR5VHJ1c3QuLi5gXG4gICAgICogbWV0aG9kcywgYW5kIHRoZW4gYmluZGluZyB0byB0aGF0IHZhbHVlIGZyb20gdGhlIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogVGhlc2Ugc2l0dWF0aW9ucyBzaG91bGQgYmUgdmVyeSByYXJlLCBhbmQgZXh0cmFvcmRpbmFyeSBjYXJlIG11c3QgYmUgdGFrZW4gdG8gYXZvaWQgY3JlYXRpbmcgYVxuICAgICAqIENyb3NzIFNpdGUgU2NyaXB0aW5nIChYU1MpIHNlY3VyaXR5IGJ1ZyFcbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgYGJ5cGFzc1NlY3VyaXR5VHJ1c3QuLi5gLCBtYWtlIHN1cmUgdG8gY2FsbCB0aGUgbWV0aG9kIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGFuZCBhc1xuICAgICAqIGNsb3NlIGFzIHBvc3NpYmxlIHRvIHRoZSBzb3VyY2Ugb2YgdGhlIHZhbHVlLCB0byBtYWtlIGl0IGVhc3kgdG8gdmVyaWZ5IG5vIHNlY3VyaXR5IGJ1ZyBpc1xuICAgICAqIGNyZWF0ZWQgYnkgaXRzIHVzZS5cbiAgICAgKlxuICAgICAqIEl0IGlzIG5vdCByZXF1aXJlZCAoYW5kIG5vdCByZWNvbW1lbmRlZCkgdG8gYnlwYXNzIHNlY3VyaXR5IGlmIHRoZSB2YWx1ZSBpcyBzYWZlLCBlLmcuIGEgVVJMIHRoYXRcbiAgICAgKiBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3VzcGljaW91cyBwcm90b2NvbCwgb3IgYW4gSFRNTCBzbmlwcGV0IHRoYXQgZG9lcyBub3QgY29udGFpbiBkYW5nZXJvdXNcbiAgICAgKiBjb2RlLiBUaGUgc2FuaXRpemVyIGxlYXZlcyBzYWZlIHZhbHVlcyBpbnRhY3QuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgQ2FsbGluZyBhbnkgb2YgdGhlIGBieXBhc3NTZWN1cml0eVRydXN0Li4uYCBBUElzIGRpc2FibGVzIEFuZ3VsYXIncyBidWlsdC1pblxuICAgICAqIHNhbml0aXphdGlvbiBmb3IgdGhlIHZhbHVlIHBhc3NlZCBpbi4gQ2FyZWZ1bGx5IGNoZWNrIGFuZCBhdWRpdCBhbGwgdmFsdWVzIGFuZCBjb2RlIHBhdGhzIGdvaW5nXG4gICAgICogaW50byB0aGlzIGNhbGwuIE1ha2Ugc3VyZSBhbnkgdXNlciBkYXRhIGlzIGFwcHJvcHJpYXRlbHkgZXNjYXBlZCBmb3IgdGhpcyBzZWN1cml0eSBjb250ZXh0LlxuICAgICAqIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRG9tU2FuaXRpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9tU2FuaXRpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEb21TYW5pdGl6ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgRG9tU2FuaXRpemVySW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ4KERvbVNhbml0aXplckltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbVNhbml0aXplckltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChjdHgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoY3R4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5IVE1MOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlSHRtbEltcGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ0hUTUwnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhbml0aXplSHRtbChTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlNUWUxFOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlU3R5bGVJbXBsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RTYWZlVmFsdWUodmFsdWUsICdTdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FuaXRpemVTdHlsZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TQ1JJUFQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTY3JpcHRJbXBsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RTYWZlVmFsdWUodmFsdWUsICdTY3JpcHQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmUgdmFsdWUgdXNlZCBpbiBhIHNjcmlwdCBjb250ZXh0Jyk7XG4gICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5VUkw6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVSZXNvdXJjZVVybEltcGwgfHwgdmFsdWUgaW5zdGFuY2VvZiBTYWZlVXJsSW1wbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgcmVzb3VyY2UgVVJMcyBpbiBVUkwgY29udGV4dHMsIHRoZXkgYXJlIHN0cmljdGx5IG1vcmUgdHJ1c3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RTYWZlVmFsdWUodmFsdWUsICdVUkwnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNhbml0aXplVXJsKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlUmVzb3VyY2VVcmxJbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm90U2FmZVZhbHVlKHZhbHVlLCAnUmVzb3VyY2VVUkwnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmUgdmFsdWUgdXNlZCBpbiBhIHJlc291cmNlIFVSTCBjb250ZXh0IChzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKScpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VjdXJpdHlDb250ZXh0IFwiICsgY3R4ICsgXCIgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5jaGVja05vdFNhZmVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlVmFsdWVJbXBsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlJlcXVpcmVkIGEgc2FmZSBcIiArIGV4cGVjdGVkVHlwZSArIFwiLCBnb3QgYSBcIiArIHZhbHVlLmdldFR5cGVOYW1lKCkgKyBcIiBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIihzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tU2FuaXRpemVySW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdEh0bWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBTYWZlSHRtbEltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBTYWZlU3R5bGVJbXBsKHZhbHVlKTsgfTtcbiAgICAgICAgRG9tU2FuaXRpemVySW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdFNjcmlwdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVTY3JpcHRJbXBsKHZhbHVlKTsgfTtcbiAgICAgICAgRG9tU2FuaXRpemVySW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdFVybCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVVcmxJbXBsKHZhbHVlKTsgfTtcbiAgICAgICAgRG9tU2FuaXRpemVySW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdFJlc291cmNlVXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNhZmVSZXNvdXJjZVVybEltcGwodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRG9tU2FuaXRpemVySW1wbC5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gRG9tU2FuaXRpemVySW1wbDtcbiAgICB9KERvbVNhbml0aXplcikpO1xuICAgIHZhciBTYWZlVmFsdWVJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2FmZVZhbHVlSW1wbChjaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5KSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHkgPSBjaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgLy8gZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBTYWZlVmFsdWVJbXBsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCJTYWZlVmFsdWUgbXVzdCB1c2UgW3Byb3BlcnR5XT1iaW5kaW5nOiBcIiArIHRoaXMuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eSkgK1xuICAgICAgICAgICAgICAgIFwiIChzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2FmZVZhbHVlSW1wbDtcbiAgICB9KCkpO1xuICAgIHZhciBTYWZlSHRtbEltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChTYWZlSHRtbEltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVIdG1sSW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFNhZmVIdG1sSW1wbC5wcm90b3R5cGUuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnSFRNTCc7IH07XG4gICAgICAgIHJldHVybiBTYWZlSHRtbEltcGw7XG4gICAgfShTYWZlVmFsdWVJbXBsKSk7XG4gICAgdmFyIFNhZmVTdHlsZUltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChTYWZlU3R5bGVJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTYWZlU3R5bGVJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZVN0eWxlSW1wbC5wcm90b3R5cGUuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnU3R5bGUnOyB9O1xuICAgICAgICByZXR1cm4gU2FmZVN0eWxlSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcbiAgICB2YXIgU2FmZVNjcmlwdEltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChTYWZlU2NyaXB0SW1wbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2FmZVNjcmlwdEltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTYWZlU2NyaXB0SW1wbC5wcm90b3R5cGUuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnU2NyaXB0JzsgfTtcbiAgICAgICAgcmV0dXJuIFNhZmVTY3JpcHRJbXBsO1xuICAgIH0oU2FmZVZhbHVlSW1wbCkpO1xuICAgIHZhciBTYWZlVXJsSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ4KFNhZmVVcmxJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTYWZlVXJsSW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFNhZmVVcmxJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdVUkwnOyB9O1xuICAgICAgICByZXR1cm4gU2FmZVVybEltcGw7XG4gICAgfShTYWZlVmFsdWVJbXBsKSk7XG4gICAgdmFyIFNhZmVSZXNvdXJjZVVybEltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChTYWZlUmVzb3VyY2VVcmxJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTYWZlUmVzb3VyY2VVcmxJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZVJlc291cmNlVXJsSW1wbC5wcm90b3R5cGUuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnUmVzb3VyY2VVUkwnOyB9O1xuICAgICAgICByZXR1cm4gU2FmZVJlc291cmNlVXJsSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcblxuICAgIHZhciBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyA9IFtcbiAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBMQVRGT1JNX0lOSVRJQUxJWkVSLCB1c2VWYWx1ZTogaW5pdERvbUFkYXB0ZXIsIG11bHRpOiB0cnVlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29tbW9uLlBsYXRmb3JtTG9jYXRpb24sIHVzZUNsYXNzOiBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbiB9XG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBAc2VjdXJpdHkgUmVwbGFjaW5nIGJ1aWx0LWluIHNhbml0aXphdGlvbiBwcm92aWRlcnMgZXhwb3NlcyB0aGUgYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLlxuICAgICAqIEF0dGFja2VyLWNvbnRyb2xsZWQgZGF0YSBpbnRyb2R1Y2VkIGJ5IGFuIHVuc2FuaXRpemVkIHByb3ZpZGVyIGNvdWxkIGV4cG9zZSB5b3VyXG4gICAgICogYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLiBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBCUk9XU0VSX1NBTklUSVpBVElPTl9QUk9WSURFUlMgPSBbXG4gICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5TYW5pdGl6ZXIsIHVzZUV4aXN0aW5nOiBEb21TYW5pdGl6ZXIgfSxcbiAgICAgICAgeyBwcm92aWRlOiBEb21TYW5pdGl6ZXIsIHVzZUNsYXNzOiBEb21TYW5pdGl6ZXJJbXBsIH0sXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIHBsYXRmb3JtQnJvd3NlciA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvcmUucGxhdGZvcm1Db3JlLCAnYnJvd3NlcicsIElOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTKTtcbiAgICBmdW5jdGlvbiBpbml0RG9tQWRhcHRlcigpIHtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIubWFrZUN1cnJlbnQoKTtcbiAgICAgICAgQnJvd3NlckdldFRlc3RhYmlsaXR5LmluaXQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2NvcmUuRXJyb3JIYW5kbGVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIGdldERPTSgpLmRlZmF1bHREb2MoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Jlc29sdmVEZWZhdWx0QW5pbWF0aW9uRHJpdmVyKCkge1xuICAgICAgICBpZiAoZ2V0RE9NKCkuc3VwcG9ydHNXZWJBbmltYXRpb24oKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBbmltYXRpb25zRHJpdmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkRyaXZlci5OT09QO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmcgbW9kdWxlIGZvciB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQnJvd3Nlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJyb3dzZXJNb2R1bGUocGFyZW50TW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50TW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnJvd3Nlck1vZHVsZSBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC4gSWYgeW91IG5lZWQgYWNjZXNzIHRvIGNvbW1vbiBkaXJlY3RpdmVzIHN1Y2ggYXMgTmdJZiBhbmQgTmdGb3IgZnJvbSBhIGxhenkgbG9hZGVkIG1vZHVsZSwgaW1wb3J0IENvbW1vbk1vZHVsZSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBCcm93c2VyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCUk9XU0VSX1NBTklUSVpBVElPTl9QUk9WSURFUlMsIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5FcnJvckhhbmRsZXIsIHVzZUZhY3Rvcnk6IGVycm9ySGFuZGxlciwgZGVwczogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IERPQ1VNRU5ULCB1c2VGYWN0b3J5OiBfZG9jdW1lbnQsIGRlcHM6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBFVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHVzZUNsYXNzOiBEb21FdmVudHNQbHVnaW4sIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBFVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHVzZUNsYXNzOiBLZXlFdmVudHNQbHVnaW4sIG11bHRpOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBFVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHVzZUNsYXNzOiBIYW1tZXJHZXN0dXJlc1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IEhhbW1lckdlc3R1cmVDb25maWcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IERvbVJvb3RSZW5kZXJlciwgdXNlQ2xhc3M6IERvbVJvb3RSZW5kZXJlcl8gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUm9vdFJlbmRlcmVyLCB1c2VFeGlzdGluZzogRG9tUm9vdFJlbmRlcmVyIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBTaGFyZWRTdHlsZXNIb3N0LCB1c2VFeGlzdGluZzogRG9tU2hhcmVkU3R5bGVzSG9zdCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogQW5pbWF0aW9uRHJpdmVyLCB1c2VGYWN0b3J5OiBfcmVzb2x2ZURlZmF1bHRBbmltYXRpb25Ecml2ZXIgfSwgRG9tU2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLlRlc3RhYmlsaXR5LCBFdmVudE1hbmFnZXIsIEVMRU1FTlRfUFJPQkVfUFJPVklERVJTLCBUaXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBfYW5ndWxhcl9jb3JlLkFwcGxpY2F0aW9uTW9kdWxlXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEJyb3dzZXJNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEJyb3dzZXJNb2R1bGUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQnJvd3Nlck1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEpTIHZlcnNpb24gb2YgYnJvd3NlciBBUElzLiBUaGlzIGxpYnJhcnkgY2FuIG9ubHkgcnVuIGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIHZhciB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgfHwge307XG5cbiAgICB2YXIgQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdGlvblBlcmZSZWNvcmQobXNQZXJUaWNrLCBudW1UaWNrcykge1xuICAgICAgICAgICAgdGhpcy5tc1BlclRpY2sgPSBtc1BlclRpY2s7XG4gICAgICAgICAgICB0aGlzLm51bVRpY2tzID0gbnVtVGlja3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENoYW5nZURldGVjdGlvblBlcmZSZWNvcmQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgYWxsIEFuZ3VsYXIgZGVidWcgdG9vbHMuIFRoaXMgb2JqZWN0IGNvcnJlc3BvbmRzIHRvIHRoZSBgbmdgXG4gICAgICogZ2xvYmFsIHZhcmlhYmxlIGFjY2Vzc2libGUgaW4gdGhlIGRldiBjb25zb2xlLlxuICAgICAqL1xuICAgIHZhciBBbmd1bGFyVG9vbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmd1bGFyVG9vbHMocmVmKSB7XG4gICAgICAgICAgICB0aGlzLnByb2ZpbGVyID0gbmV3IEFuZ3VsYXJQcm9maWxlcihyZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmd1bGFyVG9vbHM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgYWxsIEFuZ3VsYXIgcHJvZmlsaW5nLXJlbGF0ZWQgZGVidWcgdG9vbHMuIFRoaXMgb2JqZWN0XG4gICAgICogY29ycmVzcG9uZHMgdG8gdGhlIGBuZy5wcm9maWxlcmAgaW4gdGhlIGRldiBjb25zb2xlLlxuICAgICAqL1xuICAgIHZhciBBbmd1bGFyUHJvZmlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmd1bGFyUHJvZmlsZXIocmVmKSB7XG4gICAgICAgICAgICB0aGlzLmFwcFJlZiA9IHJlZi5pbmplY3Rvci5nZXQoX2FuZ3VsYXJfY29yZS5BcHBsaWNhdGlvblJlZik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZXJjaXNlcyBjaGFuZ2UgZGV0ZWN0aW9uIGluIGEgbG9vcCBhbmQgdGhlbiBwcmludHMgdGhlIGF2ZXJhZ2UgYW1vdW50IG9mXG4gICAgICAgICAqIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGhvdyBsb25nIGEgc2luZ2xlIHJvdW5kIG9mIGNoYW5nZSBkZXRlY3Rpb24gdGFrZXMgZm9yXG4gICAgICAgICAqIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBVSS4gSXQgcnVucyBhIG1pbmltdW0gb2YgNSByb3VuZHMgZm9yIGEgbWluaW11bVxuICAgICAgICAgKiBvZiA1MDAgbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPcHRpb25hbGx5LCBhIHVzZXIgbWF5IHBhc3MgYSBgY29uZmlnYCBwYXJhbWV0ZXIgY29udGFpbmluZyBhIG1hcCBvZlxuICAgICAgICAgKiBvcHRpb25zLiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gICAgICAgICAqXG4gICAgICAgICAqIGByZWNvcmRgIChib29sZWFuKSAtIGNhdXNlcyB0aGUgcHJvZmlsZXIgdG8gcmVjb3JkIGEgQ1BVIHByb2ZpbGUgd2hpbGVcbiAgICAgICAgICogaXQgZXhlcmNpc2VzIHRoZSBjaGFuZ2UgZGV0ZWN0b3IuIEV4YW1wbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBuZy5wcm9maWxlci50aW1lQ2hhbmdlRGV0ZWN0aW9uKHtyZWNvcmQ6IHRydWV9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEFuZ3VsYXJQcm9maWxlci5wcm90b3R5cGUudGltZUNoYW5nZURldGVjdGlvbiA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBjb25maWcgJiYgY29uZmlnWydyZWNvcmQnXTtcbiAgICAgICAgICAgIHZhciBwcm9maWxlTmFtZSA9ICdDaGFuZ2UgRGV0ZWN0aW9uJztcbiAgICAgICAgICAgIC8vIFByb2ZpbGVyIGlzIG5vdCBhdmFpbGFibGUgaW4gQW5kcm9pZCBicm93c2Vycywgbm9yIGluIElFIDkgd2l0aG91dCBkZXYgdG9vbHMgb3BlbmVkXG4gICAgICAgICAgICB2YXIgaXNQcm9maWxlckF2YWlsYWJsZSA9IGlzUHJlc2VudCh3aW4uY29uc29sZS5wcm9maWxlKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQgJiYgaXNQcm9maWxlckF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHdpbi5jb25zb2xlLnByb2ZpbGUocHJvZmlsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0RE9NKCkucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgIHZhciBudW1UaWNrcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAobnVtVGlja3MgPCA1IHx8IChnZXRET00oKS5wZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQpIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBSZWYudGljaygpO1xuICAgICAgICAgICAgICAgIG51bVRpY2tzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5kID0gZ2V0RE9NKCkucGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQgJiYgaXNQcm9maWxlckF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2FzdCB0byA8YW55PiBiZWNhdXNlIHR5cGUgY2hlY2tlciB0aGlua3MgdGhlcmUncyBubyBhcmd1bWVudFxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIGluIGZhY3QgdGhlcmUgaXM6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ29uc29sZS9wcm9maWxlRW5kXG4gICAgICAgICAgICAgICAgd2luLmNvbnNvbGUucHJvZmlsZUVuZChwcm9maWxlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbXNQZXJUaWNrID0gKGVuZCAtIHN0YXJ0KSAvIG51bVRpY2tzO1xuICAgICAgICAgICAgd2luLmNvbnNvbGUubG9nKFwicmFuIFwiICsgbnVtVGlja3MgKyBcIiBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlc1wiKTtcbiAgICAgICAgICAgIHdpbi5jb25zb2xlLmxvZyhtc1BlclRpY2sudG9GaXhlZCgyKSArIFwiIG1zIHBlciBjaGVja1wiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZChtc1BlclRpY2ssIG51bVRpY2tzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJQcm9maWxlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGNvbnRleHQgPSBnbG9iYWwkMTtcbiAgICAvKipcbiAgICAgKiBFbmFibGVkIEFuZ3VsYXIgMiBkZWJ1ZyB0b29scyB0aGF0IGFyZSBhY2Nlc3NpYmxlIHZpYSB5b3VyIGJyb3dzZXInc1xuICAgICAqIGRldmVsb3BlciBjb25zb2xlLlxuICAgICAqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiAxLiBPcGVuIGRldmVsb3BlciBjb25zb2xlIChlLmcuIGluIENocm9tZSBDdHJsICsgU2hpZnQgKyBqKVxuICAgICAqIDEuIFR5cGUgYG5nLmAgKHVzdWFsbHkgdGhlIGNvbnNvbGUgd2lsbCBzaG93IGF1dG8tY29tcGxldGUgc3VnZ2VzdGlvbilcbiAgICAgKiAxLiBUcnkgdGhlIGNoYW5nZSBkZXRlY3Rpb24gcHJvZmlsZXIgYG5nLnByb2ZpbGVyLnRpbWVDaGFuZ2VEZXRlY3Rpb24oKWBcbiAgICAgKiAgICB0aGVuIGhpdCBFbnRlci5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQWxsIGRlYnVnZ2luZyBhcGlzIGFyZSBjdXJyZW50bHkgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuYWJsZURlYnVnVG9vbHMocmVmKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5uZywgbmV3IEFuZ3VsYXJUb29scyhyZWYpKTtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgQW5ndWxhciAyIHRvb2xzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzYWJsZURlYnVnVG9vbHMoKSB7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0Lm5nLnByb2ZpbGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZWRpY2F0ZXMgZm9yIHVzZSB3aXRoIHtAbGluayBEZWJ1Z0VsZW1lbnR9J3MgcXVlcnkgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGNoIGFsbCBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiB7QGV4YW1wbGUgcGxhdGZvcm0tYnJvd3Nlci9kb20vZGVidWcvdHMvYnkvYnkudHMgcmVnaW9uPSdieV9hbGwnfVxuICAgICAgICAgKi9cbiAgICAgICAgQnkuYWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGNoIGVsZW1lbnRzIGJ5IHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICoge0BleGFtcGxlIHBsYXRmb3JtLWJyb3dzZXIvZG9tL2RlYnVnL3RzL2J5L2J5LnRzIHJlZ2lvbj0nYnlfY3NzJ31cbiAgICAgICAgICovXG4gICAgICAgIEJ5LmNzcyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmVsZW1lbnRNYXRjaGVzKGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50LCBzZWxlY3RvcikgOlxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXRjaCBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIGRpcmVjdGl2ZSBwcmVzZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHtAZXhhbXBsZSBwbGF0Zm9ybS1icm93c2VyL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2RpcmVjdGl2ZSd9XG4gICAgICAgICAqL1xuICAgICAgICBCeS5kaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHsgcmV0dXJuIGRlYnVnRWxlbWVudC5wcm92aWRlclRva2Vucy5pbmRleE9mKHR5cGUpICE9PSAtMTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJ5O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXyA9IHtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb246IEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLFxuICAgICAgICBEb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlcjogQnJvd3NlckRvbUFkYXB0ZXIsXG4gICAgICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eTogQnJvd3NlckdldFRlc3RhYmlsaXR5LFxuICAgICAgICBnZXRET006IGdldERPTSxcbiAgICAgICAgc2V0Um9vdERvbUFkYXB0ZXI6IHNldFJvb3REb21BZGFwdGVyLFxuICAgICAgICBEb21Sb290UmVuZGVyZXJfOiBEb21Sb290UmVuZGVyZXJfLFxuICAgICAgICBEb21Sb290UmVuZGVyZXI6IERvbVJvb3RSZW5kZXJlcixcbiAgICAgICAgTkFNRVNQQUNFX1VSSVM6IE5BTUVTUEFDRV9VUklTLFxuICAgICAgICBzaGltQ29udGVudEF0dHJpYnV0ZTogc2hpbUNvbnRlbnRBdHRyaWJ1dGUsXG4gICAgICAgIHNoaW1Ib3N0QXR0cmlidXRlOiBzaGltSG9zdEF0dHJpYnV0ZSxcbiAgICAgICAgZmxhdHRlblN0eWxlczogZmxhdHRlblN0eWxlcyxcbiAgICAgICAgc3BsaXROYW1lc3BhY2U6IHNwbGl0TmFtZXNwYWNlLFxuICAgICAgICBpc05hbWVzcGFjZWQ6IGlzTmFtZXNwYWNlZCxcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdDogRG9tU2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdDogU2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgRUxFTUVOVF9QUk9CRV9QUk9WSURFUlM6IEVMRU1FTlRfUFJPQkVfUFJPVklERVJTLFxuICAgICAgICBEb21FdmVudHNQbHVnaW46IERvbUV2ZW50c1BsdWdpbixcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luOiBLZXlFdmVudHNQbHVnaW4sXG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luOiBIYW1tZXJHZXN0dXJlc1BsdWdpbixcbiAgICAgICAgaW5pdERvbUFkYXB0ZXI6IGluaXREb21BZGFwdGVyLFxuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUzogSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMsXG4gICAgICAgIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUzogQlJPV1NFUl9TQU5JVElaQVRJT05fUFJPVklERVJTLFxuICAgICAgICBXZWJBbmltYXRpb25zRHJpdmVyOiBXZWJBbmltYXRpb25zRHJpdmVyXG4gICAgfTtcblxuICAgIGV4cG9ydHMuQnJvd3Nlck1vZHVsZSA9IEJyb3dzZXJNb2R1bGU7XG4gICAgZXhwb3J0cy5wbGF0Zm9ybUJyb3dzZXIgPSBwbGF0Zm9ybUJyb3dzZXI7XG4gICAgZXhwb3J0cy5UaXRsZSA9IFRpdGxlO1xuICAgIGV4cG9ydHMuZGlzYWJsZURlYnVnVG9vbHMgPSBkaXNhYmxlRGVidWdUb29scztcbiAgICBleHBvcnRzLmVuYWJsZURlYnVnVG9vbHMgPSBlbmFibGVEZWJ1Z1Rvb2xzO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uRHJpdmVyID0gQW5pbWF0aW9uRHJpdmVyO1xuICAgIGV4cG9ydHMuQnkgPSBCeTtcbiAgICBleHBvcnRzLk5nUHJvYmVUb2tlbiA9IE5nUHJvYmVUb2tlbjtcbiAgICBleHBvcnRzLkRPQ1VNRU5UID0gRE9DVU1FTlQ7XG4gICAgZXhwb3J0cy5FVkVOVF9NQU5BR0VSX1BMVUdJTlMgPSBFVkVOVF9NQU5BR0VSX1BMVUdJTlM7XG4gICAgZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXI7XG4gICAgZXhwb3J0cy5IQU1NRVJfR0VTVFVSRV9DT05GSUcgPSBIQU1NRVJfR0VTVFVSRV9DT05GSUc7XG4gICAgZXhwb3J0cy5IYW1tZXJHZXN0dXJlQ29uZmlnID0gSGFtbWVyR2VzdHVyZUNvbmZpZztcbiAgICBleHBvcnRzLkRvbVNhbml0aXplciA9IERvbVNhbml0aXplcjtcbiAgICBleHBvcnRzLl9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18gPSBfX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnVuZGxlcy9wbGF0Zm9ybS1icm93c2VyLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.2.0\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(2)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));\n}(this, function (exports,_angular_core) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * This class should not be used directly by an application developer. Instead, use\n     * {@link Location}.\n     *\n     * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform\n     * agnostic.\n     * This means that we can have different implementation of `PlatformLocation` for the different\n     * platforms\n     * that angular supports. For example, the default `PlatformLocation` is {@link\n     * BrowserPlatformLocation},\n     * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.\n     *\n     * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}\n     * when\n     * they need to interact with the DOM apis like pushState, popState, etc...\n     *\n     * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly\n     * by\n     * the {@link Router} in order to navigate between routes. Since all interactions between {@link\n     * Router} /\n     * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`\n     * class\n     * they are all platform independent.\n     *\n     * @stable\n     */\n    var PlatformLocation = (function () {\n        function PlatformLocation() {\n        }\n        Object.defineProperty(PlatformLocation.prototype, \"pathname\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PlatformLocation.prototype, \"search\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PlatformLocation.prototype, \"hash\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        return PlatformLocation;\n    }());\n\n    /**\n     * `LocationStrategy` is responsible for representing and reading route state\n     * from the browser's URL. Angular provides two strategies:\n     * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).\n     *\n     * This is used under the hood of the {@link Location} service.\n     *\n     * Applications should use the {@link Router} or {@link Location} services to\n     * interact with application route state.\n     *\n     * For instance, {@link HashLocationStrategy} produces URLs like\n     * `http://example.com#/foo`, and {@link PathLocationStrategy} produces\n     * `http://example.com/foo` as an equivalent URL.\n     *\n     * See these two classes for more.\n     *\n     * @stable\n     */\n    var LocationStrategy = (function () {\n        function LocationStrategy() {\n        }\n        return LocationStrategy;\n    }());\n    /**\n     * The `APP_BASE_HREF` token represents the base href to be used with the\n     * {@link PathLocationStrategy}.\n     *\n     * If you're using {@link PathLocationStrategy}, you must provide a provider to a string\n     * representing the URL prefix that should be preserved when generating and recognizing\n     * URLs.\n     *\n     * ### Example\n     *\n     * ```typescript\n     * import {Component, NgModule} from '@angular/core';\n     * import {APP_BASE_HREF} from '@angular/common';\n     *\n     * @NgModule({\n     *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]\n     * })\n     * class AppModule {}\n     * ```\n     *\n     * @stable\n     */\n    var APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var _global = globalScope;\n    function getTypeNameForDebugging(type) {\n        return type['name'] || typeof type;\n    }\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    _global.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj != null;\n    }\n    function isBlank(obj) {\n        return obj == null;\n    }\n    function isDate(obj) {\n        return obj instanceof Date && !isNaN(obj.valueOf());\n    }\n    function stringify(token) {\n        if (typeof token === 'string') {\n            return token;\n        }\n        if (token == null) {\n            return '' + token;\n        }\n        if (token.overriddenName) {\n            return token.overriddenName;\n        }\n        if (token.name) {\n            return token.name;\n        }\n        var res = token.toString();\n        var newLineIndex = res.indexOf('\\n');\n        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n    }\n    var NumberWrapper = (function () {\n        function NumberWrapper() {\n        }\n        NumberWrapper.parseIntAutoRadix = function (text) {\n            var result = parseInt(text);\n            if (isNaN(result)) {\n                throw new Error('Invalid integer literal when parsing ' + text);\n            }\n            return result;\n        };\n        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n        return NumberWrapper;\n    }());\n    function isJsObject(o) {\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\n    }\n    var _symbolIterator = null;\n    function getSymbolIterator() {\n        if (!_symbolIterator) {\n            if (globalScope.Symbol && Symbol.iterator) {\n                _symbolIterator = Symbol.iterator;\n            }\n            else {\n                // es6-shim specific logic\n                var keys = Object.getOwnPropertyNames(Map.prototype);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (key !== 'entries' && key !== 'size' &&\n                        Map.prototype[key] === Map.prototype['entries']) {\n                        _symbolIterator = key;\n                    }\n                }\n            }\n        }\n        return _symbolIterator;\n    }\n\n    /**\n     * `Location` is a service that applications can use to interact with a browser's URL.\n     * Depending on which {@link LocationStrategy} is used, `Location` will either persist\n     * to the URL's path or the URL's hash segment.\n     *\n     * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use\n     * `Location` only if you need to interact with or create normalized URLs outside of\n     * routing.\n     *\n     * `Location` is responsible for normalizing the URL against the application's base href.\n     * A normalized URL is absolute from the URL host, includes the application's base href, and has no\n     * trailing slash:\n     * - `/my/app/user/123` is normalized\n     * - `my/app/user/123` **is not** normalized\n     * - `/my/app/user/123/` **is not** normalized\n     *\n     * ### Example\n     *\n     * ```\n     * import {Component} from '@angular/core';\n     * import {Location} from '@angular/common';\n     *\n     * @Component({selector: 'app-component'})\n     * class AppCmp {\n     *   constructor(location: Location) {\n     *     location.go('/foo');\n     *   }\n     * }\n     * ```\n     *\n     * @stable\n     */\n    var Location = (function () {\n        function Location(platformStrategy) {\n            var _this = this;\n            /** @internal */\n            this._subject = new _angular_core.EventEmitter();\n            this._platformStrategy = platformStrategy;\n            var browserBaseHref = this._platformStrategy.getBaseHref();\n            this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));\n            this._platformStrategy.onPopState(function (ev) {\n                _this._subject.emit({\n                    'url': _this.path(true),\n                    'pop': true,\n                    'type': ev.type,\n                });\n            });\n        }\n        /**\n         * Returns the normalized URL path.\n         */\n        // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is\n        // removed.\n        Location.prototype.path = function (includeHash) {\n            if (includeHash === void 0) { includeHash = false; }\n            return this.normalize(this._platformStrategy.path(includeHash));\n        };\n        /**\n         * Normalizes the given path and compares to the current normalized path.\n         */\n        Location.prototype.isCurrentPathEqualTo = function (path, query) {\n            if (query === void 0) { query = ''; }\n            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));\n        };\n        /**\n         * Given a string representing a URL, returns the normalized URL path without leading or\n         * trailing slashes.\n         */\n        Location.prototype.normalize = function (url) {\n            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));\n        };\n        /**\n         * Given a string representing a URL, returns the platform-specific external URL path.\n         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one\n         * before normalizing. This method will also add a hash if `HashLocationStrategy` is\n         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.\n         */\n        Location.prototype.prepareExternalUrl = function (url) {\n            if (url.length > 0 && !url.startsWith('/')) {\n                url = '/' + url;\n            }\n            return this._platformStrategy.prepareExternalUrl(url);\n        };\n        // TODO: rename this method to pushState\n        /**\n         * Changes the browsers URL to the normalized version of the given URL, and pushes a\n         * new item onto the platform's history.\n         */\n        Location.prototype.go = function (path, query) {\n            if (query === void 0) { query = ''; }\n            this._platformStrategy.pushState(null, '', path, query);\n        };\n        /**\n         * Changes the browsers URL to the normalized version of the given URL, and replaces\n         * the top item on the platform's history stack.\n         */\n        Location.prototype.replaceState = function (path, query) {\n            if (query === void 0) { query = ''; }\n            this._platformStrategy.replaceState(null, '', path, query);\n        };\n        /**\n         * Navigates forward in the platform's history.\n         */\n        Location.prototype.forward = function () { this._platformStrategy.forward(); };\n        /**\n         * Navigates back in the platform's history.\n         */\n        Location.prototype.back = function () { this._platformStrategy.back(); };\n        /**\n         * Subscribe to the platform's `popState` events.\n         */\n        Location.prototype.subscribe = function (onNext, onThrow, onReturn) {\n            if (onThrow === void 0) { onThrow = null; }\n            if (onReturn === void 0) { onReturn = null; }\n            return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });\n        };\n        /**\n         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as\n         * is.\n         */\n        Location.normalizeQueryParams = function (params) {\n            return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;\n        };\n        /**\n         * Given 2 parts of a url, join them with a slash if needed.\n         */\n        Location.joinWithSlash = function (start, end) {\n            if (start.length == 0) {\n                return end;\n            }\n            if (end.length == 0) {\n                return start;\n            }\n            var slashes = 0;\n            if (start.endsWith('/')) {\n                slashes++;\n            }\n            if (end.startsWith('/')) {\n                slashes++;\n            }\n            if (slashes == 2) {\n                return start + end.substring(1);\n            }\n            if (slashes == 1) {\n                return start + end;\n            }\n            return start + '/' + end;\n        };\n        /**\n         * If url has a trailing slash, remove it, otherwise return url as is.\n         */\n        Location.stripTrailingSlash = function (url) {\n            if (/\\/$/g.test(url)) {\n                url = url.substring(0, url.length - 1);\n            }\n            return url;\n        };\n        Location.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        Location.ctorParameters = [\n            { type: LocationStrategy, },\n        ];\n        return Location;\n    }());\n    function _stripBaseHref(baseHref, url) {\n        if (baseHref.length > 0 && url.startsWith(baseHref)) {\n            return url.substring(baseHref.length);\n        }\n        return url;\n    }\n    function _stripIndexHtml(url) {\n        if (/\\/index.html$/g.test(url)) {\n            // '/index.html'.length == 11\n            return url.substring(0, url.length - 11);\n        }\n        return url;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the\n     * {@link Location} service to represent its state in the\n     * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)\n     * of the browser's URL.\n     *\n     * For instance, if you call `location.go('/foo')`, the browser's URL will become\n     * `example.com#/foo`.\n     *\n     * ### Example\n     *\n     * ```\n     * import {Component, NgModule} from '@angular/core';\n     * import {\n     *   LocationStrategy,\n     *   HashLocationStrategy\n     * } from '@angular/common';\n     *\n     * @NgModule({\n     *   providers: [{provide: LocationStrategy, useClass: HashLocationStrategy}]\n     * })\n     * class AppModule {}\n     * ```\n     *\n     * @stable\n     */\n    var HashLocationStrategy = (function (_super) {\n        __extends(HashLocationStrategy, _super);\n        function HashLocationStrategy(_platformLocation, _baseHref) {\n            _super.call(this);\n            this._platformLocation = _platformLocation;\n            this._baseHref = '';\n            if (isPresent(_baseHref)) {\n                this._baseHref = _baseHref;\n            }\n        }\n        HashLocationStrategy.prototype.onPopState = function (fn) {\n            this._platformLocation.onPopState(fn);\n            this._platformLocation.onHashChange(fn);\n        };\n        HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };\n        HashLocationStrategy.prototype.path = function (includeHash) {\n            if (includeHash === void 0) { includeHash = false; }\n            // the hash value is always prefixed with a `#`\n            // and if it is empty then it will stay empty\n            var path = this._platformLocation.hash;\n            if (!isPresent(path))\n                path = '#';\n            return path.length > 0 ? path.substring(1) : path;\n        };\n        HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {\n            var url = Location.joinWithSlash(this._baseHref, internal);\n            return url.length > 0 ? ('#' + url) : url;\n        };\n        HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {\n            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));\n            if (url.length == 0) {\n                url = this._platformLocation.pathname;\n            }\n            this._platformLocation.pushState(state, title, url);\n        };\n        HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {\n            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));\n            if (url.length == 0) {\n                url = this._platformLocation.pathname;\n            }\n            this._platformLocation.replaceState(state, title, url);\n        };\n        HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };\n        HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };\n        HashLocationStrategy.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        HashLocationStrategy.ctorParameters = [\n            { type: PlatformLocation, },\n            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },\n        ];\n        return HashLocationStrategy;\n    }(LocationStrategy));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the\n     * {@link Location} service to represent its state in the\n     * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the\n     * browser's URL.\n     *\n     * `PathLocationStrategy` is the default binding for {@link LocationStrategy}\n     * provided in {@link ROUTER_PROVIDERS}.\n     *\n     * If you're using `PathLocationStrategy`, you must provide a {@link APP_BASE_HREF}\n     * or add a base element to the document. This URL prefix that will be preserved\n     * when generating and recognizing URLs.\n     *\n     * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call\n     * `location.go('/foo')`, the browser's URL will become\n     * `example.com/my/app/foo`.\n     *\n     * Similarly, if you add `<base href='/my/app'/>` to the document and call\n     * `location.go('/foo')`, the browser's URL will become\n     * `example.com/my/app/foo`.\n     *\n     * @stable\n     */\n    var PathLocationStrategy = (function (_super) {\n        __extends$1(PathLocationStrategy, _super);\n        function PathLocationStrategy(_platformLocation, href) {\n            _super.call(this);\n            this._platformLocation = _platformLocation;\n            if (isBlank(href)) {\n                href = this._platformLocation.getBaseHrefFromDOM();\n            }\n            if (isBlank(href)) {\n                throw new Error(\"No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.\");\n            }\n            this._baseHref = href;\n        }\n        PathLocationStrategy.prototype.onPopState = function (fn) {\n            this._platformLocation.onPopState(fn);\n            this._platformLocation.onHashChange(fn);\n        };\n        PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };\n        PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {\n            return Location.joinWithSlash(this._baseHref, internal);\n        };\n        PathLocationStrategy.prototype.path = function (includeHash) {\n            if (includeHash === void 0) { includeHash = false; }\n            var pathname = this._platformLocation.pathname +\n                Location.normalizeQueryParams(this._platformLocation.search);\n            var hash = this._platformLocation.hash;\n            return hash && includeHash ? \"\" + pathname + hash : pathname;\n        };\n        PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {\n            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));\n            this._platformLocation.pushState(state, title, externalUrl);\n        };\n        PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {\n            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));\n            this._platformLocation.replaceState(state, title, externalUrl);\n        };\n        PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };\n        PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };\n        PathLocationStrategy.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        PathLocationStrategy.ctorParameters = [\n            { type: PlatformLocation, },\n            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },\n        ];\n        return PathLocationStrategy;\n    }(LocationStrategy));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @experimental\n     */\n    var NgLocalization = (function () {\n        function NgLocalization() {\n        }\n        return NgLocalization;\n    }());\n    /**\n     * Returns the plural category for a given value.\n     * - \"=value\" when the case exists,\n     * - the plural category otherwise\n     *\n     * @internal\n     */\n    function getPluralCategory(value, cases, ngLocalization) {\n        var nbCase = \"=\" + value;\n        return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);\n    }\n    /**\n     * Returns the plural case based on the locale\n     *\n     * @experimental\n     */\n    var NgLocaleLocalization = (function (_super) {\n        __extends$2(NgLocaleLocalization, _super);\n        function NgLocaleLocalization(_locale) {\n            _super.call(this);\n            this._locale = _locale;\n        }\n        NgLocaleLocalization.prototype.getPluralCategory = function (value) {\n            var plural = getPluralCase(this._locale, value);\n            switch (plural) {\n                case Plural.Zero:\n                    return 'zero';\n                case Plural.One:\n                    return 'one';\n                case Plural.Two:\n                    return 'two';\n                case Plural.Few:\n                    return 'few';\n                case Plural.Many:\n                    return 'many';\n                default:\n                    return 'other';\n            }\n        };\n        NgLocaleLocalization.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgLocaleLocalization.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return NgLocaleLocalization;\n    }(NgLocalization));\n    // This is generated code DO NOT MODIFY\n    // see angular2/script/cldr/gen_plural_rules.js\n    /** @experimental */\n    var Plural;\n    (function (Plural) {\n        Plural[Plural[\"Zero\"] = 0] = \"Zero\";\n        Plural[Plural[\"One\"] = 1] = \"One\";\n        Plural[Plural[\"Two\"] = 2] = \"Two\";\n        Plural[Plural[\"Few\"] = 3] = \"Few\";\n        Plural[Plural[\"Many\"] = 4] = \"Many\";\n        Plural[Plural[\"Other\"] = 5] = \"Other\";\n    })(Plural || (Plural = {}));\n    /**\n     * Returns the plural case based on the locale\n     *\n     * @experimental\n     */\n    function getPluralCase(locale, nLike) {\n        // TODO(vicb): lazy compute\n        if (typeof nLike === 'string') {\n            nLike = parseInt(nLike, 10);\n        }\n        var n = nLike;\n        var nDecimal = n.toString().replace(/^[^.]*\\.?/, '');\n        var i = Math.floor(Math.abs(n));\n        var v = nDecimal.length;\n        var f = parseInt(nDecimal, 10);\n        var t = parseInt(n.toString().replace(/^[^.]*\\.?|0+$/g, ''), 10) || 0;\n        var lang = locale.split('-')[0].toLowerCase();\n        switch (lang) {\n            case 'af':\n            case 'asa':\n            case 'az':\n            case 'bem':\n            case 'bez':\n            case 'bg':\n            case 'brx':\n            case 'ce':\n            case 'cgg':\n            case 'chr':\n            case 'ckb':\n            case 'ee':\n            case 'el':\n            case 'eo':\n            case 'es':\n            case 'eu':\n            case 'fo':\n            case 'fur':\n            case 'gsw':\n            case 'ha':\n            case 'haw':\n            case 'hu':\n            case 'jgo':\n            case 'jmc':\n            case 'ka':\n            case 'kk':\n            case 'kkj':\n            case 'kl':\n            case 'ks':\n            case 'ksb':\n            case 'ky':\n            case 'lb':\n            case 'lg':\n            case 'mas':\n            case 'mgo':\n            case 'ml':\n            case 'mn':\n            case 'nb':\n            case 'nd':\n            case 'ne':\n            case 'nn':\n            case 'nnh':\n            case 'nyn':\n            case 'om':\n            case 'or':\n            case 'os':\n            case 'ps':\n            case 'rm':\n            case 'rof':\n            case 'rwk':\n            case 'saq':\n            case 'seh':\n            case 'sn':\n            case 'so':\n            case 'sq':\n            case 'ta':\n            case 'te':\n            case 'teo':\n            case 'tk':\n            case 'tr':\n            case 'ug':\n            case 'uz':\n            case 'vo':\n            case 'vun':\n            case 'wae':\n            case 'xog':\n                if (n === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'agq':\n            case 'bas':\n            case 'cu':\n            case 'dav':\n            case 'dje':\n            case 'dua':\n            case 'dyo':\n            case 'ebu':\n            case 'ewo':\n            case 'guz':\n            case 'kam':\n            case 'khq':\n            case 'ki':\n            case 'kln':\n            case 'kok':\n            case 'ksf':\n            case 'lrc':\n            case 'lu':\n            case 'luo':\n            case 'luy':\n            case 'mer':\n            case 'mfe':\n            case 'mgh':\n            case 'mua':\n            case 'mzn':\n            case 'nmg':\n            case 'nus':\n            case 'qu':\n            case 'rn':\n            case 'rw':\n            case 'sbp':\n            case 'twq':\n            case 'vai':\n            case 'yav':\n            case 'yue':\n            case 'zgh':\n            case 'ak':\n            case 'ln':\n            case 'mg':\n            case 'pa':\n            case 'ti':\n                if (n === Math.floor(n) && n >= 0 && n <= 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'am':\n            case 'as':\n            case 'bn':\n            case 'fa':\n            case 'gu':\n            case 'hi':\n            case 'kn':\n            case 'mr':\n            case 'zu':\n                if (i === 0 || n === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'ar':\n                if (n === 0)\n                    return Plural.Zero;\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)\n                    return Plural.Few;\n                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'ast':\n            case 'ca':\n            case 'de':\n            case 'en':\n            case 'et':\n            case 'fi':\n            case 'fy':\n            case 'gl':\n            case 'it':\n            case 'nl':\n            case 'sv':\n            case 'sw':\n            case 'ur':\n            case 'yi':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                return Plural.Other;\n            case 'be':\n                if (n % 10 === 1 && !(n % 100 === 11))\n                    return Plural.One;\n                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&\n                    !(n % 100 >= 12 && n % 100 <= 14))\n                    return Plural.Few;\n                if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||\n                    n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'br':\n                if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))\n                    return Plural.One;\n                if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))\n                    return Plural.Two;\n                if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&\n                    !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||\n                        n % 100 >= 90 && n % 100 <= 99))\n                    return Plural.Few;\n                if (!(n === 0) && n % 1e6 === 0)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'bs':\n            case 'hr':\n            case 'sr':\n                if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))\n                    return Plural.One;\n                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n                    !(i % 100 >= 12 && i % 100 <= 14) ||\n                    f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&\n                        !(f % 100 >= 12 && f % 100 <= 14))\n                    return Plural.Few;\n                return Plural.Other;\n            case 'cs':\n            case 'sk':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)\n                    return Plural.Few;\n                if (!(v === 0))\n                    return Plural.Many;\n                return Plural.Other;\n            case 'cy':\n                if (n === 0)\n                    return Plural.Zero;\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                if (n === 3)\n                    return Plural.Few;\n                if (n === 6)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'da':\n                if (n === 1 || !(t === 0) && (i === 0 || i === 1))\n                    return Plural.One;\n                return Plural.Other;\n            case 'dsb':\n            case 'hsb':\n                if (v === 0 && i % 100 === 1 || f % 100 === 1)\n                    return Plural.One;\n                if (v === 0 && i % 100 === 2 || f % 100 === 2)\n                    return Plural.Two;\n                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||\n                    f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)\n                    return Plural.Few;\n                return Plural.Other;\n            case 'ff':\n            case 'fr':\n            case 'hy':\n            case 'kab':\n                if (i === 0 || i === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'fil':\n                if (v === 0 && (i === 1 || i === 2 || i === 3) ||\n                    v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||\n                    !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))\n                    return Plural.One;\n                return Plural.Other;\n            case 'ga':\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                if (n === Math.floor(n) && n >= 3 && n <= 6)\n                    return Plural.Few;\n                if (n === Math.floor(n) && n >= 7 && n <= 10)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'gd':\n                if (n === 1 || n === 11)\n                    return Plural.One;\n                if (n === 2 || n === 12)\n                    return Plural.Two;\n                if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))\n                    return Plural.Few;\n                return Plural.Other;\n            case 'gv':\n                if (v === 0 && i % 10 === 1)\n                    return Plural.One;\n                if (v === 0 && i % 10 === 2)\n                    return Plural.Two;\n                if (v === 0 &&\n                    (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))\n                    return Plural.Few;\n                if (!(v === 0))\n                    return Plural.Many;\n                return Plural.Other;\n            case 'he':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (i === 2 && v === 0)\n                    return Plural.Two;\n                if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'is':\n                if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))\n                    return Plural.One;\n                return Plural.Other;\n            case 'ksh':\n                if (n === 0)\n                    return Plural.Zero;\n                if (n === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'kw':\n            case 'naq':\n            case 'se':\n            case 'smn':\n                if (n === 1)\n                    return Plural.One;\n                if (n === 2)\n                    return Plural.Two;\n                return Plural.Other;\n            case 'lag':\n                if (n === 0)\n                    return Plural.Zero;\n                if ((i === 0 || i === 1) && !(n === 0))\n                    return Plural.One;\n                return Plural.Other;\n            case 'lt':\n                if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))\n                    return Plural.One;\n                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&\n                    !(n % 100 >= 11 && n % 100 <= 19))\n                    return Plural.Few;\n                if (!(f === 0))\n                    return Plural.Many;\n                return Plural.Other;\n            case 'lv':\n            case 'prg':\n                if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||\n                    v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)\n                    return Plural.Zero;\n                if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||\n                    !(v === 2) && f % 10 === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'mk':\n                if (v === 0 && i % 10 === 1 || f % 10 === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'mt':\n                if (n === 1)\n                    return Plural.One;\n                if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)\n                    return Plural.Few;\n                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'pl':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n                    !(i % 100 >= 12 && i % 100 <= 14))\n                    return Plural.Few;\n                if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||\n                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||\n                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'pt':\n                if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))\n                    return Plural.One;\n                return Plural.Other;\n            case 'ro':\n                if (i === 1 && v === 0)\n                    return Plural.One;\n                if (!(v === 0) || n === 0 ||\n                    !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)\n                    return Plural.Few;\n                return Plural.Other;\n            case 'ru':\n            case 'uk':\n                if (v === 0 && i % 10 === 1 && !(i % 100 === 11))\n                    return Plural.One;\n                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&\n                    !(i % 100 >= 12 && i % 100 <= 14))\n                    return Plural.Few;\n                if (v === 0 && i % 10 === 0 ||\n                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||\n                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)\n                    return Plural.Many;\n                return Plural.Other;\n            case 'shi':\n                if (i === 0 || n === 1)\n                    return Plural.One;\n                if (n === Math.floor(n) && n >= 2 && n <= 10)\n                    return Plural.Few;\n                return Plural.Other;\n            case 'si':\n                if (n === 0 || n === 1 || i === 0 && f === 1)\n                    return Plural.One;\n                return Plural.Other;\n            case 'sl':\n                if (v === 0 && i % 100 === 1)\n                    return Plural.One;\n                if (v === 0 && i % 100 === 2)\n                    return Plural.Two;\n                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))\n                    return Plural.Few;\n                return Plural.Other;\n            case 'tzm':\n                if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)\n                    return Plural.One;\n                return Plural.Other;\n            default:\n                return Plural.Other;\n        }\n    }\n\n    function isListLikeIterable(obj) {\n        if (!isJsObject(obj))\n            return false;\n        return Array.isArray(obj) ||\n            (!(obj instanceof Map) &&\n                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\n    }\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Adds and removes CSS classes on an HTML element.\n     *\n     * @howToUse\n     * ```\n     *     <some-element [ngClass]=\"'first second'\">...</some-element>\n     *\n     *     <some-element [ngClass]=\"['first', 'second']\">...</some-element>\n     *\n     *     <some-element [ngClass]=\"{'first': true, 'second': true, 'third': false}\">...</some-element>\n     *\n     *     <some-element [ngClass]=\"stringExp|arrayExp|objExp\">...</some-element>\n     * ```\n     *\n     * @description\n     *\n     * The CSS classes are updated as follows, depending on the type of the expression evaluation:\n     * - `string` - the CSS classes listed in the string (space delimited) are added,\n     * - `Array` - the CSS classes declared as Array elements are added,\n     * - `Object` - keys are CSS classes that get added when the expression given in the value\n     *              evaluates to a truthy value, otherwise they are removed.\n     *\n     * @stable\n     */\n    var NgClass = (function () {\n        function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {\n            this._iterableDiffers = _iterableDiffers;\n            this._keyValueDiffers = _keyValueDiffers;\n            this._ngEl = _ngEl;\n            this._renderer = _renderer;\n            this._initialClasses = [];\n        }\n        Object.defineProperty(NgClass.prototype, \"klass\", {\n            set: function (v) {\n                this._applyInitialClasses(true);\n                this._initialClasses = typeof v === 'string' ? v.split(/\\s+/) : [];\n                this._applyInitialClasses(false);\n                this._applyClasses(this._rawClass, false);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgClass.prototype, \"ngClass\", {\n            set: function (v) {\n                this._cleanupClasses(this._rawClass);\n                this._iterableDiffer = null;\n                this._keyValueDiffer = null;\n                this._rawClass = typeof v === 'string' ? v.split(/\\s+/) : v;\n                if (this._rawClass) {\n                    if (isListLikeIterable(this._rawClass)) {\n                        this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create(null);\n                    }\n                    else {\n                        this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create(null);\n                    }\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgClass.prototype.ngDoCheck = function () {\n            if (this._iterableDiffer) {\n                var changes = this._iterableDiffer.diff(this._rawClass);\n                if (changes) {\n                    this._applyIterableChanges(changes);\n                }\n            }\n            else if (this._keyValueDiffer) {\n                var changes = this._keyValueDiffer.diff(this._rawClass);\n                if (changes) {\n                    this._applyKeyValueChanges(changes);\n                }\n            }\n        };\n        NgClass.prototype._cleanupClasses = function (rawClassVal) {\n            this._applyClasses(rawClassVal, true);\n            this._applyInitialClasses(false);\n        };\n        NgClass.prototype._applyKeyValueChanges = function (changes) {\n            var _this = this;\n            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });\n            changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });\n            changes.forEachRemovedItem(function (record) {\n                if (record.previousValue) {\n                    _this._toggleClass(record.key, false);\n                }\n            });\n        };\n        NgClass.prototype._applyIterableChanges = function (changes) {\n            var _this = this;\n            changes.forEachAddedItem(function (record) {\n                if (typeof record.item === 'string') {\n                    _this._toggleClass(record.item, true);\n                }\n                else {\n                    throw new Error(\"NgClass can only toggle CSS classes expressed as strings, got \" + stringify(record.item));\n                }\n            });\n            changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });\n        };\n        NgClass.prototype._applyInitialClasses = function (isCleanup) {\n            var _this = this;\n            this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });\n        };\n        NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {\n            var _this = this;\n            if (rawClassVal) {\n                if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {\n                    rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });\n                }\n                else {\n                    Object.keys(rawClassVal).forEach(function (klass) {\n                        if (isPresent(rawClassVal[klass]))\n                            _this._toggleClass(klass, !isCleanup);\n                    });\n                }\n            }\n        };\n        NgClass.prototype._toggleClass = function (klass, enabled) {\n            var _this = this;\n            klass = klass.trim();\n            if (klass) {\n                klass.split(/\\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, enabled); });\n            }\n        };\n        NgClass.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },\n        ];\n        /** @nocollapse */\n        NgClass.ctorParameters = [\n            { type: _angular_core.IterableDiffers, },\n            { type: _angular_core.KeyValueDiffers, },\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n        ];\n        NgClass.propDecorators = {\n            'klass': [{ type: _angular_core.Input, args: ['class',] },],\n            'ngClass': [{ type: _angular_core.Input },],\n        };\n        return NgClass;\n    }());\n\n    var NgForRow = (function () {\n        function NgForRow($implicit, index, count) {\n            this.$implicit = $implicit;\n            this.index = index;\n            this.count = count;\n        }\n        Object.defineProperty(NgForRow.prototype, \"first\", {\n            get: function () { return this.index === 0; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForRow.prototype, \"last\", {\n            get: function () { return this.index === this.count - 1; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForRow.prototype, \"even\", {\n            get: function () { return this.index % 2 === 0; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForRow.prototype, \"odd\", {\n            get: function () { return !this.even; },\n            enumerable: true,\n            configurable: true\n        });\n        return NgForRow;\n    }());\n    /**\n     * The `NgFor` directive instantiates a template once per item from an iterable. The context for\n     * each instantiated template inherits from the outer context with the given loop variable set\n     * to the current item from the iterable.\n     *\n     * ### Local Variables\n     *\n     * `NgFor` provides several exported values that can be aliased to local variables:\n     *\n     * * `index` will be set to the current loop iteration for each template context.\n     * * `first` will be set to a boolean value indicating whether the item is the first one in the\n     *   iteration.\n     * * `last` will be set to a boolean value indicating whether the item is the last one in the\n     *   iteration.\n     * * `even` will be set to a boolean value indicating whether this item has an even index.\n     * * `odd` will be set to a boolean value indicating whether this item has an odd index.\n     *\n     * ### Change Propagation\n     *\n     * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:\n     *\n     * * When an item is added, a new instance of the template is added to the DOM.\n     * * When an item is removed, its template instance is removed from the DOM.\n     * * When items are reordered, their respective templates are reordered in the DOM.\n     * * Otherwise, the DOM element for that item will remain the same.\n     *\n     * Angular uses object identity to track insertions and deletions within the iterator and reproduce\n     * those changes in the DOM. This has important implications for animations and any stateful\n     * controls\n     * (such as `<input>` elements which accept user input) that are present. Inserted rows can be\n     * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such\n     * as user input.\n     *\n     * It is possible for the identities of elements in the iterator to change while the data does not.\n     * This can happen, for example, if the iterator produced from an RPC to the server, and that\n     * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with\n     * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old\n     * elements were deleted and all new elements inserted). This is an expensive operation and should\n     * be avoided if possible.\n     *\n     * To customize the default tracking algorithm, `NgFor` supports `trackBy` option.\n     * `trackBy` takes a function which has two arguments: `index` and `item`.\n     * If `trackBy` is given, Angular tracks changes by the return value of the function.\n     *\n     * ### Syntax\n     *\n     * - `<li *ngFor=\"let item of items; let i = index; trackBy: trackByFn\">...</li>`\n     * - `<li template=\"ngFor let item of items; let i = index; trackBy: trackByFn\">...</li>`\n     *\n     * With `<template>` element:\n     *\n     * ```\n     * <template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">\n     *   <li>...</li>\n     * </template>\n     * ```\n     *\n     * ### Example\n     *\n     * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed\n     * example.\n     *\n     * @stable\n     */\n    var NgFor = (function () {\n        function NgFor(_viewContainer, _template, _differs, _cdr) {\n            this._viewContainer = _viewContainer;\n            this._template = _template;\n            this._differs = _differs;\n            this._cdr = _cdr;\n            this._differ = null;\n        }\n        Object.defineProperty(NgFor.prototype, \"ngForTemplate\", {\n            set: function (value) {\n                if (value) {\n                    this._template = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgFor.prototype.ngOnChanges = function (changes) {\n            if ('ngForOf' in changes) {\n                // React on ngForOf changes only once all inputs have been initialized\n                var value = changes['ngForOf'].currentValue;\n                if (!this._differ && value) {\n                    try {\n                        this._differ = this._differs.find(value).create(this._cdr, this.ngForTrackBy);\n                    }\n                    catch (e) {\n                        throw new Error(\"Cannot find a differ supporting object '\" + value + \"' of type '\" + getTypeNameForDebugging(value) + \"'. NgFor only supports binding to Iterables such as Arrays.\");\n                    }\n                }\n            }\n        };\n        NgFor.prototype.ngDoCheck = function () {\n            if (this._differ) {\n                var changes = this._differ.diff(this.ngForOf);\n                if (changes)\n                    this._applyChanges(changes);\n            }\n        };\n        NgFor.prototype._applyChanges = function (changes) {\n            var _this = this;\n            var insertTuples = [];\n            changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {\n                if (item.previousIndex == null) {\n                    var view = _this._viewContainer.createEmbeddedView(_this._template, new NgForRow(null, null, null), currentIndex);\n                    var tuple = new RecordViewTuple(item, view);\n                    insertTuples.push(tuple);\n                }\n                else if (currentIndex == null) {\n                    _this._viewContainer.remove(adjustedPreviousIndex);\n                }\n                else {\n                    var view = _this._viewContainer.get(adjustedPreviousIndex);\n                    _this._viewContainer.move(view, currentIndex);\n                    var tuple = new RecordViewTuple(item, view);\n                    insertTuples.push(tuple);\n                }\n            });\n            for (var i = 0; i < insertTuples.length; i++) {\n                this._perViewChange(insertTuples[i].view, insertTuples[i].record);\n            }\n            for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {\n                var viewRef = this._viewContainer.get(i);\n                viewRef.context.index = i;\n                viewRef.context.count = ilen;\n            }\n            changes.forEachIdentityChange(function (record) {\n                var viewRef = _this._viewContainer.get(record.currentIndex);\n                viewRef.context.$implicit = record.item;\n            });\n        };\n        NgFor.prototype._perViewChange = function (view, record) {\n            view.context.$implicit = record.item;\n        };\n        NgFor.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },\n        ];\n        /** @nocollapse */\n        NgFor.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n            { type: _angular_core.IterableDiffers, },\n            { type: _angular_core.ChangeDetectorRef, },\n        ];\n        NgFor.propDecorators = {\n            'ngForOf': [{ type: _angular_core.Input },],\n            'ngForTrackBy': [{ type: _angular_core.Input },],\n            'ngForTemplate': [{ type: _angular_core.Input },],\n        };\n        return NgFor;\n    }());\n    var RecordViewTuple = (function () {\n        function RecordViewTuple(record, view) {\n            this.record = record;\n            this.view = view;\n        }\n        return RecordViewTuple;\n    }());\n\n    /**\n     * Removes or recreates a portion of the DOM tree based on an {expression}.\n     *\n     * If the expression assigned to `ngIf` evaluates to a falsy value then the element\n     * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.\n     *\n     * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):\n     *\n     * ```\n     * <div *ngIf=\"errorCount > 0\" class=\"error\">\n     *   <!-- Error message displayed when the errorCount property in the current context is greater\n     * than 0. -->\n     *   {{errorCount}} errors detected\n     * </div>\n     * ```\n     *\n     * ### Syntax\n     *\n     * - `<div *ngIf=\"condition\">...</div>`\n     * - `<div template=\"ngIf condition\">...</div>`\n     * - `<template [ngIf]=\"condition\"><div>...</div></template>`\n     *\n     * @stable\n     */\n    var NgIf = (function () {\n        function NgIf(_viewContainer, _template) {\n            this._viewContainer = _viewContainer;\n            this._template = _template;\n            this._hasView = false;\n        }\n        Object.defineProperty(NgIf.prototype, \"ngIf\", {\n            set: function (condition) {\n                if (condition && !this._hasView) {\n                    this._hasView = true;\n                    this._viewContainer.createEmbeddedView(this._template);\n                }\n                else if (!condition && this._hasView) {\n                    this._hasView = false;\n                    this._viewContainer.clear();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgIf.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },\n        ];\n        /** @nocollapse */\n        NgIf.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n        ];\n        NgIf.propDecorators = {\n            'ngIf': [{ type: _angular_core.Input },],\n        };\n        return NgIf;\n    }());\n\n    var SwitchView = (function () {\n        function SwitchView(_viewContainerRef, _templateRef) {\n            this._viewContainerRef = _viewContainerRef;\n            this._templateRef = _templateRef;\n            this._created = false;\n        }\n        SwitchView.prototype.create = function () {\n            this._created = true;\n            this._viewContainerRef.createEmbeddedView(this._templateRef);\n        };\n        SwitchView.prototype.destroy = function () {\n            this._created = false;\n            this._viewContainerRef.clear();\n        };\n        SwitchView.prototype.enforceState = function (created) {\n            if (created && !this._created) {\n                this.create();\n            }\n            else if (!created && this._created) {\n                this.destroy();\n            }\n        };\n        return SwitchView;\n    }());\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch\n     *             expression.\n     *\n     * @howToUse\n     * ```\n     *     <container-element [ngSwitch]=\"switch_expression\">\n     *       <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n     *       <some-element *ngSwitchCase=\"match_expression_2\">...</some-element>\n     *       <some-other-element *ngSwitchCase=\"match_expression_3\">...</some-other-element>\n     *       <ng-container *ngSwitchCase=\"match_expression_3\">\n     *         <!-- use a ng-container to group multiple root nodes -->\n     *         <inner-element></inner-element>\n     *         <inner-other-element></inner-other-element>\n     *       </ng-container>\n     *       <some-element *ngSwitchDefault>...</some-element>\n     *     </container-element>\n     * ```\n     * @description\n     *\n     * `NgSwitch` stamps out nested views when their match expression value matches the value of the\n     * switch expression.\n     *\n     * In other words:\n     * - you define a container element (where you place the directive with a switch expression on the\n     * `[ngSwitch]=\"...\"` attribute)\n     * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view\n     * root elements.\n     *\n     * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will\n     * be preserved at the location.\n     *\n     * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the\n     * expression is evaluated.\n     * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is\n     * stamped out.\n     *\n     * @stable\n     */\n    var NgSwitch = (function () {\n        function NgSwitch() {\n            this._defaultUsed = false;\n            this._caseCount = 0;\n            this._lastCaseCheckIndex = 0;\n            this._lastCasesMatched = false;\n        }\n        Object.defineProperty(NgSwitch.prototype, \"ngSwitch\", {\n            set: function (newValue) {\n                this._ngSwitch = newValue;\n                if (this._caseCount === 0) {\n                    this._updateDefaultCases(true);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        NgSwitch.prototype._addCase = function () { return this._caseCount++; };\n        /** @internal */\n        NgSwitch.prototype._addDefault = function (view) {\n            if (!this._defaultViews) {\n                this._defaultViews = [];\n            }\n            this._defaultViews.push(view);\n        };\n        /** @internal */\n        NgSwitch.prototype._matchCase = function (value) {\n            var matched = value == this._ngSwitch;\n            this._lastCasesMatched = this._lastCasesMatched || matched;\n            this._lastCaseCheckIndex++;\n            if (this._lastCaseCheckIndex === this._caseCount) {\n                this._updateDefaultCases(!this._lastCasesMatched);\n                this._lastCaseCheckIndex = 0;\n                this._lastCasesMatched = false;\n            }\n            return matched;\n        };\n        NgSwitch.prototype._updateDefaultCases = function (useDefault) {\n            if (this._defaultViews && useDefault !== this._defaultUsed) {\n                this._defaultUsed = useDefault;\n                for (var i = 0; i < this._defaultViews.length; i++) {\n                    var defaultView = this._defaultViews[i];\n                    defaultView.enforceState(useDefault);\n                }\n            }\n        };\n        NgSwitch.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },\n        ];\n        /** @nocollapse */\n        NgSwitch.ctorParameters = [];\n        NgSwitch.propDecorators = {\n            'ngSwitch': [{ type: _angular_core.Input },],\n        };\n        return NgSwitch;\n    }());\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgSwitch} when the\n     *             given expression evaluate to respectively the same/different value as the switch\n     *             expression.\n     *\n     * @howToUse\n     * ```\n     * <container-element [ngSwitch]=\"switch_expression\">\n     *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n     * </container-element>\n     *```\n     * @description\n     *\n     * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch\n     * expression.\n     *\n     * If multiple match expressions match the switch expression value, all of them are displayed.\n     *\n     * See {@link NgSwitch} for more details and example.\n     *\n     * @stable\n     */\n    var NgSwitchCase = (function () {\n        function NgSwitchCase(viewContainer, templateRef, ngSwitch) {\n            this.ngSwitch = ngSwitch;\n            ngSwitch._addCase();\n            this._view = new SwitchView(viewContainer, templateRef);\n        }\n        NgSwitchCase.prototype.ngDoCheck = function () { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)); };\n        NgSwitchCase.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },\n        ];\n        /** @nocollapse */\n        NgSwitchCase.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },\n        ];\n        NgSwitchCase.propDecorators = {\n            'ngSwitchCase': [{ type: _angular_core.Input },],\n        };\n        return NgSwitchCase;\n    }());\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Creates a view that is added to the parent {@link NgSwitch} when no case expressions\n     * match the\n     *             switch expression.\n     *\n     * @howToUse\n     * ```\n     * <container-element [ngSwitch]=\"switch_expression\">\n     *   <some-element *ngSwitchCase=\"match_expression_1\">...</some-element>\n     *   <some-other-element *ngSwitchDefault>...</some-other-element>\n     * </container-element>\n     * ```\n     *\n     * @description\n     *\n     * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch\n     * expression.\n     *\n     * See {@link NgSwitch} for more details and example.\n     *\n     * @stable\n     */\n    var NgSwitchDefault = (function () {\n        function NgSwitchDefault(viewContainer, templateRef, ngSwitch) {\n            ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));\n        }\n        NgSwitchDefault.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },\n        ];\n        /** @nocollapse */\n        NgSwitchDefault.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n            { type: _angular_core.TemplateRef, },\n            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },\n        ];\n        return NgSwitchDefault;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.\n     *\n     * @howToUse\n     * ```\n     * <some-element [ngPlural]=\"value\">\n     *   <ng-container *ngPluralCase=\"'=0'\">there is nothing</ng-container>\n     *   <ng-container *ngPluralCase=\"'=1'\">there is one</ng-container>\n     *   <ng-container *ngPluralCase=\"'few'\">there are a few</ng-container>\n     *   <ng-container *ngPluralCase=\"'other'\">there are exactly #</ng-container>\n     * </some-element>\n     * ```\n     *\n     * @description\n     *\n     * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees\n     * that match the switch expression's pluralization category.\n     *\n     * To use this directive you must provide a container element that sets the `[ngPlural]` attribute\n     * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their\n     * expression:\n     * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value\n     *   matches the switch expression exactly,\n     * - otherwise, the view will be treated as a \"category match\", and will only display if exact\n     *   value matches aren't found and the value maps to its category for the defined locale.\n     *\n     * See http://cldr.unicode.org/index/cldr-spec/plural-rules\n     *\n     * @experimental\n     */\n    var NgPlural = (function () {\n        function NgPlural(_localization) {\n            this._localization = _localization;\n            this._caseViews = {};\n        }\n        Object.defineProperty(NgPlural.prototype, \"ngPlural\", {\n            set: function (value) {\n                this._switchValue = value;\n                this._updateView();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };\n        NgPlural.prototype._updateView = function () {\n            this._clearViews();\n            var cases = Object.keys(this._caseViews);\n            var key = getPluralCategory(this._switchValue, cases, this._localization);\n            this._activateView(this._caseViews[key]);\n        };\n        NgPlural.prototype._clearViews = function () {\n            if (this._activeView)\n                this._activeView.destroy();\n        };\n        NgPlural.prototype._activateView = function (view) {\n            if (view) {\n                this._activeView = view;\n                this._activeView.create();\n            }\n        };\n        NgPlural.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },\n        ];\n        /** @nocollapse */\n        NgPlural.ctorParameters = [\n            { type: NgLocalization, },\n        ];\n        NgPlural.propDecorators = {\n            'ngPlural': [{ type: _angular_core.Input },],\n        };\n        return NgPlural;\n    }());\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgPlural} when the\n     *             given expression matches the plural expression according to CLDR rules.\n     *\n     * @howToUse\n     * ```\n     * <some-element [ngPlural]=\"value\">\n     *   <ng-container *ngPluralCase=\"'=0'\">...</ng-container>\n     *   <ng-container *ngPluralCase=\"'other'\">...</ng-container>\n     * </some-element>\n     *```\n     *\n     * See {@link NgPlural} for more details and example.\n     *\n     * @experimental\n     */\n    var NgPluralCase = (function () {\n        function NgPluralCase(value, template, viewContainer, ngPlural) {\n            this.value = value;\n            ngPlural.addCase(value, new SwitchView(viewContainer, template));\n        }\n        NgPluralCase.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },\n        ];\n        /** @nocollapse */\n        NgPluralCase.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },\n            { type: _angular_core.TemplateRef, },\n            { type: _angular_core.ViewContainerRef, },\n            { type: NgPlural, decorators: [{ type: _angular_core.Host },] },\n        ];\n        return NgPluralCase;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Update an HTML element styles.\n     *\n     * @howToUse\n     * ```\n     * <some-element [ngStyle]=\"{'font-style': styleExp}\">...</some-element>\n     *\n     * <some-element [ngStyle]=\"{'max-width.px': widthExp}\">...</some-element>\n     *\n     * <some-element [ngStyle]=\"objExp\">...</some-element>\n     * ```\n     *\n     * @description\n     *\n     * The styles are updated according to the value of the expression evaluation:\n     * - keys are style names with an optional `.<unit>` suffix (ie 'top.px', 'font-style.em'),\n     * - values are the values assigned to those properties (expressed in the given unit).\n     *\n     * @stable\n     */\n    var NgStyle = (function () {\n        function NgStyle(_differs, _ngEl, _renderer) {\n            this._differs = _differs;\n            this._ngEl = _ngEl;\n            this._renderer = _renderer;\n        }\n        Object.defineProperty(NgStyle.prototype, \"ngStyle\", {\n            set: function (v) {\n                this._ngStyle = v;\n                if (!this._differ && v) {\n                    this._differ = this._differs.find(v).create(null);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgStyle.prototype.ngDoCheck = function () {\n            if (this._differ) {\n                var changes = this._differ.diff(this._ngStyle);\n                if (changes) {\n                    this._applyChanges(changes);\n                }\n            }\n        };\n        NgStyle.prototype._applyChanges = function (changes) {\n            var _this = this;\n            changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });\n            changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });\n            changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });\n        };\n        NgStyle.prototype._setStyle = function (nameAndUnit, value) {\n            var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];\n            value = value && unit ? \"\" + value + unit : value;\n            this._renderer.setElementStyle(this._ngEl.nativeElement, name, value);\n        };\n        NgStyle.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },\n        ];\n        /** @nocollapse */\n        NgStyle.ctorParameters = [\n            { type: _angular_core.KeyValueDiffers, },\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n        ];\n        NgStyle.propDecorators = {\n            'ngStyle': [{ type: _angular_core.Input },],\n        };\n        return NgStyle;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     *\n     * @whatItDoes Inserts an embedded view from a prepared `TemplateRef`\n     *\n     * @howToUse\n     * ```\n     * <template [ngTemplateOutlet]=\"templateRefExpression\"\n     *           [ngOutletContext]=\"objectExpression\">\n     * </template>\n     * ```\n     *\n     * @description\n     *\n     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngOutletContext]`.\n     * `[ngOutletContext]` should be an object, the object's keys will be the local template variables\n     * available within the `TemplateRef`.\n     *\n     * Note: using the key `$implicit` in the context object will set it's value as default.\n     *\n     * @experimental\n     */\n    var NgTemplateOutlet = (function () {\n        function NgTemplateOutlet(_viewContainerRef) {\n            this._viewContainerRef = _viewContainerRef;\n        }\n        Object.defineProperty(NgTemplateOutlet.prototype, \"ngOutletContext\", {\n            set: function (context) { this._context = context; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgTemplateOutlet.prototype, \"ngTemplateOutlet\", {\n            set: function (templateRef) { this._templateRef = templateRef; },\n            enumerable: true,\n            configurable: true\n        });\n        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {\n            if (this._viewRef) {\n                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));\n            }\n            if (this._templateRef) {\n                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);\n            }\n        };\n        NgTemplateOutlet.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },\n        ];\n        /** @nocollapse */\n        NgTemplateOutlet.ctorParameters = [\n            { type: _angular_core.ViewContainerRef, },\n        ];\n        NgTemplateOutlet.propDecorators = {\n            'ngOutletContext': [{ type: _angular_core.Input },],\n            'ngTemplateOutlet': [{ type: _angular_core.Input },],\n        };\n        return NgTemplateOutlet;\n    }());\n\n    /**\n     * A collection of Angular directives that are likely to be used in each and every Angular\n     * application.\n     */\n    var COMMON_DIRECTIVES = [\n        NgClass,\n        NgFor,\n        NgIf,\n        NgTemplateOutlet,\n        NgStyle,\n        NgSwitch,\n        NgSwitchCase,\n        NgSwitchDefault,\n        NgPlural,\n        NgPluralCase,\n    ];\n\n    var isPromise = _angular_core.__core_private__.isPromise;\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * @stable\n     */\n    var BaseError = (function (_super) {\n        __extends$4(BaseError, _super);\n        function BaseError(message) {\n            // Errors don't use current this, instead they create a new instance.\n            // We have to do forward all of our api to the nativeInstance.\n            var nativeError = _super.call(this, message);\n            this._nativeError = nativeError;\n        }\n        Object.defineProperty(BaseError.prototype, \"message\", {\n            get: function () { return this._nativeError.message; },\n            set: function (message) { this._nativeError.message = message; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"name\", {\n            get: function () { return this._nativeError.name; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseError.prototype, \"stack\", {\n            get: function () { return this._nativeError.stack; },\n            set: function (value) { this._nativeError.stack = value; },\n            enumerable: true,\n            configurable: true\n        });\n        BaseError.prototype.toString = function () { return this._nativeError.toString(); };\n        return BaseError;\n    }(Error));\n    /**\n     * @stable\n     */\n    var WrappedError = (function (_super) {\n        __extends$4(WrappedError, _super);\n        function WrappedError(message, error) {\n            _super.call(this, message + \" caused by: \" + (error instanceof Error ? error.message : error));\n            this.originalError = error;\n        }\n        Object.defineProperty(WrappedError.prototype, \"stack\", {\n            get: function () {\n                return (this.originalError instanceof Error ? this.originalError : this._nativeError)\n                    .stack;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return WrappedError;\n    }(BaseError));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var InvalidPipeArgumentError = (function (_super) {\n        __extends$3(InvalidPipeArgumentError, _super);\n        function InvalidPipeArgumentError(type, value) {\n            _super.call(this, \"Invalid argument '\" + value + \"' for pipe '\" + stringify(type) + \"'\");\n        }\n        return InvalidPipeArgumentError;\n    }(BaseError));\n\n    var ObservableStrategy = (function () {\n        function ObservableStrategy() {\n        }\n        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {\n            return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });\n        };\n        ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };\n        ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };\n        return ObservableStrategy;\n    }());\n    var PromiseStrategy = (function () {\n        function PromiseStrategy() {\n        }\n        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {\n            return async.then(updateLatestValue, function (e) { throw e; });\n        };\n        PromiseStrategy.prototype.dispose = function (subscription) { };\n        PromiseStrategy.prototype.onDestroy = function (subscription) { };\n        return PromiseStrategy;\n    }());\n    var _promiseStrategy = new PromiseStrategy();\n    var _observableStrategy = new ObservableStrategy();\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Unwraps a value from an asynchronous primitive.\n     * @howToUse `observable_or_promise_expression | async`\n     * @description\n     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has\n     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for\n     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid\n     * potential memory leaks.\n     *\n     *\n     * ## Examples\n     *\n     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the\n     * promise.\n     *\n     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}\n     *\n     * It's also possible to use `async` with Observables. The example below binds the `time` Observable\n     * to the view. The Observable continuesly updates the view with the current time.\n     *\n     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}\n     *\n     * @stable\n     */\n    var AsyncPipe = (function () {\n        function AsyncPipe(_ref) {\n            this._ref = _ref;\n            this._latestValue = null;\n            this._latestReturnedValue = null;\n            this._subscription = null;\n            this._obj = null;\n            this._strategy = null;\n        }\n        AsyncPipe.prototype.ngOnDestroy = function () {\n            if (this._subscription) {\n                this._dispose();\n            }\n        };\n        AsyncPipe.prototype.transform = function (obj) {\n            if (!this._obj) {\n                if (obj) {\n                    this._subscribe(obj);\n                }\n                this._latestReturnedValue = this._latestValue;\n                return this._latestValue;\n            }\n            if (obj !== this._obj) {\n                this._dispose();\n                return this.transform(obj);\n            }\n            if (this._latestValue === this._latestReturnedValue) {\n                return this._latestReturnedValue;\n            }\n            this._latestReturnedValue = this._latestValue;\n            return _angular_core.WrappedValue.wrap(this._latestValue);\n        };\n        AsyncPipe.prototype._subscribe = function (obj) {\n            var _this = this;\n            this._obj = obj;\n            this._strategy = this._selectStrategy(obj);\n            this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });\n        };\n        AsyncPipe.prototype._selectStrategy = function (obj) {\n            if (isPromise(obj)) {\n                return _promiseStrategy;\n            }\n            if (obj.subscribe) {\n                return _observableStrategy;\n            }\n            throw new InvalidPipeArgumentError(AsyncPipe, obj);\n        };\n        AsyncPipe.prototype._dispose = function () {\n            this._strategy.dispose(this._subscription);\n            this._latestValue = null;\n            this._latestReturnedValue = null;\n            this._subscription = null;\n            this._obj = null;\n        };\n        AsyncPipe.prototype._updateLatestValue = function (async, value) {\n            if (async === this._obj) {\n                this._latestValue = value;\n                this._ref.markForCheck();\n            }\n        };\n        AsyncPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },\n        ];\n        /** @nocollapse */\n        AsyncPipe.ctorParameters = [\n            { type: _angular_core.ChangeDetectorRef, },\n        ];\n        return AsyncPipe;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var NumberFormatStyle;\n    (function (NumberFormatStyle) {\n        NumberFormatStyle[NumberFormatStyle[\"Decimal\"] = 0] = \"Decimal\";\n        NumberFormatStyle[NumberFormatStyle[\"Percent\"] = 1] = \"Percent\";\n        NumberFormatStyle[NumberFormatStyle[\"Currency\"] = 2] = \"Currency\";\n    })(NumberFormatStyle || (NumberFormatStyle = {}));\n    var NumberFormatter = (function () {\n        function NumberFormatter() {\n        }\n        NumberFormatter.format = function (num, locale, style, _a) {\n            var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;\n            var options = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                minimumFractionDigits: minimumFractionDigits,\n                maximumFractionDigits: maximumFractionDigits,\n                style: NumberFormatStyle[style].toLowerCase()\n            };\n            if (style == NumberFormatStyle.Currency) {\n                options.currency = currency;\n                options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';\n            }\n            return new Intl.NumberFormat(locale, options).format(num);\n        };\n        return NumberFormatter;\n    }());\n    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;\n    var PATTERN_ALIASES = {\n        yMMMdjms: datePartGetterFactory(combine([\n            digitCondition('year', 1),\n            nameCondition('month', 3),\n            digitCondition('day', 1),\n            digitCondition('hour', 1),\n            digitCondition('minute', 1),\n            digitCondition('second', 1),\n        ])),\n        yMdjm: datePartGetterFactory(combine([\n            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),\n            digitCondition('hour', 1), digitCondition('minute', 1)\n        ])),\n        yMMMMEEEEd: datePartGetterFactory(combine([\n            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),\n            digitCondition('day', 1)\n        ])),\n        yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),\n        yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),\n        yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),\n        jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),\n        jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))\n    };\n    var DATE_FORMATS = {\n        yyyy: datePartGetterFactory(digitCondition('year', 4)),\n        yy: datePartGetterFactory(digitCondition('year', 2)),\n        y: datePartGetterFactory(digitCondition('year', 1)),\n        MMMM: datePartGetterFactory(nameCondition('month', 4)),\n        MMM: datePartGetterFactory(nameCondition('month', 3)),\n        MM: datePartGetterFactory(digitCondition('month', 2)),\n        M: datePartGetterFactory(digitCondition('month', 1)),\n        LLLL: datePartGetterFactory(nameCondition('month', 4)),\n        L: datePartGetterFactory(nameCondition('month', 1)),\n        dd: datePartGetterFactory(digitCondition('day', 2)),\n        d: datePartGetterFactory(digitCondition('day', 1)),\n        HH: digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),\n        H: hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),\n        hh: digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),\n        h: hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),\n        jj: datePartGetterFactory(digitCondition('hour', 2)),\n        j: datePartGetterFactory(digitCondition('hour', 1)),\n        mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),\n        m: datePartGetterFactory(digitCondition('minute', 1)),\n        ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),\n        s: datePartGetterFactory(digitCondition('second', 1)),\n        // while ISO 8601 requires fractions to be prefixed with `.` or `,`\n        // we can be just safely rely on using `sss` since we currently don't support single or two digit\n        // fractions\n        sss: datePartGetterFactory(digitCondition('second', 3)),\n        EEEE: datePartGetterFactory(nameCondition('weekday', 4)),\n        EEE: datePartGetterFactory(nameCondition('weekday', 3)),\n        EE: datePartGetterFactory(nameCondition('weekday', 2)),\n        E: datePartGetterFactory(nameCondition('weekday', 1)),\n        a: hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),\n        Z: timeZoneGetter('short'),\n        z: timeZoneGetter('long'),\n        ww: datePartGetterFactory({}),\n        // first Thursday of the year. not support ?\n        w: datePartGetterFactory({}),\n        // of the year not support ?\n        G: datePartGetterFactory(nameCondition('era', 1)),\n        GG: datePartGetterFactory(nameCondition('era', 2)),\n        GGG: datePartGetterFactory(nameCondition('era', 3)),\n        GGGG: datePartGetterFactory(nameCondition('era', 4))\n    };\n    function digitModifier(inner) {\n        return function (date, locale) {\n            var result = inner(date, locale);\n            return result.length == 1 ? '0' + result : result;\n        };\n    }\n    function hourClockExtractor(inner) {\n        return function (date, locale) { return inner(date, locale).split(' ')[1]; };\n    }\n    function hourExtractor(inner) {\n        return function (date, locale) { return inner(date, locale).split(' ')[0]; };\n    }\n    function intlDateFormat(date, locale, options) {\n        return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\\u200e\\u200f]/g, '');\n    }\n    function timeZoneGetter(timezone) {\n        // To workaround `Intl` API restriction for single timezone let format with 24 hours\n        var options = { hour: '2-digit', hour12: false, timeZoneName: timezone };\n        return function (date, locale) {\n            var result = intlDateFormat(date, locale, options);\n            // Then extract first 3 letters that related to hours\n            return result ? result.substring(3) : '';\n        };\n    }\n    function hour12Modify(options, value) {\n        options.hour12 = value;\n        return options;\n    }\n    function digitCondition(prop, len) {\n        var result = {};\n        result[prop] = len === 2 ? '2-digit' : 'numeric';\n        return result;\n    }\n    function nameCondition(prop, len) {\n        var result = {};\n        if (len < 4) {\n            result[prop] = len > 1 ? 'short' : 'narrow';\n        }\n        else {\n            result[prop] = 'long';\n        }\n        return result;\n    }\n    function combine(options) {\n        return (_a = Object).assign.apply(_a, [{}].concat(options));\n        var _a;\n    }\n    function datePartGetterFactory(ret) {\n        return function (date, locale) { return intlDateFormat(date, locale, ret); };\n    }\n    var DATE_FORMATTER_CACHE = new Map();\n    function dateFormatter(format, date, locale) {\n        var fn = PATTERN_ALIASES[format];\n        if (fn)\n            return fn(date, locale);\n        var parts = DATE_FORMATTER_CACHE.get(format);\n        if (!parts) {\n            parts = [];\n            var match = void 0;\n            DATE_FORMATS_SPLIT.exec(format);\n            while (format) {\n                match = DATE_FORMATS_SPLIT.exec(format);\n                if (match) {\n                    parts = parts.concat(match.slice(1));\n                    format = parts.pop();\n                }\n                else {\n                    parts.push(format);\n                    format = null;\n                }\n            }\n            DATE_FORMATTER_CACHE.set(format, parts);\n        }\n        return parts.reduce(function (text, part) {\n            var fn = DATE_FORMATS[part];\n            return text + (fn ? fn(date, locale) : partToTime(part));\n        }, '');\n    }\n    function partToTime(part) {\n        return part === '\\'\\'' ? '\\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\\'');\n    }\n    var DateFormatter = (function () {\n        function DateFormatter() {\n        }\n        DateFormatter.format = function (date, locale, pattern) {\n            return dateFormatter(pattern, date, locale);\n        };\n        return DateFormatter;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a date according to locale rules.\n     * @howToUse `date_expression | date[:format]`\n     * @description\n     *\n     * Where:\n     * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string\n     * (https://www.w3.org/TR/NOTE-datetime).\n     * - `format` indicates which date/time components to include. The format can be predifined as\n     *   shown below or custom as shown in the table.\n     *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)\n     *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)\n     *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)\n     *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)\n     *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)\n     *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)\n     *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)\n     *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)\n     *\n     *\n     *  | Component | Symbol | Narrow | Short Form   | Long Form         | Numeric   | 2-digit   |\n     *  |-----------|:------:|--------|--------------|-------------------|-----------|-----------|\n     *  | era       |   G    | G (A)  | GGG (AD)     | GGGG (Anno Domini)| -         | -         |\n     *  | year      |   y    | -      | -            | -                 | y (2015)  | yy (15)   |\n     *  | month     |   M    | L (S)  | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |\n     *  | day       |   d    | -      | -            | -                 | d (3)     | dd (03)   |\n     *  | weekday   |   E    | E (S)  | EEE (Sun)    | EEEE (Sunday)     | -         | -         |\n     *  | hour      |   j    | -      | -            | -                 | j (13)    | jj (13)   |\n     *  | hour12    |   h    | -      | -            | -                 | h (1 PM)  | hh (01 PM)|\n     *  | hour24    |   H    | -      | -            | -                 | H (13)    | HH (13)   |\n     *  | minute    |   m    | -      | -            | -                 | m (5)     | mm (05)   |\n     *  | second    |   s    | -      | -            | -                 | s (9)     | ss (09)   |\n     *  | timezone  |   z    | -      | -            | z (Pacific Standard Time)| -  | -         |\n     *  | timezone  |   Z    | -      | Z (GMT-8:00) | -                 | -         | -         |\n     *  | timezone  |   a    | -      | a (PM)       | -                 | -         | -         |\n     *\n     * In javascript, only the components specified will be respected (not the ordering,\n     * punctuations, ...) and details of the formatting will be dependent on the locale.\n     *\n     * Timezone of the formatted text will be the local system timezone of the end-user's machine.\n     *\n     * When the expression is a ISO string without time (e.g. 2016-09-19) the time zone offset is not\n     * applied and the formatted text will have the same day, month and year of the expression.\n     *\n     * WARNINGS:\n     * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.\n     *   Instead users should treat the date as an immutable object and change the reference when the\n     *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run\n     *   which would be an expensive operation).\n     * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera\n     *   browsers.\n     *\n     * ### Examples\n     *\n     * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)\n     * in the _local_ time and locale is 'en-US':\n     *\n     * ```\n     *     {{ dateObj | date }}               // output is 'Jun 15, 2015'\n     *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'\n     *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'\n     *     {{ dateObj | date:'mmss' }}        // output is '43:11'\n     * ```\n     *\n     * {@example common/pipes/ts/date_pipe.ts region='DatePipe'}\n     *\n     * @stable\n     */\n    var DatePipe = (function () {\n        function DatePipe(_locale) {\n            this._locale = _locale;\n        }\n        DatePipe.prototype.transform = function (value, pattern) {\n            if (pattern === void 0) { pattern = 'mediumDate'; }\n            var date;\n            if (isBlank$1(value))\n                return null;\n            if (typeof value === 'string') {\n                value = value.trim();\n            }\n            if (isDate(value)) {\n                date = value;\n            }\n            else if (NumberWrapper.isNumeric(value)) {\n                date = new Date(parseFloat(value));\n            }\n            else if (typeof value === 'string' && /^(\\d{4}-\\d{1,2}-\\d{1,2})$/.test(value)) {\n                /**\n                * For ISO Strings without time the day, month and year must be extracted from the ISO String\n                * before Date creation to avoid time offset and errors in the new Date.\n                * If we only replace '-' with ',' in the ISO String (\"2015,01,01\"), and try to create a new\n                * date, some browsers (e.g. IE 9) will throw an invalid Date error\n                * If we leave the '-' (\"2015-01-01\") and try to create a new Date(\"2015-01-01\") the timeoffset\n                * is applied\n                * Note: ISO months are 0 for January, 1 for February, ...\n                */\n                var _a = value.split('-').map(function (val) { return parseInt(val, 10); }), y = _a[0], m = _a[1], d = _a[2];\n                date = new Date(y, m - 1, d);\n            }\n            else {\n                date = new Date(value);\n            }\n            if (!isDate(date)) {\n                throw new InvalidPipeArgumentError(DatePipe, value);\n            }\n            return DateFormatter.format(date, this._locale, DatePipe._ALIASES[pattern] || pattern);\n        };\n        /** @internal */\n        DatePipe._ALIASES = {\n            'medium': 'yMMMdjms',\n            'short': 'yMdjm',\n            'fullDate': 'yMMMMEEEEd',\n            'longDate': 'yMMMMd',\n            'mediumDate': 'yMMMd',\n            'shortDate': 'yMd',\n            'mediumTime': 'jms',\n            'shortTime': 'jm'\n        };\n        DatePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },\n        ];\n        /** @nocollapse */\n        DatePipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return DatePipe;\n    }());\n    function isBlank$1(obj) {\n        return obj == null || obj === '';\n    }\n\n    var _INTERPOLATION_REGEXP = /#/g;\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Maps a value to a string that pluralizes the value according to locale rules.\n     * @howToUse `expression | i18nPlural:mapping`\n     * @description\n     *\n     *  Where:\n     *  - `expression` is a number.\n     *  - `mapping` is an object that mimics the ICU format, see\n     *    http://userguide.icu-project.org/formatparse/messages\n     *\n     *  ## Example\n     *\n     * {@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}\n     *\n     * @experimental\n     */\n    var I18nPluralPipe = (function () {\n        function I18nPluralPipe(_localization) {\n            this._localization = _localization;\n        }\n        I18nPluralPipe.prototype.transform = function (value, pluralMap) {\n            if (isBlank(value))\n                return '';\n            if (typeof pluralMap !== 'object' || pluralMap === null) {\n                throw new InvalidPipeArgumentError(I18nPluralPipe, pluralMap);\n            }\n            var key = getPluralCategory(value, Object.keys(pluralMap), this._localization);\n            return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());\n        };\n        I18nPluralPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },\n        ];\n        /** @nocollapse */\n        I18nPluralPipe.ctorParameters = [\n            { type: NgLocalization, },\n        ];\n        return I18nPluralPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Generic selector that displays the string that matches the current value.\n     * @howToUse `expression | i18nSelect:mapping`\n     * @description\n     *\n     *  Where `mapping` is an object that indicates the text that should be displayed\n     *  for different values of the provided `expression`.\n     *  If none of the keys of the mapping match the value of the `expression`, then the content\n     *  of the `other` key is returned when present, otherwise an empty string is returned.\n     *\n     *  ## Example\n     *\n     * {@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}\n     *\n     *  @experimental\n     */\n    var I18nSelectPipe = (function () {\n        function I18nSelectPipe() {\n        }\n        I18nSelectPipe.prototype.transform = function (value, mapping) {\n            if (value == null)\n                return '';\n            if (typeof mapping !== 'object' || typeof value !== 'string') {\n                throw new InvalidPipeArgumentError(I18nSelectPipe, mapping);\n            }\n            if (mapping.hasOwnProperty(value)) {\n                return mapping[value];\n            }\n            if (mapping.hasOwnProperty('other')) {\n                return mapping['other'];\n            }\n            return '';\n        };\n        I18nSelectPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },\n        ];\n        /** @nocollapse */\n        I18nSelectPipe.ctorParameters = [];\n        return I18nSelectPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Converts value into JSON string.\n     * @howToUse `expression | json`\n     * @description\n     *\n     * Converts value into string using `JSON.stringify`. Useful for debugging.\n     *\n     * ### Example\n     * {@example common/pipes/ts/json_pipe.ts region='JsonPipe'}\n     *\n     * @stable\n     */\n    var JsonPipe = (function () {\n        function JsonPipe() {\n        }\n        JsonPipe.prototype.transform = function (value) { return JSON.stringify(value, null, 2); };\n        JsonPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },\n        ];\n        /** @nocollapse */\n        JsonPipe.ctorParameters = [];\n        return JsonPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Transforms string to lowercase.\n     * @howToUse `expression | lowercase`\n     * @description\n     *\n     * Converts value into a lowercase string using `String.prototype.toLowerCase()`.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}\n     *\n     * @stable\n     */\n    var LowerCasePipe = (function () {\n        function LowerCasePipe() {\n        }\n        LowerCasePipe.prototype.transform = function (value) {\n            if (isBlank(value))\n                return value;\n            if (typeof value !== 'string') {\n                throw new InvalidPipeArgumentError(LowerCasePipe, value);\n            }\n            return value.toLowerCase();\n        };\n        LowerCasePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },\n        ];\n        /** @nocollapse */\n        LowerCasePipe.ctorParameters = [];\n        return LowerCasePipe;\n    }());\n\n    var _NUMBER_FORMAT_REGEXP = /^(\\d+)?\\.((\\d+)(-(\\d+))?)?$/;\n    function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {\n        if (currency === void 0) { currency = null; }\n        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }\n        if (isBlank(value))\n            return null;\n        // Convert strings to numbers\n        value = typeof value === 'string' && NumberWrapper.isNumeric(value) ? +value : value;\n        if (typeof value !== 'number') {\n            throw new InvalidPipeArgumentError(pipe, value);\n        }\n        var minInt;\n        var minFraction;\n        var maxFraction;\n        if (style !== NumberFormatStyle.Currency) {\n            // rely on Intl default for currency\n            minInt = 1;\n            minFraction = 0;\n            maxFraction = 3;\n        }\n        if (digits) {\n            var parts = digits.match(_NUMBER_FORMAT_REGEXP);\n            if (parts === null) {\n                throw new Error(digits + \" is not a valid digit info for number pipes\");\n            }\n            if (isPresent(parts[1])) {\n                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);\n            }\n            if (isPresent(parts[3])) {\n                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);\n            }\n            if (isPresent(parts[5])) {\n                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);\n            }\n        }\n        return NumberFormatter.format(value, locale, style, {\n            minimumIntegerDigits: minInt,\n            minimumFractionDigits: minFraction,\n            maximumFractionDigits: maxFraction,\n            currency: currency,\n            currencyAsSymbol: currencyAsSymbol,\n        });\n    }\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a number according to locale rules.\n     * @howToUse `number_expression | number[:digitInfo]`\n     *\n     * Formats a number as text. Group sizing and separator and other locale-specific\n     * configurations are based on the active locale.\n     *\n     * where `expression` is a number:\n     *  - `digitInfo` is a `string` which has a following format: <br>\n     *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>\n     *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.\n     *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.\n     *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.\n     *\n     * For more information on the acceptable range for each of these numbers and other\n     * details see your native internationalization library.\n     *\n     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/number_pipe.ts region='NumberPipe'}\n     *\n     * @stable\n     */\n    var DecimalPipe = (function () {\n        function DecimalPipe(_locale) {\n            this._locale = _locale;\n        }\n        DecimalPipe.prototype.transform = function (value, digits) {\n            if (digits === void 0) { digits = null; }\n            return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);\n        };\n        DecimalPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'number' },] },\n        ];\n        /** @nocollapse */\n        DecimalPipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return DecimalPipe;\n    }());\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a number as a percentage according to locale rules.\n     * @howToUse `number_expression | percent[:digitInfo]`\n     *\n     * @description\n     *\n     * Formats a number as percentage.\n     *\n     * - `digitInfo` See {@link DecimalPipe} for detailed description.\n     *\n     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/number_pipe.ts region='PercentPipe'}\n     *\n     * @stable\n     */\n    var PercentPipe = (function () {\n        function PercentPipe(_locale) {\n            this._locale = _locale;\n        }\n        PercentPipe.prototype.transform = function (value, digits) {\n            if (digits === void 0) { digits = null; }\n            return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);\n        };\n        PercentPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'percent' },] },\n        ];\n        /** @nocollapse */\n        PercentPipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return PercentPipe;\n    }());\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Formats a number as currency using locale rules.\n     * @howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`\n     * @description\n     *\n     * Use `currency` to format a number as currency.\n     *\n     * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such\n     *    as `USD` for the US dollar and `EUR` for the euro.\n     * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.\n     *   - `true`: use symbol (e.g. `$`).\n     *   - `false`(default): use code (e.g. `USD`).\n     * - `digitInfo` See {@link DecimalPipe} for detailed description.\n     *\n     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers\n     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}\n     *\n     * @stable\n     */\n    var CurrencyPipe = (function () {\n        function CurrencyPipe(_locale) {\n            this._locale = _locale;\n        }\n        CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {\n            if (currencyCode === void 0) { currencyCode = 'USD'; }\n            if (symbolDisplay === void 0) { symbolDisplay = false; }\n            if (digits === void 0) { digits = null; }\n            return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);\n        };\n        CurrencyPipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'currency' },] },\n        ];\n        /** @nocollapse */\n        CurrencyPipe.ctorParameters = [\n            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },\n        ];\n        return CurrencyPipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Creates a new List or String containing a subset (slice) of the elements.\n     * @howToUse `array_or_string_expression | slice:start[:end]`\n     * @description\n     *\n     * Where the input expression is a `List` or `String`, and:\n     * - `start`: The starting index of the subset to return.\n     *   - **a positive integer**: return the item at `start` index and all items after\n     *     in the list or string expression.\n     *   - **a negative integer**: return the item at `start` index from the end and all items after\n     *     in the list or string expression.\n     *   - **if positive and greater than the size of the expression**: return an empty list or string.\n     *   - **if negative and greater than the size of the expression**: return entire list or string.\n     * - `end`: The ending index of the subset to return.\n     *   - **omitted**: return all items until the end.\n     *   - **if positive**: return all items before `end` index of the list or string.\n     *   - **if negative**: return all items before `end` index from the end of the list or string.\n     *\n     * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`\n     * and `String.prototype.slice()`.\n     *\n     * When operating on a [List], the returned list is always a copy even when all\n     * the elements are being returned.\n     *\n     * When operating on a blank value, the pipe returns the blank value.\n     *\n     * ## List Example\n     *\n     * This `ngFor` example:\n     *\n     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}\n     *\n     * produces the following:\n     *\n     *     <li>b</li>\n     *     <li>c</li>\n     *\n     * ## String Examples\n     *\n     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}\n     *\n     * @stable\n     */\n    var SlicePipe = (function () {\n        function SlicePipe() {\n        }\n        SlicePipe.prototype.transform = function (value, start, end) {\n            if (isBlank(value))\n                return value;\n            if (!this.supports(value)) {\n                throw new InvalidPipeArgumentError(SlicePipe, value);\n            }\n            return value.slice(start, end);\n        };\n        SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };\n        SlicePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },\n        ];\n        /** @nocollapse */\n        SlicePipe.ctorParameters = [];\n        return SlicePipe;\n    }());\n\n    /**\n     * @ngModule CommonModule\n     * @whatItDoes Transforms string to uppercase.\n     * @howToUse `expression | uppercase`\n     * @description\n     *\n     * Converts value into an uppercase string using `String.prototype.toUpperCase()`.\n     *\n     * ### Example\n     *\n     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}\n     *\n     * @stable\n     */\n    var UpperCasePipe = (function () {\n        function UpperCasePipe() {\n        }\n        UpperCasePipe.prototype.transform = function (value) {\n            if (isBlank(value))\n                return value;\n            if (typeof value !== 'string') {\n                throw new InvalidPipeArgumentError(UpperCasePipe, value);\n            }\n            return value.toUpperCase();\n        };\n        UpperCasePipe.decorators = [\n            { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },\n        ];\n        /** @nocollapse */\n        UpperCasePipe.ctorParameters = [];\n        return UpperCasePipe;\n    }());\n\n    /**\n     * A collection of Angular pipes that are likely to be used in each and every application.\n     */\n    var COMMON_PIPES = [\n        AsyncPipe,\n        UpperCasePipe,\n        LowerCasePipe,\n        JsonPipe,\n        SlicePipe,\n        DecimalPipe,\n        PercentPipe,\n        CurrencyPipe,\n        DatePipe,\n        I18nPluralPipe,\n        I18nSelectPipe,\n    ];\n\n    // Note: This does not contain the location providers,\n    // as they need some platform specific implementations to work.\n    /**\n     * The module that includes all the basic Angular directives like {@link NgIf}, {@link NgFor}, ...\n     *\n     * @stable\n     */\n    var CommonModule = (function () {\n        function CommonModule() {\n        }\n        CommonModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        declarations: [COMMON_DIRECTIVES, COMMON_PIPES],\n                        exports: [COMMON_DIRECTIVES, COMMON_PIPES],\n                        providers: [\n                            { provide: NgLocalization, useClass: NgLocaleLocalization },\n                        ],\n                    },] },\n        ];\n        /** @nocollapse */\n        CommonModule.ctorParameters = [];\n        return CommonModule;\n    }());\n\n    exports.NgLocalization = NgLocalization;\n    exports.CommonModule = CommonModule;\n    exports.NgClass = NgClass;\n    exports.NgFor = NgFor;\n    exports.NgIf = NgIf;\n    exports.NgPlural = NgPlural;\n    exports.NgPluralCase = NgPluralCase;\n    exports.NgStyle = NgStyle;\n    exports.NgSwitch = NgSwitch;\n    exports.NgSwitchCase = NgSwitchCase;\n    exports.NgSwitchDefault = NgSwitchDefault;\n    exports.NgTemplateOutlet = NgTemplateOutlet;\n    exports.AsyncPipe = AsyncPipe;\n    exports.DatePipe = DatePipe;\n    exports.I18nPluralPipe = I18nPluralPipe;\n    exports.I18nSelectPipe = I18nSelectPipe;\n    exports.JsonPipe = JsonPipe;\n    exports.LowerCasePipe = LowerCasePipe;\n    exports.CurrencyPipe = CurrencyPipe;\n    exports.DecimalPipe = DecimalPipe;\n    exports.PercentPipe = PercentPipe;\n    exports.SlicePipe = SlicePipe;\n    exports.UpperCasePipe = UpperCasePipe;\n    exports.PlatformLocation = PlatformLocation;\n    exports.LocationStrategy = LocationStrategy;\n    exports.APP_BASE_HREF = APP_BASE_HREF;\n    exports.HashLocationStrategy = HashLocationStrategy;\n    exports.PathLocationStrategy = PathLocationStrategy;\n    exports.Location = Location;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2NvbW1vbi9idW5kbGVzL2NvbW1vbi51bWQuanM/ZDk4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJDQUEyQztBQUNwRixDQUFDLHlDQUF5Qzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUUsK0JBQStCO0FBQy9CLDZEQUE2RCxnQ0FBZ0M7QUFDN0Y7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUIseUJBQXlCLGVBQWU7QUFDdkU7QUFDQSxZQUFZLGFBQWEsc0VBQXNFO0FBQy9GLGNBQWM7QUFDZCxRQUFRLGVBQWUsSUFBSSx1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWEsRUFBRTtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEJBQThCLGFBQWEsRUFBRTtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEJBQThCLGFBQWEsRUFBRTtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJCQUEyQixNQUFNLDJCQUEyQjtBQUNwRTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0Esb0NBQW9DLGFBQWEsS0FBSyxlQUFlO0FBQ3JFO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pELHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsMkJBQTJCO0FBQ25DO0FBQ0Esd0JB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUMsb0JBQW9CLElBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxXQUFXLEdBQUcsWUFBWTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQTBEO0FBQ3ZGO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjIuMFxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5jb21tb24gPSBnbG9iYWwubmcuY29tbW9uIHx8IHt9KSxnbG9iYWwubmcuY29yZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSBieSBhbiBhcHBsaWNhdGlvbiBkZXZlbG9wZXIuIEluc3RlYWQsIHVzZVxuICAgICAqIHtAbGluayBMb2NhdGlvbn0uXG4gICAgICpcbiAgICAgKiBgUGxhdGZvcm1Mb2NhdGlvbmAgZW5jYXBzdWxhdGVzIGFsbCBjYWxscyB0byBET00gYXBpcywgd2hpY2ggYWxsb3dzIHRoZSBSb3V0ZXIgdG8gYmUgcGxhdGZvcm1cbiAgICAgKiBhZ25vc3RpYy5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgd2UgY2FuIGhhdmUgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uIG9mIGBQbGF0Zm9ybUxvY2F0aW9uYCBmb3IgdGhlIGRpZmZlcmVudFxuICAgICAqIHBsYXRmb3Jtc1xuICAgICAqIHRoYXQgYW5ndWxhciBzdXBwb3J0cy4gRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IGBQbGF0Zm9ybUxvY2F0aW9uYCBpcyB7QGxpbmtcbiAgICAgKiBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbn0sXG4gICAgICogaG93ZXZlciB3aGVuIHlvdSBydW4geW91ciBhcHAgaW4gYSBXZWJXb3JrZXIgeW91IHVzZSB7QGxpbmsgV2ViV29ya2VyUGxhdGZvcm1Mb2NhdGlvbn0uXG4gICAgICpcbiAgICAgKiBUaGUgYFBsYXRmb3JtTG9jYXRpb25gIGNsYXNzIGlzIHVzZWQgZGlyZWN0bHkgYnkgYWxsIGltcGxlbWVudGF0aW9ucyBvZiB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX1cbiAgICAgKiB3aGVuXG4gICAgICogdGhleSBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhlIERPTSBhcGlzIGxpa2UgcHVzaFN0YXRlLCBwb3BTdGF0ZSwgZXRjLi4uXG4gICAgICpcbiAgICAgKiB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gaW4gdHVybiBpcyB1c2VkIGJ5IHRoZSB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2Ugd2hpY2ggaXMgdXNlZCBkaXJlY3RseVxuICAgICAqIGJ5XG4gICAgICogdGhlIHtAbGluayBSb3V0ZXJ9IGluIG9yZGVyIHRvIG5hdmlnYXRlIGJldHdlZW4gcm91dGVzLiBTaW5jZSBhbGwgaW50ZXJhY3Rpb25zIGJldHdlZW4ge0BsaW5rXG4gICAgICogUm91dGVyfSAvXG4gICAgICoge0BsaW5rIExvY2F0aW9ufSAvIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBhbmQgRE9NIGFwaXMgZmxvdyB0aHJvdWdoIHRoZSBgUGxhdGZvcm1Mb2NhdGlvbmBcbiAgICAgKiBjbGFzc1xuICAgICAqIHRoZXkgYXJlIGFsbCBwbGF0Zm9ybSBpbmRlcGVuZGVudC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGxhdGZvcm1Mb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtTG9jYXRpb24oKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInBhdGhuYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhhc2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtTG9jYXRpb247XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIGBMb2NhdGlvblN0cmF0ZWd5YCBpcyByZXNwb25zaWJsZSBmb3IgcmVwcmVzZW50aW5nIGFuZCByZWFkaW5nIHJvdXRlIHN0YXRlXG4gICAgICogZnJvbSB0aGUgYnJvd3NlcidzIFVSTC4gQW5ndWxhciBwcm92aWRlcyB0d28gc3RyYXRlZ2llczpcbiAgICAgKiB7QGxpbmsgSGFzaExvY2F0aW9uU3RyYXRlZ3l9IGFuZCB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9IChkZWZhdWx0KS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZCB1bmRlciB0aGUgaG9vZCBvZiB0aGUge0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhlIHtAbGluayBSb3V0ZXJ9IG9yIHtAbGluayBMb2NhdGlvbn0gc2VydmljZXMgdG9cbiAgICAgKiBpbnRlcmFjdCB3aXRoIGFwcGxpY2F0aW9uIHJvdXRlIHN0YXRlLlxuICAgICAqXG4gICAgICogRm9yIGluc3RhbmNlLCB7QGxpbmsgSGFzaExvY2F0aW9uU3RyYXRlZ3l9IHByb2R1Y2VzIFVSTHMgbGlrZVxuICAgICAqIGBodHRwOi8vZXhhbXBsZS5jb20jL2Zvb2AsIGFuZCB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9IHByb2R1Y2VzXG4gICAgICogYGh0dHA6Ly9leGFtcGxlLmNvbS9mb29gIGFzIGFuIGVxdWl2YWxlbnQgVVJMLlxuICAgICAqXG4gICAgICogU2VlIHRoZXNlIHR3byBjbGFzc2VzIGZvciBtb3JlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBMb2NhdGlvblN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9jYXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTG9jYXRpb25TdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBgQVBQX0JBU0VfSFJFRmAgdG9rZW4gcmVwcmVzZW50cyB0aGUgYmFzZSBocmVmIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICAgKiB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9LlxuICAgICAqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0sIHlvdSBtdXN0IHByb3ZpZGUgYSBwcm92aWRlciB0byBhIHN0cmluZ1xuICAgICAqIHJlcHJlc2VudGluZyB0aGUgVVJMIHByZWZpeCB0aGF0IHNob3VsZCBiZSBwcmVzZXJ2ZWQgd2hlbiBnZW5lcmF0aW5nIGFuZCByZWNvZ25pemluZ1xuICAgICAqIFVSTHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7Q29tcG9uZW50LCBOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHtBUFBfQkFTRV9IUkVGfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBBUFBfQkFTRV9IUkVGLCB1c2VWYWx1ZTogJy9teS9hcHAnfV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcE1vZHVsZSB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBUFBfQkFTRV9IUkVGID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ2FwcEJhc2VIcmVmJyk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIGdsb2JhbFNjb3BlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gZ2xvYmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbiAgICB9XG4gICAgLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4gICAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgICB2YXIgX2dsb2JhbCA9IGdsb2JhbFNjb3BlO1xuICAgIGZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVbJ25hbWUnXSB8fCB0eXBlb2YgdHlwZTtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlIGNhbGxzIHRvIGFzc2VydCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4gICAgLy8gTm90ZTogQ2FuJ3QganVzdCBleHBvcnQgdGhpcyBhbmQgaW1wb3J0IGluIGluIG90aGVyIGZpbGVzXG4gICAgLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbiAgICBfZ2xvYmFsLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKG9iai52YWx1ZU9mKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ub3ZlcnJpZGRlbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbiAgICB9XG4gICAgdmFyIE51bWJlcldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLmlzTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIWlzTmFOKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgICByZXR1cm4gTnVtYmVyV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG8gPT09ICdvYmplY3QnKTtcbiAgICB9XG4gICAgdmFyIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XG4gICAgZnVuY3Rpb24gZ2V0U3ltYm9sSXRlcmF0b3IoKSB7XG4gICAgICAgIGlmICghX3N5bWJvbEl0ZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsU2NvcGUuU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIF9zeW1ib2xJdGVyYXRvciA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzNi1zaGltIHNwZWNpZmljIGxvZ2ljXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtrZXldID09PSBNYXAucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zeW1ib2xJdGVyYXRvciA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N5bWJvbEl0ZXJhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGBMb2NhdGlvbmAgaXMgYSBzZXJ2aWNlIHRoYXQgYXBwbGljYXRpb25zIGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCBhIGJyb3dzZXIncyBVUkwuXG4gICAgICogRGVwZW5kaW5nIG9uIHdoaWNoIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBpcyB1c2VkLCBgTG9jYXRpb25gIHdpbGwgZWl0aGVyIHBlcnNpc3RcbiAgICAgKiB0byB0aGUgVVJMJ3MgcGF0aCBvciB0aGUgVVJMJ3MgaGFzaCBzZWdtZW50LlxuICAgICAqXG4gICAgICogTm90ZTogaXQncyBiZXR0ZXIgdG8gdXNlIHtAbGluayBSb3V0ZXIjbmF2aWdhdGV9IHNlcnZpY2UgdG8gdHJpZ2dlciByb3V0ZSBjaGFuZ2VzLiBVc2VcbiAgICAgKiBgTG9jYXRpb25gIG9ubHkgaWYgeW91IG5lZWQgdG8gaW50ZXJhY3Qgd2l0aCBvciBjcmVhdGUgbm9ybWFsaXplZCBVUkxzIG91dHNpZGUgb2ZcbiAgICAgKiByb3V0aW5nLlxuICAgICAqXG4gICAgICogYExvY2F0aW9uYCBpcyByZXNwb25zaWJsZSBmb3Igbm9ybWFsaXppbmcgdGhlIFVSTCBhZ2FpbnN0IHRoZSBhcHBsaWNhdGlvbidzIGJhc2UgaHJlZi5cbiAgICAgKiBBIG5vcm1hbGl6ZWQgVVJMIGlzIGFic29sdXRlIGZyb20gdGhlIFVSTCBob3N0LCBpbmNsdWRlcyB0aGUgYXBwbGljYXRpb24ncyBiYXNlIGhyZWYsIGFuZCBoYXMgbm9cbiAgICAgKiB0cmFpbGluZyBzbGFzaDpcbiAgICAgKiAtIGAvbXkvYXBwL3VzZXIvMTIzYCBpcyBub3JtYWxpemVkXG4gICAgICogLSBgbXkvYXBwL3VzZXIvMTIzYCAqKmlzIG5vdCoqIG5vcm1hbGl6ZWRcbiAgICAgKiAtIGAvbXkvYXBwL3VzZXIvMTIzL2AgKippcyBub3QqKiBub3JtYWxpemVkXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7TG9jYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gICAgICpcbiAgICAgKiBAQ29tcG9uZW50KHtzZWxlY3RvcjogJ2FwcC1jb21wb25lbnQnfSlcbiAgICAgKiBjbGFzcyBBcHBDbXAge1xuICAgICAqICAgY29uc3RydWN0b3IobG9jYXRpb246IExvY2F0aW9uKSB7XG4gICAgICogICAgIGxvY2F0aW9uLmdvKCcvZm9vJyk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBMb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExvY2F0aW9uKHBsYXRmb3JtU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5ID0gcGxhdGZvcm1TdHJhdGVneTtcbiAgICAgICAgICAgIHZhciBicm93c2VyQmFzZUhyZWYgPSB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LmdldEJhc2VIcmVmKCk7XG4gICAgICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBJbmRleEh0bWwoYnJvd3NlckJhc2VIcmVmKSk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5Lm9uUG9wU3RhdGUoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1YmplY3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICd1cmwnOiBfdGhpcy5wYXRoKHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAncG9wJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBldi50eXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIHBhdGguXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPOiB2c2F2a2luLiBSZW1vdmUgdGhlIGJvb2xlYW4gZmxhZyBhbmQgYWx3YXlzIGluY2x1ZGUgaGFzaCBvbmNlIHRoZSBkZXByZWNhdGVkIHJvdXRlciBpc1xuICAgICAgICAvLyByZW1vdmVkLlxuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChpbmNsdWRlSGFzaCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVIYXNoID09PSB2b2lkIDApIHsgaW5jbHVkZUhhc2ggPSBmYWxzZTsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kucGF0aChpbmNsdWRlSGFzaCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gcGF0aCBhbmQgY29tcGFyZXMgdG8gdGhlIGN1cnJlbnQgbm9ybWFsaXplZCBwYXRoLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLmlzQ3VycmVudFBhdGhFcXVhbFRvID0gZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9ICcnOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoKCkgPT0gdGhpcy5ub3JtYWxpemUocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwsIHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIHBhdGggd2l0aG91dCBsZWFkaW5nIG9yXG4gICAgICAgICAqIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBCYXNlSHJlZih0aGlzLl9iYXNlSHJlZiwgX3N0cmlwSW5kZXhIdG1sKHVybCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFVSTCwgcmV0dXJucyB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgZXh0ZXJuYWwgVVJMIHBhdGguXG4gICAgICAgICAqIElmIHRoZSBnaXZlbiBVUkwgZG9lc24ndCBiZWdpbiB3aXRoIGEgbGVhZGluZyBzbGFzaCAoYCcvJ2ApLCB0aGlzIG1ldGhvZCBhZGRzIG9uZVxuICAgICAgICAgKiBiZWZvcmUgbm9ybWFsaXppbmcuIFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBhZGQgYSBoYXNoIGlmIGBIYXNoTG9jYXRpb25TdHJhdGVneWAgaXNcbiAgICAgICAgICogdXNlZCwgb3IgdGhlIGBBUFBfQkFTRV9IUkVGYCBpZiB0aGUgYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyBpbiB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUucHJlcGFyZUV4dGVybmFsVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggPiAwICYmICF1cmwuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gJy8nICsgdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kucHJlcGFyZUV4dGVybmFsVXJsKHVybCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IHJlbmFtZSB0aGlzIG1ldGhvZCB0byBwdXNoU3RhdGVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZXMgdGhlIGJyb3dzZXJzIFVSTCB0byB0aGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBVUkwsIGFuZCBwdXNoZXMgYVxuICAgICAgICAgKiBuZXcgaXRlbSBvbnRvIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAocGF0aCwgcXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0gJyc7IH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kucHVzaFN0YXRlKG51bGwsICcnLCBwYXRoLCBxdWVyeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBicm93c2VycyBVUkwgdG8gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLCBhbmQgcmVwbGFjZXNcbiAgICAgICAgICogdGhlIHRvcCBpdGVtIG9uIHRoZSBwbGF0Zm9ybSdzIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9ICcnOyB9XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnJlcGxhY2VTdGF0ZShudWxsLCAnJywgcGF0aCwgcXVlcnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTmF2aWdhdGVzIGZvcndhcmQgaW4gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeS5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LmZvcndhcmQoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hdmlnYXRlcyBiYWNrIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5iYWNrKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIHBsYXRmb3JtJ3MgYHBvcFN0YXRlYCBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9uTmV4dCwgb25UaHJvdywgb25SZXR1cm4pIHtcbiAgICAgICAgICAgIGlmIChvblRocm93ID09PSB2b2lkIDApIHsgb25UaHJvdyA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChvblJldHVybiA9PT0gdm9pZCAwKSB7IG9uUmV0dXJuID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Quc3Vic2NyaWJlKHsgbmV4dDogb25OZXh0LCBlcnJvcjogb25UaHJvdywgY29tcGxldGU6IG9uUmV0dXJuIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBzdHJpbmcgb2YgdXJsIHBhcmFtZXRlcnMsIHByZXBlbmQgd2l0aCAnPycgaWYgbmVlZGVkLCBvdGhlcndpc2UgcmV0dXJuIHBhcmFtZXRlcnMgYXNcbiAgICAgICAgICogaXMuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgcGFyYW1zLnN1YnN0cmluZygwLCAxKSAhPSAnPycpID8gKCc/JyArIHBhcmFtcykgOiBwYXJhbXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiAyIHBhcnRzIG9mIGEgdXJsLCBqb2luIHRoZW0gd2l0aCBhIHNsYXNoIGlmIG5lZWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLmpvaW5XaXRoU2xhc2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2xhc2hlcyA9IDA7XG4gICAgICAgICAgICBpZiAoc3RhcnQuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHNsYXNoZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgc2xhc2hlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsYXNoZXMgPT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCArIGVuZC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2xhc2hlcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgJy8nICsgZW5kO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdXJsIGhhcyBhIHRyYWlsaW5nIHNsYXNoLCByZW1vdmUgaXQsIG90aGVyd2lzZSByZXR1cm4gdXJsIGFzIGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24uc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaWYgKC9cXC8kL2cudGVzdCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9O1xuICAgICAgICBMb2NhdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIExvY2F0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBMb2NhdGlvblN0cmF0ZWd5LCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTG9jYXRpb247XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfc3RyaXBCYXNlSHJlZihiYXNlSHJlZiwgdXJsKSB7XG4gICAgICAgIGlmIChiYXNlSHJlZi5sZW5ndGggPiAwICYmIHVybC5zdGFydHNXaXRoKGJhc2VIcmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoYmFzZUhyZWYubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc3RyaXBJbmRleEh0bWwodXJsKSB7XG4gICAgICAgIGlmICgvXFwvaW5kZXguaHRtbCQvZy50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgIC8vICcvaW5kZXguaHRtbCcubGVuZ3RoID09IDExXG4gICAgICAgICAgICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgIGlzIGEge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IHVzZWQgdG8gY29uZmlndXJlIHRoZVxuICAgICAqIHtAbGluayBMb2NhdGlvbn0gc2VydmljZSB0byByZXByZXNlbnQgaXRzIHN0YXRlIGluIHRoZVxuICAgICAqIFtoYXNoIGZyYWdtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbmlmb3JtX1Jlc291cmNlX0xvY2F0b3IjU3ludGF4KVxuICAgICAqIG9mIHRoZSBicm93c2VyJ3MgVVJMLlxuICAgICAqXG4gICAgICogRm9yIGluc3RhbmNlLCBpZiB5b3UgY2FsbCBgbG9jYXRpb24uZ28oJy9mb28nKWAsIHRoZSBicm93c2VyJ3MgVVJMIHdpbGwgYmVjb21lXG4gICAgICogYGV4YW1wbGUuY29tIy9mb29gLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7Q29tcG9uZW50LCBOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHtcbiAgICAgKiAgIExvY2F0aW9uU3RyYXRlZ3ksXG4gICAgICogICBIYXNoTG9jYXRpb25TdHJhdGVneVxuICAgICAqIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbiAgICAgKlxuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBwcm92aWRlcnM6IFt7cHJvdmlkZTogTG9jYXRpb25TdHJhdGVneSwgdXNlQ2xhc3M6IEhhc2hMb2NhdGlvblN0cmF0ZWd5fV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcE1vZHVsZSB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBIYXNoTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhIYXNoTG9jYXRpb25TdHJhdGVneSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSGFzaExvY2F0aW9uU3RyYXRlZ3koX3BsYXRmb3JtTG9jYXRpb24sIF9iYXNlSHJlZikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uID0gX3BsYXRmb3JtTG9jYXRpb247XG4gICAgICAgICAgICB0aGlzLl9iYXNlSHJlZiA9ICcnO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChfYmFzZUhyZWYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSBfYmFzZUhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLm9uUG9wU3RhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ub25Qb3BTdGF0ZShmbik7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uSGFzaENoYW5nZShmbik7XG4gICAgICAgIH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jhc2VIcmVmOyB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChpbmNsdWRlSGFzaCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVIYXNoID09PSB2b2lkIDApIHsgaW5jbHVkZUhhc2ggPSBmYWxzZTsgfVxuICAgICAgICAgICAgLy8gdGhlIGhhc2ggdmFsdWUgaXMgYWx3YXlzIHByZWZpeGVkIHdpdGggYSBgI2BcbiAgICAgICAgICAgIC8vIGFuZCBpZiBpdCBpcyBlbXB0eSB0aGVuIGl0IHdpbGwgc3RheSBlbXB0eVxuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmhhc2g7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChwYXRoKSlcbiAgICAgICAgICAgICAgICBwYXRoID0gJyMnO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aDtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnByZXBhcmVFeHRlcm5hbFVybCA9IGZ1bmN0aW9uIChpbnRlcm5hbCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IExvY2F0aW9uLmpvaW5XaXRoU2xhc2godGhpcy5fYmFzZUhyZWYsIGludGVybmFsKTtcbiAgICAgICAgICAgIHJldHVybiB1cmwubGVuZ3RoID4gMCA/ICgnIycgKyB1cmwpIDogdXJsO1xuICAgICAgICB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnByZXBhcmVFeHRlcm5hbFVybChwYXRoICsgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpKTtcbiAgICAgICAgICAgIGlmICh1cmwubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICAgICAgICB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnByZXBhcmVFeHRlcm5hbFVybChwYXRoICsgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpKTtcbiAgICAgICAgICAgIGlmICh1cmwubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICAgICAgICB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5mb3J3YXJkKCk7IH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmJhY2soKTsgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogUGxhdGZvcm1Mb2NhdGlvbiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtBUFBfQkFTRV9IUkVGLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBIYXNoTG9jYXRpb25TdHJhdGVneTtcbiAgICB9KExvY2F0aW9uU3RyYXRlZ3kpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgUGF0aExvY2F0aW9uU3RyYXRlZ3lgIGlzIGEge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IHVzZWQgdG8gY29uZmlndXJlIHRoZVxuICAgICAqIHtAbGluayBMb2NhdGlvbn0gc2VydmljZSB0byByZXByZXNlbnQgaXRzIHN0YXRlIGluIHRoZVxuICAgICAqIFtwYXRoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbmlmb3JtX1Jlc291cmNlX0xvY2F0b3IjU3ludGF4KSBvZiB0aGVcbiAgICAgKiBicm93c2VyJ3MgVVJMLlxuICAgICAqXG4gICAgICogYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyB0aGUgZGVmYXVsdCBiaW5kaW5nIGZvciB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX1cbiAgICAgKiBwcm92aWRlZCBpbiB7QGxpbmsgUk9VVEVSX1BST1ZJREVSU30uXG4gICAgICpcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCwgeW91IG11c3QgcHJvdmlkZSBhIHtAbGluayBBUFBfQkFTRV9IUkVGfVxuICAgICAqIG9yIGFkZCBhIGJhc2UgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQuIFRoaXMgVVJMIHByZWZpeCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkXG4gICAgICogd2hlbiBnZW5lcmF0aW5nIGFuZCByZWNvZ25pemluZyBVUkxzLlxuICAgICAqXG4gICAgICogRm9yIGluc3RhbmNlLCBpZiB5b3UgcHJvdmlkZSBhbiBgQVBQX0JBU0VfSFJFRmAgb2YgYCcvbXkvYXBwJ2AgYW5kIGNhbGxcbiAgICAgKiBgbG9jYXRpb24uZ28oJy9mb28nKWAsIHRoZSBicm93c2VyJ3MgVVJMIHdpbGwgYmVjb21lXG4gICAgICogYGV4YW1wbGUuY29tL215L2FwcC9mb29gLlxuICAgICAqXG4gICAgICogU2ltaWxhcmx5LCBpZiB5b3UgYWRkIGA8YmFzZSBocmVmPScvbXkvYXBwJy8+YCB0byB0aGUgZG9jdW1lbnQgYW5kIGNhbGxcbiAgICAgKiBgbG9jYXRpb24uZ28oJy9mb28nKWAsIHRoZSBicm93c2VyJ3MgVVJMIHdpbGwgYmVjb21lXG4gICAgICogYGV4YW1wbGUuY29tL215L2FwcC9mb29gLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQYXRoTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKFBhdGhMb2NhdGlvblN0cmF0ZWd5LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBQYXRoTG9jYXRpb25TdHJhdGVneShfcGxhdGZvcm1Mb2NhdGlvbiwgaHJlZikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uID0gX3BsYXRmb3JtTG9jYXRpb247XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhocmVmKSkge1xuICAgICAgICAgICAgICAgIGhyZWYgPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmdldEJhc2VIcmVmRnJvbURPTSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmxhbmsoaHJlZikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBiYXNlIGhyZWYgc2V0LiBQbGVhc2UgcHJvdmlkZSBhIHZhbHVlIGZvciB0aGUgQVBQX0JBU0VfSFJFRiB0b2tlbiBvciBhZGQgYSBiYXNlIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gaHJlZjtcbiAgICAgICAgfVxuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5vblBvcFN0YXRlKGZuKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ub25IYXNoQ2hhbmdlKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYmFzZUhyZWY7IH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wcmVwYXJlRXh0ZXJuYWxVcmwgPSBmdW5jdGlvbiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2NhdGlvbi5qb2luV2l0aFNsYXNoKHRoaXMuX2Jhc2VIcmVmLCBpbnRlcm5hbCk7XG4gICAgICAgIH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKGluY2x1ZGVIYXNoKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUhhc2ggPT09IHZvaWQgMCkgeyBpbmNsdWRlSGFzaCA9IGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgcGF0aG5hbWUgPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgICAgICAgICAgICBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyh0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAgIHJldHVybiBoYXNoICYmIGluY2x1ZGVIYXNoID8gXCJcIiArIHBhdGhuYW1lICsgaGFzaCA6IHBhdGhuYW1lO1xuICAgICAgICB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCBxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGV4dGVybmFsVXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsICsgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgZXh0ZXJuYWxVcmwpO1xuICAgICAgICB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCBxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGV4dGVybmFsVXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsICsgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgZXh0ZXJuYWxVcmwpO1xuICAgICAgICB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5mb3J3YXJkKCk7IH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmJhY2soKTsgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogUGxhdGZvcm1Mb2NhdGlvbiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtBUFBfQkFTRV9IUkVGLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBQYXRoTG9jYXRpb25TdHJhdGVneTtcbiAgICB9KExvY2F0aW9uU3RyYXRlZ3kpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nTG9jYWxpemF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdMb2NhbGl6YXRpb24oKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5nTG9jYWxpemF0aW9uO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGx1cmFsIGNhdGVnb3J5IGZvciBhIGdpdmVuIHZhbHVlLlxuICAgICAqIC0gXCI9dmFsdWVcIiB3aGVuIHRoZSBjYXNlIGV4aXN0cyxcbiAgICAgKiAtIHRoZSBwbHVyYWwgY2F0ZWdvcnkgb3RoZXJ3aXNlXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQbHVyYWxDYXRlZ29yeSh2YWx1ZSwgY2FzZXMsIG5nTG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHZhciBuYkNhc2UgPSBcIj1cIiArIHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FzZXMuaW5kZXhPZihuYkNhc2UpID4gLTEgPyBuYkNhc2UgOiBuZ0xvY2FsaXphdGlvbi5nZXRQbHVyYWxDYXRlZ29yeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBsdXJhbCBjYXNlIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdMb2NhbGVMb2NhbGl6YXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihOZ0xvY2FsZUxvY2FsaXphdGlvbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdMb2NhbGVMb2NhbGl6YXRpb24oX2xvY2FsZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIE5nTG9jYWxlTG9jYWxpemF0aW9uLnByb3RvdHlwZS5nZXRQbHVyYWxDYXRlZ29yeSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBsdXJhbCA9IGdldFBsdXJhbENhc2UodGhpcy5fbG9jYWxlLCB2YWx1ZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBsdXJhbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLlplcm86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnemVybyc7XG4gICAgICAgICAgICAgICAgY2FzZSBQbHVyYWwuT25lOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ29uZSc7XG4gICAgICAgICAgICAgICAgY2FzZSBQbHVyYWwuVHdvOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3R3byc7XG4gICAgICAgICAgICAgICAgY2FzZSBQbHVyYWwuRmV3OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zldyc7XG4gICAgICAgICAgICAgICAgY2FzZSBQbHVyYWwuTWFueTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtYW55JztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdMb2NhbGVMb2NhbGl6YXRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0xvY2FsZUxvY2FsaXphdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuTE9DQUxFX0lELF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOZ0xvY2FsZUxvY2FsaXphdGlvbjtcbiAgICB9KE5nTG9jYWxpemF0aW9uKSk7XG4gICAgLy8gVGhpcyBpcyBnZW5lcmF0ZWQgY29kZSBETyBOT1QgTU9ESUZZXG4gICAgLy8gc2VlIGFuZ3VsYXIyL3NjcmlwdC9jbGRyL2dlbl9wbHVyYWxfcnVsZXMuanNcbiAgICAvKiogQGV4cGVyaW1lbnRhbCAqL1xuICAgIHZhciBQbHVyYWw7XG4gICAgKGZ1bmN0aW9uIChQbHVyYWwpIHtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIlplcm9cIl0gPSAwXSA9IFwiWmVyb1wiO1xuICAgICAgICBQbHVyYWxbUGx1cmFsW1wiT25lXCJdID0gMV0gPSBcIk9uZVwiO1xuICAgICAgICBQbHVyYWxbUGx1cmFsW1wiVHdvXCJdID0gMl0gPSBcIlR3b1wiO1xuICAgICAgICBQbHVyYWxbUGx1cmFsW1wiRmV3XCJdID0gM10gPSBcIkZld1wiO1xuICAgICAgICBQbHVyYWxbUGx1cmFsW1wiTWFueVwiXSA9IDRdID0gXCJNYW55XCI7XG4gICAgICAgIFBsdXJhbFtQbHVyYWxbXCJPdGhlclwiXSA9IDVdID0gXCJPdGhlclwiO1xuICAgIH0pKFBsdXJhbCB8fCAoUGx1cmFsID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwbHVyYWwgY2FzZSBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGx1cmFsQ2FzZShsb2NhbGUsIG5MaWtlKSB7XG4gICAgICAgIC8vIFRPRE8odmljYik6IGxhenkgY29tcHV0ZVxuICAgICAgICBpZiAodHlwZW9mIG5MaWtlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbkxpa2UgPSBwYXJzZUludChuTGlrZSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gbkxpa2U7XG4gICAgICAgIHZhciBuRGVjaW1hbCA9IG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eW14uXSpcXC4/LywgJycpO1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICB2YXIgdiA9IG5EZWNpbWFsLmxlbmd0aDtcbiAgICAgICAgdmFyIGYgPSBwYXJzZUludChuRGVjaW1hbCwgMTApO1xuICAgICAgICB2YXIgdCA9IHBhcnNlSW50KG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eW14uXSpcXC4/fDArJC9nLCAnJyksIDEwKSB8fCAwO1xuICAgICAgICB2YXIgbGFuZyA9IGxvY2FsZS5zcGxpdCgnLScpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAobGFuZykge1xuICAgICAgICAgICAgY2FzZSAnYWYnOlxuICAgICAgICAgICAgY2FzZSAnYXNhJzpcbiAgICAgICAgICAgIGNhc2UgJ2F6JzpcbiAgICAgICAgICAgIGNhc2UgJ2JlbSc6XG4gICAgICAgICAgICBjYXNlICdiZXonOlxuICAgICAgICAgICAgY2FzZSAnYmcnOlxuICAgICAgICAgICAgY2FzZSAnYnJ4JzpcbiAgICAgICAgICAgIGNhc2UgJ2NlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NnZyc6XG4gICAgICAgICAgICBjYXNlICdjaHInOlxuICAgICAgICAgICAgY2FzZSAnY2tiJzpcbiAgICAgICAgICAgIGNhc2UgJ2VlJzpcbiAgICAgICAgICAgIGNhc2UgJ2VsJzpcbiAgICAgICAgICAgIGNhc2UgJ2VvJzpcbiAgICAgICAgICAgIGNhc2UgJ2VzJzpcbiAgICAgICAgICAgIGNhc2UgJ2V1JzpcbiAgICAgICAgICAgIGNhc2UgJ2ZvJzpcbiAgICAgICAgICAgIGNhc2UgJ2Z1cic6XG4gICAgICAgICAgICBjYXNlICdnc3cnOlxuICAgICAgICAgICAgY2FzZSAnaGEnOlxuICAgICAgICAgICAgY2FzZSAnaGF3JzpcbiAgICAgICAgICAgIGNhc2UgJ2h1JzpcbiAgICAgICAgICAgIGNhc2UgJ2pnbyc6XG4gICAgICAgICAgICBjYXNlICdqbWMnOlxuICAgICAgICAgICAgY2FzZSAna2EnOlxuICAgICAgICAgICAgY2FzZSAna2snOlxuICAgICAgICAgICAgY2FzZSAna2tqJzpcbiAgICAgICAgICAgIGNhc2UgJ2tsJzpcbiAgICAgICAgICAgIGNhc2UgJ2tzJzpcbiAgICAgICAgICAgIGNhc2UgJ2tzYic6XG4gICAgICAgICAgICBjYXNlICdreSc6XG4gICAgICAgICAgICBjYXNlICdsYic6XG4gICAgICAgICAgICBjYXNlICdsZyc6XG4gICAgICAgICAgICBjYXNlICdtYXMnOlxuICAgICAgICAgICAgY2FzZSAnbWdvJzpcbiAgICAgICAgICAgIGNhc2UgJ21sJzpcbiAgICAgICAgICAgIGNhc2UgJ21uJzpcbiAgICAgICAgICAgIGNhc2UgJ25iJzpcbiAgICAgICAgICAgIGNhc2UgJ25kJzpcbiAgICAgICAgICAgIGNhc2UgJ25lJzpcbiAgICAgICAgICAgIGNhc2UgJ25uJzpcbiAgICAgICAgICAgIGNhc2UgJ25uaCc6XG4gICAgICAgICAgICBjYXNlICdueW4nOlxuICAgICAgICAgICAgY2FzZSAnb20nOlxuICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgY2FzZSAnb3MnOlxuICAgICAgICAgICAgY2FzZSAncHMnOlxuICAgICAgICAgICAgY2FzZSAncm0nOlxuICAgICAgICAgICAgY2FzZSAncm9mJzpcbiAgICAgICAgICAgIGNhc2UgJ3J3ayc6XG4gICAgICAgICAgICBjYXNlICdzYXEnOlxuICAgICAgICAgICAgY2FzZSAnc2VoJzpcbiAgICAgICAgICAgIGNhc2UgJ3NuJzpcbiAgICAgICAgICAgIGNhc2UgJ3NvJzpcbiAgICAgICAgICAgIGNhc2UgJ3NxJzpcbiAgICAgICAgICAgIGNhc2UgJ3RhJzpcbiAgICAgICAgICAgIGNhc2UgJ3RlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Rlbyc6XG4gICAgICAgICAgICBjYXNlICd0ayc6XG4gICAgICAgICAgICBjYXNlICd0cic6XG4gICAgICAgICAgICBjYXNlICd1Zyc6XG4gICAgICAgICAgICBjYXNlICd1eic6XG4gICAgICAgICAgICBjYXNlICd2byc6XG4gICAgICAgICAgICBjYXNlICd2dW4nOlxuICAgICAgICAgICAgY2FzZSAnd2FlJzpcbiAgICAgICAgICAgIGNhc2UgJ3hvZyc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdhZ3EnOlxuICAgICAgICAgICAgY2FzZSAnYmFzJzpcbiAgICAgICAgICAgIGNhc2UgJ2N1JzpcbiAgICAgICAgICAgIGNhc2UgJ2Rhdic6XG4gICAgICAgICAgICBjYXNlICdkamUnOlxuICAgICAgICAgICAgY2FzZSAnZHVhJzpcbiAgICAgICAgICAgIGNhc2UgJ2R5byc6XG4gICAgICAgICAgICBjYXNlICdlYnUnOlxuICAgICAgICAgICAgY2FzZSAnZXdvJzpcbiAgICAgICAgICAgIGNhc2UgJ2d1eic6XG4gICAgICAgICAgICBjYXNlICdrYW0nOlxuICAgICAgICAgICAgY2FzZSAna2hxJzpcbiAgICAgICAgICAgIGNhc2UgJ2tpJzpcbiAgICAgICAgICAgIGNhc2UgJ2tsbic6XG4gICAgICAgICAgICBjYXNlICdrb2snOlxuICAgICAgICAgICAgY2FzZSAna3NmJzpcbiAgICAgICAgICAgIGNhc2UgJ2xyYyc6XG4gICAgICAgICAgICBjYXNlICdsdSc6XG4gICAgICAgICAgICBjYXNlICdsdW8nOlxuICAgICAgICAgICAgY2FzZSAnbHV5JzpcbiAgICAgICAgICAgIGNhc2UgJ21lcic6XG4gICAgICAgICAgICBjYXNlICdtZmUnOlxuICAgICAgICAgICAgY2FzZSAnbWdoJzpcbiAgICAgICAgICAgIGNhc2UgJ211YSc6XG4gICAgICAgICAgICBjYXNlICdtem4nOlxuICAgICAgICAgICAgY2FzZSAnbm1nJzpcbiAgICAgICAgICAgIGNhc2UgJ251cyc6XG4gICAgICAgICAgICBjYXNlICdxdSc6XG4gICAgICAgICAgICBjYXNlICdybic6XG4gICAgICAgICAgICBjYXNlICdydyc6XG4gICAgICAgICAgICBjYXNlICdzYnAnOlxuICAgICAgICAgICAgY2FzZSAndHdxJzpcbiAgICAgICAgICAgIGNhc2UgJ3ZhaSc6XG4gICAgICAgICAgICBjYXNlICd5YXYnOlxuICAgICAgICAgICAgY2FzZSAneXVlJzpcbiAgICAgICAgICAgIGNhc2UgJ3pnaCc6XG4gICAgICAgICAgICBjYXNlICdhayc6XG4gICAgICAgICAgICBjYXNlICdsbic6XG4gICAgICAgICAgICBjYXNlICdtZyc6XG4gICAgICAgICAgICBjYXNlICdwYSc6XG4gICAgICAgICAgICBjYXNlICd0aSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAwICYmIG4gPD0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FtJzpcbiAgICAgICAgICAgIGNhc2UgJ2FzJzpcbiAgICAgICAgICAgIGNhc2UgJ2JuJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZhJzpcbiAgICAgICAgICAgIGNhc2UgJ2d1JzpcbiAgICAgICAgICAgIGNhc2UgJ2hpJzpcbiAgICAgICAgICAgIGNhc2UgJ2tuJzpcbiAgICAgICAgICAgIGNhc2UgJ21yJzpcbiAgICAgICAgICAgIGNhc2UgJ3p1JzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYXInOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlplcm87XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDk5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FzdCc6XG4gICAgICAgICAgICBjYXNlICdjYSc6XG4gICAgICAgICAgICBjYXNlICdkZSc6XG4gICAgICAgICAgICBjYXNlICdlbic6XG4gICAgICAgICAgICBjYXNlICdldCc6XG4gICAgICAgICAgICBjYXNlICdmaSc6XG4gICAgICAgICAgICBjYXNlICdmeSc6XG4gICAgICAgICAgICBjYXNlICdnbCc6XG4gICAgICAgICAgICBjYXNlICdpdCc6XG4gICAgICAgICAgICBjYXNlICdubCc6XG4gICAgICAgICAgICBjYXNlICdzdic6XG4gICAgICAgICAgICBjYXNlICdzdyc6XG4gICAgICAgICAgICBjYXNlICd1cic6XG4gICAgICAgICAgICBjYXNlICd5aSc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2JlJzpcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSAxICYmICEobiAlIDEwMCA9PT0gMTEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSBNYXRoLmZsb29yKG4gJSAxMCkgJiYgbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiZcbiAgICAgICAgICAgICAgICAgICAgIShuICUgMTAwID49IDEyICYmIG4gJSAxMDAgPD0gMTQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSAwIHx8IG4gJSAxMCA9PT0gTWF0aC5mbG9vcihuICUgMTApICYmIG4gJSAxMCA+PSA1ICYmIG4gJSAxMCA8PSA5IHx8XG4gICAgICAgICAgICAgICAgICAgIG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSAxICYmICEobiAlIDEwMCA9PT0gMTEgfHwgbiAlIDEwMCA9PT0gNzEgfHwgbiAlIDEwMCA9PT0gOTEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSAyICYmICEobiAlIDEwMCA9PT0gMTIgfHwgbiAlIDEwMCA9PT0gNzIgfHwgbiAlIDEwMCA9PT0gOTIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSBNYXRoLmZsb29yKG4gJSAxMCkgJiYgKG4gJSAxMCA+PSAzICYmIG4gJSAxMCA8PSA0IHx8IG4gJSAxMCA9PT0gOSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShuICUgMTAwID49IDEwICYmIG4gJSAxMDAgPD0gMTkgfHwgbiAlIDEwMCA+PSA3MCAmJiBuICUgMTAwIDw9IDc5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuICUgMTAwID49IDkwICYmIG4gJSAxMDAgPD0gOTkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAoIShuID09PSAwKSAmJiBuICUgMWU2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2JzJzpcbiAgICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NyJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IDEgJiYgIShpICUgMTAwID09PSAxMSkgfHwgZiAlIDEwID09PSAxICYmICEoZiAlIDEwMCA9PT0gMTEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gMiAmJiBpICUgMTAgPD0gNCAmJlxuICAgICAgICAgICAgICAgICAgICAhKGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZiAlIDEwID09PSBNYXRoLmZsb29yKGYgJSAxMCkgJiYgZiAlIDEwID49IDIgJiYgZiAlIDEwIDw9IDQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEoZiAlIDEwMCA+PSAxMiAmJiBmICUgMTAwIDw9IDE0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2NzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NrJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gTWF0aC5mbG9vcihpKSAmJiBpID49IDIgJiYgaSA8PSA0ICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICghKHYgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2N5JzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmIChuID09PSA2KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2RhJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSB8fCAhKHQgPT09IDApICYmIChpID09PSAwIHx8IGkgPT09IDEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZHNiJzpcbiAgICAgICAgICAgIGNhc2UgJ2hzYic6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gMSB8fCBmICUgMTAwID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAyIHx8IGYgJSAxMDAgPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IE1hdGguZmxvb3IoaSAlIDEwMCkgJiYgaSAlIDEwMCA+PSAzICYmIGkgJSAxMDAgPD0gNCB8fFxuICAgICAgICAgICAgICAgICAgICBmICUgMTAwID09PSBNYXRoLmZsb29yKGYgJSAxMDApICYmIGYgJSAxMDAgPj0gMyAmJiBmICUgMTAwIDw9IDQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdmZic6XG4gICAgICAgICAgICBjYXNlICdmcic6XG4gICAgICAgICAgICBjYXNlICdoeSc6XG4gICAgICAgICAgICBjYXNlICdrYWInOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdmaWwnOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIChpID09PSAxIHx8IGkgPT09IDIgfHwgaSA9PT0gMykgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMCAmJiAhKGkgJSAxMCA9PT0gNCB8fCBpICUgMTAgPT09IDYgfHwgaSAlIDEwID09PSA5KSB8fFxuICAgICAgICAgICAgICAgICAgICAhKHYgPT09IDApICYmICEoZiAlIDEwID09PSA0IHx8IGYgJSAxMCA9PT0gNiB8fCBmICUgMTAgPT09IDkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZ2EnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAzICYmIG4gPD0gNilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSA3ICYmIG4gPD0gMTApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZ2QnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAxIHx8IG4gPT09IDExKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMiB8fCBuID09PSAxMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgKG4gPj0gMyAmJiBuIDw9IDEwIHx8IG4gPj0gMTMgJiYgbiA8PSAxOSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdndic6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIChpICUgMTAwID09PSAwIHx8IGkgJSAxMDAgPT09IDIwIHx8IGkgJSAxMDAgPT09IDQwIHx8IGkgJSAxMDAgPT09IDYwIHx8IGkgJSAxMDAgPT09IDgwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKCEodiA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnaGUnOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAyICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmICEobiA+PSAwICYmIG4gPD0gMTApICYmIG4gJSAxMCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdpcyc6XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09IDAgJiYgaSAlIDEwID09PSAxICYmICEoaSAlIDEwMCA9PT0gMTEpIHx8ICEodCA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdrc2gnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlplcm87XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdrdyc6XG4gICAgICAgICAgICBjYXNlICduYXEnOlxuICAgICAgICAgICAgY2FzZSAnc2UnOlxuICAgICAgICAgICAgY2FzZSAnc21uJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdsYWcnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlplcm87XG4gICAgICAgICAgICAgICAgaWYgKChpID09PSAwIHx8IGkgPT09IDEpICYmICEobiA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdsdCc6XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSAxOSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IE1hdGguZmxvb3IobiAlIDEwKSAmJiBuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gOSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSAxOSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICghKGYgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2x2JzpcbiAgICAgICAgICAgIGNhc2UgJ3ByZyc6XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMCB8fCBuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSAxOSB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAyICYmIGYgJSAxMDAgPT09IE1hdGguZmxvb3IoZiAlIDEwMCkgJiYgZiAlIDEwMCA+PSAxMSAmJiBmICUgMTAwIDw9IDE5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlplcm87XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPT09IDExKSB8fCB2ID09PSAyICYmIGYgJSAxMCA9PT0gMSAmJiAhKGYgJSAxMDAgPT09IDExKSB8fFxuICAgICAgICAgICAgICAgICAgICAhKHYgPT09IDIpICYmIGYgJSAxMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ21rJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IDEgfHwgZiAlIDEwID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnbXQnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMCB8fCBuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMiAmJiBuICUgMTAwIDw9IDEwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAncGwnOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSAyICYmIGkgJSAxMCA8PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICEoaSAlIDEwMCA+PSAxMiAmJiBpICUgMTAwIDw9IDE0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgIShpID09PSAxKSAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gMCAmJiBpICUgMTAgPD0gMSB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSA1ICYmIGkgJSAxMCA8PSA5IHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gTWF0aC5mbG9vcihpICUgMTAwKSAmJiBpICUgMTAwID49IDEyICYmIGkgJSAxMDAgPD0gMTQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAncHQnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMCAmJiBuIDw9IDIgJiYgIShuID09PSAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3JvJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAoISh2ID09PSAwKSB8fCBuID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICEobiA9PT0gMSkgJiYgbiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDEgJiYgbiAlIDEwMCA8PSAxOSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3J1JzpcbiAgICAgICAgICAgIGNhc2UgJ3VrJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IDEgJiYgIShpICUgMTAwID09PSAxMSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSAyICYmIGkgJSAxMCA8PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICEoaSAlIDEwMCA+PSAxMiAmJiBpICUgMTAwIDw9IDE0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDUgJiYgaSAlIDEwIDw9IDkgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMCAmJiBpICUgMTAwID09PSBNYXRoLmZsb29yKGkgJSAxMDApICYmIGkgJSAxMDAgPj0gMTEgJiYgaSAlIDEwMCA8PSAxNClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdzaGknOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMiAmJiBuIDw9IDEwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnc2knOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAwIHx8IG4gPT09IDEgfHwgaSA9PT0gMCAmJiBmID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnc2wnOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IE1hdGguZmxvb3IoaSAlIDEwMCkgJiYgaSAlIDEwMCA+PSAzICYmIGkgJSAxMDAgPD0gNCB8fCAhKHYgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAndHptJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDAgJiYgbiA8PSAxIHx8IG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAxMSAmJiBuIDw9IDk5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMaXN0TGlrZUl0ZXJhYmxlKG9iaikge1xuICAgICAgICBpZiAoIWlzSnNPYmplY3Qob2JqKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgICAgICAgICAgKCEob2JqIGluc3RhbmNlb2YgTWFwKSAmJlxuICAgICAgICAgICAgICAgIGdldFN5bWJvbEl0ZXJhdG9yKCkgaW4gb2JqKTsgLy8gSlMgSXRlcmFibGUgaGF2ZSBhIFN5bWJvbC5pdGVyYXRvciBwcm9wXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyBhbmQgcmVtb3ZlcyBDU1MgY2xhc3NlcyBvbiBhbiBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiAgICAgPHNvbWUtZWxlbWVudCBbbmdDbGFzc109XCInZmlyc3Qgc2Vjb25kJ1wiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqXG4gICAgICogICAgIDxzb21lLWVsZW1lbnQgW25nQ2xhc3NdPVwiWydmaXJzdCcsICdzZWNvbmQnXVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqXG4gICAgICogICAgIDxzb21lLWVsZW1lbnQgW25nQ2xhc3NdPVwieydmaXJzdCc6IHRydWUsICdzZWNvbmQnOiB0cnVlLCAndGhpcmQnOiBmYWxzZX1cIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKlxuICAgICAqICAgICA8c29tZS1lbGVtZW50IFtuZ0NsYXNzXT1cInN0cmluZ0V4cHxhcnJheUV4cHxvYmpFeHBcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogVGhlIENTUyBjbGFzc2VzIGFyZSB1cGRhdGVkIGFzIGZvbGxvd3MsIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiB0aGUgZXhwcmVzc2lvbiBldmFsdWF0aW9uOlxuICAgICAqIC0gYHN0cmluZ2AgLSB0aGUgQ1NTIGNsYXNzZXMgbGlzdGVkIGluIHRoZSBzdHJpbmcgKHNwYWNlIGRlbGltaXRlZCkgYXJlIGFkZGVkLFxuICAgICAqIC0gYEFycmF5YCAtIHRoZSBDU1MgY2xhc3NlcyBkZWNsYXJlZCBhcyBBcnJheSBlbGVtZW50cyBhcmUgYWRkZWQsXG4gICAgICogLSBgT2JqZWN0YCAtIGtleXMgYXJlIENTUyBjbGFzc2VzIHRoYXQgZ2V0IGFkZGVkIHdoZW4gdGhlIGV4cHJlc3Npb24gZ2l2ZW4gaW4gdGhlIHZhbHVlXG4gICAgICogICAgICAgICAgICAgIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZSwgb3RoZXJ3aXNlIHRoZXkgYXJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nQ2xhc3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ0NsYXNzKF9pdGVyYWJsZURpZmZlcnMsIF9rZXlWYWx1ZURpZmZlcnMsIF9uZ0VsLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVycyA9IF9pdGVyYWJsZURpZmZlcnM7XG4gICAgICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlcnMgPSBfa2V5VmFsdWVEaWZmZXJzO1xuICAgICAgICAgICAgdGhpcy5fbmdFbCA9IF9uZ0VsO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NsYXNzLnByb3RvdHlwZSwgXCJrbGFzc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3Nlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2xhc3Nlcyh0aGlzLl9yYXdDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NsYXNzLnByb3RvdHlwZSwgXCJuZ0NsYXNzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xhc3Nlcyh0aGlzLl9yYXdDbGFzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYXdDbGFzcyA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYuc3BsaXQoL1xccysvKSA6IHY7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jhd0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xpc3RMaWtlSXRlcmFibGUodGhpcy5fcmF3Q2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVyYWJsZURpZmZlciA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVycy5maW5kKHRoaXMuX3Jhd0NsYXNzKS5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlciA9IHRoaXMuX2tleVZhbHVlRGlmZmVycy5maW5kKHRoaXMuX3Jhd0NsYXNzKS5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZXJhYmxlRGlmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9pdGVyYWJsZURpZmZlci5kaWZmKHRoaXMuX3Jhd0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUl0ZXJhYmxlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9rZXlWYWx1ZURpZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fa2V5VmFsdWVEaWZmZXIuZGlmZih0aGlzLl9yYXdDbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlLZXlWYWx1ZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5fY2xlYW51cENsYXNzZXMgPSBmdW5jdGlvbiAocmF3Q2xhc3NWYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2xhc3NlcyhyYXdDbGFzc1ZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUl0ZXJhYmxlQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlY29yZC5pdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmdDbGFzcyBjYW4gb25seSB0b2dnbGUgQ1NTIGNsYXNzZXMgZXhwcmVzc2VkIGFzIHN0cmluZ3MsIGdvdCBcIiArIHN0cmluZ2lmeShyZWNvcmQuaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5pdGVtLCBmYWxzZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlJbml0aWFsQ2xhc3NlcyA9IGZ1bmN0aW9uIChpc0NsZWFudXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKGtsYXNzLCAhaXNDbGVhbnVwKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUNsYXNzZXMgPSBmdW5jdGlvbiAocmF3Q2xhc3NWYWwsIGlzQ2xlYW51cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChyYXdDbGFzc1ZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0NsYXNzVmFsKSB8fCByYXdDbGFzc1ZhbCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICByYXdDbGFzc1ZhbC5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKGtsYXNzLCAhaXNDbGVhbnVwKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyYXdDbGFzc1ZhbCkuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocmF3Q2xhc3NWYWxba2xhc3NdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsICFpc0NsZWFudXApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl90b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIChrbGFzcywgZW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGtsYXNzID0ga2xhc3MudHJpbSgpO1xuICAgICAgICAgICAgaWYgKGtsYXNzKSB7XG4gICAgICAgICAgICAgICAga2xhc3Muc3BsaXQoL1xccysvZykuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHsgX3RoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhfdGhpcy5fbmdFbC5uYXRpdmVFbGVtZW50LCBrbGFzcywgZW5hYmxlZCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ0NsYXNzXScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0NsYXNzLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkl0ZXJhYmxlRGlmZmVycywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5LZXlWYWx1ZURpZmZlcnMsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdDbGFzcy5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdrbGFzcyc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnY2xhc3MnLF0gfSxdLFxuICAgICAgICAgICAgJ25nQ2xhc3MnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nQ2xhc3M7XG4gICAgfSgpKTtcblxuICAgIHZhciBOZ0ZvclJvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nRm9yUm93KCRpbXBsaWNpdCwgaW5kZXgsIGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLiRpbXBsaWNpdCA9ICRpbXBsaWNpdDtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JSb3cucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCA9PT0gMDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwibGFzdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPT09IHRoaXMuY291bnQgLSAxOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yUm93LnByb3RvdHlwZSwgXCJldmVuXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JSb3cucHJvdG90eXBlLCBcIm9kZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLmV2ZW47IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gTmdGb3JSb3c7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYE5nRm9yYCBkaXJlY3RpdmUgaW5zdGFudGlhdGVzIGEgdGVtcGxhdGUgb25jZSBwZXIgaXRlbSBmcm9tIGFuIGl0ZXJhYmxlLiBUaGUgY29udGV4dCBmb3JcbiAgICAgKiBlYWNoIGluc3RhbnRpYXRlZCB0ZW1wbGF0ZSBpbmhlcml0cyBmcm9tIHRoZSBvdXRlciBjb250ZXh0IHdpdGggdGhlIGdpdmVuIGxvb3AgdmFyaWFibGUgc2V0XG4gICAgICogdG8gdGhlIGN1cnJlbnQgaXRlbSBmcm9tIHRoZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqICMjIyBMb2NhbCBWYXJpYWJsZXNcbiAgICAgKlxuICAgICAqIGBOZ0ZvcmAgcHJvdmlkZXMgc2V2ZXJhbCBleHBvcnRlZCB2YWx1ZXMgdGhhdCBjYW4gYmUgYWxpYXNlZCB0byBsb2NhbCB2YXJpYWJsZXM6XG4gICAgICpcbiAgICAgKiAqIGBpbmRleGAgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgbG9vcCBpdGVyYXRpb24gZm9yIGVhY2ggdGVtcGxhdGUgY29udGV4dC5cbiAgICAgKiAqIGBmaXJzdGAgd2lsbCBiZSBzZXQgdG8gYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgaXRlbSBpcyB0aGUgZmlyc3Qgb25lIGluIHRoZVxuICAgICAqICAgaXRlcmF0aW9uLlxuICAgICAqICogYGxhc3RgIHdpbGwgYmUgc2V0IHRvIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGl0ZW0gaXMgdGhlIGxhc3Qgb25lIGluIHRoZVxuICAgICAqICAgaXRlcmF0aW9uLlxuICAgICAqICogYGV2ZW5gIHdpbGwgYmUgc2V0IHRvIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpdGVtIGhhcyBhbiBldmVuIGluZGV4LlxuICAgICAqICogYG9kZGAgd2lsbCBiZSBzZXQgdG8gYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGl0ZW0gaGFzIGFuIG9kZCBpbmRleC5cbiAgICAgKlxuICAgICAqICMjIyBDaGFuZ2UgUHJvcGFnYXRpb25cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGNvbnRlbnRzIG9mIHRoZSBpdGVyYXRvciBjaGFuZ2VzLCBgTmdGb3JgIG1ha2VzIHRoZSBjb3JyZXNwb25kaW5nIGNoYW5nZXMgdG8gdGhlIERPTTpcbiAgICAgKlxuICAgICAqICogV2hlbiBhbiBpdGVtIGlzIGFkZGVkLCBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgaXMgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgKiAqIFdoZW4gYW4gaXRlbSBpcyByZW1vdmVkLCBpdHMgdGVtcGxhdGUgaW5zdGFuY2UgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAgICogKiBXaGVuIGl0ZW1zIGFyZSByZW9yZGVyZWQsIHRoZWlyIHJlc3BlY3RpdmUgdGVtcGxhdGVzIGFyZSByZW9yZGVyZWQgaW4gdGhlIERPTS5cbiAgICAgKiAqIE90aGVyd2lzZSwgdGhlIERPTSBlbGVtZW50IGZvciB0aGF0IGl0ZW0gd2lsbCByZW1haW4gdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiBBbmd1bGFyIHVzZXMgb2JqZWN0IGlkZW50aXR5IHRvIHRyYWNrIGluc2VydGlvbnMgYW5kIGRlbGV0aW9ucyB3aXRoaW4gdGhlIGl0ZXJhdG9yIGFuZCByZXByb2R1Y2VcbiAgICAgKiB0aG9zZSBjaGFuZ2VzIGluIHRoZSBET00uIFRoaXMgaGFzIGltcG9ydGFudCBpbXBsaWNhdGlvbnMgZm9yIGFuaW1hdGlvbnMgYW5kIGFueSBzdGF0ZWZ1bFxuICAgICAqIGNvbnRyb2xzXG4gICAgICogKHN1Y2ggYXMgYDxpbnB1dD5gIGVsZW1lbnRzIHdoaWNoIGFjY2VwdCB1c2VyIGlucHV0KSB0aGF0IGFyZSBwcmVzZW50LiBJbnNlcnRlZCByb3dzIGNhbiBiZVxuICAgICAqIGFuaW1hdGVkIGluLCBkZWxldGVkIHJvd3MgY2FuIGJlIGFuaW1hdGVkIG91dCwgYW5kIHVuY2hhbmdlZCByb3dzIHJldGFpbiBhbnkgdW5zYXZlZCBzdGF0ZSBzdWNoXG4gICAgICogYXMgdXNlciBpbnB1dC5cbiAgICAgKlxuICAgICAqIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgaWRlbnRpdGllcyBvZiBlbGVtZW50cyBpbiB0aGUgaXRlcmF0b3IgdG8gY2hhbmdlIHdoaWxlIHRoZSBkYXRhIGRvZXMgbm90LlxuICAgICAqIFRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIHRoZSBpdGVyYXRvciBwcm9kdWNlZCBmcm9tIGFuIFJQQyB0byB0aGUgc2VydmVyLCBhbmQgdGhhdFxuICAgICAqIFJQQyBpcyByZS1ydW4uIEV2ZW4gaWYgdGhlIGRhdGEgaGFzbid0IGNoYW5nZWQsIHRoZSBzZWNvbmQgcmVzcG9uc2Ugd2lsbCBwcm9kdWNlIG9iamVjdHMgd2l0aFxuICAgICAqIGRpZmZlcmVudCBpZGVudGl0aWVzLCBhbmQgQW5ndWxhciB3aWxsIHRlYXIgZG93biB0aGUgZW50aXJlIERPTSBhbmQgcmVidWlsZCBpdCAoYXMgaWYgYWxsIG9sZFxuICAgICAqIGVsZW1lbnRzIHdlcmUgZGVsZXRlZCBhbmQgYWxsIG5ldyBlbGVtZW50cyBpbnNlcnRlZCkuIFRoaXMgaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiBhbmQgc2hvdWxkXG4gICAgICogYmUgYXZvaWRlZCBpZiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIFRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCB0cmFja2luZyBhbGdvcml0aG0sIGBOZ0ZvcmAgc3VwcG9ydHMgYHRyYWNrQnlgIG9wdGlvbi5cbiAgICAgKiBgdHJhY2tCeWAgdGFrZXMgYSBmdW5jdGlvbiB3aGljaCBoYXMgdHdvIGFyZ3VtZW50czogYGluZGV4YCBhbmQgYGl0ZW1gLlxuICAgICAqIElmIGB0cmFja0J5YCBpcyBnaXZlbiwgQW5ndWxhciB0cmFja3MgY2hhbmdlcyBieSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyBTeW50YXhcbiAgICAgKlxuICAgICAqIC0gYDxsaSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtczsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUZuXCI+Li4uPC9saT5gXG4gICAgICogLSBgPGxpIHRlbXBsYXRlPVwibmdGb3IgbGV0IGl0ZW0gb2YgaXRlbXM7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlGblwiPi4uLjwvbGk+YFxuICAgICAqXG4gICAgICogV2l0aCBgPHRlbXBsYXRlPmAgZWxlbWVudDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDx0ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XCJpdGVtc1wiIGxldC1pPVwiaW5kZXhcIiBbbmdGb3JUcmFja0J5XT1cInRyYWNrQnlGblwiPlxuICAgICAqICAgPGxpPi4uLjwvbGk+XG4gICAgICogPC90ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBTZWUgYSBbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LVnVYeERwMHFpbkdEeW8zMDdRVz9wPXByZXZpZXcpIGZvciBhIG1vcmUgZGV0YWlsZWRcbiAgICAgKiBleGFtcGxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0ZvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nRm9yKF92aWV3Q29udGFpbmVyLCBfdGVtcGxhdGUsIF9kaWZmZXJzLCBfY2RyKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyID0gX3ZpZXdDb250YWluZXI7XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IF90ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2RpZmZlcnMgPSBfZGlmZmVycztcbiAgICAgICAgICAgIHRoaXMuX2NkciA9IF9jZHI7XG4gICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvci5wcm90b3R5cGUsIFwibmdGb3JUZW1wbGF0ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ0Zvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKCduZ0Zvck9mJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhY3Qgb24gbmdGb3JPZiBjaGFuZ2VzIG9ubHkgb25jZSBhbGwgaW5wdXRzIGhhdmUgYmVlbiBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYW5nZXNbJ25nRm9yT2YnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2YWx1ZSkuY3JlYXRlKHRoaXMuX2NkciwgdGhpcy5uZ0ZvclRyYWNrQnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCAnXCIgKyB2YWx1ZSArIFwiJyBvZiB0eXBlICdcIiArIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHZhbHVlKSArIFwiJy4gTmdGb3Igb25seSBzdXBwb3J0cyBiaW5kaW5nIHRvIEl0ZXJhYmxlcyBzdWNoIGFzIEFycmF5cy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9yLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLm5nRm9yT2YpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9yLnByb3RvdHlwZS5fYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0VHVwbGVzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hPcGVyYXRpb24oZnVuY3Rpb24gKGl0ZW0sIGFkanVzdGVkUHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ucHJldmlvdXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gX3RoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KF90aGlzLl90ZW1wbGF0ZSwgbmV3IE5nRm9yUm93KG51bGwsIG51bGwsIG51bGwpLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHVwbGUgPSBuZXcgUmVjb3JkVmlld1R1cGxlKGl0ZW0sIHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUdXBsZXMucHVzaCh0dXBsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl92aWV3Q29udGFpbmVyLnJlbW92ZShhZGp1c3RlZFByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBfdGhpcy5fdmlld0NvbnRhaW5lci5nZXQoYWRqdXN0ZWRQcmV2aW91c0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ZpZXdDb250YWluZXIubW92ZSh2aWV3LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHVwbGUgPSBuZXcgUmVjb3JkVmlld1R1cGxlKGl0ZW0sIHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUdXBsZXMucHVzaCh0dXBsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc2VydFR1cGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlclZpZXdDaGFuZ2UoaW5zZXJ0VHVwbGVzW2ldLnZpZXcsIGluc2VydFR1cGxlc1tpXS5yZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLl92aWV3Q29udGFpbmVyLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lci5nZXQoaSk7XG4gICAgICAgICAgICAgICAgdmlld1JlZi5jb250ZXh0LmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuY291bnQgPSBpbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UoZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3UmVmID0gX3RoaXMuX3ZpZXdDb250YWluZXIuZ2V0KHJlY29yZC5jdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC4kaW1wbGljaXQgPSByZWNvcmQuaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvci5wcm90b3R5cGUuX3BlclZpZXdDaGFuZ2UgPSBmdW5jdGlvbiAodmlldywgcmVjb3JkKSB7XG4gICAgICAgICAgICB2aWV3LmNvbnRleHQuJGltcGxpY2l0ID0gcmVjb3JkLml0ZW07XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ0Zvcl1bbmdGb3JPZl0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdGb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JdGVyYWJsZURpZmZlcnMsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0b3JSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nRm9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nRm9yT2YnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICduZ0ZvclRyYWNrQnknOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICduZ0ZvclRlbXBsYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ0ZvcjtcbiAgICB9KCkpO1xuICAgIHZhciBSZWNvcmRWaWV3VHVwbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWNvcmRWaWV3VHVwbGUocmVjb3JkLCB2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlY29yZFZpZXdUdXBsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBvciByZWNyZWF0ZXMgYSBwb3J0aW9uIG9mIHRoZSBET00gdHJlZSBiYXNlZCBvbiBhbiB7ZXhwcmVzc2lvbn0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXhwcmVzc2lvbiBhc3NpZ25lZCB0byBgbmdJZmAgZXZhbHVhdGVzIHRvIGEgZmFsc3kgdmFsdWUgdGhlbiB0aGUgZWxlbWVudFxuICAgICAqIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLCBvdGhlcndpc2UgYSBjbG9uZSBvZiB0aGUgZWxlbWVudCBpcyByZWluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9mZTBrZ2VtRkJ0bVFPWTMxYjR0dz9wPXByZXZpZXcpKTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxkaXYgKm5nSWY9XCJlcnJvckNvdW50ID4gMFwiIGNsYXNzPVwiZXJyb3JcIj5cbiAgICAgKiAgIDwhLS0gRXJyb3IgbWVzc2FnZSBkaXNwbGF5ZWQgd2hlbiB0aGUgZXJyb3JDb3VudCBwcm9wZXJ0eSBpbiB0aGUgY3VycmVudCBjb250ZXh0IGlzIGdyZWF0ZXJcbiAgICAgKiB0aGFuIDAuIC0tPlxuICAgICAqICAge3tlcnJvckNvdW50fX0gZXJyb3JzIGRldGVjdGVkXG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgU3ludGF4XG4gICAgICpcbiAgICAgKiAtIGA8ZGl2ICpuZ0lmPVwiY29uZGl0aW9uXCI+Li4uPC9kaXY+YFxuICAgICAqIC0gYDxkaXYgdGVtcGxhdGU9XCJuZ0lmIGNvbmRpdGlvblwiPi4uLjwvZGl2PmBcbiAgICAgKiAtIGA8dGVtcGxhdGUgW25nSWZdPVwiY29uZGl0aW9uXCI+PGRpdj4uLi48L2Rpdj48L3RlbXBsYXRlPmBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdJZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nSWYoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lciA9IF92aWV3Q29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBfdGVtcGxhdGU7XG4gICAgICAgICAgICB0aGlzLl9oYXNWaWV3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nSWYucHJvdG90eXBlLCBcIm5nSWZcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbiAmJiAhdGhpcy5faGFzVmlldykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY29uZGl0aW9uICYmIHRoaXMuX2hhc1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzVmlldyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nSWYuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nSWZdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nSWYuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdJZi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ0lmJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ0lmO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU3dpdGNoVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN3aXRjaFZpZXcoX3ZpZXdDb250YWluZXJSZWYsIF90ZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVSZWYgPSBfdGVtcGxhdGVSZWY7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgU3dpdGNoVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZik7XG4gICAgICAgIH07XG4gICAgICAgIFN3aXRjaFZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7XG4gICAgICAgIH07XG4gICAgICAgIFN3aXRjaFZpZXcucHJvdG90eXBlLmVuZm9yY2VTdGF0ZSA9IGZ1bmN0aW9uIChjcmVhdGVkKSB7XG4gICAgICAgICAgICBpZiAoY3JlYXRlZCAmJiAhdGhpcy5fY3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY3JlYXRlZCAmJiB0aGlzLl9jcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTd2l0Y2hWaWV3O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyB3aGVuIHRoZSBuZXN0IG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoZXMgdGhlIHN3aXRjaFxuICAgICAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiAgICAgPGNvbnRhaW5lci1lbGVtZW50IFtuZ1N3aXRjaF09XCJzd2l0Y2hfZXhwcmVzc2lvblwiPlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMlwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLW90aGVyLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPi4uLjwvc29tZS1vdGhlci1lbGVtZW50PlxuICAgICAqICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPlxuICAgICAqICAgICAgICAgPCEtLSB1c2UgYSBuZy1jb250YWluZXIgdG8gZ3JvdXAgbXVsdGlwbGUgcm9vdCBub2RlcyAtLT5cbiAgICAgKiAgICAgICAgIDxpbm5lci1lbGVtZW50PjwvaW5uZXItZWxlbWVudD5cbiAgICAgKiAgICAgICAgIDxpbm5lci1vdGhlci1lbGVtZW50PjwvaW5uZXItb3RoZXItZWxlbWVudD5cbiAgICAgKiAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgKiAgICAgICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaERlZmF1bHQ+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICogICAgIDwvY29udGFpbmVyLWVsZW1lbnQ+XG4gICAgICogYGBgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBgTmdTd2l0Y2hgIHN0YW1wcyBvdXQgbmVzdGVkIHZpZXdzIHdoZW4gdGhlaXIgbWF0Y2ggZXhwcmVzc2lvbiB2YWx1ZSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiBzd2l0Y2ggZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzOlxuICAgICAqIC0geW91IGRlZmluZSBhIGNvbnRhaW5lciBlbGVtZW50ICh3aGVyZSB5b3UgcGxhY2UgdGhlIGRpcmVjdGl2ZSB3aXRoIGEgc3dpdGNoIGV4cHJlc3Npb24gb24gdGhlXG4gICAgICogYFtuZ1N3aXRjaF09XCIuLi5cImAgYXR0cmlidXRlKVxuICAgICAqIC0geW91IGRlZmluZSBpbm5lciB2aWV3cyBpbnNpZGUgdGhlIGBOZ1N3aXRjaGAgYW5kIHBsYWNlIGEgYCpuZ1N3aXRjaENhc2VgIGF0dHJpYnV0ZSBvbiB0aGUgdmlld1xuICAgICAqIHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBFbGVtZW50cyB3aXRoaW4gYE5nU3dpdGNoYCBidXQgb3V0c2lkZSBvZiBhIGBOZ1N3aXRjaENhc2VgIG9yIGBOZ1N3aXRjaERlZmF1bHRgIGRpcmVjdGl2ZXMgd2lsbFxuICAgICAqIGJlIHByZXNlcnZlZCBhdCB0aGUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYG5nU3dpdGNoQ2FzZWAgZGlyZWN0aXZlIGluZm9ybXMgdGhlIHBhcmVudCBgTmdTd2l0Y2hgIG9mIHdoaWNoIHZpZXcgdG8gZGlzcGxheSB3aGVuIHRoZVxuICAgICAqIGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLlxuICAgICAqIFdoZW4gbm8gbWF0Y2hpbmcgZXhwcmVzc2lvbiBpcyBmb3VuZCBvbiBhIGBuZ1N3aXRjaENhc2VgIHZpZXcsIHRoZSBgbmdTd2l0Y2hEZWZhdWx0YCB2aWV3IGlzXG4gICAgICogc3RhbXBlZCBvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3dpdGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTd2l0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0VXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2FzZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RDYXNlQ2hlY2tJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Q2FzZXNNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU3dpdGNoLnByb3RvdHlwZSwgXCJuZ1N3aXRjaFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25nU3dpdGNoID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nhc2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEZWZhdWx0Q2FzZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTd2l0Y2gucHJvdG90eXBlLl9hZGRDYXNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2FzZUNvdW50Kys7IH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTd2l0Y2gucHJvdG90eXBlLl9hZGREZWZhdWx0ID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVmYXVsdFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFZpZXdzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0Vmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX21hdGNoQ2FzZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSB2YWx1ZSA9PSB0aGlzLl9uZ1N3aXRjaDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RDYXNlc01hdGNoZWQgPSB0aGlzLl9sYXN0Q2FzZXNNYXRjaGVkIHx8IG1hdGNoZWQ7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Q2FzZUNoZWNrSW5kZXgrKztcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0Q2FzZUNoZWNrSW5kZXggPT09IHRoaXMuX2Nhc2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURlZmF1bHRDYXNlcyghdGhpcy5fbGFzdENhc2VzTWF0Y2hlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdENhc2VDaGVja0luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0Q2FzZXNNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgfTtcbiAgICAgICAgTmdTd2l0Y2gucHJvdG90eXBlLl91cGRhdGVEZWZhdWx0Q2FzZXMgPSBmdW5jdGlvbiAodXNlRGVmYXVsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRWaWV3cyAmJiB1c2VEZWZhdWx0ICE9PSB0aGlzLl9kZWZhdWx0VXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRVc2VkID0gdXNlRGVmYXVsdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RlZmF1bHRWaWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFZpZXcgPSB0aGlzLl9kZWZhdWx0Vmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWaWV3LmVuZm9yY2VTdGF0ZSh1c2VEZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N3aXRjaF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTd2l0Y2guY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgTmdTd2l0Y2gucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdTd2l0Y2gnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU3dpdGNoO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHZpZXcgdGhhdCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHtAbGluayBOZ1N3aXRjaH0gd2hlbiB0aGVcbiAgICAgKiAgICAgICAgICAgICBnaXZlbiBleHByZXNzaW9uIGV2YWx1YXRlIHRvIHJlc3BlY3RpdmVseSB0aGUgc2FtZS9kaWZmZXJlbnQgdmFsdWUgYXMgdGhlIHN3aXRjaFxuICAgICAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8Y29udGFpbmVyLWVsZW1lbnQgW25nU3dpdGNoXT1cInN3aXRjaF9leHByZXNzaW9uXCI+XG4gICAgICogICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzFcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiA8L2NvbnRhaW5lci1lbGVtZW50PlxuICAgICAqYGBgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBlbmNsb3Npbmcgc3dpdGNoXG4gICAgICogZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIElmIG11bHRpcGxlIG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiB2YWx1ZSwgYWxsIG9mIHRoZW0gYXJlIGRpc3BsYXllZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgTmdTd2l0Y2h9IGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3dpdGNoQ2FzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU3dpdGNoQ2FzZSh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgbmdTd2l0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMubmdTd2l0Y2ggPSBuZ1N3aXRjaDtcbiAgICAgICAgICAgIG5nU3dpdGNoLl9hZGRDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gbmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYpO1xuICAgICAgICB9XG4gICAgICAgIE5nU3dpdGNoQ2FzZS5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmVuZm9yY2VTdGF0ZSh0aGlzLm5nU3dpdGNoLl9tYXRjaENhc2UodGhpcy5uZ1N3aXRjaENhc2UpKTsgfTtcbiAgICAgICAgTmdTd2l0Y2hDYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N3aXRjaENhc2VdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU3dpdGNoQ2FzZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBOZ1N3aXRjaCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1N3aXRjaENhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdTd2l0Y2hDYXNlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1N3aXRjaENhc2U7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHZpZXcgdGhhdCBpcyBhZGRlZCB0byB0aGUgcGFyZW50IHtAbGluayBOZ1N3aXRjaH0gd2hlbiBubyBjYXNlIGV4cHJlc3Npb25zXG4gICAgICogbWF0Y2ggdGhlXG4gICAgICogICAgICAgICAgICAgc3dpdGNoIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8Y29udGFpbmVyLWVsZW1lbnQgW25nU3dpdGNoXT1cInN3aXRjaF9leHByZXNzaW9uXCI+XG4gICAgICogICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzFcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiAgIDxzb21lLW90aGVyLWVsZW1lbnQgKm5nU3dpdGNoRGVmYXVsdD4uLi48L3NvbWUtb3RoZXItZWxlbWVudD5cbiAgICAgKiA8L2NvbnRhaW5lci1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gbm8gY2FzZSBleHByZXNzaW9ucyBldmFsdWF0ZSB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZW5jbG9zaW5nIHN3aXRjaFxuICAgICAqIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5nU3dpdGNofSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ1N3aXRjaERlZmF1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1N3aXRjaERlZmF1bHQodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIG5nU3dpdGNoKSB7XG4gICAgICAgICAgICBuZ1N3aXRjaC5fYWRkRGVmYXVsdChuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZikpO1xuICAgICAgICB9XG4gICAgICAgIE5nU3dpdGNoRGVmYXVsdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hEZWZhdWx0XScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1N3aXRjaERlZmF1bHQuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogTmdTd2l0Y2gsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nU3dpdGNoRGVmYXVsdDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyBiYXNlZCBvbiBhIG51bWVyaWMgdmFsdWUuIFRhaWxvcmVkIGZvciBwbHVyYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogPHNvbWUtZWxlbWVudCBbbmdQbHVyYWxdPVwidmFsdWVcIj5cbiAgICAgKiAgIDxuZy1jb250YWluZXIgKm5nUGx1cmFsQ2FzZT1cIic9MCdcIj50aGVyZSBpcyBub3RoaW5nPC9uZy1jb250YWluZXI+XG4gICAgICogICA8bmctY29udGFpbmVyICpuZ1BsdXJhbENhc2U9XCInPTEnXCI+dGhlcmUgaXMgb25lPC9uZy1jb250YWluZXI+XG4gICAgICogICA8bmctY29udGFpbmVyICpuZ1BsdXJhbENhc2U9XCInZmV3J1wiPnRoZXJlIGFyZSBhIGZldzwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJ290aGVyJ1wiPnRoZXJlIGFyZSBleGFjdGx5ICM8L25nLWNvbnRhaW5lcj5cbiAgICAgKiA8L3NvbWUtZWxlbWVudD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGlzcGxheXMgRE9NIHN1Yi10cmVlcyB0aGF0IG1hdGNoIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiB2YWx1ZSwgb3IgZmFpbGluZyB0aGF0LCBET00gc3ViLXRyZWVzXG4gICAgICogdGhhdCBtYXRjaCB0aGUgc3dpdGNoIGV4cHJlc3Npb24ncyBwbHVyYWxpemF0aW9uIGNhdGVnb3J5LlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoaXMgZGlyZWN0aXZlIHlvdSBtdXN0IHByb3ZpZGUgYSBjb250YWluZXIgZWxlbWVudCB0aGF0IHNldHMgdGhlIGBbbmdQbHVyYWxdYCBhdHRyaWJ1dGVcbiAgICAgKiB0byBhIHN3aXRjaCBleHByZXNzaW9uLiBJbm5lciBlbGVtZW50cyB3aXRoIGEgYFtuZ1BsdXJhbENhc2VdYCB3aWxsIGRpc3BsYXkgYmFzZWQgb24gdGhlaXJcbiAgICAgKiBleHByZXNzaW9uOlxuICAgICAqIC0gaWYgYFtuZ1BsdXJhbENhc2VdYCBpcyBzZXQgdG8gYSB2YWx1ZSBzdGFydGluZyB3aXRoIGA9YCwgaXQgd2lsbCBvbmx5IGRpc3BsYXkgaWYgdGhlIHZhbHVlXG4gICAgICogICBtYXRjaGVzIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiBleGFjdGx5LFxuICAgICAqIC0gb3RoZXJ3aXNlLCB0aGUgdmlldyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBcImNhdGVnb3J5IG1hdGNoXCIsIGFuZCB3aWxsIG9ubHkgZGlzcGxheSBpZiBleGFjdFxuICAgICAqICAgdmFsdWUgbWF0Y2hlcyBhcmVuJ3QgZm91bmQgYW5kIHRoZSB2YWx1ZSBtYXBzIHRvIGl0cyBjYXRlZ29yeSBmb3IgdGhlIGRlZmluZWQgbG9jYWxlLlxuICAgICAqXG4gICAgICogU2VlIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdQbHVyYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1BsdXJhbChfbG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xuICAgICAgICAgICAgdGhpcy5fY2FzZVZpZXdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nUGx1cmFsLnByb3RvdHlwZSwgXCJuZ1BsdXJhbFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3aXRjaFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nUGx1cmFsLnByb3RvdHlwZS5hZGRDYXNlID0gZnVuY3Rpb24gKHZhbHVlLCBzd2l0Y2hWaWV3KSB7IHRoaXMuX2Nhc2VWaWV3c1t2YWx1ZV0gPSBzd2l0Y2hWaWV3OyB9O1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX3VwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclZpZXdzKCk7XG4gICAgICAgICAgICB2YXIgY2FzZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jYXNlVmlld3MpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldFBsdXJhbENhdGVnb3J5KHRoaXMuX3N3aXRjaFZhbHVlLCBjYXNlcywgdGhpcy5fbG9jYWxpemF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlldyh0aGlzLl9jYXNlVmlld3Nba2V5XSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nUGx1cmFsLnByb3RvdHlwZS5fY2xlYXJWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX2FjdGl2YXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nUGx1cmFsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1BsdXJhbF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdQbHVyYWwuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nTG9jYWxpemF0aW9uLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1BsdXJhbC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1BsdXJhbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdQbHVyYWw7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGEgdmlldyB0aGF0IHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQge0BsaW5rIE5nUGx1cmFsfSB3aGVuIHRoZVxuICAgICAqICAgICAgICAgICAgIGdpdmVuIGV4cHJlc3Npb24gbWF0Y2hlcyB0aGUgcGx1cmFsIGV4cHJlc3Npb24gYWNjb3JkaW5nIHRvIENMRFIgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1BsdXJhbF09XCJ2YWx1ZVwiPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJz0wJ1wiPi4uLjwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJ290aGVyJ1wiPi4uLjwvbmctY29udGFpbmVyPlxuICAgICAqIDwvc29tZS1lbGVtZW50PlxuICAgICAqYGBgXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5nUGx1cmFsfSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1BsdXJhbENhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1BsdXJhbENhc2UodmFsdWUsIHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyLCBuZ1BsdXJhbCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbmdQbHVyYWwuYWRkQ2FzZSh2YWx1ZSwgbmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBOZ1BsdXJhbENhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nUGx1cmFsQ2FzZV0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdQbHVyYWxDYXNlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuQXR0cmlidXRlLCBhcmdzOiBbJ25nUGx1cmFsQ2FzZScsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBOZ1BsdXJhbCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdQbHVyYWxDYXNlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBVcGRhdGUgYW4gSFRNTCBlbGVtZW50IHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqIDxzb21lLWVsZW1lbnQgW25nU3R5bGVdPVwieydmb250LXN0eWxlJzogc3R5bGVFeHB9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cInsnbWF4LXdpZHRoLnB4Jzogd2lkdGhFeHB9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cIm9iakV4cFwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgc3R5bGVzIGFyZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgdmFsdWUgb2YgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGlvbjpcbiAgICAgKiAtIGtleXMgYXJlIHN0eWxlIG5hbWVzIHdpdGggYW4gb3B0aW9uYWwgYC48dW5pdD5gIHN1ZmZpeCAoaWUgJ3RvcC5weCcsICdmb250LXN0eWxlLmVtJyksXG4gICAgICogLSB2YWx1ZXMgYXJlIHRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhvc2UgcHJvcGVydGllcyAoZXhwcmVzc2VkIGluIHRoZSBnaXZlbiB1bml0KS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdTdHlsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU3R5bGUoX2RpZmZlcnMsIF9uZ0VsLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpZmZlcnMgPSBfZGlmZmVycztcbiAgICAgICAgICAgIHRoaXMuX25nRWwgPSBfbmdFbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1N0eWxlLnByb3RvdHlwZSwgXCJuZ1N0eWxlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZ1N0eWxlID0gdjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpZmZlciAmJiB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2KS5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nU3R5bGUucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuX25nU3R5bGUpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU3R5bGUucHJvdG90eXBlLl9hcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCBudWxsKTsgfSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nU3R5bGUucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lQW5kVW5pdCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG5hbWVBbmRVbml0LnNwbGl0KCcuJyksIG5hbWUgPSBfYVswXSwgdW5pdCA9IF9hWzFdO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB1bml0ID8gXCJcIiArIHZhbHVlICsgdW5pdCA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX25nRWwubmF0aXZlRWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1N0eWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N0eWxlXScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1N0eWxlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLktleVZhbHVlRGlmZmVycywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1N0eWxlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nU3R5bGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU3R5bGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKlxuICAgICAqIEB3aGF0SXREb2VzIEluc2VydHMgYW4gZW1iZWRkZWQgdmlldyBmcm9tIGEgcHJlcGFyZWQgYFRlbXBsYXRlUmVmYFxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogPHRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRlbXBsYXRlUmVmRXhwcmVzc2lvblwiXG4gICAgICogICAgICAgICAgIFtuZ091dGxldENvbnRleHRdPVwib2JqZWN0RXhwcmVzc2lvblwiPlxuICAgICAqIDwvdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYXR0YWNoIGEgY29udGV4dCBvYmplY3QgdG8gdGhlIGBFbWJlZGRlZFZpZXdSZWZgIGJ5IHNldHRpbmcgYFtuZ091dGxldENvbnRleHRdYC5cbiAgICAgKiBgW25nT3V0bGV0Q29udGV4dF1gIHNob3VsZCBiZSBhbiBvYmplY3QsIHRoZSBvYmplY3QncyBrZXlzIHdpbGwgYmUgdGhlIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlc1xuICAgICAqIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGBUZW1wbGF0ZVJlZmAuXG4gICAgICpcbiAgICAgKiBOb3RlOiB1c2luZyB0aGUga2V5IGAkaW1wbGljaXRgIGluIHRoZSBjb250ZXh0IG9iamVjdCB3aWxsIHNldCBpdCdzIHZhbHVlIGFzIGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nVGVtcGxhdGVPdXRsZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1RlbXBsYXRlT3V0bGV0KF92aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nVGVtcGxhdGVPdXRsZXQucHJvdG90eXBlLCBcIm5nT3V0bGV0Q29udGV4dFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7IHRoaXMuX2NvbnRleHQgPSBjb250ZXh0OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nVGVtcGxhdGVPdXRsZXQucHJvdG90eXBlLCBcIm5nVGVtcGxhdGVPdXRsZXRcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGVtcGxhdGVSZWYpIHsgdGhpcy5fdGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nVGVtcGxhdGVPdXRsZXQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92aWV3UmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5yZW1vdmUodGhpcy5fdmlld0NvbnRhaW5lclJlZi5pbmRleE9mKHRoaXMuX3ZpZXdSZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdSZWYgPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZiwgdGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nVGVtcGxhdGVPdXRsZXQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nVGVtcGxhdGVPdXRsZXRdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nVGVtcGxhdGVPdXRsZXQuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdUZW1wbGF0ZU91dGxldC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ091dGxldENvbnRleHQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICduZ1RlbXBsYXRlT3V0bGV0JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1RlbXBsYXRlT3V0bGV0O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgQW5ndWxhciBkaXJlY3RpdmVzIHRoYXQgYXJlIGxpa2VseSB0byBiZSB1c2VkIGluIGVhY2ggYW5kIGV2ZXJ5IEFuZ3VsYXJcbiAgICAgKiBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgQ09NTU9OX0RJUkVDVElWRVMgPSBbXG4gICAgICAgIE5nQ2xhc3MsXG4gICAgICAgIE5nRm9yLFxuICAgICAgICBOZ0lmLFxuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LFxuICAgICAgICBOZ1N0eWxlLFxuICAgICAgICBOZ1N3aXRjaCxcbiAgICAgICAgTmdTd2l0Y2hDYXNlLFxuICAgICAgICBOZ1N3aXRjaERlZmF1bHQsXG4gICAgICAgIE5nUGx1cmFsLFxuICAgICAgICBOZ1BsdXJhbENhc2UsXG4gICAgXTtcblxuICAgIHZhciBpc1Byb21pc2UgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uaXNQcm9taXNlO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQmFzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoQmFzZUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCYXNlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gRXJyb3JzIGRvbid0IHVzZSBjdXJyZW50IHRoaXMsIGluc3RlYWQgdGhleSBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGRvIGZvcndhcmQgYWxsIG9mIG91ciBhcGkgdG8gdGhlIG5hdGl2ZUluc3RhbmNlLlxuICAgICAgICAgICAgdmFyIG5hdGl2ZUVycm9yID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXJyb3IucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYXRpdmVFcnJvci5tZXNzYWdlOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobWVzc2FnZSkgeyB0aGlzLl9uYXRpdmVFcnJvci5tZXNzYWdlID0gbWVzc2FnZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYXRpdmVFcnJvci5uYW1lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYXRpdmVFcnJvci5zdGFjazsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX25hdGl2ZUVycm9yLnN0YWNrID0gdmFsdWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBCYXNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgcmV0dXJuIEJhc2VFcnJvcjtcbiAgICB9KEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBXcmFwcGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNChXcmFwcGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFdyYXBwZWRFcnJvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSArIFwiIGNhdXNlZCBieTogXCIgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFcnJvci5wcm90b3R5cGUsIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm9yaWdpbmFsRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRoaXMub3JpZ2luYWxFcnJvciA6IHRoaXMuX25hdGl2ZUVycm9yKVxuICAgICAgICAgICAgICAgICAgICAuc3RhY2s7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFdyYXBwZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEludmFsaWRQaXBlQXJndW1lbnRFcnJvcih0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbnZhbGlkIGFyZ3VtZW50ICdcIiArIHZhbHVlICsgXCInIGZvciBwaXBlICdcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW52YWxpZFBpcGVBcmd1bWVudEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICB2YXIgT2JzZXJ2YWJsZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT2JzZXJ2YWJsZVN0cmF0ZWd5KCkge1xuICAgICAgICB9XG4gICAgICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnN1YnNjcmliZSh7IG5leHQ6IHVwZGF0ZUxhdGVzdFZhbHVlLCBlcnJvcjogZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JzZXJ2YWJsZVN0cmF0ZWd5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgICAgT2JzZXJ2YWJsZVN0cmF0ZWd5LnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZVN0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgdmFyIFByb21pc2VTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFByb21pc2VTdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYy50aGVuKHVwZGF0ZUxhdGVzdFZhbHVlLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyB9O1xuICAgICAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIHZhciBfcHJvbWlzZVN0cmF0ZWd5ID0gbmV3IFByb21pc2VTdHJhdGVneSgpO1xuICAgIHZhciBfb2JzZXJ2YWJsZVN0cmF0ZWd5ID0gbmV3IE9ic2VydmFibGVTdHJhdGVneSgpO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBVbndyYXBzIGEgdmFsdWUgZnJvbSBhbiBhc3luY2hyb25vdXMgcHJpbWl0aXZlLlxuICAgICAqIEBob3dUb1VzZSBgb2JzZXJ2YWJsZV9vcl9wcm9taXNlX2V4cHJlc3Npb24gfCBhc3luY2BcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgYGFzeW5jYCBwaXBlIHN1YnNjcmliZXMgdG8gYW4gYE9ic2VydmFibGVgIG9yIGBQcm9taXNlYCBhbmQgcmV0dXJucyB0aGUgbGF0ZXN0IHZhbHVlIGl0IGhhc1xuICAgICAqIGVtaXR0ZWQuIFdoZW4gYSBuZXcgdmFsdWUgaXMgZW1pdHRlZCwgdGhlIGBhc3luY2AgcGlwZSBtYXJrcyB0aGUgY29tcG9uZW50IHRvIGJlIGNoZWNrZWQgZm9yXG4gICAgICogY2hhbmdlcy4gV2hlbiB0aGUgY29tcG9uZW50IGdldHMgZGVzdHJveWVkLCB0aGUgYGFzeW5jYCBwaXBlIHVuc3Vic2NyaWJlcyBhdXRvbWF0aWNhbGx5IHRvIGF2b2lkXG4gICAgICogcG90ZW50aWFsIG1lbW9yeSBsZWFrcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIFRoaXMgZXhhbXBsZSBiaW5kcyBhIGBQcm9taXNlYCB0byB0aGUgdmlldy4gQ2xpY2tpbmcgdGhlIGBSZXNvbHZlYCBidXR0b24gcmVzb2x2ZXMgdGhlXG4gICAgICogcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvYXN5bmNfcGlwZS50cyByZWdpb249J0FzeW5jUGlwZVByb21pc2UnfVxuICAgICAqXG4gICAgICogSXQncyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBgYXN5bmNgIHdpdGggT2JzZXJ2YWJsZXMuIFRoZSBleGFtcGxlIGJlbG93IGJpbmRzIHRoZSBgdGltZWAgT2JzZXJ2YWJsZVxuICAgICAqIHRvIHRoZSB2aWV3LiBUaGUgT2JzZXJ2YWJsZSBjb250aW51ZXNseSB1cGRhdGVzIHRoZSB2aWV3IHdpdGggdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvYXN5bmNfcGlwZS50cyByZWdpb249J0FzeW5jUGlwZU9ic2VydmFibGUnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBc3luY1BpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBc3luY1BpcGUoX3JlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVmID0gX3JlZjtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX29iaiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdHJhdGVneSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgQXN5bmNQaXBlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFzeW5jUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9vYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iaiAhPT0gdGhpcy5fb2JqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhdGVzdFZhbHVlID09PSB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX2FuZ3VsYXJfY29yZS5XcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9vYmogPSBvYmo7XG4gICAgICAgICAgICB0aGlzLl9zdHJhdGVneSA9IHRoaXMuX3NlbGVjdFN0cmF0ZWd5KG9iaik7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9zdHJhdGVneS5jcmVhdGVTdWJzY3JpcHRpb24ob2JqLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl91cGRhdGVMYXRlc3RWYWx1ZShvYmosIHZhbHVlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3NlbGVjdFN0cmF0ZWd5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9taXNlU3RyYXRlZ3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb2JzZXJ2YWJsZVN0cmF0ZWd5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihBc3luY1BpcGUsIG9iaik7XG4gICAgICAgIH07XG4gICAgICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX2Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJhdGVneS5kaXNwb3NlKHRoaXMuX3N1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vYmogPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLl91cGRhdGVMYXRlc3RWYWx1ZSA9IGZ1bmN0aW9uIChhc3luYywgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChhc3luYyA9PT0gdGhpcy5fb2JqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFzeW5jUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdhc3luYycsIHB1cmU6IGZhbHNlIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQXN5bmNQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQXN5bmNQaXBlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIE51bWJlckZvcm1hdFN0eWxlO1xuICAgIChmdW5jdGlvbiAoTnVtYmVyRm9ybWF0U3R5bGUpIHtcbiAgICAgICAgTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGVbXCJEZWNpbWFsXCJdID0gMF0gPSBcIkRlY2ltYWxcIjtcbiAgICAgICAgTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGVbXCJQZXJjZW50XCJdID0gMV0gPSBcIlBlcmNlbnRcIjtcbiAgICAgICAgTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGVbXCJDdXJyZW5jeVwiXSA9IDJdID0gXCJDdXJyZW5jeVwiO1xuICAgIH0pKE51bWJlckZvcm1hdFN0eWxlIHx8IChOdW1iZXJGb3JtYXRTdHlsZSA9IHt9KSk7XG4gICAgdmFyIE51bWJlckZvcm1hdHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE51bWJlckZvcm1hdHRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBOdW1iZXJGb3JtYXR0ZXIuZm9ybWF0ID0gZnVuY3Rpb24gKG51bSwgbG9jYWxlLCBzdHlsZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IF9iLm1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBfYi5taW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IF9iLm1heGltdW1GcmFjdGlvbkRpZ2l0cywgY3VycmVuY3kgPSBfYi5jdXJyZW5jeSwgX2MgPSBfYi5jdXJyZW5jeUFzU3ltYm9sLCBjdXJyZW5jeUFzU3ltYm9sID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtSW50ZWdlckRpZ2l0czogbWluaW11bUludGVnZXJEaWdpdHMsXG4gICAgICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsXG4gICAgICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsXG4gICAgICAgICAgICAgICAgc3R5bGU6IE51bWJlckZvcm1hdFN0eWxlW3N0eWxlXS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0eWxlID09IE51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY3VycmVuY3lEaXNwbGF5ID0gY3VycmVuY3lBc1N5bWJvbCA/ICdzeW1ib2wnIDogJ2NvZGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTnVtYmVyRm9ybWF0dGVyO1xuICAgIH0oKSk7XG4gICAgdmFyIERBVEVfRk9STUFUU19TUExJVCA9IC8oKD86W155TUxkSGhtc2F6WkV3R2pKJ10rKXwoPzonKD86W14nXXwnJykqJyl8KD86RSt8eSt8TSt8TCt8ZCt8SCt8aCt8Sit8ait8bSt8cyt8YXx6fFp8Ryt8dyspKSguKikvO1xuICAgIHZhciBQQVRURVJOX0FMSUFTRVMgPSB7XG4gICAgICAgIHlNTU1kam1zOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbigneWVhcicsIDEpLFxuICAgICAgICAgICAgbmFtZUNvbmRpdGlvbignbW9udGgnLCAzKSxcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKSxcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignbWludXRlJywgMSksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMSksXG4gICAgICAgIF0pKSxcbiAgICAgICAgeU1kam06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdtb250aCcsIDEpLCBkaWdpdENvbmRpdGlvbignZGF5JywgMSksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCBkaWdpdENvbmRpdGlvbignbWludXRlJywgMSlcbiAgICAgICAgXSkpLFxuICAgICAgICB5TU1NTUVFRUVkOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbigneWVhcicsIDEpLCBuYW1lQ29uZGl0aW9uKCdtb250aCcsIDQpLCBuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgNCksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignZGF5JywgMSlcbiAgICAgICAgXSkpLFxuICAgICAgICB5TU1NTWQ6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtkaWdpdENvbmRpdGlvbigneWVhcicsIDEpLCBuYW1lQ29uZGl0aW9uKCdtb250aCcsIDQpLCBkaWdpdENvbmRpdGlvbignZGF5JywgMSldKSksXG4gICAgICAgIHlNTU1kOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgbmFtZUNvbmRpdGlvbignbW9udGgnLCAzKSwgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpXSkpLFxuICAgICAgICB5TWQ6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtkaWdpdENvbmRpdGlvbigneWVhcicsIDEpLCBkaWdpdENvbmRpdGlvbignbW9udGgnLCAxKSwgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpXSkpLFxuICAgICAgICBqbXM6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCBkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdtaW51dGUnLCAxKV0pKSxcbiAgICAgICAgam06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCBkaWdpdENvbmRpdGlvbignbWludXRlJywgMSldKSlcbiAgICB9O1xuICAgIHZhciBEQVRFX0ZPUk1BVFMgPSB7XG4gICAgICAgIHl5eXk6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbigneWVhcicsIDQpKSxcbiAgICAgICAgeXk6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbigneWVhcicsIDIpKSxcbiAgICAgICAgeTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSkpLFxuICAgICAgICBNTU1NOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSksXG4gICAgICAgIE1NTTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ21vbnRoJywgMykpLFxuICAgICAgICBNTTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdtb250aCcsIDIpKSxcbiAgICAgICAgTTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdtb250aCcsIDEpKSxcbiAgICAgICAgTExMTDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ21vbnRoJywgNCkpLFxuICAgICAgICBMOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignbW9udGgnLCAxKSksXG4gICAgICAgIGRkOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ2RheScsIDIpKSxcbiAgICAgICAgZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKSksXG4gICAgICAgIEhIOiBkaWdpdE1vZGlmaWVyKGhvdXJFeHRyYWN0b3IoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDIpLCBmYWxzZSkpKSksXG4gICAgICAgIEg6IGhvdXJFeHRyYWN0b3IoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCBmYWxzZSkpKSxcbiAgICAgICAgaGg6IGRpZ2l0TW9kaWZpZXIoaG91ckV4dHJhY3RvcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMiksIHRydWUpKSkpLFxuICAgICAgICBoOiBob3VyRXh0cmFjdG9yKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShob3VyMTJNb2RpZnkoZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgdHJ1ZSkpKSxcbiAgICAgICAgamo6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignaG91cicsIDIpKSxcbiAgICAgICAgajogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSkpLFxuICAgICAgICBtbTogZGlnaXRNb2RpZmllcihkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDIpKSksXG4gICAgICAgIG06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbWludXRlJywgMSkpLFxuICAgICAgICBzczogZGlnaXRNb2RpZmllcihkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDIpKSksXG4gICAgICAgIHM6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMSkpLFxuICAgICAgICAvLyB3aGlsZSBJU08gODYwMSByZXF1aXJlcyBmcmFjdGlvbnMgdG8gYmUgcHJlZml4ZWQgd2l0aCBgLmAgb3IgYCxgXG4gICAgICAgIC8vIHdlIGNhbiBiZSBqdXN0IHNhZmVseSByZWx5IG9uIHVzaW5nIGBzc3NgIHNpbmNlIHdlIGN1cnJlbnRseSBkb24ndCBzdXBwb3J0IHNpbmdsZSBvciB0d28gZGlnaXRcbiAgICAgICAgLy8gZnJhY3Rpb25zXG4gICAgICAgIHNzczogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdzZWNvbmQnLCAzKSksXG4gICAgICAgIEVFRUU6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgNCkpLFxuICAgICAgICBFRUU6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgMykpLFxuICAgICAgICBFRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCAyKSksXG4gICAgICAgIEU6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgMSkpLFxuICAgICAgICBhOiBob3VyQ2xvY2tFeHRyYWN0b3IoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCB0cnVlKSkpLFxuICAgICAgICBaOiB0aW1lWm9uZUdldHRlcignc2hvcnQnKSxcbiAgICAgICAgejogdGltZVpvbmVHZXR0ZXIoJ2xvbmcnKSxcbiAgICAgICAgd3c6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeSh7fSksXG4gICAgICAgIC8vIGZpcnN0IFRodXJzZGF5IG9mIHRoZSB5ZWFyLiBub3Qgc3VwcG9ydCA/XG4gICAgICAgIHc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeSh7fSksXG4gICAgICAgIC8vIG9mIHRoZSB5ZWFyIG5vdCBzdXBwb3J0ID9cbiAgICAgICAgRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDEpKSxcbiAgICAgICAgR0c6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCdlcmEnLCAyKSksXG4gICAgICAgIEdHRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDMpKSxcbiAgICAgICAgR0dHRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDQpKVxuICAgIH07XG4gICAgZnVuY3Rpb24gZGlnaXRNb2RpZmllcihpbm5lcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGlubmVyKGRhdGUsIGxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PSAxID8gJzAnICsgcmVzdWx0IDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBob3VyQ2xvY2tFeHRyYWN0b3IoaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHsgcmV0dXJuIGlubmVyKGRhdGUsIGxvY2FsZSkuc3BsaXQoJyAnKVsxXTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG91ckV4dHJhY3Rvcihpbm5lcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkgeyByZXR1cm4gaW5uZXIoZGF0ZSwgbG9jYWxlKS5zcGxpdCgnICcpWzBdOyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KGRhdGUpLnJlcGxhY2UoL1tcXHUyMDBlXFx1MjAwZl0vZywgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aW1lWm9uZUdldHRlcih0aW1lem9uZSkge1xuICAgICAgICAvLyBUbyB3b3JrYXJvdW5kIGBJbnRsYCBBUEkgcmVzdHJpY3Rpb24gZm9yIHNpbmdsZSB0aW1lem9uZSBsZXQgZm9ybWF0IHdpdGggMjQgaG91cnNcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGhvdXI6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSwgdGltZVpvbmVOYW1lOiB0aW1lem9uZSB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGludGxEYXRlRm9ybWF0KGRhdGUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBUaGVuIGV4dHJhY3QgZmlyc3QgMyBsZXR0ZXJzIHRoYXQgcmVsYXRlZCB0byBob3Vyc1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC5zdWJzdHJpbmcoMykgOiAnJztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG91cjEyTW9kaWZ5KG9wdGlvbnMsIHZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnMuaG91cjEyID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWdpdENvbmRpdGlvbihwcm9wLCBsZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbcHJvcF0gPSBsZW4gPT09IDIgPyAnMi1kaWdpdCcgOiAnbnVtZXJpYyc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hbWVDb25kaXRpb24ocHJvcCwgbGVuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKGxlbiA8IDQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IGxlbiA+IDEgPyAnc2hvcnQnIDogJ25hcnJvdyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbcHJvcF0gPSAnbG9uZyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoX2EgPSBPYmplY3QpLmFzc2lnbi5hcHBseShfYSwgW3t9XS5jb25jYXQob3B0aW9ucykpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShyZXQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHsgcmV0dXJuIGludGxEYXRlRm9ybWF0KGRhdGUsIGxvY2FsZSwgcmV0KTsgfTtcbiAgICB9XG4gICAgdmFyIERBVEVfRk9STUFUVEVSX0NBQ0hFID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGRhdGVGb3JtYXR0ZXIoZm9ybWF0LCBkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGZuID0gUEFUVEVSTl9BTElBU0VTW2Zvcm1hdF07XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIHJldHVybiBmbihkYXRlLCBsb2NhbGUpO1xuICAgICAgICB2YXIgcGFydHMgPSBEQVRFX0ZPUk1BVFRFUl9DQUNIRS5nZXQoZm9ybWF0KTtcbiAgICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHZvaWQgMDtcbiAgICAgICAgICAgIERBVEVfRk9STUFUU19TUExJVC5leGVjKGZvcm1hdCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBEQVRFX0ZPUk1BVFNfU1BMSVQuZXhlYyhmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHBhcnRzLmNvbmNhdChtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERBVEVfRk9STUFUVEVSX0NBQ0hFLnNldChmb3JtYXQsIHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uICh0ZXh0LCBwYXJ0KSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBEQVRFX0ZPUk1BVFNbcGFydF07XG4gICAgICAgICAgICByZXR1cm4gdGV4dCArIChmbiA/IGZuKGRhdGUsIGxvY2FsZSkgOiBwYXJ0VG9UaW1lKHBhcnQpKTtcbiAgICAgICAgfSwgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0VG9UaW1lKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQgPT09ICdcXCdcXCcnID8gJ1xcJycgOiBwYXJ0LnJlcGxhY2UoLyheJ3wnJCkvZywgJycpLnJlcGxhY2UoLycnL2csICdcXCcnKTtcbiAgICB9XG4gICAgdmFyIERhdGVGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEYXRlRm9ybWF0dGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIERhdGVGb3JtYXR0ZXIuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXR0ZXIocGF0dGVybiwgZGF0ZSwgbG9jYWxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERhdGVGb3JtYXR0ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBGb3JtYXRzIGEgZGF0ZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgZGF0ZV9leHByZXNzaW9uIHwgZGF0ZVs6Zm9ybWF0XWBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFdoZXJlOlxuICAgICAqIC0gYGV4cHJlc3Npb25gIGlzIGEgZGF0ZSBvYmplY3Qgb3IgYSBudW1iZXIgKG1pbGxpc2Vjb25kcyBzaW5jZSBVVEMgZXBvY2gpIG9yIGFuIElTTyBzdHJpbmdcbiAgICAgKiAoaHR0cHM6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWUpLlxuICAgICAqIC0gYGZvcm1hdGAgaW5kaWNhdGVzIHdoaWNoIGRhdGUvdGltZSBjb21wb25lbnRzIHRvIGluY2x1ZGUuIFRoZSBmb3JtYXQgY2FuIGJlIHByZWRpZmluZWQgYXNcbiAgICAgKiAgIHNob3duIGJlbG93IG9yIGN1c3RvbSBhcyBzaG93biBpbiB0aGUgdGFibGUuXG4gICAgICogICAtIGAnbWVkaXVtJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NZGptcydgIChlLmcuIGBTZXAgMywgMjAxMCwgMTI6MDU6MDggUE1gIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ3Nob3J0J2A6IGVxdWl2YWxlbnQgdG8gYCd5TWRqbSdgIChlLmcuIGA5LzMvMjAxMCwgMTI6MDUgUE1gIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ2Z1bGxEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NTUVFRUVkJ2AgKGUuZy4gYEZyaWRheSwgU2VwdGVtYmVyIDMsIDIwMTBgIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ2xvbmdEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NTWQnYCAoZS5nLiBgU2VwdGVtYmVyIDMsIDIwMTBgIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ21lZGl1bURhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNTU1kJ2AgKGUuZy4gYFNlcCAzLCAyMDEwYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdzaG9ydERhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNZCdgIChlLmcuIGA5LzMvMjAxMGAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnbWVkaXVtVGltZSdgOiBlcXVpdmFsZW50IHRvIGAnam1zJ2AgKGUuZy4gYDEyOjA1OjA4IFBNYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdzaG9ydFRpbWUnYDogZXF1aXZhbGVudCB0byBgJ2ptJ2AgKGUuZy4gYDEyOjA1IFBNYCBmb3IgYGVuLVVTYClcbiAgICAgKlxuICAgICAqXG4gICAgICogIHwgQ29tcG9uZW50IHwgU3ltYm9sIHwgTmFycm93IHwgU2hvcnQgRm9ybSAgIHwgTG9uZyBGb3JtICAgICAgICAgfCBOdW1lcmljICAgfCAyLWRpZ2l0ICAgfFxuICAgICAqICB8LS0tLS0tLS0tLS18Oi0tLS0tLTp8LS0tLS0tLS18LS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICAgKiAgfCBlcmEgICAgICAgfCAgIEcgICAgfCBHIChBKSAgfCBHR0cgKEFEKSAgICAgfCBHR0dHIChBbm5vIERvbWluaSl8IC0gICAgICAgICB8IC0gICAgICAgICB8XG4gICAgICogIHwgeWVhciAgICAgIHwgICB5ICAgIHwgLSAgICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCB5ICgyMDE1KSAgfCB5eSAoMTUpICAgfFxuICAgICAqICB8IG1vbnRoICAgICB8ICAgTSAgICB8IEwgKFMpICB8IE1NTSAoU2VwKSAgICB8IE1NTU0gKFNlcHRlbWJlcikgIHwgTSAoOSkgICAgIHwgTU0gKDA5KSAgIHxcbiAgICAgKiAgfCBkYXkgICAgICAgfCAgIGQgICAgfCAtICAgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGQgKDMpICAgICB8IGRkICgwMykgICB8XG4gICAgICogIHwgd2Vla2RheSAgIHwgICBFICAgIHwgRSAoUykgIHwgRUVFIChTdW4pICAgIHwgRUVFRSAoU3VuZGF5KSAgICAgfCAtICAgICAgICAgfCAtICAgICAgICAgfFxuICAgICAqICB8IGhvdXIgICAgICB8ICAgaiAgICB8IC0gICAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgaiAoMTMpICAgIHwgamogKDEzKSAgIHxcbiAgICAgKiAgfCBob3VyMTIgICAgfCAgIGggICAgfCAtICAgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGggKDEgUE0pICB8IGhoICgwMSBQTSl8XG4gICAgICogIHwgaG91cjI0ICAgIHwgICBIICAgIHwgLSAgICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBIICgxMykgICAgfCBISCAoMTMpICAgfFxuICAgICAqICB8IG1pbnV0ZSAgICB8ICAgbSAgICB8IC0gICAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgbSAoNSkgICAgIHwgbW0gKDA1KSAgIHxcbiAgICAgKiAgfCBzZWNvbmQgICAgfCAgIHMgICAgfCAtICAgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IHMgKDkpICAgICB8IHNzICgwOSkgICB8XG4gICAgICogIHwgdGltZXpvbmUgIHwgICB6ICAgIHwgLSAgICAgIHwgLSAgICAgICAgICAgIHwgeiAoUGFjaWZpYyBTdGFuZGFyZCBUaW1lKXwgLSAgfCAtICAgICAgICAgfFxuICAgICAqICB8IHRpbWV6b25lICB8ICAgWiAgICB8IC0gICAgICB8IFogKEdNVC04OjAwKSB8IC0gICAgICAgICAgICAgICAgIHwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcbiAgICAgKiAgfCB0aW1lem9uZSAgfCAgIGEgICAgfCAtICAgICAgfCBhIChQTSkgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IC0gICAgICAgICB8IC0gICAgICAgICB8XG4gICAgICpcbiAgICAgKiBJbiBqYXZhc2NyaXB0LCBvbmx5IHRoZSBjb21wb25lbnRzIHNwZWNpZmllZCB3aWxsIGJlIHJlc3BlY3RlZCAobm90IHRoZSBvcmRlcmluZyxcbiAgICAgKiBwdW5jdHVhdGlvbnMsIC4uLikgYW5kIGRldGFpbHMgb2YgdGhlIGZvcm1hdHRpbmcgd2lsbCBiZSBkZXBlbmRlbnQgb24gdGhlIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIFRpbWV6b25lIG9mIHRoZSBmb3JtYXR0ZWQgdGV4dCB3aWxsIGJlIHRoZSBsb2NhbCBzeXN0ZW0gdGltZXpvbmUgb2YgdGhlIGVuZC11c2VyJ3MgbWFjaGluZS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIGV4cHJlc3Npb24gaXMgYSBJU08gc3RyaW5nIHdpdGhvdXQgdGltZSAoZS5nLiAyMDE2LTA5LTE5KSB0aGUgdGltZSB6b25lIG9mZnNldCBpcyBub3RcbiAgICAgKiBhcHBsaWVkIGFuZCB0aGUgZm9ybWF0dGVkIHRleHQgd2lsbCBoYXZlIHRoZSBzYW1lIGRheSwgbW9udGggYW5kIHllYXIgb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBXQVJOSU5HUzpcbiAgICAgKiAtIHRoaXMgcGlwZSBpcyBtYXJrZWQgYXMgcHVyZSBoZW5jZSBpdCB3aWxsIG5vdCBiZSByZS1ldmFsdWF0ZWQgd2hlbiB0aGUgaW5wdXQgaXMgbXV0YXRlZC5cbiAgICAgKiAgIEluc3RlYWQgdXNlcnMgc2hvdWxkIHRyZWF0IHRoZSBkYXRlIGFzIGFuIGltbXV0YWJsZSBvYmplY3QgYW5kIGNoYW5nZSB0aGUgcmVmZXJlbmNlIHdoZW4gdGhlXG4gICAgICogICBwaXBlIG5lZWRzIHRvIHJlLXJ1biAodGhpcyBpcyB0byBhdm9pZCByZWZvcm1hdHRpbmcgdGhlIGRhdGUgb24gZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBydW5cbiAgICAgKiAgIHdoaWNoIHdvdWxkIGJlIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24pLlxuICAgICAqIC0gdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSS4gVGhlcmVmb3JlIGl0IGlzIG9ubHkgcmVsaWFibGUgaW4gQ2hyb21lIGFuZCBPcGVyYVxuICAgICAqICAgYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIEFzc3VtaW5nIGBkYXRlT2JqYCBpcyAoeWVhcjogMjAxNSwgbW9udGg6IDYsIGRheTogMTUsIGhvdXI6IDIxLCBtaW51dGU6IDQzLCBzZWNvbmQ6IDExKVxuICAgICAqIGluIHRoZSBfbG9jYWxfIHRpbWUgYW5kIGxvY2FsZSBpcyAnZW4tVVMnOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlIH19ICAgICAgICAgICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUnXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlOidtZWRpdW0nIH19ICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUsIDk6NDM6MTEgUE0nXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlOidzaG9ydFRpbWUnIH19ICAgLy8gb3V0cHV0IGlzICc5OjQzIFBNJ1xuICAgICAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbW1zcycgfX0gICAgICAgIC8vIG91dHB1dCBpcyAnNDM6MTEnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2RhdGVfcGlwZS50cyByZWdpb249J0RhdGVQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGF0ZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEYXRlUGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIERhdGVQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuID09PSB2b2lkIDApIHsgcGF0dGVybiA9ICdtZWRpdW1EYXRlJzsgfVxuICAgICAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayQxKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE51bWJlcldyYXBwZXIuaXNOdW1lcmljKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9eKFxcZHs0fS1cXGR7MSwyfS1cXGR7MSwyfSkkLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogRm9yIElTTyBTdHJpbmdzIHdpdGhvdXQgdGltZSB0aGUgZGF5LCBtb250aCBhbmQgeWVhciBtdXN0IGJlIGV4dHJhY3RlZCBmcm9tIHRoZSBJU08gU3RyaW5nXG4gICAgICAgICAgICAgICAgKiBiZWZvcmUgRGF0ZSBjcmVhdGlvbiB0byBhdm9pZCB0aW1lIG9mZnNldCBhbmQgZXJyb3JzIGluIHRoZSBuZXcgRGF0ZS5cbiAgICAgICAgICAgICAgICAqIElmIHdlIG9ubHkgcmVwbGFjZSAnLScgd2l0aCAnLCcgaW4gdGhlIElTTyBTdHJpbmcgKFwiMjAxNSwwMSwwMVwiKSwgYW5kIHRyeSB0byBjcmVhdGUgYSBuZXdcbiAgICAgICAgICAgICAgICAqIGRhdGUsIHNvbWUgYnJvd3NlcnMgKGUuZy4gSUUgOSkgd2lsbCB0aHJvdyBhbiBpbnZhbGlkIERhdGUgZXJyb3JcbiAgICAgICAgICAgICAgICAqIElmIHdlIGxlYXZlIHRoZSAnLScgKFwiMjAxNS0wMS0wMVwiKSBhbmQgdHJ5IHRvIGNyZWF0ZSBhIG5ldyBEYXRlKFwiMjAxNS0wMS0wMVwiKSB0aGUgdGltZW9mZnNldFxuICAgICAgICAgICAgICAgICogaXMgYXBwbGllZFxuICAgICAgICAgICAgICAgICogTm90ZTogSVNPIG1vbnRocyBhcmUgMCBmb3IgSmFudWFyeSwgMSBmb3IgRmVicnVhcnksIC4uLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdmFsdWUuc3BsaXQoJy0nKS5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0pLCB5ID0gX2FbMF0sIG0gPSBfYVsxXSwgZCA9IF9hWzJdO1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtIC0gMSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKERhdGVQaXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRGF0ZUZvcm1hdHRlci5mb3JtYXQoZGF0ZSwgdGhpcy5fbG9jYWxlLCBEYXRlUGlwZS5fQUxJQVNFU1twYXR0ZXJuXSB8fCBwYXR0ZXJuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEYXRlUGlwZS5fQUxJQVNFUyA9IHtcbiAgICAgICAgICAgICdtZWRpdW0nOiAneU1NTWRqbXMnLFxuICAgICAgICAgICAgJ3Nob3J0JzogJ3lNZGptJyxcbiAgICAgICAgICAgICdmdWxsRGF0ZSc6ICd5TU1NTUVFRUVkJyxcbiAgICAgICAgICAgICdsb25nRGF0ZSc6ICd5TU1NTWQnLFxuICAgICAgICAgICAgJ21lZGl1bURhdGUnOiAneU1NTWQnLFxuICAgICAgICAgICAgJ3Nob3J0RGF0ZSc6ICd5TWQnLFxuICAgICAgICAgICAgJ21lZGl1bVRpbWUnOiAnam1zJyxcbiAgICAgICAgICAgICdzaG9ydFRpbWUnOiAnam0nXG4gICAgICAgIH07XG4gICAgICAgIERhdGVQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2RhdGUnLCBwdXJlOiB0cnVlIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRGF0ZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRGF0ZVBpcGU7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBpc0JsYW5rJDEob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbCB8fCBvYmogPT09ICcnO1xuICAgIH1cblxuICAgIHZhciBfSU5URVJQT0xBVElPTl9SRUdFWFAgPSAvIy9nO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBNYXBzIGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBwbHVyYWxpemVzIHRoZSB2YWx1ZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IGkxOG5QbHVyYWw6bWFwcGluZ2BcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqICBXaGVyZTpcbiAgICAgKiAgLSBgZXhwcmVzc2lvbmAgaXMgYSBudW1iZXIuXG4gICAgICogIC0gYG1hcHBpbmdgIGlzIGFuIG9iamVjdCB0aGF0IG1pbWljcyB0aGUgSUNVIGZvcm1hdCwgc2VlXG4gICAgICogICAgaHR0cDovL3VzZXJndWlkZS5pY3UtcHJvamVjdC5vcmcvZm9ybWF0cGFyc2UvbWVzc2FnZXNcbiAgICAgKlxuICAgICAqICAjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2kxOG5fcGlwZS50cyByZWdpb249J0kxOG5QbHVyYWxQaXBlQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSTE4blBsdXJhbFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJMThuUGx1cmFsUGlwZShfbG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIEkxOG5QbHVyYWxQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHBsdXJhbE1hcCkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1cmFsTWFwICE9PSAnb2JqZWN0JyB8fCBwbHVyYWxNYXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEkxOG5QbHVyYWxQaXBlLCBwbHVyYWxNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IGdldFBsdXJhbENhdGVnb3J5KHZhbHVlLCBPYmplY3Qua2V5cyhwbHVyYWxNYXApLCB0aGlzLl9sb2NhbGl6YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHBsdXJhbE1hcFtrZXldLnJlcGxhY2UoX0lOVEVSUE9MQVRJT05fUkVHRVhQLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSTE4blBsdXJhbFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blBsdXJhbCcsIHB1cmU6IHRydWUgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJMThuUGx1cmFsUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdMb2NhbGl6YXRpb24sIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBJMThuUGx1cmFsUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEdlbmVyaWMgc2VsZWN0b3IgdGhhdCBkaXNwbGF5cyB0aGUgc3RyaW5nIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBpMThuU2VsZWN0Om1hcHBpbmdgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiAgV2hlcmUgYG1hcHBpbmdgIGlzIGFuIG9iamVjdCB0aGF0IGluZGljYXRlcyB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICAgKiAgZm9yIGRpZmZlcmVudCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIGBleHByZXNzaW9uYC5cbiAgICAgKiAgSWYgbm9uZSBvZiB0aGUga2V5cyBvZiB0aGUgbWFwcGluZyBtYXRjaCB0aGUgdmFsdWUgb2YgdGhlIGBleHByZXNzaW9uYCwgdGhlbiB0aGUgY29udGVudFxuICAgICAqICBvZiB0aGUgYG90aGVyYCBrZXkgaXMgcmV0dXJuZWQgd2hlbiBwcmVzZW50LCBvdGhlcndpc2UgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogICMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvaTE4bl9waXBlLnRzIHJlZ2lvbj0nSTE4blNlbGVjdFBpcGVDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSTE4blNlbGVjdFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJMThuU2VsZWN0UGlwZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBJMThuU2VsZWN0UGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBtYXBwaW5nKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcgIT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEkxOG5TZWxlY3RQaXBlLCBtYXBwaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwaW5nLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBwaW5nW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwaW5nLmhhc093blByb3BlcnR5KCdvdGhlcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdbJ290aGVyJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH07XG4gICAgICAgIEkxOG5TZWxlY3RQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2kxOG5TZWxlY3QnLCBwdXJlOiB0cnVlIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSTE4blNlbGVjdFBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEkxOG5TZWxlY3RQaXBlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgQ29udmVydHMgdmFsdWUgaW50byBKU09OIHN0cmluZy5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBqc29uYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ29udmVydHMgdmFsdWUgaW50byBzdHJpbmcgdXNpbmcgYEpTT04uc3RyaW5naWZ5YC4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvanNvbl9waXBlLnRzIHJlZ2lvbj0nSnNvblBpcGUnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBKc29uUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEpzb25QaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIEpzb25QaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAyKTsgfTtcbiAgICAgICAgSnNvblBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnanNvbicsIHB1cmU6IGZhbHNlIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSnNvblBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEpzb25QaXBlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgVHJhbnNmb3JtcyBzdHJpbmcgdG8gbG93ZXJjYXNlLlxuICAgICAqIEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IGxvd2VyY2FzZWBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENvbnZlcnRzIHZhbHVlIGludG8gYSBsb3dlcmNhc2Ugc3RyaW5nIHVzaW5nIGBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKClgLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbG93ZXJ1cHBlcl9waXBlLnRzIHJlZ2lvbj0nTG93ZXJVcHBlclBpcGUnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBMb3dlckNhc2VQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG93ZXJDYXNlUGlwZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBMb3dlckNhc2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoTG93ZXJDYXNlUGlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExvd2VyQ2FzZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnbG93ZXJjYXNlJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIExvd2VyQ2FzZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIExvd2VyQ2FzZVBpcGU7XG4gICAgfSgpKTtcblxuICAgIHZhciBfTlVNQkVSX0ZPUk1BVF9SRUdFWFAgPSAvXihcXGQrKT9cXC4oKFxcZCspKC0oXFxkKykpPyk/JC87XG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHBpcGUsIGxvY2FsZSwgdmFsdWUsIHN0eWxlLCBkaWdpdHMsIGN1cnJlbmN5LCBjdXJyZW5jeUFzU3ltYm9sKSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5ID0gbnVsbDsgfVxuICAgICAgICBpZiAoY3VycmVuY3lBc1N5bWJvbCA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5QXNTeW1ib2wgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gQ29udmVydCBzdHJpbmdzIHRvIG51bWJlcnNcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIE51bWJlcldyYXBwZXIuaXNOdW1lcmljKHZhbHVlKSA/ICt2YWx1ZSA6IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihwaXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbkludDtcbiAgICAgICAgdmFyIG1pbkZyYWN0aW9uO1xuICAgICAgICB2YXIgbWF4RnJhY3Rpb247XG4gICAgICAgIGlmIChzdHlsZSAhPT0gTnVtYmVyRm9ybWF0U3R5bGUuQ3VycmVuY3kpIHtcbiAgICAgICAgICAgIC8vIHJlbHkgb24gSW50bCBkZWZhdWx0IGZvciBjdXJyZW5jeVxuICAgICAgICAgICAgbWluSW50ID0gMTtcbiAgICAgICAgICAgIG1pbkZyYWN0aW9uID0gMDtcbiAgICAgICAgICAgIG1heEZyYWN0aW9uID0gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlnaXRzKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBkaWdpdHMubWF0Y2goX05VTUJFUl9GT1JNQVRfUkVHRVhQKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkaWdpdHMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbmZvIGZvciBudW1iZXIgcGlwZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcnRzWzFdKSkge1xuICAgICAgICAgICAgICAgIG1pbkludCA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJ0c1szXSkpIHtcbiAgICAgICAgICAgICAgICBtaW5GcmFjdGlvbiA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJ0c1s1XSkpIHtcbiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbiA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXJGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlLCBsb2NhbGUsIHN0eWxlLCB7XG4gICAgICAgICAgICBtaW5pbXVtSW50ZWdlckRpZ2l0czogbWluSW50LFxuICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBtaW5GcmFjdGlvbixcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbWF4RnJhY3Rpb24sXG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgICBjdXJyZW5jeUFzU3ltYm9sOiBjdXJyZW5jeUFzU3ltYm9sLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEZvcm1hdHMgYSBudW1iZXIgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cbiAgICAgKiBAaG93VG9Vc2UgYG51bWJlcl9leHByZXNzaW9uIHwgbnVtYmVyWzpkaWdpdEluZm9dYFxuICAgICAqXG4gICAgICogRm9ybWF0cyBhIG51bWJlciBhcyB0ZXh0LiBHcm91cCBzaXppbmcgYW5kIHNlcGFyYXRvciBhbmQgb3RoZXIgbG9jYWxlLXNwZWNpZmljXG4gICAgICogY29uZmlndXJhdGlvbnMgYXJlIGJhc2VkIG9uIHRoZSBhY3RpdmUgbG9jYWxlLlxuICAgICAqXG4gICAgICogd2hlcmUgYGV4cHJlc3Npb25gIGlzIGEgbnVtYmVyOlxuICAgICAqICAtIGBkaWdpdEluZm9gIGlzIGEgYHN0cmluZ2Agd2hpY2ggaGFzIGEgZm9sbG93aW5nIGZvcm1hdDogPGJyPlxuICAgICAqICAgICA8Y29kZT57bWluSW50ZWdlckRpZ2l0c30ue21pbkZyYWN0aW9uRGlnaXRzfS17bWF4RnJhY3Rpb25EaWdpdHN9PC9jb2RlPlxuICAgICAqICAgLSBgbWluSW50ZWdlckRpZ2l0c2AgaXMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGludGVnZXIgZGlnaXRzIHRvIHVzZS4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqICAgLSBgbWluRnJhY3Rpb25EaWdpdHNgIGlzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZnJhY3Rpb24uIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKiAgIC0gYG1heEZyYWN0aW9uRGlnaXRzYCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIGZyYWN0aW9uLiBEZWZhdWx0cyB0byBgM2AuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgYWNjZXB0YWJsZSByYW5nZSBmb3IgZWFjaCBvZiB0aGVzZSBudW1iZXJzIGFuZCBvdGhlclxuICAgICAqIGRldGFpbHMgc2VlIHlvdXIgbmF0aXZlIGludGVybmF0aW9uYWxpemF0aW9uIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJIHdoaWNoIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGluIGFsbCBicm93c2Vyc1xuICAgICAqIGFuZCBtYXkgcmVxdWlyZSBhIHBvbHlmaWxsLiBTZWUge0BsaW5rRG9jcyBndWlkZS9icm93c2VyLXN1cHBvcnR9IGZvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbnVtYmVyX3BpcGUudHMgcmVnaW9uPSdOdW1iZXJQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGVjaW1hbFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWNpbWFsUGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIERlY2ltYWxQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoRGVjaW1hbFBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLkRlY2ltYWwsIGRpZ2l0cyk7XG4gICAgICAgIH07XG4gICAgICAgIERlY2ltYWxQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ251bWJlcicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEZWNpbWFsUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuTE9DQUxFX0lELF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBEZWNpbWFsUGlwZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBGb3JtYXRzIGEgbnVtYmVyIGFzIGEgcGVyY2VudGFnZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgbnVtYmVyX2V4cHJlc3Npb24gfCBwZXJjZW50WzpkaWdpdEluZm9dYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBGb3JtYXRzIGEgbnVtYmVyIGFzIHBlcmNlbnRhZ2UuXG4gICAgICpcbiAgICAgKiAtIGBkaWdpdEluZm9gIFNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9IGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXG4gICAgICogYW5kIG1heSByZXF1aXJlIGEgcG9seWZpbGwuIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J1BlcmNlbnRQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGVyY2VudFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQZXJjZW50UGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIFBlcmNlbnRQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoUGVyY2VudFBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLlBlcmNlbnQsIGRpZ2l0cyk7XG4gICAgICAgIH07XG4gICAgICAgIFBlcmNlbnRQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3BlcmNlbnQnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGVyY2VudFBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUGVyY2VudFBpcGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgRm9ybWF0cyBhIG51bWJlciBhcyBjdXJyZW5jeSB1c2luZyBsb2NhbGUgcnVsZXMuXG4gICAgICogQGhvd1RvVXNlIGBudW1iZXJfZXhwcmVzc2lvbiB8IGN1cnJlbmN5WzpjdXJyZW5jeUNvZGVbOnN5bWJvbERpc3BsYXlbOmRpZ2l0SW5mb11dXWBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFVzZSBgY3VycmVuY3lgIHRvIGZvcm1hdCBhIG51bWJlciBhcyBjdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIC0gYGN1cnJlbmN5Q29kZWAgaXMgdGhlIFtJU08gNDIxN10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzQyMTcpIGN1cnJlbmN5IGNvZGUsIHN1Y2hcbiAgICAgKiAgICBhcyBgVVNEYCBmb3IgdGhlIFVTIGRvbGxhciBhbmQgYEVVUmAgZm9yIHRoZSBldXJvLlxuICAgICAqIC0gYHN5bWJvbERpc3BsYXlgIGlzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gdXNlIHRoZSBjdXJyZW5jeSBzeW1ib2wgb3IgY29kZS5cbiAgICAgKiAgIC0gYHRydWVgOiB1c2Ugc3ltYm9sIChlLmcuIGAkYCkuXG4gICAgICogICAtIGBmYWxzZWAoZGVmYXVsdCk6IHVzZSBjb2RlIChlLmcuIGBVU0RgKS5cbiAgICAgKiAtIGBkaWdpdEluZm9gIFNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9IGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXG4gICAgICogYW5kIG1heSByZXF1aXJlIGEgcG9seWZpbGwuIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J0N1cnJlbmN5UGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEN1cnJlbmN5UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEN1cnJlbmN5UGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIEN1cnJlbmN5UGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXksIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5Q29kZSA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5Q29kZSA9ICdVU0QnOyB9XG4gICAgICAgICAgICBpZiAoc3ltYm9sRGlzcGxheSA9PT0gdm9pZCAwKSB7IHN5bWJvbERpc3BsYXkgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoQ3VycmVuY3lQaXBlLCB0aGlzLl9sb2NhbGUsIHZhbHVlLCBOdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSwgZGlnaXRzLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXkpO1xuICAgICAgICB9O1xuICAgICAgICBDdXJyZW5jeVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnY3VycmVuY3knIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ3VycmVuY3lQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEN1cnJlbmN5UGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSBuZXcgTGlzdCBvciBTdHJpbmcgY29udGFpbmluZyBhIHN1YnNldCAoc2xpY2UpIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBAaG93VG9Vc2UgYGFycmF5X29yX3N0cmluZ19leHByZXNzaW9uIHwgc2xpY2U6c3RhcnRbOmVuZF1gXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBXaGVyZSB0aGUgaW5wdXQgZXhwcmVzc2lvbiBpcyBhIGBMaXN0YCBvciBgU3RyaW5nYCwgYW5kOlxuICAgICAqIC0gYHN0YXJ0YDogVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBzdWJzZXQgdG8gcmV0dXJuLlxuICAgICAqICAgLSAqKmEgcG9zaXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgYHN0YXJ0YCBpbmRleCBhbmQgYWxsIGl0ZW1zIGFmdGVyXG4gICAgICogICAgIGluIHRoZSBsaXN0IG9yIHN0cmluZyBleHByZXNzaW9uLlxuICAgICAqICAgLSAqKmEgbmVnYXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgYHN0YXJ0YCBpbmRleCBmcm9tIHRoZSBlbmQgYW5kIGFsbCBpdGVtcyBhZnRlclxuICAgICAqICAgICBpbiB0aGUgbGlzdCBvciBzdHJpbmcgZXhwcmVzc2lvbi5cbiAgICAgKiAgIC0gKippZiBwb3NpdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBhbiBlbXB0eSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKiAgIC0gKippZiBuZWdhdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBlbnRpcmUgbGlzdCBvciBzdHJpbmcuXG4gICAgICogLSBgZW5kYDogVGhlIGVuZGluZyBpbmRleCBvZiB0aGUgc3Vic2V0IHRvIHJldHVybi5cbiAgICAgKiAgIC0gKipvbWl0dGVkKio6IHJldHVybiBhbGwgaXRlbXMgdW50aWwgdGhlIGVuZC5cbiAgICAgKiAgIC0gKippZiBwb3NpdGl2ZSoqOiByZXR1cm4gYWxsIGl0ZW1zIGJlZm9yZSBgZW5kYCBpbmRleCBvZiB0aGUgbGlzdCBvciBzdHJpbmcuXG4gICAgICogICAtICoqaWYgbmVnYXRpdmUqKjogcmV0dXJuIGFsbCBpdGVtcyBiZWZvcmUgYGVuZGAgaW5kZXggZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEFsbCBiZWhhdmlvciBpcyBiYXNlZCBvbiB0aGUgZXhwZWN0ZWQgYmVoYXZpb3Igb2YgdGhlIEphdmFTY3JpcHQgQVBJIGBBcnJheS5wcm90b3R5cGUuc2xpY2UoKWBcbiAgICAgKiBhbmQgYFN0cmluZy5wcm90b3R5cGUuc2xpY2UoKWAuXG4gICAgICpcbiAgICAgKiBXaGVuIG9wZXJhdGluZyBvbiBhIFtMaXN0XSwgdGhlIHJldHVybmVkIGxpc3QgaXMgYWx3YXlzIGEgY29weSBldmVuIHdoZW4gYWxsXG4gICAgICogdGhlIGVsZW1lbnRzIGFyZSBiZWluZyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFdoZW4gb3BlcmF0aW5nIG9uIGEgYmxhbmsgdmFsdWUsIHRoZSBwaXBlIHJldHVybnMgdGhlIGJsYW5rIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMgTGlzdCBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBUaGlzIGBuZ0ZvcmAgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvc2xpY2VfcGlwZS50cyByZWdpb249J1NsaWNlUGlwZV9saXN0J31cbiAgICAgKlxuICAgICAqIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiAgICAgPGxpPmI8L2xpPlxuICAgICAqICAgICA8bGk+YzwvbGk+XG4gICAgICpcbiAgICAgKiAjIyBTdHJpbmcgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvc2xpY2VfcGlwZS50cyByZWdpb249J1NsaWNlUGlwZV9zdHJpbmcnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBTbGljZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTbGljZVBpcGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU2xpY2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihTbGljZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2xpY2VQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob2JqKTsgfTtcbiAgICAgICAgU2xpY2VQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3NsaWNlJywgcHVyZTogZmFsc2UgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTbGljZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFNsaWNlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIFRyYW5zZm9ybXMgc3RyaW5nIHRvIHVwcGVyY2FzZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCB1cHBlcmNhc2VgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyB2YWx1ZSBpbnRvIGFuIHVwcGVyY2FzZSBzdHJpbmcgdXNpbmcgYFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UoKWAuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9sb3dlcnVwcGVyX3BpcGUudHMgcmVnaW9uPSdMb3dlclVwcGVyUGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFVwcGVyQ2FzZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBVcHBlckNhc2VQaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIFVwcGVyQ2FzZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihVcHBlckNhc2VQaXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgVXBwZXJDYXNlUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICd1cHBlcmNhc2UnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVXBwZXJDYXNlUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gVXBwZXJDYXNlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIEFuZ3VsYXIgcGlwZXMgdGhhdCBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgaW4gZWFjaCBhbmQgZXZlcnkgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgdmFyIENPTU1PTl9QSVBFUyA9IFtcbiAgICAgICAgQXN5bmNQaXBlLFxuICAgICAgICBVcHBlckNhc2VQaXBlLFxuICAgICAgICBMb3dlckNhc2VQaXBlLFxuICAgICAgICBKc29uUGlwZSxcbiAgICAgICAgU2xpY2VQaXBlLFxuICAgICAgICBEZWNpbWFsUGlwZSxcbiAgICAgICAgUGVyY2VudFBpcGUsXG4gICAgICAgIEN1cnJlbmN5UGlwZSxcbiAgICAgICAgRGF0ZVBpcGUsXG4gICAgICAgIEkxOG5QbHVyYWxQaXBlLFxuICAgICAgICBJMThuU2VsZWN0UGlwZSxcbiAgICBdO1xuXG4gICAgLy8gTm90ZTogVGhpcyBkb2VzIG5vdCBjb250YWluIHRoZSBsb2NhdGlvbiBwcm92aWRlcnMsXG4gICAgLy8gYXMgdGhleSBuZWVkIHNvbWUgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zIHRvIHdvcmsuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZHVsZSB0aGF0IGluY2x1ZGVzIGFsbCB0aGUgYmFzaWMgQW5ndWxhciBkaXJlY3RpdmVzIGxpa2Uge0BsaW5rIE5nSWZ9LCB7QGxpbmsgTmdGb3J9LCAuLi5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tbW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tbW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbW1vbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NTU9OX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbQ09NTU9OX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5nTG9jYWxpemF0aW9uLCB1c2VDbGFzczogTmdMb2NhbGVMb2NhbGl6YXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ29tbW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBDb21tb25Nb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIGV4cG9ydHMuTmdMb2NhbGl6YXRpb24gPSBOZ0xvY2FsaXphdGlvbjtcbiAgICBleHBvcnRzLkNvbW1vbk1vZHVsZSA9IENvbW1vbk1vZHVsZTtcbiAgICBleHBvcnRzLk5nQ2xhc3MgPSBOZ0NsYXNzO1xuICAgIGV4cG9ydHMuTmdGb3IgPSBOZ0ZvcjtcbiAgICBleHBvcnRzLk5nSWYgPSBOZ0lmO1xuICAgIGV4cG9ydHMuTmdQbHVyYWwgPSBOZ1BsdXJhbDtcbiAgICBleHBvcnRzLk5nUGx1cmFsQ2FzZSA9IE5nUGx1cmFsQ2FzZTtcbiAgICBleHBvcnRzLk5nU3R5bGUgPSBOZ1N0eWxlO1xuICAgIGV4cG9ydHMuTmdTd2l0Y2ggPSBOZ1N3aXRjaDtcbiAgICBleHBvcnRzLk5nU3dpdGNoQ2FzZSA9IE5nU3dpdGNoQ2FzZTtcbiAgICBleHBvcnRzLk5nU3dpdGNoRGVmYXVsdCA9IE5nU3dpdGNoRGVmYXVsdDtcbiAgICBleHBvcnRzLk5nVGVtcGxhdGVPdXRsZXQgPSBOZ1RlbXBsYXRlT3V0bGV0O1xuICAgIGV4cG9ydHMuQXN5bmNQaXBlID0gQXN5bmNQaXBlO1xuICAgIGV4cG9ydHMuRGF0ZVBpcGUgPSBEYXRlUGlwZTtcbiAgICBleHBvcnRzLkkxOG5QbHVyYWxQaXBlID0gSTE4blBsdXJhbFBpcGU7XG4gICAgZXhwb3J0cy5JMThuU2VsZWN0UGlwZSA9IEkxOG5TZWxlY3RQaXBlO1xuICAgIGV4cG9ydHMuSnNvblBpcGUgPSBKc29uUGlwZTtcbiAgICBleHBvcnRzLkxvd2VyQ2FzZVBpcGUgPSBMb3dlckNhc2VQaXBlO1xuICAgIGV4cG9ydHMuQ3VycmVuY3lQaXBlID0gQ3VycmVuY3lQaXBlO1xuICAgIGV4cG9ydHMuRGVjaW1hbFBpcGUgPSBEZWNpbWFsUGlwZTtcbiAgICBleHBvcnRzLlBlcmNlbnRQaXBlID0gUGVyY2VudFBpcGU7XG4gICAgZXhwb3J0cy5TbGljZVBpcGUgPSBTbGljZVBpcGU7XG4gICAgZXhwb3J0cy5VcHBlckNhc2VQaXBlID0gVXBwZXJDYXNlUGlwZTtcbiAgICBleHBvcnRzLlBsYXRmb3JtTG9jYXRpb24gPSBQbGF0Zm9ybUxvY2F0aW9uO1xuICAgIGV4cG9ydHMuTG9jYXRpb25TdHJhdGVneSA9IExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5BUFBfQkFTRV9IUkVGID0gQVBQX0JBU0VfSFJFRjtcbiAgICBleHBvcnRzLkhhc2hMb2NhdGlvblN0cmF0ZWd5ID0gSGFzaExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5QYXRoTG9jYXRpb25TdHJhdGVneSA9IFBhdGhMb2NhdGlvblN0cmF0ZWd5O1xuICAgIGV4cG9ydHMuTG9jYXRpb24gPSBMb2NhdGlvbjtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9jb21tb24vYnVuZGxlcy9jb21tb24udW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar core_1 = __webpack_require__(2);\nvar platform_browser_1 = __webpack_require__(22);\nvar app_component_1 = __webpack_require__(25);\nvar AppModule = (function () {\n    function AppModule() {\n    }\n    AppModule = __decorate([\n        core_1.NgModule({\n            imports: [\n                platform_browser_1.BrowserModule\n            ],\n            declarations: [\n                app_component_1.AppComponent\n            ],\n            bootstrap: [app_component_1.AppComponent]\n        }), \n        __metadata('design:paramtypes', [])\n    ], AppModule);\n    return AppModule;\n}());\nexports.AppModule = AppModule;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5tb2R1bGUudHM/NWRlNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsaUNBQXlCLENBQWUsQ0FBQztBQUN6Qyw2Q0FBK0IsRUFBMkIsQ0FBQztBQUMzRCwwQ0FBNkIsRUFBaUIsQ0FBQztBQVkvQztJQUFBO0lBQXlCLENBQUM7SUFWMUI7UUFBQyxlQUFRLENBQUM7WUFDUixPQUFPLEVBQUU7Z0JBQ1AsZ0NBQWE7YUFDZDtZQUNELFlBQVksRUFBRTtnQkFDWiw0QkFBWTthQUNiO1lBQ0QsU0FBUyxFQUFFLENBQUUsNEJBQVksQ0FBRTtTQUM1QixDQUFDOztpQkFBQTtJQUV1QixnQkFBQztBQUFELENBQUM7QUFBYixpQkFBUyxZQUFJIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSAgZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQnJvd3Nlck1vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBBcHBDb21wb25lbnRcbiAgXSxcbiAgYm9vdHN0cmFwOiBbIEFwcENvbXBvbmVudCBdXG59KVxuXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L0Bhbmd1bGFyY2xhc3MvaG1yLWxvYWRlciEuL3NyYy9hcHAvYXBwLm1vZHVsZS50cyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar core_1 = __webpack_require__(2);\n// import '../../public/css/styles.css';\nvar AppComponent = (function () {\n    function AppComponent() {\n    }\n    AppComponent = __decorate([\n        core_1.Component({\n            selector: 'my-app',\n            template: '<h1>Hello Angular2</h1>',\n        }), \n        __metadata('design:paramtypes', [])\n    ], AppComponent);\n    return AppComponent;\n}());\nexports.AppComponent = AppComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHM/Y2JkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQUMxQyx3Q0FBd0M7QUFPeEM7SUFBQTtJQUE0QixDQUFDO0lBTDdCO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxRQUFRO1lBQ2xCLFFBQVEsRUFBRSx5QkFBeUI7U0FDcEMsQ0FBQzs7b0JBQUE7SUFFMEIsbUJBQUM7QUFBRCxDQUFDO0FBQWhCLG9CQUFZLGVBQUkiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbi8vIGltcG9ydCAnLi4vLi4vcHVibGljL2Nzcy9zdHlsZXMuY3NzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgdGVtcGxhdGU6ICc8aDE+SGVsbG8gQW5ndWxhcjI8L2gxPicsXG59KVxuXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHsgfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L0Bhbmd1bGFyY2xhc3MvaG1yLWxvYWRlciEuL3NyYy9hcHAvYXBwLmNvbXBvbmVudC50cyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
]);